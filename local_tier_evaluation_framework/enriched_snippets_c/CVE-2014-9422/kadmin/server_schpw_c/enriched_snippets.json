[
  {
    "function_name": "process_chpw_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/schpw.c",
    "lines": "15-407",
    "snippet": "krb5_error_code\nprocess_chpw_request(context, server_handle, realm, s, keytab, sockin, \n\t\t     req, rep)\n     krb5_context context;\n     void *server_handle;\n     char *realm;\n     int s;\n     krb5_keytab keytab;\n     struct sockaddr_in *sockin;\n     krb5_data *req;\n     krb5_data *rep;\n{\n    krb5_error_code ret;\n    char *ptr;\n    int plen, vno;\n    krb5_address local_kaddr, remote_kaddr;\n    int allocated_mem = 0;  \n    krb5_data ap_req, ap_rep;\n    krb5_auth_context auth_context;\n    krb5_principal changepw;\n    krb5_ticket *ticket;\n    krb5_data cipher, clear;\n    struct sockaddr local_addr, remote_addr;\n    GETSOCKNAME_ARG3_TYPE addrlen;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr;\n\n    ret = 0;\n    rep->length = 0;\n\n    auth_context = NULL;\n    changepw = NULL;\n    ap_rep.length = 0;\n    ticket = NULL;\n    clear.length = 0;\n    cipher.length = 0;\n\n    if (req->length < 4) {\n\t/* either this, or the server is printing bad messages,\n\t   or the caller passed in garbage */\n\tret = KRB5KRB_AP_ERR_MODIFIED;\n\tnumresult = KRB5_KPASSWD_MALFORMED;\n\tstrcpy(strresult, \"Request was truncated\");\n\tgoto chpwfail;\n    }\n\n    ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length)\n\treturn(KRB5KRB_AP_ERR_MODIFIED);\n\n    /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1) {\n\tret = KRB5KDC_ERR_BAD_PVNO;\n\tnumresult = KRB5_KPASSWD_BAD_VERSION;\n\tsprintf(strresult,\n\t\t\"Request contained unknown protocol version number %d\", vno);\n\tgoto chpwfail;\n    }\n\n    /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n\tret = KRB5KRB_AP_ERR_MODIFIED;\n\tnumresult = KRB5_KPASSWD_MALFORMED;\n\tstrcpy(strresult, \"Request was truncated in AP-REQ\");\n\tgoto chpwfail;\n    }\n\n    /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed initializing auth context\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n\t\t\t\t KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed initializing auth context\");\n\tgoto chpwfail;\n    }\n\t\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n\t\t\t       \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed building kadmin/changepw principal\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n\t\t      NULL, &ticket);\n\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Failed reading application request\");\n\tgoto chpwfail;\n    }\n\n    /* set up address info */\n\n    addrlen = sizeof(local_addr);\n\n    if (getsockname(s, &local_addr, &addrlen) < 0) {\n\tret = errno;\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed getting server internet address\");\n\tgoto chpwfail;\n    }\n\n    /* some brain-dead OS's don't return useful information from\n     * the getsockname call.  Namely, windows and solaris.  */\n\n    if (((struct sockaddr_in *)&local_addr)->sin_addr.s_addr != 0) {\n\tlocal_kaddr.addrtype = ADDRTYPE_INET;\n\tlocal_kaddr.length =\n\t    sizeof(((struct sockaddr_in *) &local_addr)->sin_addr);\n\tlocal_kaddr.contents = \n\t    (krb5_octet *) &(((struct sockaddr_in *) &local_addr)->sin_addr);\n    } else {\n\tkrb5_address **addrs;\n\n\tkrb5_os_localaddr(context, &addrs);\n\tlocal_kaddr.magic = addrs[0]->magic;\n\tlocal_kaddr.addrtype = addrs[0]->addrtype;\n\tlocal_kaddr.length = addrs[0]->length;\n\tlocal_kaddr.contents = malloc(addrs[0]->length);\n\tmemcpy(local_kaddr.contents, addrs[0]->contents, addrs[0]->length);\n\tallocated_mem++;\n\n\tkrb5_free_addresses(context, addrs);\n    }\n\n    addrlen = sizeof(remote_addr);\n\n    if (getpeername(s, &remote_addr, &addrlen) < 0) {\n\tret = errno;\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed getting client internet address\");\n\tgoto chpwfail;\n    }\n\n    remote_kaddr.addrtype = ADDRTYPE_INET;\n    remote_kaddr.length =\n\tsizeof(((struct sockaddr_in *) &remote_addr)->sin_addr);\n    remote_kaddr.contents = \n\t(krb5_octet *) &(((struct sockaddr_in *) &remote_addr)->sin_addr);\n    \n    remote_kaddr.addrtype = ADDRTYPE_INET;\n    remote_kaddr.length = sizeof(sockin->sin_addr);\n    remote_kaddr.contents = (krb5_octet *) &sockin->sin_addr;\n    \n    /* mk_priv requires that the local address be set.\n       getsockname is used for this.  rd_priv requires that the\n       remote address be set.  recvfrom is used for this.  If\n       rd_priv is given a local address, and the message has the\n       recipient addr in it, this will be checked.  However, there\n       is simply no way to know ahead of time what address the\n       message will be delivered *to*.  Therefore, it is important\n       that either no recipient address is in the messages when\n       mk_priv is called, or that no local address is passed to\n       rd_priv.  Both is a better idea, and I have done that.  In\n       summary, when mk_priv is called, *only* a local address is\n       specified.  when rd_priv is called, *only* a remote address\n       is specified.  Are we having fun yet?  */\n\n    ret = krb5_auth_con_setaddrs(context, auth_context, NULL,\n\t\t\t     &remote_kaddr);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed storing client internet address\");\n\tgoto chpwfail;\n    }\n\n    /* verify that this is an AS_REQ ticket */\n\n    if (!(ticket->enc_part2->flags & TKT_FLG_INITIAL)) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Ticket must be derived from a password\");\n\tgoto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Failed replying to application request\");\n\tgoto chpwfail;\n    }\n\n    /* decrypt the new password */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed decrypting request\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_unparse_name(context, ticket->enc_part2->client, &clientstr);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed unparsing client name for log\");\n\tgoto chpwfail;\n    }\n    /* change the password */\n\n    ptr = (char *) malloc(clear.length+1);\n    memcpy(ptr, clear.data, clear.length);\n    ptr[clear.length] = '\\0';\n\n    ret = kadm5_chpass_principal_util(server_handle, ticket->enc_part2->client,\n\t\t\t\t      ptr, NULL, strresult, sizeof(strresult));\n\n    /* zap the password */\n    memset(clear.data, 0, clear.length);\n    memset(ptr, 0, clear.length);\n    krb5_xfree(clear.data);\n    free(ptr);\n    clear.length = 0;\n\n    krb5_klog_syslog(LOG_NOTICE, \"chpw request from %s for %s: %s\",\n\t\t     inet_ntoa(((struct sockaddr_in *)&remote_addr)->sin_addr),\n\t\t     clientstr, ret ? error_message(ret) : \"success\");\n    krb5_free_unparsed_name(context, clientstr);\n\n    if (ret) {\n\tif ((ret != KADM5_PASS_Q_TOOSHORT) && \n\t    (ret != KADM5_PASS_REUSE) && (ret != KADM5_PASS_Q_CLASS) && \n\t    (ret != KADM5_PASS_Q_DICT) && (ret != KADM5_PASS_TOOSOON))\n\t    numresult = KRB5_KPASSWD_HARDERROR;\n\telse\n\t    numresult = KRB5_KPASSWD_SOFTERROR;\n\t/* strresult set by kadb5_chpass_principal_util() */\n\tgoto chpwfail;\n    }\n\n    /* success! */\n\n    numresult = KRB5_KPASSWD_SUCCESS;\n    strcpy(strresult, \"\");\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher.length = 0;\n\n    if (ap_rep.length) {\n\tret = krb5_auth_con_setaddrs(context, auth_context, &local_kaddr,\n\t\t\t\t     NULL);\n\tif (ret) {\n\t    numresult = KRB5_KPASSWD_HARDERROR;\n\t    strcpy(strresult,\n\t\t   \"Failed storing client and server internet addresses\");\n\t} else {\n\t    ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n\t\t\t       &replay);\n\t    if (ret) {\n\t\tnumresult = KRB5_KPASSWD_HARDERROR;\n\t\tstrcpy(strresult, \"Failed encrypting reply\");\n\t    }\n\t}\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n\t/* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n\tif (ap_rep.length) {\n\t    krb5_xfree(ap_rep.data);\n\t    ap_rep.length = 0;\n\t}\n\n\tkrberror.ctime = 0;\n\tkrberror.cusec = 0;\n\tkrberror.susec = 0;\n\tret = krb5_timeofday(context, &krberror.stime);\n\tif (ret)\n\t    goto bailout;\n\n\t/* this is really icky.  but it's what all the other callers\n\t   to mk_error do. */\n\tkrberror.error = ret;\n\tkrberror.error -= ERROR_TABLE_BASE_krb5;\n\tif (krberror.error < 0 || krberror.error > 128)\n\t    krberror.error = KRB_ERR_GENERIC;\n\n\tkrberror.client = NULL;\n\n\tret = krb5_build_principal(context, &krberror.server,\n\t\t\t\t   strlen(realm), realm,\n\t\t\t\t   \"kadmin\", \"changepw\", NULL);\n\tif (ret)\n\t    goto bailout;\n\tkrberror.text.length = 0;\n\tkrberror.e_data = clear;\n\n\tret = krb5_mk_error(context, &krberror, &cipher);\n\n\tkrb5_free_principal(context, krberror.server);\n\n\tif (ret)\n\t    goto bailout;\n    }\n\n    /* construct the reply */\n\n    rep->length = 6 + ap_rep.length + cipher.length;\n    rep->data = (char *) malloc(rep->length);\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n\tmemcpy(ptr, ap_rep.data, ap_rep.length);\n\tptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    if (auth_context)\n\tkrb5_auth_con_free(context, auth_context);\n    if (changepw)\n\tkrb5_free_principal(context, changepw);\n    if (ap_rep.length)\n\tkrb5_xfree(ap_rep.data);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if (clear.length)\n\tkrb5_xfree(clear.data);\n    if (cipher.length)\n\tkrb5_xfree(cipher.data);\n    if (allocated_mem) \n        krb5_xfree(local_kaddr.contents);\n\n    return(ret);\n}",
    "includes": [
      "#include \"misc.h\"",
      "#include <errno.h>",
      "#include <stdio.h>",
      "#include <krb5/adm_proto.h>\t/* krb5_klog_syslog */",
      "#include <syslog.h>",
      "#include <kadm5/admin.h>",
      "#include \"k5-int.h\""
    ],
    "macros_used": [
      "#define GETSOCKNAME_ARG3_TYPE int"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "local_kaddr.contents"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "cipher.data"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "clear.data"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_ticket",
          "args": [
            "context",
            "ticket"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "ap_rep.data"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "changepw"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_auth_con_free",
          "args": [
            "context",
            "auth_context"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "cipher.data",
            "cipher.length"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "ap_rep.data",
            "ap_rep.length"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "rep->length"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "krberror.server"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_mk_error",
          "args": [
            "context",
            "&krberror",
            "&cipher"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_build_principal",
          "args": [
            "context",
            "&krberror.server",
            "strlen(realm)",
            "realm",
            "\"kadmin\"",
            "\"changepw\"",
            "NULL"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "realm"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_timeofday",
          "args": [
            "context",
            "&krberror.stime"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "ap_rep.data"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed encrypting reply\""
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_mk_priv",
          "args": [
            "context",
            "auth_context",
            "&clear",
            "&cipher",
            "&replay"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed storing client and server internet addresses\""
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_auth_con_setaddrs",
          "args": [
            "context",
            "auth_context",
            "&local_kaddr",
            "NULL"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "strresult",
            "strlen(strresult)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "strresult"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "clear.length"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "strresult"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_unparsed_name",
          "args": [
            "context",
            "clientstr"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_NOTICE",
            "\"chpw request from %s for %s: %s\"",
            "inet_ntoa(((struct sockaddr_in *)&remote_addr)->sin_addr)",
            "clientstr",
            "ret ? error_message(ret) : \"success\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "((struct sockaddr_in *)&remote_addr)->sin_addr"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ptr"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "free_server_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/server_stubs.c",
          "lines": "137-141",
          "snippet": "static void free_server_handle(kadm5_server_handle_t handle)\n{\n     krb5_free_principal(handle->context, handle->current_caller);\n     free(handle);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include <krb5/adm_proto.h>  /* krb5_klog_syslog */",
            "#include <arpa/inet.h>  /* inet_ntoa */",
            "#include <syslog.h>",
            "#include <kadm5/server_acl.h>",
            "#include <kadm5/server_internal.h>",
            "#include <kadm5/kadm_rpc.h>",
            "#include <kadm5/admin.h>",
            "#include <krb5.h>",
            "#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */",
            "#include <gssapi/gssapi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static gss_name_t acceptor_name(gss_ctx_id_t context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include <krb5/adm_proto.h>  /* krb5_klog_syslog */\n#include <arpa/inet.h>  /* inet_ntoa */\n#include <syslog.h>\n#include <kadm5/server_acl.h>\n#include <kadm5/server_internal.h>\n#include <kadm5/kadm_rpc.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */\n#include <gssapi/gssapi.h>\n\nstatic gss_name_t acceptor_name(gss_ctx_id_t context);\n\nstatic void free_server_handle(kadm5_server_handle_t handle)\n{\n     krb5_free_principal(handle->context, handle->current_caller);\n     free(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "clear.data"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ptr",
            "0",
            "clear.length"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "clear.data",
            "0",
            "clear.length"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_chpass_principal_util",
          "args": [
            "server_handle",
            "ticket->enc_part2->client",
            "ptr",
            "NULL",
            "strresult",
            "sizeof(strresult)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ptr",
            "clear.data",
            "clear.length"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "clear.length+1"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed unparsing client name for log\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "context",
            "ticket->enc_part2->client",
            "&clientstr"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed decrypting request\""
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_rd_priv",
          "args": [
            "context",
            "auth_context",
            "&cipher",
            "&clear",
            "&replay"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed replying to application request\""
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_mk_rep",
          "args": [
            "context",
            "auth_context",
            "&ap_rep"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Ticket must be derived from a password\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed storing client internet address\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_auth_con_setaddrs",
          "args": [
            "context",
            "auth_context",
            "NULL",
            "&remote_kaddr"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed getting client internet address\""
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpeername",
          "args": [
            "s",
            "&remote_addr",
            "&addrlen"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_addresses",
          "args": [
            "context",
            "addrs"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "local_kaddr.contents",
            "addrs[0]->contents",
            "addrs[0]->length"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "addrs[0]->length"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_os_localaddr",
          "args": [
            "context",
            "&addrs"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed getting server internet address\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getsockname",
          "args": [
            "s",
            "&local_addr",
            "&addrlen"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed reading application request\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_rd_req",
          "args": [
            "context",
            "&auth_context",
            "&ap_req",
            "changepw",
            "keytab",
            "NULL",
            "&ticket"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed building kadmin/changepw principal\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_build_principal",
          "args": [
            "context",
            "&changepw",
            "strlen(realm)",
            "realm",
            "\"kadmin\"",
            "\"changepw\"",
            "NULL"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "realm"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed initializing auth context\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_auth_con_setflags",
          "args": [
            "context",
            "auth_context",
            "KRB5_AUTH_CONTEXT_DO_SEQUENCE"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Failed initializing auth context\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_auth_con_init",
          "args": [
            "context",
            "&auth_context"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Request was truncated in AP-REQ\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "strresult",
            "\"Request contained unknown protocol version number %d\"",
            "vno"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "strresult",
            "\"Request was truncated\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"misc.h\"\n#include <errno.h>\n#include <stdio.h>\n#include <krb5/adm_proto.h>\t/* krb5_klog_syslog */\n#include <syslog.h>\n#include <kadm5/admin.h>\n#include \"k5-int.h\"\n\n#define GETSOCKNAME_ARG3_TYPE int\n\nkrb5_error_code\nprocess_chpw_request(context, server_handle, realm, s, keytab, sockin, \n\t\t     req, rep)\n     krb5_context context;\n     void *server_handle;\n     char *realm;\n     int s;\n     krb5_keytab keytab;\n     struct sockaddr_in *sockin;\n     krb5_data *req;\n     krb5_data *rep;\n{\n    krb5_error_code ret;\n    char *ptr;\n    int plen, vno;\n    krb5_address local_kaddr, remote_kaddr;\n    int allocated_mem = 0;  \n    krb5_data ap_req, ap_rep;\n    krb5_auth_context auth_context;\n    krb5_principal changepw;\n    krb5_ticket *ticket;\n    krb5_data cipher, clear;\n    struct sockaddr local_addr, remote_addr;\n    GETSOCKNAME_ARG3_TYPE addrlen;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr;\n\n    ret = 0;\n    rep->length = 0;\n\n    auth_context = NULL;\n    changepw = NULL;\n    ap_rep.length = 0;\n    ticket = NULL;\n    clear.length = 0;\n    cipher.length = 0;\n\n    if (req->length < 4) {\n\t/* either this, or the server is printing bad messages,\n\t   or the caller passed in garbage */\n\tret = KRB5KRB_AP_ERR_MODIFIED;\n\tnumresult = KRB5_KPASSWD_MALFORMED;\n\tstrcpy(strresult, \"Request was truncated\");\n\tgoto chpwfail;\n    }\n\n    ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length)\n\treturn(KRB5KRB_AP_ERR_MODIFIED);\n\n    /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1) {\n\tret = KRB5KDC_ERR_BAD_PVNO;\n\tnumresult = KRB5_KPASSWD_BAD_VERSION;\n\tsprintf(strresult,\n\t\t\"Request contained unknown protocol version number %d\", vno);\n\tgoto chpwfail;\n    }\n\n    /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n\tret = KRB5KRB_AP_ERR_MODIFIED;\n\tnumresult = KRB5_KPASSWD_MALFORMED;\n\tstrcpy(strresult, \"Request was truncated in AP-REQ\");\n\tgoto chpwfail;\n    }\n\n    /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed initializing auth context\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n\t\t\t\t KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed initializing auth context\");\n\tgoto chpwfail;\n    }\n\t\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n\t\t\t       \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed building kadmin/changepw principal\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n\t\t      NULL, &ticket);\n\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Failed reading application request\");\n\tgoto chpwfail;\n    }\n\n    /* set up address info */\n\n    addrlen = sizeof(local_addr);\n\n    if (getsockname(s, &local_addr, &addrlen) < 0) {\n\tret = errno;\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed getting server internet address\");\n\tgoto chpwfail;\n    }\n\n    /* some brain-dead OS's don't return useful information from\n     * the getsockname call.  Namely, windows and solaris.  */\n\n    if (((struct sockaddr_in *)&local_addr)->sin_addr.s_addr != 0) {\n\tlocal_kaddr.addrtype = ADDRTYPE_INET;\n\tlocal_kaddr.length =\n\t    sizeof(((struct sockaddr_in *) &local_addr)->sin_addr);\n\tlocal_kaddr.contents = \n\t    (krb5_octet *) &(((struct sockaddr_in *) &local_addr)->sin_addr);\n    } else {\n\tkrb5_address **addrs;\n\n\tkrb5_os_localaddr(context, &addrs);\n\tlocal_kaddr.magic = addrs[0]->magic;\n\tlocal_kaddr.addrtype = addrs[0]->addrtype;\n\tlocal_kaddr.length = addrs[0]->length;\n\tlocal_kaddr.contents = malloc(addrs[0]->length);\n\tmemcpy(local_kaddr.contents, addrs[0]->contents, addrs[0]->length);\n\tallocated_mem++;\n\n\tkrb5_free_addresses(context, addrs);\n    }\n\n    addrlen = sizeof(remote_addr);\n\n    if (getpeername(s, &remote_addr, &addrlen) < 0) {\n\tret = errno;\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed getting client internet address\");\n\tgoto chpwfail;\n    }\n\n    remote_kaddr.addrtype = ADDRTYPE_INET;\n    remote_kaddr.length =\n\tsizeof(((struct sockaddr_in *) &remote_addr)->sin_addr);\n    remote_kaddr.contents = \n\t(krb5_octet *) &(((struct sockaddr_in *) &remote_addr)->sin_addr);\n    \n    remote_kaddr.addrtype = ADDRTYPE_INET;\n    remote_kaddr.length = sizeof(sockin->sin_addr);\n    remote_kaddr.contents = (krb5_octet *) &sockin->sin_addr;\n    \n    /* mk_priv requires that the local address be set.\n       getsockname is used for this.  rd_priv requires that the\n       remote address be set.  recvfrom is used for this.  If\n       rd_priv is given a local address, and the message has the\n       recipient addr in it, this will be checked.  However, there\n       is simply no way to know ahead of time what address the\n       message will be delivered *to*.  Therefore, it is important\n       that either no recipient address is in the messages when\n       mk_priv is called, or that no local address is passed to\n       rd_priv.  Both is a better idea, and I have done that.  In\n       summary, when mk_priv is called, *only* a local address is\n       specified.  when rd_priv is called, *only* a remote address\n       is specified.  Are we having fun yet?  */\n\n    ret = krb5_auth_con_setaddrs(context, auth_context, NULL,\n\t\t\t     &remote_kaddr);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed storing client internet address\");\n\tgoto chpwfail;\n    }\n\n    /* verify that this is an AS_REQ ticket */\n\n    if (!(ticket->enc_part2->flags & TKT_FLG_INITIAL)) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Ticket must be derived from a password\");\n\tgoto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Failed replying to application request\");\n\tgoto chpwfail;\n    }\n\n    /* decrypt the new password */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed decrypting request\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_unparse_name(context, ticket->enc_part2->client, &clientstr);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed unparsing client name for log\");\n\tgoto chpwfail;\n    }\n    /* change the password */\n\n    ptr = (char *) malloc(clear.length+1);\n    memcpy(ptr, clear.data, clear.length);\n    ptr[clear.length] = '\\0';\n\n    ret = kadm5_chpass_principal_util(server_handle, ticket->enc_part2->client,\n\t\t\t\t      ptr, NULL, strresult, sizeof(strresult));\n\n    /* zap the password */\n    memset(clear.data, 0, clear.length);\n    memset(ptr, 0, clear.length);\n    krb5_xfree(clear.data);\n    free(ptr);\n    clear.length = 0;\n\n    krb5_klog_syslog(LOG_NOTICE, \"chpw request from %s for %s: %s\",\n\t\t     inet_ntoa(((struct sockaddr_in *)&remote_addr)->sin_addr),\n\t\t     clientstr, ret ? error_message(ret) : \"success\");\n    krb5_free_unparsed_name(context, clientstr);\n\n    if (ret) {\n\tif ((ret != KADM5_PASS_Q_TOOSHORT) && \n\t    (ret != KADM5_PASS_REUSE) && (ret != KADM5_PASS_Q_CLASS) && \n\t    (ret != KADM5_PASS_Q_DICT) && (ret != KADM5_PASS_TOOSOON))\n\t    numresult = KRB5_KPASSWD_HARDERROR;\n\telse\n\t    numresult = KRB5_KPASSWD_SOFTERROR;\n\t/* strresult set by kadb5_chpass_principal_util() */\n\tgoto chpwfail;\n    }\n\n    /* success! */\n\n    numresult = KRB5_KPASSWD_SUCCESS;\n    strcpy(strresult, \"\");\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher.length = 0;\n\n    if (ap_rep.length) {\n\tret = krb5_auth_con_setaddrs(context, auth_context, &local_kaddr,\n\t\t\t\t     NULL);\n\tif (ret) {\n\t    numresult = KRB5_KPASSWD_HARDERROR;\n\t    strcpy(strresult,\n\t\t   \"Failed storing client and server internet addresses\");\n\t} else {\n\t    ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n\t\t\t       &replay);\n\t    if (ret) {\n\t\tnumresult = KRB5_KPASSWD_HARDERROR;\n\t\tstrcpy(strresult, \"Failed encrypting reply\");\n\t    }\n\t}\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n\t/* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n\tif (ap_rep.length) {\n\t    krb5_xfree(ap_rep.data);\n\t    ap_rep.length = 0;\n\t}\n\n\tkrberror.ctime = 0;\n\tkrberror.cusec = 0;\n\tkrberror.susec = 0;\n\tret = krb5_timeofday(context, &krberror.stime);\n\tif (ret)\n\t    goto bailout;\n\n\t/* this is really icky.  but it's what all the other callers\n\t   to mk_error do. */\n\tkrberror.error = ret;\n\tkrberror.error -= ERROR_TABLE_BASE_krb5;\n\tif (krberror.error < 0 || krberror.error > 128)\n\t    krberror.error = KRB_ERR_GENERIC;\n\n\tkrberror.client = NULL;\n\n\tret = krb5_build_principal(context, &krberror.server,\n\t\t\t\t   strlen(realm), realm,\n\t\t\t\t   \"kadmin\", \"changepw\", NULL);\n\tif (ret)\n\t    goto bailout;\n\tkrberror.text.length = 0;\n\tkrberror.e_data = clear;\n\n\tret = krb5_mk_error(context, &krberror, &cipher);\n\n\tkrb5_free_principal(context, krberror.server);\n\n\tif (ret)\n\t    goto bailout;\n    }\n\n    /* construct the reply */\n\n    rep->length = 6 + ap_rep.length + cipher.length;\n    rep->data = (char *) malloc(rep->length);\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n\tmemcpy(ptr, ap_rep.data, ap_rep.length);\n\tptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    if (auth_context)\n\tkrb5_auth_con_free(context, auth_context);\n    if (changepw)\n\tkrb5_free_principal(context, changepw);\n    if (ap_rep.length)\n\tkrb5_xfree(ap_rep.data);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if (clear.length)\n\tkrb5_xfree(clear.data);\n    if (cipher.length)\n\tkrb5_xfree(cipher.data);\n    if (allocated_mem) \n        krb5_xfree(local_kaddr.contents);\n\n    return(ret);\n}"
  }
]