[
  {
    "function_name": "load_db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "2082-2410",
    "snippet": "void\nload_db(argc, argv)\n    int\t\targc;\n    char\t**argv;\n{\n    kadm5_config_params newparams;\n    osa_adb_policy_t\ttmppol_db;\n    krb5_error_code\tkret;\n    krb5_context\tkcontext;\n    FILE\t\t*f;\n    extern char\t\t*optarg;\n    extern int\t\toptind;\n    char\t\t*programname;\n    char\t\t*dumpfile;\n    char\t\t*dbname;\n    char\t\t*dbname_tmp;\n    char\t\tbuf[BUFSIZ];\n    dump_version\t*load;\n    int\t\t\tupdate, verbose;\n    krb5_int32\t\tcrflags;\n    int\t\t\taindex;\n\n    /*\n     * Parse the arguments.\n     */\n    programname = argv[0];\n    if (strrchr(programname, (int) '/'))\n\tprogramname = strrchr(argv[0], (int) '/') + 1;\n    dumpfile = (char *) NULL;\n    dbname = global_params.dbname;\n    load = NULL;\n    update = 0;\n    verbose = 0;\n    crflags = KRB5_KDB_CREATE_BTREE;\n    exit_status = 0;\n    dbname_tmp = (char *) NULL;\n    tmppol_db = NULL;\n    for (aindex = 1; aindex < argc; aindex++) {\n\tif (!strcmp(argv[aindex], oldoption))\n\t     load = &old_version;\n\telse if (!strcmp(argv[aindex], b6option))\n\t     load = &beta6_version;\n\telse if (!strcmp(argv[aindex], b7option))\n\t     load = &beta7_version;\n\telse if (!strcmp(argv[aindex], ovoption))\n\t     load = &ov_version;\n\telse if (!strcmp(argv[aindex], verboseoption))\n\t    verbose = 1;\n\telse if (!strcmp(argv[aindex], updateoption))\n\t    update = 1;\n\telse if (!strcmp(argv[aindex], hashoption))\n\t    crflags = KRB5_KDB_CREATE_HASH;\n\telse\n\t    break;\n    }\n    if ((argc - aindex) != 1) {\n\tusage();\n\treturn;\n    }\n    dumpfile = argv[aindex];\n\n    if (!(dbname_tmp = (char *) malloc(strlen(dbname)+\n\t\t\t\t       strlen(dump_tmptrail)+1))) {\n\tfprintf(stderr, no_name_mem_fmt, argv[0]);\n\texit_status++;\n\treturn;\n    }\n    strcpy(dbname_tmp, dbname);\n    strcat(dbname_tmp, dump_tmptrail);\n\n    /*\n     * Initialize the Kerberos context and error tables.\n     */\n    if ((kret = krb5_init_context(&kcontext))) {\n\tfprintf(stderr, ctx_err_fmt, programname);\n\tfree(dbname_tmp);\n\texit_status++;\n\treturn;\n    }\n\n    /*\n     * Open the dumpfile\n     */\n    if (dumpfile) {\n\tif ((f = fopen(dumpfile, \"r+\")) == NULL) {\n\t     fprintf(stderr, dfile_err_fmt, programname, dumpfile,\n\t\t     error_message(errno)); \n\t     exit_status++;\n\t     return;\n\t}\n\tif ((kret = krb5_lock_file(kcontext, fileno(f),\n\t\t\t\t   KRB5_LOCKMODE_SHARED))) {\n\t     fprintf(stderr, \"%s: Cannot lock %s: %s\\n\", programname,\n\t\t     dumpfile, error_message(errno));\n\t     exit_status++;\n\t     return;\n\t}\n    } else\n\tf = stdin;\n\n    /*\n     * Auto-detect dump version if we weren't told, verify if we\n     * were told.\n     */\n    fgets(buf, sizeof(buf), f);\n    if (load) {\n\t /* only check what we know; some headers only contain a prefix */\n\t if (strncmp(buf, load->header, strlen(load->header)) != 0) {\n\t      fprintf(stderr, head_bad_fmt, programname, dumpfile);\n\t      exit_status++;\n\t      if (dumpfile) fclose(f);\n\t      return;\n\t }\n    } else {\n\t /* perhaps this should be in an array, but so what? */\n\t if (strcmp(buf, old_version.header) == 0)\n\t      load = &old_version;\n\t else if (strcmp(buf, beta6_version.header) == 0)\n\t      load = &beta6_version;\n\t else if (strcmp(buf, beta7_version.header) == 0)\n\t      load = &beta7_version;\n\t else if (strcmp(buf, r1_3_version.header) == 0)\n\t      load = &r1_3_version;\n\t else if (strncmp(buf, ov_version.header,\n\t\t\t  strlen(ov_version.header)) == 0)\n\t      load = &ov_version;\n\t else {\n\t      fprintf(stderr, head_bad_fmt, programname, dumpfile);\n\t      exit_status++;\n\t      if (dumpfile) fclose(f);\n\t      return;\n\t }\n    }\n    if (load->updateonly && !update) {\n\t fprintf(stderr, \"%s: dump version %s can only be loaded with the \"\n\t\t \"-update flag\\n\", programname, load->name);\n\t exit_status++;\n\t return;\n    }\n\n    /*\n     * Cons up params for the new databases.  If we are not in update\n     * mode use a temp name that we'll rename later.\n     */\n    newparams = global_params;\n    if (! update) {\n\t newparams.mask |= KADM5_CONFIG_DBNAME;\n\t newparams.dbname = dbname_tmp;\n\n\t if ((kret = kadm5_get_config_params(kcontext, NULL, NULL,\n\t\t\t\t\t     &newparams, &newparams))) {\n\t      com_err(argv[0], kret,\n\t\t      \"while retreiving new configuration parameters\");\n\t      exit_status++;\n\t      return;\n\t }\n    }\n    \n    /*\n     * If not an update restoration, create the temp database.  Always\n     * create a temp policy db, even if we are not loading a dump file\n     * with policy info, because they may be loading an old dump\n     * intending to use it with the new kadm5 system.\n     */\n    if (!update && ((kret = krb5_db_create(kcontext, dbname_tmp, crflags)))) {\n\t fprintf(stderr, dbcreaterr_fmt,\n\t\t programname, dbname_tmp, error_message(kret));\n\t exit_status++;\n\t kadm5_free_config_params(kcontext, &newparams);\n\t if (dumpfile) fclose(f);\n\t return;\n    }\n    if (!update && (kret = osa_adb_create_policy_db(&newparams))) {\n\t fprintf(stderr, \"%s: %s while creating policy database\\n\",\n\t\t programname, error_message(kret));\n\t exit_status++;\n\t kadm5_free_config_params(kcontext, &newparams);\n\t if (dumpfile) fclose(f);\n\t return;\n    }\n\n    /*\n     * Point ourselves at the new databases.\n     */\n    if ((kret = krb5_db_set_name(kcontext,\n\t\t\t\t(update) ? dbname : dbname_tmp))) {\n\t fprintf(stderr, dbname_err_fmt,\n\t\t programname, \n\t\t (update) ? dbname : dbname_tmp, error_message(kret));\n\t exit_status++;\n\t goto error;\n    }\n    if ((kret = osa_adb_open_policy(&tmppol_db, &newparams))) {\n\t fprintf(stderr, \"%s: %s while opening policy database\\n\",\n\t\t programname, error_message(kret));\n\t exit_status++;\n\t goto error;\n    }\n    /*\n     * If an update restoration, make sure the db is left unusable if\n     * the update fails.\n     */\n    if (update) {\n\t if ((kret = osa_adb_get_lock(tmppol_db, OSA_ADB_PERMANENT))) {\n\t      fprintf(stderr, \"%s: %s while permanently locking database\\n\",\n\t\t      programname, error_message(kret));\n\t      exit_status++;\n\t      goto error;\n\t }\n    }\n\t\t      \n    /*\n     * Initialize the database.\n     */\n    if ((kret = krb5_db_init(kcontext))) {\n\t fprintf(stderr, dbinit_err_fmt,\n\t\t programname, error_message(kret));\n\t exit_status++;\n\t goto error;\n    }\n    /* \n     * grab an extra lock, since there are no other users\n     */\n    if (!update) {\n\t kret = krb5_db_lock(kcontext, KRB5_LOCKMODE_EXCLUSIVE);\n\t if (kret) {\n\t\t fprintf(stderr, dblock_err_fmt,\n\t\t\t programname, error_message(kret));\n\t\t exit_status++;\n\t\t goto error;\n\t }\n    }\n    \n    if (restore_dump(programname, kcontext, (dumpfile) ? dumpfile : stdin_name,\n\t\t     f, verbose, load, tmppol_db)) {\n\t fprintf(stderr, restfail_fmt,\n\t\t programname, load->name);\n\t exit_status++;\n    }\n\n    if (!update && (kret = krb5_db_unlock(kcontext))) {\n\t /* change this error? */\n\t fprintf(stderr, dbunlockerr_fmt,\n\t\t programname, dbname_tmp, error_message(kret));\n\t exit_status++;\n    }\n    if ((kret = krb5_db_fini(kcontext))) {\n\t fprintf(stderr, close_err_fmt,\n\t\t programname, error_message(kret));\n\t exit_status++;\n    }\n\n    if (!update && load->create_kadm5 &&\n\t((kret = kadm5_create_magic_princs(&newparams, kcontext)))) {\n\t /* error message printed by create_magic_princs */\n\t exit_status++;\n    }\n    \n    /* close policy db below */\n\nerror:\n    /*\n     * If not an update: if there was an error, destroy the temp database,\n     * otherwise rename it into place.\n     *\n     * If an update: if there was no error, unlock the database.\n     */\n    if (!update) {\n\t if (exit_status) {\n\t      if ((kret = krb5_db_destroy(kcontext, dbname_tmp))) {\n\t\t   fprintf(stderr, dbdelerr_fmt,\n\t\t\t   programname, dbname_tmp, error_message(kret));\n\t\t   exit_status++;\n\t      }\n\t      if ((kret = osa_adb_destroy_policy_db(&newparams))) {\n\t\t   fprintf(stderr, \"%s: %s while destroying policy database\\n\",\n\t\t\t   programname, error_message(kret));\n\t\t   exit_status++;\n\t      }\n\t }\n\t else {\n\t      if ((kret = krb5_db_rename(kcontext,\n\t\t\t\t\t dbname_tmp,\n\t\t\t\t\t dbname))) {\n\t\t   fprintf(stderr, dbrenerr_fmt,\n\t\t\t   programname, dbname_tmp, dbname,\n\t\t\t   error_message(kret));\n\t\t   exit_status++;\n\t      } \n\n\t      if ((kret = osa_adb_close_policy(tmppol_db))) {\n\t\t   fprintf(stderr, close_err_fmt,\n\t\t\t   programname, error_message(kret));\n\t\t   exit_status++;\n\t      }\n\n\t      if ((kret = osa_adb_rename_policy_db(&newparams,\n\t\t\t\t\t\t   &global_params))) {\n\t\t   fprintf(stderr,\n\t\t\t   \"%s: %s while renaming policy db %s to %s\\n\",\n\t\t\t   programname, error_message(kret),\n\t\t\t   newparams.admin_dbname,\n\t\t\t   global_params.admin_dbname);\n\t\t   exit_status++;\n\t      }\n\t }\n    } else /* update */ {\n\t if (! exit_status && ((kret = osa_adb_release_lock(tmppol_db)))) {\n\t      fprintf(stderr, \"%s: %s while releasing permanent lock\\n\",\n\t\t      programname, error_message(kret));\n\t      exit_status++;\n\t }\n\n\t if (tmppol_db && ((kret = osa_adb_close_policy(tmppol_db)))) {\n\t      fprintf(stderr, close_err_fmt,\n\t\t      programname, error_message(kret));\n\t      exit_status++;\n\t }\n    }\n\n    if (dumpfile) {\n\t (void) krb5_lock_file(kcontext, fileno(f), KRB5_LOCKMODE_UNLOCK);\n\t fclose(f);\n    }\n\n    if (dbname_tmp)\n\t free(dbname_tmp);\n    krb5_free_context(kcontext);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define dfile_err_fmt\t\t\"%s: cannot open %s (%s)\\n\"",
      "#define dbcreaterr_fmt\t\t\"%s: cannot create database %s (%s)\\n\"",
      "#define dbrenerr_fmt\t\t\"%s: cannot rename database %s to %s (%s)\\n\"",
      "#define dbunlockerr_fmt\t\t\"%s: cannot unlock database %s (%s)\\n\"",
      "#define dbdelerr_fmt\t\t\"%s: cannot delete bad database %s (%s)\\n\"",
      "#define dbname_err_fmt\t\t\"%s: cannot set database name to %s (%s)\\n\"",
      "#define dblock_err_fmt\t\t\"%s: cannot initialize database lock (%s)\\n\"",
      "#define dbinit_err_fmt\t\t\"%s: cannot initialize database (%s)\\n\"",
      "#define close_err_fmt\t\t\"%s: cannot close database (%s)\\n\"",
      "#define restfail_fmt\t\t\"%s: %s restore failed\\n\"",
      "#define stdin_name\t\t\"standard input\"",
      "#define ctx_err_fmt\t\t\"%s: cannot initialize Kerberos context\\n\"",
      "#define no_name_mem_fmt\t\t\"%s: cannot get memory for temporary name\\n\"",
      "#define head_bad_fmt\t\t\"%s: dump header bad in %s\\n\""
    ],
    "globals_used": [
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);",
      "dump_version old_version = {\n     \"Kerberos version 5 old format\",\n     \"kdb5_edit load_dump version 2.0\\n\",\n     0,\n     1,\n     dump_k5beta_iterator,\n     NULL,\n     process_k5beta_record,\n};",
      "dump_version beta6_version = {\n     \"Kerberos version 5 beta 6 format\",\n     \"kdb5_edit load_dump version 3.0\\n\",\n     0,\n     1,\n     dump_k5beta6_iterator,\n     NULL,\n     process_k5beta6_record,\n};",
      "dump_version beta7_version = {\n     \"Kerberos version 5\",\n     \"kdb5_util load_dump version 4\\n\",\n     0,\n     0,\n     dump_k5beta7_princ,\n     dump_k5beta7_policy,\n     process_k5beta7_record,\n};",
      "dump_version ov_version = {\n     \"OpenV*Secure V1.0\",\n     \"OpenV*Secure V1.0\\t\",\n     1,\n     1,\n     dump_ov_princ,\n     dump_k5beta7_policy,\n     process_ov_record,\n};",
      "dump_version r1_3_version = {\n     \"Kerberos version 5 release 1.3\",\n     \"kdb5_util load_dump version 5\\n\",\n     0,\n     0,\n     dump_k5beta7_princ_withpolicy,\n     dump_k5beta7_policy,\n     process_k5beta7_record,\n};",
      "extern int\t\texit_status;",
      "extern kadm5_config_params global_params;",
      "static const char oldoption[] = \"-old\";",
      "static const char b6option[] = \"-b6\";",
      "static const char b7option[] = \"-b7\";",
      "static const char verboseoption[] = \"-verbose\";",
      "static const char updateoption[] = \"-update\";",
      "static const char hashoption[] = \"-hash\";",
      "static const char ovoption[] = \"-ov\";",
      "static const char dump_tmptrail[] = \"~\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "kcontext"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dbname_tmp"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_lock_file",
          "args": [
            "kcontext",
            "fileno(f)",
            "KRB5_LOCKMODE_UNLOCK"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "f"
          ],
          "line": 2403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "close_err_fmt",
            "programname",
            "error_message(kret)"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_close_policy",
          "args": [
            "tmppol_db"
          ],
          "line": 2395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s while releasing permanent lock\\n\"",
            "programname",
            "error_message(kret)"
          ],
          "line": 2390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_release_lock",
          "args": [
            "tmppol_db"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s while renaming policy db %s to %s\\n\"",
            "programname",
            "error_message(kret)",
            "newparams.admin_dbname",
            "global_params.admin_dbname"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_rename_policy_db",
          "args": [
            "&newparams",
            "&global_params"
          ],
          "line": 2378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "close_err_fmt",
            "programname",
            "error_message(kret)"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_close_policy",
          "args": [
            "tmppol_db"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "dbrenerr_fmt",
            "programname",
            "dbname_tmp",
            "dbname",
            "error_message(kret)"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_rename",
          "args": [
            "kcontext",
            "dbname_tmp",
            "dbname"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s while destroying policy database\\n\"",
            "programname",
            "error_message(kret)"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_destroy_policy_db",
          "args": [
            "&newparams"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "dbdelerr_fmt",
            "programname",
            "dbname_tmp",
            "error_message(kret)"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_destroy",
          "args": [
            "kcontext",
            "dbname_tmp"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_create_magic_princs",
          "args": [
            "&newparams",
            "kcontext"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "kadm5_create_magic_princs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/kadm5_create.c",
          "lines": "101-125",
          "snippet": "int kadm5_create_magic_princs(kadm5_config_params *params,\n\t\t\t      krb5_context context)\n{\n     int retval;\n     void *handle;\n     \n     retval = krb5_klog_init(context, \"admin_server\", progname, 0);\n     if (retval)\n\t  return retval;\n     if ((retval = kadm5_init(progname, NULL, NULL, params,\n\t\t\t      KADM5_STRUCT_VERSION,\n\t\t\t      KADM5_API_VERSION_2,\n\t\t\t      &handle))) {\n\t  com_err(progname, retval, \"while initializing the Kerberos admin interface\");\n\t  return retval;\n     }\n\n     retval = add_admin_princs(handle, context, params->realm);\n\n     kadm5_destroy(handle);\n\n     krb5_klog_close(context);\n\n     return retval;\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <krb5/kdb.h>",
            "#include <krb5.h>",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <kadm5/adb.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"string_table.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int add_admin_princs(void *handle, krb5_context context, char *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <krb5/kdb.h>\n#include <krb5.h>\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <kadm5/adb.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"string_table.h\"\n\nstatic int add_admin_princs(void *handle, krb5_context context, char *realm);\n\nint kadm5_create_magic_princs(kadm5_config_params *params,\n\t\t\t      krb5_context context)\n{\n     int retval;\n     void *handle;\n     \n     retval = krb5_klog_init(context, \"admin_server\", progname, 0);\n     if (retval)\n\t  return retval;\n     if ((retval = kadm5_init(progname, NULL, NULL, params,\n\t\t\t      KADM5_STRUCT_VERSION,\n\t\t\t      KADM5_API_VERSION_2,\n\t\t\t      &handle))) {\n\t  com_err(progname, retval, \"while initializing the Kerberos admin interface\");\n\t  return retval;\n     }\n\n     retval = add_admin_princs(handle, context, params->realm);\n\n     kadm5_destroy(handle);\n\n     krb5_klog_close(context);\n\n     return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "close_err_fmt",
            "programname",
            "error_message(kret)"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_fini",
          "args": [
            "kcontext"
          ],
          "line": 2328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "dbunlockerr_fmt",
            "programname",
            "dbname_tmp",
            "error_message(kret)"
          ],
          "line": 2324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_unlock",
          "args": [
            "kcontext"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "restfail_fmt",
            "programname",
            "load->name"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restore_dump",
          "args": [
            "programname",
            "kcontext",
            "(dumpfile) ? dumpfile : stdin_name",
            "f",
            "verbose",
            "load",
            "tmppol_db"
          ],
          "line": 2315
        },
        "resolved": true,
        "details": {
          "function_name": "restore_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "2044-2076",
          "snippet": "static int\nrestore_dump(programname, kcontext, dumpfile, f, verbose, dump, pol_db)\n    char\t\t*programname;\n    krb5_context\tkcontext;\n    char\t\t*dumpfile;\n    FILE\t\t*f;\n    int\t\t\tverbose;\n    dump_version\t*dump;\n    osa_adb_policy_t\tpol_db;\n{\n    int\t\terror;\t\n    int\t\tlineno;\n\n    error = 0;\n    lineno = 1;\n\n    /*\n     * Process the records.\n     */\n    while (!(error = (*dump->load_record)(dumpfile,\n\t\t\t\t\t  kcontext, \n\t\t\t\t\t  f,\n\t\t\t\t\t  verbose,\n\t\t\t\t\t  &lineno,\n\t\t\t\t\t  pol_db)))\n\t ;\n    if (error != -1)\n\t fprintf(stderr, err_line_fmt, programname, lineno, dumpfile);\n    else\n\t error = 0;\n\n    return(error);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define err_line_fmt\t\t\"%s: error processing line %d of %s\\n\""
          ],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define err_line_fmt\t\t\"%s: error processing line %d of %s\\n\"\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nrestore_dump(programname, kcontext, dumpfile, f, verbose, dump, pol_db)\n    char\t\t*programname;\n    krb5_context\tkcontext;\n    char\t\t*dumpfile;\n    FILE\t\t*f;\n    int\t\t\tverbose;\n    dump_version\t*dump;\n    osa_adb_policy_t\tpol_db;\n{\n    int\t\terror;\t\n    int\t\tlineno;\n\n    error = 0;\n    lineno = 1;\n\n    /*\n     * Process the records.\n     */\n    while (!(error = (*dump->load_record)(dumpfile,\n\t\t\t\t\t  kcontext, \n\t\t\t\t\t  f,\n\t\t\t\t\t  verbose,\n\t\t\t\t\t  &lineno,\n\t\t\t\t\t  pol_db)))\n\t ;\n    if (error != -1)\n\t fprintf(stderr, err_line_fmt, programname, lineno, dumpfile);\n    else\n\t error = 0;\n\n    return(error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "dblock_err_fmt",
            "programname",
            "error_message(kret)"
          ],
          "line": 2308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_lock",
          "args": [
            "kcontext",
            "KRB5_LOCKMODE_EXCLUSIVE"
          ],
          "line": 2306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "dbinit_err_fmt",
            "programname",
            "error_message(kret)"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_init",
          "args": [
            "kcontext"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s while permanently locking database\\n\"",
            "programname",
            "error_message(kret)"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_get_lock",
          "args": [
            "tmppol_db",
            "OSA_ADB_PERMANENT"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s while opening policy database\\n\"",
            "programname",
            "error_message(kret)"
          ],
          "line": 2275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_open_policy",
          "args": [
            "&tmppol_db",
            "&newparams"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "dbname_err_fmt",
            "programname",
            "(update) ? dbname : dbname_tmp",
            "error_message(kret)"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_set_name",
          "args": [
            "kcontext",
            "(update) ? dbname : dbname_tmp"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_free_config_params",
          "args": [
            "kcontext",
            "&newparams"
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s while creating policy database\\n\"",
            "programname",
            "error_message(kret)"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_create_policy_db",
          "args": [
            "&newparams"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_free_config_params",
          "args": [
            "kcontext",
            "&newparams"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "dbcreaterr_fmt",
            "programname",
            "dbname_tmp",
            "error_message(kret)"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_create",
          "args": [
            "kcontext",
            "dbname_tmp",
            "crflags"
          ],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "kret",
            "\"while retreiving new configuration parameters\""
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_get_config_params",
          "args": [
            "kcontext",
            "NULL",
            "NULL",
            "&newparams",
            "&newparams"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: dump version %s can only be loaded with the \"\n\t\t \"-update flag\\n\"",
            "programname",
            "load->name"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "head_bad_fmt",
            "programname",
            "dumpfile"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "ov_version.header",
            "strlen(ov_version.header)"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ov_version.header"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "r1_3_version.header"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "beta7_version.header"
          ],
          "line": 2201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "beta6_version.header"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "old_version.header"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "head_bad_fmt",
            "programname",
            "dumpfile"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "load->header",
            "strlen(load->header)"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "load->header"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "sizeof(buf)",
            "f"
          ],
          "line": 2186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Cannot lock %s: %s\\n\"",
            "programname",
            "dumpfile",
            "error_message(errno)"
          ],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_lock_file",
          "args": [
            "kcontext",
            "fileno(f)",
            "KRB5_LOCKMODE_SHARED"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "f"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "dfile_err_fmt",
            "programname",
            "dumpfile",
            "error_message(errno)"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "dumpfile",
            "\"r+\""
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "ctx_err_fmt",
            "programname"
          ],
          "line": 2156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_init_context",
          "args": [
            "&kcontext"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "dbname_tmp",
            "dump_tmptrail"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dbname_tmp",
            "dbname"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "no_name_mem_fmt",
            "argv[0]"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(dbname)+\n\t\t\t\t       strlen(dump_tmptrail)+1"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dump_tmptrail"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbname"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 2138
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/kdb5_util.c",
          "lines": "82-98",
          "snippet": "void usage()\n{\n     fprintf(stderr, \"Usage: \"\n\t   \"kdb5_util [-r realm] [-d dbname] [-k mkeytype] [-M mkeyname]\\n\"\n\t     \"\\t        [-sf stashfilename] [-m] cmd [cmd_options]\\n\"\n\t     \"\\tcreate\t[-s]\\n\"\n\t     \"\\tdestroy\t[-f]\\n\"\n\t     \"\\tstash\t[-f keyfile]\\n\"\n\t     \"\\tdump\t[-old] [-ov] [-b6] [-verbose]\\n\"\n\t     \"\\t\t[-mkey_convert] [-new_mkey_file mkey_file]\\n\"\n\t     \"\\t\t[-rev] [-recurse] [filename [princs...]]\\n\"\n\t     \"\\tload\t[-old] [-ov] [-b6] [-verbose] [-update] filename\\n\"\n\t     \"\\tdump_v4\t[-S] [filename]\\n\"\n\t     \"\\tload_v4\t[-S] [-t] [-n] [-v] [-K] [-s stashfile] inputfile\\n\"\n\t     \"\\tark\t[-e etype_list] principal\\n\");\n     exit(1);\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <time.h>",
            "#include <kadm5/adb.h>",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <time.h>\n#include <kadm5/adb.h>\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nvoid usage()\n{\n     fprintf(stderr, \"Usage: \"\n\t   \"kdb5_util [-r realm] [-d dbname] [-k mkeytype] [-M mkeyname]\\n\"\n\t     \"\\t        [-sf stashfilename] [-m] cmd [cmd_options]\\n\"\n\t     \"\\tcreate\t[-s]\\n\"\n\t     \"\\tdestroy\t[-f]\\n\"\n\t     \"\\tstash\t[-f keyfile]\\n\"\n\t     \"\\tdump\t[-old] [-ov] [-b6] [-verbose]\\n\"\n\t     \"\\t\t[-mkey_convert] [-new_mkey_file mkey_file]\\n\"\n\t     \"\\t\t[-rev] [-recurse] [filename [princs...]]\\n\"\n\t     \"\\tload\t[-old] [-ov] [-b6] [-verbose] [-update] filename\\n\"\n\t     \"\\tdump_v4\t[-S] [filename]\\n\"\n\t     \"\\tload_v4\t[-S] [-t] [-n] [-v] [-K] [-s stashfile] inputfile\\n\"\n\t     \"\\tark\t[-e etype_list] principal\\n\");\n     exit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "hashoption"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "updateoption"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "verboseoption"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "ovoption"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "b7option"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "b6option"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "oldoption"
          ],
          "line": 2120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "(int) '/'"
          ],
          "line": 2109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "programname",
            "(int) '/'"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define dfile_err_fmt\t\t\"%s: cannot open %s (%s)\\n\"\n#define dbcreaterr_fmt\t\t\"%s: cannot create database %s (%s)\\n\"\n#define dbrenerr_fmt\t\t\"%s: cannot rename database %s to %s (%s)\\n\"\n#define dbunlockerr_fmt\t\t\"%s: cannot unlock database %s (%s)\\n\"\n#define dbdelerr_fmt\t\t\"%s: cannot delete bad database %s (%s)\\n\"\n#define dbname_err_fmt\t\t\"%s: cannot set database name to %s (%s)\\n\"\n#define dblock_err_fmt\t\t\"%s: cannot initialize database lock (%s)\\n\"\n#define dbinit_err_fmt\t\t\"%s: cannot initialize database (%s)\\n\"\n#define close_err_fmt\t\t\"%s: cannot close database (%s)\\n\"\n#define restfail_fmt\t\t\"%s: %s restore failed\\n\"\n#define stdin_name\t\t\"standard input\"\n#define ctx_err_fmt\t\t\"%s: cannot initialize Kerberos context\\n\"\n#define no_name_mem_fmt\t\t\"%s: cannot get memory for temporary name\\n\"\n#define head_bad_fmt\t\t\"%s: dump header bad in %s\\n\"\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\ndump_version old_version = {\n     \"Kerberos version 5 old format\",\n     \"kdb5_edit load_dump version 2.0\\n\",\n     0,\n     1,\n     dump_k5beta_iterator,\n     NULL,\n     process_k5beta_record,\n};\ndump_version beta6_version = {\n     \"Kerberos version 5 beta 6 format\",\n     \"kdb5_edit load_dump version 3.0\\n\",\n     0,\n     1,\n     dump_k5beta6_iterator,\n     NULL,\n     process_k5beta6_record,\n};\ndump_version beta7_version = {\n     \"Kerberos version 5\",\n     \"kdb5_util load_dump version 4\\n\",\n     0,\n     0,\n     dump_k5beta7_princ,\n     dump_k5beta7_policy,\n     process_k5beta7_record,\n};\ndump_version ov_version = {\n     \"OpenV*Secure V1.0\",\n     \"OpenV*Secure V1.0\\t\",\n     1,\n     1,\n     dump_ov_princ,\n     dump_k5beta7_policy,\n     process_ov_record,\n};\ndump_version r1_3_version = {\n     \"Kerberos version 5 release 1.3\",\n     \"kdb5_util load_dump version 5\\n\",\n     0,\n     0,\n     dump_k5beta7_princ_withpolicy,\n     dump_k5beta7_policy,\n     process_k5beta7_record,\n};\nextern int\t\texit_status;\nextern kadm5_config_params global_params;\nstatic const char oldoption[] = \"-old\";\nstatic const char b6option[] = \"-b6\";\nstatic const char b7option[] = \"-b7\";\nstatic const char verboseoption[] = \"-verbose\";\nstatic const char updateoption[] = \"-update\";\nstatic const char hashoption[] = \"-hash\";\nstatic const char ovoption[] = \"-ov\";\nstatic const char dump_tmptrail[] = \"~\";\n\nvoid\nload_db(argc, argv)\n    int\t\targc;\n    char\t**argv;\n{\n    kadm5_config_params newparams;\n    osa_adb_policy_t\ttmppol_db;\n    krb5_error_code\tkret;\n    krb5_context\tkcontext;\n    FILE\t\t*f;\n    extern char\t\t*optarg;\n    extern int\t\toptind;\n    char\t\t*programname;\n    char\t\t*dumpfile;\n    char\t\t*dbname;\n    char\t\t*dbname_tmp;\n    char\t\tbuf[BUFSIZ];\n    dump_version\t*load;\n    int\t\t\tupdate, verbose;\n    krb5_int32\t\tcrflags;\n    int\t\t\taindex;\n\n    /*\n     * Parse the arguments.\n     */\n    programname = argv[0];\n    if (strrchr(programname, (int) '/'))\n\tprogramname = strrchr(argv[0], (int) '/') + 1;\n    dumpfile = (char *) NULL;\n    dbname = global_params.dbname;\n    load = NULL;\n    update = 0;\n    verbose = 0;\n    crflags = KRB5_KDB_CREATE_BTREE;\n    exit_status = 0;\n    dbname_tmp = (char *) NULL;\n    tmppol_db = NULL;\n    for (aindex = 1; aindex < argc; aindex++) {\n\tif (!strcmp(argv[aindex], oldoption))\n\t     load = &old_version;\n\telse if (!strcmp(argv[aindex], b6option))\n\t     load = &beta6_version;\n\telse if (!strcmp(argv[aindex], b7option))\n\t     load = &beta7_version;\n\telse if (!strcmp(argv[aindex], ovoption))\n\t     load = &ov_version;\n\telse if (!strcmp(argv[aindex], verboseoption))\n\t    verbose = 1;\n\telse if (!strcmp(argv[aindex], updateoption))\n\t    update = 1;\n\telse if (!strcmp(argv[aindex], hashoption))\n\t    crflags = KRB5_KDB_CREATE_HASH;\n\telse\n\t    break;\n    }\n    if ((argc - aindex) != 1) {\n\tusage();\n\treturn;\n    }\n    dumpfile = argv[aindex];\n\n    if (!(dbname_tmp = (char *) malloc(strlen(dbname)+\n\t\t\t\t       strlen(dump_tmptrail)+1))) {\n\tfprintf(stderr, no_name_mem_fmt, argv[0]);\n\texit_status++;\n\treturn;\n    }\n    strcpy(dbname_tmp, dbname);\n    strcat(dbname_tmp, dump_tmptrail);\n\n    /*\n     * Initialize the Kerberos context and error tables.\n     */\n    if ((kret = krb5_init_context(&kcontext))) {\n\tfprintf(stderr, ctx_err_fmt, programname);\n\tfree(dbname_tmp);\n\texit_status++;\n\treturn;\n    }\n\n    /*\n     * Open the dumpfile\n     */\n    if (dumpfile) {\n\tif ((f = fopen(dumpfile, \"r+\")) == NULL) {\n\t     fprintf(stderr, dfile_err_fmt, programname, dumpfile,\n\t\t     error_message(errno)); \n\t     exit_status++;\n\t     return;\n\t}\n\tif ((kret = krb5_lock_file(kcontext, fileno(f),\n\t\t\t\t   KRB5_LOCKMODE_SHARED))) {\n\t     fprintf(stderr, \"%s: Cannot lock %s: %s\\n\", programname,\n\t\t     dumpfile, error_message(errno));\n\t     exit_status++;\n\t     return;\n\t}\n    } else\n\tf = stdin;\n\n    /*\n     * Auto-detect dump version if we weren't told, verify if we\n     * were told.\n     */\n    fgets(buf, sizeof(buf), f);\n    if (load) {\n\t /* only check what we know; some headers only contain a prefix */\n\t if (strncmp(buf, load->header, strlen(load->header)) != 0) {\n\t      fprintf(stderr, head_bad_fmt, programname, dumpfile);\n\t      exit_status++;\n\t      if (dumpfile) fclose(f);\n\t      return;\n\t }\n    } else {\n\t /* perhaps this should be in an array, but so what? */\n\t if (strcmp(buf, old_version.header) == 0)\n\t      load = &old_version;\n\t else if (strcmp(buf, beta6_version.header) == 0)\n\t      load = &beta6_version;\n\t else if (strcmp(buf, beta7_version.header) == 0)\n\t      load = &beta7_version;\n\t else if (strcmp(buf, r1_3_version.header) == 0)\n\t      load = &r1_3_version;\n\t else if (strncmp(buf, ov_version.header,\n\t\t\t  strlen(ov_version.header)) == 0)\n\t      load = &ov_version;\n\t else {\n\t      fprintf(stderr, head_bad_fmt, programname, dumpfile);\n\t      exit_status++;\n\t      if (dumpfile) fclose(f);\n\t      return;\n\t }\n    }\n    if (load->updateonly && !update) {\n\t fprintf(stderr, \"%s: dump version %s can only be loaded with the \"\n\t\t \"-update flag\\n\", programname, load->name);\n\t exit_status++;\n\t return;\n    }\n\n    /*\n     * Cons up params for the new databases.  If we are not in update\n     * mode use a temp name that we'll rename later.\n     */\n    newparams = global_params;\n    if (! update) {\n\t newparams.mask |= KADM5_CONFIG_DBNAME;\n\t newparams.dbname = dbname_tmp;\n\n\t if ((kret = kadm5_get_config_params(kcontext, NULL, NULL,\n\t\t\t\t\t     &newparams, &newparams))) {\n\t      com_err(argv[0], kret,\n\t\t      \"while retreiving new configuration parameters\");\n\t      exit_status++;\n\t      return;\n\t }\n    }\n    \n    /*\n     * If not an update restoration, create the temp database.  Always\n     * create a temp policy db, even if we are not loading a dump file\n     * with policy info, because they may be loading an old dump\n     * intending to use it with the new kadm5 system.\n     */\n    if (!update && ((kret = krb5_db_create(kcontext, dbname_tmp, crflags)))) {\n\t fprintf(stderr, dbcreaterr_fmt,\n\t\t programname, dbname_tmp, error_message(kret));\n\t exit_status++;\n\t kadm5_free_config_params(kcontext, &newparams);\n\t if (dumpfile) fclose(f);\n\t return;\n    }\n    if (!update && (kret = osa_adb_create_policy_db(&newparams))) {\n\t fprintf(stderr, \"%s: %s while creating policy database\\n\",\n\t\t programname, error_message(kret));\n\t exit_status++;\n\t kadm5_free_config_params(kcontext, &newparams);\n\t if (dumpfile) fclose(f);\n\t return;\n    }\n\n    /*\n     * Point ourselves at the new databases.\n     */\n    if ((kret = krb5_db_set_name(kcontext,\n\t\t\t\t(update) ? dbname : dbname_tmp))) {\n\t fprintf(stderr, dbname_err_fmt,\n\t\t programname, \n\t\t (update) ? dbname : dbname_tmp, error_message(kret));\n\t exit_status++;\n\t goto error;\n    }\n    if ((kret = osa_adb_open_policy(&tmppol_db, &newparams))) {\n\t fprintf(stderr, \"%s: %s while opening policy database\\n\",\n\t\t programname, error_message(kret));\n\t exit_status++;\n\t goto error;\n    }\n    /*\n     * If an update restoration, make sure the db is left unusable if\n     * the update fails.\n     */\n    if (update) {\n\t if ((kret = osa_adb_get_lock(tmppol_db, OSA_ADB_PERMANENT))) {\n\t      fprintf(stderr, \"%s: %s while permanently locking database\\n\",\n\t\t      programname, error_message(kret));\n\t      exit_status++;\n\t      goto error;\n\t }\n    }\n\t\t      \n    /*\n     * Initialize the database.\n     */\n    if ((kret = krb5_db_init(kcontext))) {\n\t fprintf(stderr, dbinit_err_fmt,\n\t\t programname, error_message(kret));\n\t exit_status++;\n\t goto error;\n    }\n    /* \n     * grab an extra lock, since there are no other users\n     */\n    if (!update) {\n\t kret = krb5_db_lock(kcontext, KRB5_LOCKMODE_EXCLUSIVE);\n\t if (kret) {\n\t\t fprintf(stderr, dblock_err_fmt,\n\t\t\t programname, error_message(kret));\n\t\t exit_status++;\n\t\t goto error;\n\t }\n    }\n    \n    if (restore_dump(programname, kcontext, (dumpfile) ? dumpfile : stdin_name,\n\t\t     f, verbose, load, tmppol_db)) {\n\t fprintf(stderr, restfail_fmt,\n\t\t programname, load->name);\n\t exit_status++;\n    }\n\n    if (!update && (kret = krb5_db_unlock(kcontext))) {\n\t /* change this error? */\n\t fprintf(stderr, dbunlockerr_fmt,\n\t\t programname, dbname_tmp, error_message(kret));\n\t exit_status++;\n    }\n    if ((kret = krb5_db_fini(kcontext))) {\n\t fprintf(stderr, close_err_fmt,\n\t\t programname, error_message(kret));\n\t exit_status++;\n    }\n\n    if (!update && load->create_kadm5 &&\n\t((kret = kadm5_create_magic_princs(&newparams, kcontext)))) {\n\t /* error message printed by create_magic_princs */\n\t exit_status++;\n    }\n    \n    /* close policy db below */\n\nerror:\n    /*\n     * If not an update: if there was an error, destroy the temp database,\n     * otherwise rename it into place.\n     *\n     * If an update: if there was no error, unlock the database.\n     */\n    if (!update) {\n\t if (exit_status) {\n\t      if ((kret = krb5_db_destroy(kcontext, dbname_tmp))) {\n\t\t   fprintf(stderr, dbdelerr_fmt,\n\t\t\t   programname, dbname_tmp, error_message(kret));\n\t\t   exit_status++;\n\t      }\n\t      if ((kret = osa_adb_destroy_policy_db(&newparams))) {\n\t\t   fprintf(stderr, \"%s: %s while destroying policy database\\n\",\n\t\t\t   programname, error_message(kret));\n\t\t   exit_status++;\n\t      }\n\t }\n\t else {\n\t      if ((kret = krb5_db_rename(kcontext,\n\t\t\t\t\t dbname_tmp,\n\t\t\t\t\t dbname))) {\n\t\t   fprintf(stderr, dbrenerr_fmt,\n\t\t\t   programname, dbname_tmp, dbname,\n\t\t\t   error_message(kret));\n\t\t   exit_status++;\n\t      } \n\n\t      if ((kret = osa_adb_close_policy(tmppol_db))) {\n\t\t   fprintf(stderr, close_err_fmt,\n\t\t\t   programname, error_message(kret));\n\t\t   exit_status++;\n\t      }\n\n\t      if ((kret = osa_adb_rename_policy_db(&newparams,\n\t\t\t\t\t\t   &global_params))) {\n\t\t   fprintf(stderr,\n\t\t\t   \"%s: %s while renaming policy db %s to %s\\n\",\n\t\t\t   programname, error_message(kret),\n\t\t\t   newparams.admin_dbname,\n\t\t\t   global_params.admin_dbname);\n\t\t   exit_status++;\n\t      }\n\t }\n    } else /* update */ {\n\t if (! exit_status && ((kret = osa_adb_release_lock(tmppol_db)))) {\n\t      fprintf(stderr, \"%s: %s while releasing permanent lock\\n\",\n\t\t      programname, error_message(kret));\n\t      exit_status++;\n\t }\n\n\t if (tmppol_db && ((kret = osa_adb_close_policy(tmppol_db)))) {\n\t      fprintf(stderr, close_err_fmt,\n\t\t      programname, error_message(kret));\n\t      exit_status++;\n\t }\n    }\n\n    if (dumpfile) {\n\t (void) krb5_lock_file(kcontext, fileno(f), KRB5_LOCKMODE_UNLOCK);\n\t fclose(f);\n    }\n\n    if (dbname_tmp)\n\t free(dbname_tmp);\n    krb5_free_context(kcontext);\n}"
  },
  {
    "function_name": "restore_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "2044-2076",
    "snippet": "static int\nrestore_dump(programname, kcontext, dumpfile, f, verbose, dump, pol_db)\n    char\t\t*programname;\n    krb5_context\tkcontext;\n    char\t\t*dumpfile;\n    FILE\t\t*f;\n    int\t\t\tverbose;\n    dump_version\t*dump;\n    osa_adb_policy_t\tpol_db;\n{\n    int\t\terror;\t\n    int\t\tlineno;\n\n    error = 0;\n    lineno = 1;\n\n    /*\n     * Process the records.\n     */\n    while (!(error = (*dump->load_record)(dumpfile,\n\t\t\t\t\t  kcontext, \n\t\t\t\t\t  f,\n\t\t\t\t\t  verbose,\n\t\t\t\t\t  &lineno,\n\t\t\t\t\t  pol_db)))\n\t ;\n    if (error != -1)\n\t fprintf(stderr, err_line_fmt, programname, lineno, dumpfile);\n    else\n\t error = 0;\n\n    return(error);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define err_line_fmt\t\t\"%s: error processing line %d of %s\\n\""
    ],
    "globals_used": [
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "err_line_fmt",
            "programname",
            "lineno",
            "dumpfile"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dumpfile",
            "kcontext",
            "f",
            "verbose",
            "&lineno",
            "pol_db"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define err_line_fmt\t\t\"%s: error processing line %d of %s\\n\"\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nrestore_dump(programname, kcontext, dumpfile, f, verbose, dump, pol_db)\n    char\t\t*programname;\n    krb5_context\tkcontext;\n    char\t\t*dumpfile;\n    FILE\t\t*f;\n    int\t\t\tverbose;\n    dump_version\t*dump;\n    osa_adb_policy_t\tpol_db;\n{\n    int\t\terror;\t\n    int\t\tlineno;\n\n    error = 0;\n    lineno = 1;\n\n    /*\n     * Process the records.\n     */\n    while (!(error = (*dump->load_record)(dumpfile,\n\t\t\t\t\t  kcontext, \n\t\t\t\t\t  f,\n\t\t\t\t\t  verbose,\n\t\t\t\t\t  &lineno,\n\t\t\t\t\t  pol_db)))\n\t ;\n    if (error != -1)\n\t fprintf(stderr, err_line_fmt, programname, lineno, dumpfile);\n    else\n\t error = 0;\n\n    return(error);\n}"
  },
  {
    "function_name": "process_ov_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "2007-2039",
    "snippet": "static int\nprocess_ov_record(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n   void *pol_db;\n{\n     int nread;\n     char rectype[100];\n\n     nread = fscanf(filep, \"%100s\\t\", rectype);\n     if (nread == EOF)\n\t  return -1;\n     else if (nread != 1)\n\t  return 1;\n     if (strcmp(rectype, \"princ\") == 0)\n\t  process_ov_principal(fname, kcontext, filep, verbose,\n\t\t\t       linenop, pol_db);\n     else if (strcmp(rectype, \"policy\") == 0)\n\t  process_k5beta7_policy(fname, kcontext, filep, verbose,\n\t\t\t\t linenop, pol_db);\n     else if (strcmp(rectype, \"End\") == 0)\n\t  return -1;\n     else {\n\t  fprintf(stderr, \"unknown record type \\\"%s\\\" on line %d\\n\",\n\t\t  rectype, *linenop);\n\t  return 1;\n     }\n\n     return 0;\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unknown record type \\\"%s\\\" on line %d\\n\"",
            "rectype",
            "*linenop"
          ],
          "line": 2033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rectype",
            "\"End\""
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_k5beta7_policy",
          "args": [
            "fname",
            "kcontext",
            "filep",
            "verbose",
            "linenop",
            "pol_db"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "process_k5beta7_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "1923-1963",
          "snippet": "static int \nprocess_k5beta7_policy(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n    void *pol_db;\n{\n    osa_policy_ent_rec rec;\n    char namebuf[1024];\n    int nread, ret;\n\n    (*linenop)++;\n    rec.name = namebuf;\n\n    nread = fscanf(filep, \"%1024s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\", rec.name,\n\t\t   &rec.pw_min_life, &rec.pw_max_life,\n\t\t   &rec.pw_min_length, &rec.pw_min_classes,\n\t\t   &rec.pw_history_num, &rec.policy_refcnt);\n    if (nread == EOF)\n\t return -1;\n    else if (nread != 7) {\n\t fprintf(stderr, \"cannot parse policy on line %d (%d read)\\n\",\n\t\t *linenop, nread);\n\t return 1;\n    }\n\n    if ((ret = osa_adb_create_policy(pol_db, &rec))) {\n\t if (ret == OSA_ADB_DUP &&\n\t     ((ret = osa_adb_put_policy(pol_db, &rec)))) {\n\t      fprintf(stderr, \"cannot create policy on line %d: %s\\n\",\n\t\t      *linenop, error_message(ret));\n\t      return 1;\n\t }\n    }\n    if (verbose)\n\t fprintf(stderr, \"created policy %s\\n\", rec.name);\n    \n    return 0;\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int \nprocess_k5beta7_policy(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n    void *pol_db;\n{\n    osa_policy_ent_rec rec;\n    char namebuf[1024];\n    int nread, ret;\n\n    (*linenop)++;\n    rec.name = namebuf;\n\n    nread = fscanf(filep, \"%1024s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\", rec.name,\n\t\t   &rec.pw_min_life, &rec.pw_max_life,\n\t\t   &rec.pw_min_length, &rec.pw_min_classes,\n\t\t   &rec.pw_history_num, &rec.policy_refcnt);\n    if (nread == EOF)\n\t return -1;\n    else if (nread != 7) {\n\t fprintf(stderr, \"cannot parse policy on line %d (%d read)\\n\",\n\t\t *linenop, nread);\n\t return 1;\n    }\n\n    if ((ret = osa_adb_create_policy(pol_db, &rec))) {\n\t if (ret == OSA_ADB_DUP &&\n\t     ((ret = osa_adb_put_policy(pol_db, &rec)))) {\n\t      fprintf(stderr, \"cannot create policy on line %d: %s\\n\",\n\t\t      *linenop, error_message(ret));\n\t      return 1;\n\t }\n    }\n    if (verbose)\n\t fprintf(stderr, \"created policy %s\\n\", rec.name);\n    \n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rectype",
            "\"policy\""
          ],
          "line": 2027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_ov_principal",
          "args": [
            "fname",
            "kcontext",
            "filep",
            "verbose",
            "linenop",
            "pol_db"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "process_ov_principal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/ovload.c",
          "lines": "95-210",
          "snippet": "int process_ov_principal(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n    void *pol_db;\n{\n    XDR\t\t\t    xdrs;\n    osa_princ_ent_t\t    rec;\n    osa_adb_ret_t\t    ret;\n    krb5_tl_data\t    tl_data;\n    krb5_principal\t    princ;\n    krb5_db_entry\t    kdb;\n    char\t\t    *current;\n    char\t\t    *cp;\n    int\t\t\t    x, one;\n    krb5_boolean\t    more;\n    char\t\t    line[LINESIZE];\n\n    if (fgets(line, LINESIZE, filep) == (char *) NULL) {\n\t return IMPORT_BAD_FILE;\n    }\n    if((cp = nstrtok(line, \"\\t\")) == NULL)\n\treturn IMPORT_BAD_FILE;\n    if((rec = (osa_princ_ent_t) malloc(sizeof(osa_princ_ent_rec))) == NULL)\n\treturn ENOMEM;\n    memset(rec, 0, sizeof(osa_princ_ent_rec));\n    if((ret = krb5_parse_name(kcontext, cp, &princ))) \n\tgoto done;\n    krb5_unparse_name(kcontext, princ, &current);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret =  IMPORT_FAILED;\n\tgoto done;\n    } else {\n\tif(strcmp(cp, \"\")) {\n\t    if((rec->policy = (char *) malloc(strlen(cp)+1)) == NULL)  {\n\t\tret = ENOMEM;\n\t\tgoto done;\n\t    }\n\t    strcpy(rec->policy, cp);\n\t} else rec->policy = NULL;\n    }\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->aux_attributes = strtol(cp, (char  **)NULL, 16);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->old_key_len = atoi(cp);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->old_key_next = atoi(cp);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->admin_history_kvno = atoi(cp);\n    if (! rec->old_key_len) {\n       rec->old_keys = NULL;\n    } else {\n       if(!(rec->old_keys = (osa_pw_hist_ent *)\n\t    malloc(sizeof(osa_pw_hist_ent) * rec->old_key_len))) {\n\t  ret = ENOMEM;\n\t  goto done;\n       }\n       memset(rec->old_keys,0,\n\t      sizeof(osa_pw_hist_ent) * rec->old_key_len);\n       for(x = 0; x < rec->old_key_len; x++)\n\t    parse_pw_hist_ent(current, &rec->old_keys[x]);\n    }\n\n    xdralloc_create(&xdrs, XDR_ENCODE);\n    if (! xdr_osa_princ_ent_rec(&xdrs, rec)) {\n\t xdr_destroy(&xdrs);\n\t ret = OSA_ADB_XDR_FAILURE;\n\t goto done;\n    }\n\n    tl_data.tl_data_type = KRB5_TL_KADM_DATA;\n    tl_data.tl_data_length = xdr_getpos(&xdrs);\n    tl_data.tl_data_contents = (krb5_octet *) xdralloc_getdata(&xdrs);\n\n    one = 1;\n    ret = krb5_db_get_principal(kcontext, princ, &kdb, &one, &more);\n    if (ret)\n\t goto done;\n    \n    ret = krb5_dbe_update_tl_data(kcontext, &kdb, &tl_data);\n    if (ret)\n\t goto done;\n\n    ret = krb5_db_put_principal(kcontext, &kdb, &one);\n    if (ret)\n\t goto done;\n\n    xdr_destroy(&xdrs);\n\n    (*linenop)++;\n\ndone:\n    free(current);\n    krb5_free_principal(kcontext, princ);\n    osa_free_princ_ent(rec);\n    return ret;\n}",
          "includes": [
            "#include    \"nstrtok.h\"",
            "#include    \"kdb5_util.h\"",
            "#include    \"import_err.h\"",
            "#include    <kadm5/adb.h>",
            "#include    <memory.h>",
            "#include    <stdlib.h>",
            "#include    <string.h>",
            "#include    <unistd.h>"
          ],
          "macros_used": [
            "#define LINESIZE\t32768 /* XXX */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include    \"nstrtok.h\"\n#include    \"kdb5_util.h\"\n#include    \"import_err.h\"\n#include    <kadm5/adb.h>\n#include    <memory.h>\n#include    <stdlib.h>\n#include    <string.h>\n#include    <unistd.h>\n\n#define LINESIZE\t32768 /* XXX */\n\nint process_ov_principal(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n    void *pol_db;\n{\n    XDR\t\t\t    xdrs;\n    osa_princ_ent_t\t    rec;\n    osa_adb_ret_t\t    ret;\n    krb5_tl_data\t    tl_data;\n    krb5_principal\t    princ;\n    krb5_db_entry\t    kdb;\n    char\t\t    *current;\n    char\t\t    *cp;\n    int\t\t\t    x, one;\n    krb5_boolean\t    more;\n    char\t\t    line[LINESIZE];\n\n    if (fgets(line, LINESIZE, filep) == (char *) NULL) {\n\t return IMPORT_BAD_FILE;\n    }\n    if((cp = nstrtok(line, \"\\t\")) == NULL)\n\treturn IMPORT_BAD_FILE;\n    if((rec = (osa_princ_ent_t) malloc(sizeof(osa_princ_ent_rec))) == NULL)\n\treturn ENOMEM;\n    memset(rec, 0, sizeof(osa_princ_ent_rec));\n    if((ret = krb5_parse_name(kcontext, cp, &princ))) \n\tgoto done;\n    krb5_unparse_name(kcontext, princ, &current);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret =  IMPORT_FAILED;\n\tgoto done;\n    } else {\n\tif(strcmp(cp, \"\")) {\n\t    if((rec->policy = (char *) malloc(strlen(cp)+1)) == NULL)  {\n\t\tret = ENOMEM;\n\t\tgoto done;\n\t    }\n\t    strcpy(rec->policy, cp);\n\t} else rec->policy = NULL;\n    }\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->aux_attributes = strtol(cp, (char  **)NULL, 16);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->old_key_len = atoi(cp);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->old_key_next = atoi(cp);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->admin_history_kvno = atoi(cp);\n    if (! rec->old_key_len) {\n       rec->old_keys = NULL;\n    } else {\n       if(!(rec->old_keys = (osa_pw_hist_ent *)\n\t    malloc(sizeof(osa_pw_hist_ent) * rec->old_key_len))) {\n\t  ret = ENOMEM;\n\t  goto done;\n       }\n       memset(rec->old_keys,0,\n\t      sizeof(osa_pw_hist_ent) * rec->old_key_len);\n       for(x = 0; x < rec->old_key_len; x++)\n\t    parse_pw_hist_ent(current, &rec->old_keys[x]);\n    }\n\n    xdralloc_create(&xdrs, XDR_ENCODE);\n    if (! xdr_osa_princ_ent_rec(&xdrs, rec)) {\n\t xdr_destroy(&xdrs);\n\t ret = OSA_ADB_XDR_FAILURE;\n\t goto done;\n    }\n\n    tl_data.tl_data_type = KRB5_TL_KADM_DATA;\n    tl_data.tl_data_length = xdr_getpos(&xdrs);\n    tl_data.tl_data_contents = (krb5_octet *) xdralloc_getdata(&xdrs);\n\n    one = 1;\n    ret = krb5_db_get_principal(kcontext, princ, &kdb, &one, &more);\n    if (ret)\n\t goto done;\n    \n    ret = krb5_dbe_update_tl_data(kcontext, &kdb, &tl_data);\n    if (ret)\n\t goto done;\n\n    ret = krb5_db_put_principal(kcontext, &kdb, &one);\n    if (ret)\n\t goto done;\n\n    xdr_destroy(&xdrs);\n\n    (*linenop)++;\n\ndone:\n    free(current);\n    krb5_free_principal(kcontext, princ);\n    osa_free_princ_ent(rec);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rectype",
            "\"princ\""
          ],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%100s\\t\"",
            "rectype"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nprocess_ov_record(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n   void *pol_db;\n{\n     int nread;\n     char rectype[100];\n\n     nread = fscanf(filep, \"%100s\\t\", rectype);\n     if (nread == EOF)\n\t  return -1;\n     else if (nread != 1)\n\t  return 1;\n     if (strcmp(rectype, \"princ\") == 0)\n\t  process_ov_principal(fname, kcontext, filep, verbose,\n\t\t\t       linenop, pol_db);\n     else if (strcmp(rectype, \"policy\") == 0)\n\t  process_k5beta7_policy(fname, kcontext, filep, verbose,\n\t\t\t\t linenop, pol_db);\n     else if (strcmp(rectype, \"End\") == 0)\n\t  return -1;\n     else {\n\t  fprintf(stderr, \"unknown record type \\\"%s\\\" on line %d\\n\",\n\t\t  rectype, *linenop);\n\t  return 1;\n     }\n\n     return 0;\n}"
  },
  {
    "function_name": "process_k5beta7_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "1970-2000",
    "snippet": "static int\nprocess_k5beta7_record(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n   void *pol_db;\n{\n     int nread;\n     char rectype[100];\n\n     nread = fscanf(filep, \"%100s\\t\", rectype);\n     if (nread == EOF)\n\t  return -1;\n     else if (nread != 1)\n\t  return 1;\n     if (strcmp(rectype, \"princ\") == 0)\n\t  process_k5beta6_record(fname, kcontext, filep, verbose,\n\t\t\t\t linenop, pol_db);\n     else if (strcmp(rectype, \"policy\") == 0)\n\t  process_k5beta7_policy(fname, kcontext, filep, verbose,\n\t\t\t\t linenop, pol_db);\n     else {\n\t  fprintf(stderr, \"unknown record type \\\"%s\\\" on line %d\\n\",\n\t\t  rectype, *linenop);\n\t  return 1;\n     }\n\n     return 0;\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"unknown record type \\\"%s\\\" on line %d\\n\"",
            "rectype",
            "*linenop"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_k5beta7_policy",
          "args": [
            "fname",
            "kcontext",
            "filep",
            "verbose",
            "linenop",
            "pol_db"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "process_k5beta7_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "1923-1963",
          "snippet": "static int \nprocess_k5beta7_policy(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n    void *pol_db;\n{\n    osa_policy_ent_rec rec;\n    char namebuf[1024];\n    int nread, ret;\n\n    (*linenop)++;\n    rec.name = namebuf;\n\n    nread = fscanf(filep, \"%1024s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\", rec.name,\n\t\t   &rec.pw_min_life, &rec.pw_max_life,\n\t\t   &rec.pw_min_length, &rec.pw_min_classes,\n\t\t   &rec.pw_history_num, &rec.policy_refcnt);\n    if (nread == EOF)\n\t return -1;\n    else if (nread != 7) {\n\t fprintf(stderr, \"cannot parse policy on line %d (%d read)\\n\",\n\t\t *linenop, nread);\n\t return 1;\n    }\n\n    if ((ret = osa_adb_create_policy(pol_db, &rec))) {\n\t if (ret == OSA_ADB_DUP &&\n\t     ((ret = osa_adb_put_policy(pol_db, &rec)))) {\n\t      fprintf(stderr, \"cannot create policy on line %d: %s\\n\",\n\t\t      *linenop, error_message(ret));\n\t      return 1;\n\t }\n    }\n    if (verbose)\n\t fprintf(stderr, \"created policy %s\\n\", rec.name);\n    \n    return 0;\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int \nprocess_k5beta7_policy(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n    void *pol_db;\n{\n    osa_policy_ent_rec rec;\n    char namebuf[1024];\n    int nread, ret;\n\n    (*linenop)++;\n    rec.name = namebuf;\n\n    nread = fscanf(filep, \"%1024s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\", rec.name,\n\t\t   &rec.pw_min_life, &rec.pw_max_life,\n\t\t   &rec.pw_min_length, &rec.pw_min_classes,\n\t\t   &rec.pw_history_num, &rec.policy_refcnt);\n    if (nread == EOF)\n\t return -1;\n    else if (nread != 7) {\n\t fprintf(stderr, \"cannot parse policy on line %d (%d read)\\n\",\n\t\t *linenop, nread);\n\t return 1;\n    }\n\n    if ((ret = osa_adb_create_policy(pol_db, &rec))) {\n\t if (ret == OSA_ADB_DUP &&\n\t     ((ret = osa_adb_put_policy(pol_db, &rec)))) {\n\t      fprintf(stderr, \"cannot create policy on line %d: %s\\n\",\n\t\t      *linenop, error_message(ret));\n\t      return 1;\n\t }\n    }\n    if (verbose)\n\t fprintf(stderr, \"created policy %s\\n\", rec.name);\n    \n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rectype",
            "\"policy\""
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_k5beta6_record",
          "args": [
            "fname",
            "kcontext",
            "filep",
            "verbose",
            "linenop",
            "pol_db"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "process_k5beta6_record",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "1666-1921",
          "snippet": "static int\nprocess_k5beta6_record(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n   void *pol_db;\n{\n    int\t\t\tretval;\n    krb5_db_entry\tdbentry;\n    krb5_int32\t\tt1, t2, t3, t4, t5, t6, t7, t8, t9;\n    int\t\t\tnread;\n    int\t\t\terror;\n    int\t\t\ti, j, one;\n    char\t\t*name;\n    krb5_key_data\t*kp, *kdatap;\n    krb5_tl_data\t**tlp, *tl;\n    krb5_octet \t\t*op;\n    krb5_error_code\tkret;\n    const char\t\t*try2read;\n\n    try2read = (char *) NULL;\n    memset((char *) &dbentry, 0, sizeof(dbentry));\n    (*linenop)++;\n    retval = 1;\n    name = (char *) NULL;\n    kp = (krb5_key_data *) NULL;\n    op = (krb5_octet *) NULL;\n    error = 0;\n    kret = 0;\n    nread = fscanf(filep, \"%d\\t%d\\t%d\\t%d\\t%d\\t\", &t1, &t2, &t3, &t4, &t5);\n    if (nread == 5) {\n\t/* Get memory for flattened principal name */\n\tif (!(name = (char *) malloc((size_t) t2 + 1)))\n\t    error++;\n\n\t/* Get memory for and form tagged data linked list */\n\ttlp = &dbentry.tl_data;\n\tfor (i=0; i<t3; i++) {\n\t    if ((*tlp = (krb5_tl_data *) malloc(sizeof(krb5_tl_data)))) {\n\t\tmemset(*tlp, 0, sizeof(krb5_tl_data));\n\t\ttlp = &((*tlp)->tl_data_next);\n\t\tdbentry.n_tl_data++;\n\t    }\n\t    else {\n\t\terror++;\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Get memory for key list */\n\tif (t4 && !(kp = (krb5_key_data *) malloc((size_t)\n\t\t\t\t\t\t  (t4*sizeof(krb5_key_data)))))\n\t    error++;\n\n\t/* Get memory for extra data */\n\tif (t5 && !(op = (krb5_octet *) malloc((size_t) t5)))\n\t    error++;\n\n\tif (!error) {\n\t    dbentry.len = t1;\n\t    dbentry.n_key_data = t4;\n\t    dbentry.e_length = t5;\n\t    if (kp) {\n\t\tmemset(kp, 0, (size_t) (t4*sizeof(krb5_key_data)));\n\t\tdbentry.key_data = kp;\n\t\tkp = (krb5_key_data *) NULL;\n\t    }\n\t    if (op) {\n\t\tmemset(op, 0, (size_t) t5);\n\t\tdbentry.e_data = op;\n\t\top = (krb5_octet *) NULL;\n\t    }\n\n\t    /* Read in and parse the principal name */\n\t    if (!read_string(filep, name, t2, linenop) &&\n\t\t!(kret = krb5_parse_name(kcontext, name, &dbentry.princ))) {\n\n\t\t/* Get the fixed principal attributes */\n\t\tnread = fscanf(filep, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t\t       &t2, &t3, &t4, &t5, &t6, &t7, &t8, &t9);\n\t\tif (nread == 8) {\n\t\t    dbentry.attributes = (krb5_flags) t2;\n\t\t    dbentry.max_life = (krb5_deltat) t3;\n\t\t    dbentry.max_renewable_life = (krb5_deltat) t4;\n\t\t    dbentry.expiration = (krb5_timestamp) t5;\n\t\t    dbentry.pw_expiration = (krb5_timestamp) t6;\n\t\t    dbentry.last_success = (krb5_timestamp) t7;\n\t\t    dbentry.last_failed = (krb5_timestamp) t8;\n\t\t    dbentry.fail_auth_count = (krb5_kvno) t9;\n\t\t} else {\n\t\t    try2read = read_nint_data;\n\t\t    error++;\n\t\t}\n\n\t\t/*\n\t\t * Get the tagged data.\n\t\t *\n\t\t * Really, this code ought to discard tl data types\n\t\t * that it knows are special to the current version\n\t\t * and were not supported in the previous version.\n\t\t * But it's a pain to implement that here, and doing\n\t\t * it at dump time has almost as good an effect, so\n\t\t * that's what I did.  [krb5-admin/89]\n\t\t */\n\t\tif (!error && dbentry.n_tl_data) {\n\t\t    for (tl = dbentry.tl_data; tl; tl = tl->tl_data_next) {\n\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t1, &t2);\n\t\t\tif (nread == 2) {\n\t\t\t    tl->tl_data_type = (krb5_int16) t1;\n\t\t\t    tl->tl_data_length = (krb5_int16) t2;\n\t\t\t    if (tl->tl_data_length) {\n\t\t\t\tif (!(tl->tl_data_contents =\n\t\t\t\t      (krb5_octet *) malloc((size_t) t2+1)) ||\n\t\t\t\t    read_octet_string(filep,\n\t\t\t\t\t\t      tl->tl_data_contents,\n\t\t\t\t\t\t      t2)) {\n\t\t\t\t    try2read = read_tcontents;\n\t\t\t\t    error++;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else {\n\t\t\t\t/* Should be a null field */\n\t\t\t\tnread = fscanf(filep, \"%d\", &t9);\n\t\t\t\tif ((nread != 1) || (t9 != -1)) {\n\t\t\t\t    error++;\n\t\t\t\t    try2read = read_tcontents;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\telse {\n\t\t\t    try2read = read_ttypelen;\n\t\t\t    error++;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/* Get the key data */\n\t\tif (!error && dbentry.n_key_data) {\n\t\t    for (i=0; !error && (i<dbentry.n_key_data); i++) {\n\t\t\tkdatap = &dbentry.key_data[i];\n\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t1, &t2);\n\t\t\tif (nread == 2) {\n\t\t\t    kdatap->key_data_ver = (krb5_int16) t1;\n\t\t\t    kdatap->key_data_kvno = (krb5_int16) t2;\n\n\t\t\t    for (j=0; j<t1; j++) {\n\t\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t3, &t4);\n\t\t\t\tif (nread == 2) {\n\t\t\t\t    kdatap->key_data_type[j] = t3;\n\t\t\t\t    kdatap->key_data_length[j] = t4;\n\t\t\t\t    if (t4) {\n\t\t\t\t\tif (!(kdatap->key_data_contents[j] =\n\t\t\t\t\t      (krb5_octet *)\n\t\t\t\t\t      malloc((size_t) t4+1)) ||\n\t\t\t\t\t    read_octet_string(filep,\n\t\t\t\t\t\t\t      kdatap->key_data_contents[j],\n\t\t\t\t\t\t\t      t4)) {\n\t\t\t\t\t    try2read = read_kcontents;\n\t\t\t\t\t    error++;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t\t/* Should be a null field */\n\t\t\t\t\tnread = fscanf(filep, \"%d\", &t9);\n\t\t\t\t\tif ((nread != 1) || (t9 != -1)) {\n\t\t\t\t\t    error++;\n\t\t\t\t\t    try2read = read_kcontents;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t    try2read = read_ktypelen;\n\t\t\t\t    error++;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/* Get the extra data */\n\t\tif (!error && dbentry.e_length) {\n\t\t    if (read_octet_string(filep,\n\t\t\t\t\t  dbentry.e_data,\n\t\t\t\t\t  (int) dbentry.e_length)) {\n\t\t\ttry2read = read_econtents;\n\t\t\terror++;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    nread = fscanf(filep, \"%d\", &t9);\n\t\t    if ((nread != 1) || (t9 != -1)) {\n\t\t\terror++;\n\t\t\ttry2read = read_econtents;\n\t\t    }\n\t\t}\n\n\t\t/* Finally, find the end of the record. */\n\t\tif (!error)\n\t\t    find_record_end(filep, fname, *linenop);\n\n\t\t/*\n\t\t * We have either read in all the data or choked.\n\t\t */\n\t\tif (!error) {\n\t\t    one = 1;\n\t\t    if ((kret = krb5_db_put_principal(kcontext,\n\t\t\t\t\t\t      &dbentry,\n\t\t\t\t\t\t      &one))) {\n\t\t\tfprintf(stderr, store_err_fmt,\n\t\t\t\tfname, *linenop,\n\t\t\t\tname, error_message(kret));\n\t\t    }\n\t\t    else {\n\t\t\tif (verbose)\n\t\t\t    fprintf(stderr, add_princ_fmt, name);\n\t\t\tretval = 0;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    fprintf(stderr, read_err_fmt, fname, *linenop, try2read);\n\t\t}\n\t    }\n\t    else {\n\t\tif (kret)\n\t\t    fprintf(stderr, parse_err_fmt,\n\t\t\t    fname, *linenop, name, error_message(kret));\n\t\telse\n\t\t    fprintf(stderr, no_mem_fmt, fname, *linenop);\n\t    }\n\t}\n\telse {\n\t    fprintf(stderr, rhead_err_fmt, fname, *linenop);\n\t}\n\n\tif (op)\n\t    free(op);\n\tif (kp)\n\t    free(kp);\n\tif (name)\n\t    free(name);\n\tkrb5_db_free_principal(kcontext, &dbentry, 1);\n    }\n    else {\n\tif (nread == EOF)\n\t    retval = -1;\n    }\n    return(retval);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define read_econtents\t\t\"extra data contents\"",
            "#define read_ktypelen\t\t\"key data type and length\"",
            "#define read_kcontents\t\t\"key data contents\"",
            "#define read_ttypelen\t\t\"tagged data type and length\"",
            "#define read_tcontents\t\t\"tagged data contents\"",
            "#define read_nint_data\t\t\"principal static attributes\"",
            "#define rhead_err_fmt\t\t\"%s(%d): cannot match size tokens\\n\"",
            "#define no_mem_fmt\t\t\"%s(%d): no memory for buffers\\n\"",
            "#define read_err_fmt\t\t\"%s(%d): cannot read %s\\n\"",
            "#define parse_err_fmt\t\t\"%s(%d): cannot parse %s (%s)\\n\"",
            "#define add_princ_fmt\t\t\"%s\\n\"",
            "#define store_err_fmt\t\t\"%s(%d): cannot store %s(%s)\\n\""
          ],
          "globals_used": [
            "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
            "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
            "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
            "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
            "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);",
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define read_econtents\t\t\"extra data contents\"\n#define read_ktypelen\t\t\"key data type and length\"\n#define read_kcontents\t\t\"key data contents\"\n#define read_ttypelen\t\t\"tagged data type and length\"\n#define read_tcontents\t\t\"tagged data contents\"\n#define read_nint_data\t\t\"principal static attributes\"\n#define rhead_err_fmt\t\t\"%s(%d): cannot match size tokens\\n\"\n#define no_mem_fmt\t\t\"%s(%d): no memory for buffers\\n\"\n#define read_err_fmt\t\t\"%s(%d): cannot read %s\\n\"\n#define parse_err_fmt\t\t\"%s(%d): cannot parse %s (%s)\\n\"\n#define add_princ_fmt\t\t\"%s\\n\"\n#define store_err_fmt\t\t\"%s(%d): cannot store %s(%s)\\n\"\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nprocess_k5beta6_record(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n   void *pol_db;\n{\n    int\t\t\tretval;\n    krb5_db_entry\tdbentry;\n    krb5_int32\t\tt1, t2, t3, t4, t5, t6, t7, t8, t9;\n    int\t\t\tnread;\n    int\t\t\terror;\n    int\t\t\ti, j, one;\n    char\t\t*name;\n    krb5_key_data\t*kp, *kdatap;\n    krb5_tl_data\t**tlp, *tl;\n    krb5_octet \t\t*op;\n    krb5_error_code\tkret;\n    const char\t\t*try2read;\n\n    try2read = (char *) NULL;\n    memset((char *) &dbentry, 0, sizeof(dbentry));\n    (*linenop)++;\n    retval = 1;\n    name = (char *) NULL;\n    kp = (krb5_key_data *) NULL;\n    op = (krb5_octet *) NULL;\n    error = 0;\n    kret = 0;\n    nread = fscanf(filep, \"%d\\t%d\\t%d\\t%d\\t%d\\t\", &t1, &t2, &t3, &t4, &t5);\n    if (nread == 5) {\n\t/* Get memory for flattened principal name */\n\tif (!(name = (char *) malloc((size_t) t2 + 1)))\n\t    error++;\n\n\t/* Get memory for and form tagged data linked list */\n\ttlp = &dbentry.tl_data;\n\tfor (i=0; i<t3; i++) {\n\t    if ((*tlp = (krb5_tl_data *) malloc(sizeof(krb5_tl_data)))) {\n\t\tmemset(*tlp, 0, sizeof(krb5_tl_data));\n\t\ttlp = &((*tlp)->tl_data_next);\n\t\tdbentry.n_tl_data++;\n\t    }\n\t    else {\n\t\terror++;\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Get memory for key list */\n\tif (t4 && !(kp = (krb5_key_data *) malloc((size_t)\n\t\t\t\t\t\t  (t4*sizeof(krb5_key_data)))))\n\t    error++;\n\n\t/* Get memory for extra data */\n\tif (t5 && !(op = (krb5_octet *) malloc((size_t) t5)))\n\t    error++;\n\n\tif (!error) {\n\t    dbentry.len = t1;\n\t    dbentry.n_key_data = t4;\n\t    dbentry.e_length = t5;\n\t    if (kp) {\n\t\tmemset(kp, 0, (size_t) (t4*sizeof(krb5_key_data)));\n\t\tdbentry.key_data = kp;\n\t\tkp = (krb5_key_data *) NULL;\n\t    }\n\t    if (op) {\n\t\tmemset(op, 0, (size_t) t5);\n\t\tdbentry.e_data = op;\n\t\top = (krb5_octet *) NULL;\n\t    }\n\n\t    /* Read in and parse the principal name */\n\t    if (!read_string(filep, name, t2, linenop) &&\n\t\t!(kret = krb5_parse_name(kcontext, name, &dbentry.princ))) {\n\n\t\t/* Get the fixed principal attributes */\n\t\tnread = fscanf(filep, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t\t       &t2, &t3, &t4, &t5, &t6, &t7, &t8, &t9);\n\t\tif (nread == 8) {\n\t\t    dbentry.attributes = (krb5_flags) t2;\n\t\t    dbentry.max_life = (krb5_deltat) t3;\n\t\t    dbentry.max_renewable_life = (krb5_deltat) t4;\n\t\t    dbentry.expiration = (krb5_timestamp) t5;\n\t\t    dbentry.pw_expiration = (krb5_timestamp) t6;\n\t\t    dbentry.last_success = (krb5_timestamp) t7;\n\t\t    dbentry.last_failed = (krb5_timestamp) t8;\n\t\t    dbentry.fail_auth_count = (krb5_kvno) t9;\n\t\t} else {\n\t\t    try2read = read_nint_data;\n\t\t    error++;\n\t\t}\n\n\t\t/*\n\t\t * Get the tagged data.\n\t\t *\n\t\t * Really, this code ought to discard tl data types\n\t\t * that it knows are special to the current version\n\t\t * and were not supported in the previous version.\n\t\t * But it's a pain to implement that here, and doing\n\t\t * it at dump time has almost as good an effect, so\n\t\t * that's what I did.  [krb5-admin/89]\n\t\t */\n\t\tif (!error && dbentry.n_tl_data) {\n\t\t    for (tl = dbentry.tl_data; tl; tl = tl->tl_data_next) {\n\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t1, &t2);\n\t\t\tif (nread == 2) {\n\t\t\t    tl->tl_data_type = (krb5_int16) t1;\n\t\t\t    tl->tl_data_length = (krb5_int16) t2;\n\t\t\t    if (tl->tl_data_length) {\n\t\t\t\tif (!(tl->tl_data_contents =\n\t\t\t\t      (krb5_octet *) malloc((size_t) t2+1)) ||\n\t\t\t\t    read_octet_string(filep,\n\t\t\t\t\t\t      tl->tl_data_contents,\n\t\t\t\t\t\t      t2)) {\n\t\t\t\t    try2read = read_tcontents;\n\t\t\t\t    error++;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else {\n\t\t\t\t/* Should be a null field */\n\t\t\t\tnread = fscanf(filep, \"%d\", &t9);\n\t\t\t\tif ((nread != 1) || (t9 != -1)) {\n\t\t\t\t    error++;\n\t\t\t\t    try2read = read_tcontents;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\telse {\n\t\t\t    try2read = read_ttypelen;\n\t\t\t    error++;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/* Get the key data */\n\t\tif (!error && dbentry.n_key_data) {\n\t\t    for (i=0; !error && (i<dbentry.n_key_data); i++) {\n\t\t\tkdatap = &dbentry.key_data[i];\n\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t1, &t2);\n\t\t\tif (nread == 2) {\n\t\t\t    kdatap->key_data_ver = (krb5_int16) t1;\n\t\t\t    kdatap->key_data_kvno = (krb5_int16) t2;\n\n\t\t\t    for (j=0; j<t1; j++) {\n\t\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t3, &t4);\n\t\t\t\tif (nread == 2) {\n\t\t\t\t    kdatap->key_data_type[j] = t3;\n\t\t\t\t    kdatap->key_data_length[j] = t4;\n\t\t\t\t    if (t4) {\n\t\t\t\t\tif (!(kdatap->key_data_contents[j] =\n\t\t\t\t\t      (krb5_octet *)\n\t\t\t\t\t      malloc((size_t) t4+1)) ||\n\t\t\t\t\t    read_octet_string(filep,\n\t\t\t\t\t\t\t      kdatap->key_data_contents[j],\n\t\t\t\t\t\t\t      t4)) {\n\t\t\t\t\t    try2read = read_kcontents;\n\t\t\t\t\t    error++;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t\t/* Should be a null field */\n\t\t\t\t\tnread = fscanf(filep, \"%d\", &t9);\n\t\t\t\t\tif ((nread != 1) || (t9 != -1)) {\n\t\t\t\t\t    error++;\n\t\t\t\t\t    try2read = read_kcontents;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t    try2read = read_ktypelen;\n\t\t\t\t    error++;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/* Get the extra data */\n\t\tif (!error && dbentry.e_length) {\n\t\t    if (read_octet_string(filep,\n\t\t\t\t\t  dbentry.e_data,\n\t\t\t\t\t  (int) dbentry.e_length)) {\n\t\t\ttry2read = read_econtents;\n\t\t\terror++;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    nread = fscanf(filep, \"%d\", &t9);\n\t\t    if ((nread != 1) || (t9 != -1)) {\n\t\t\terror++;\n\t\t\ttry2read = read_econtents;\n\t\t    }\n\t\t}\n\n\t\t/* Finally, find the end of the record. */\n\t\tif (!error)\n\t\t    find_record_end(filep, fname, *linenop);\n\n\t\t/*\n\t\t * We have either read in all the data or choked.\n\t\t */\n\t\tif (!error) {\n\t\t    one = 1;\n\t\t    if ((kret = krb5_db_put_principal(kcontext,\n\t\t\t\t\t\t      &dbentry,\n\t\t\t\t\t\t      &one))) {\n\t\t\tfprintf(stderr, store_err_fmt,\n\t\t\t\tfname, *linenop,\n\t\t\t\tname, error_message(kret));\n\t\t    }\n\t\t    else {\n\t\t\tif (verbose)\n\t\t\t    fprintf(stderr, add_princ_fmt, name);\n\t\t\tretval = 0;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    fprintf(stderr, read_err_fmt, fname, *linenop, try2read);\n\t\t}\n\t    }\n\t    else {\n\t\tif (kret)\n\t\t    fprintf(stderr, parse_err_fmt,\n\t\t\t    fname, *linenop, name, error_message(kret));\n\t\telse\n\t\t    fprintf(stderr, no_mem_fmt, fname, *linenop);\n\t    }\n\t}\n\telse {\n\t    fprintf(stderr, rhead_err_fmt, fname, *linenop);\n\t}\n\n\tif (op)\n\t    free(op);\n\tif (kp)\n\t    free(kp);\n\tif (name)\n\t    free(name);\n\tkrb5_db_free_principal(kcontext, &dbentry, 1);\n    }\n    else {\n\tif (nread == EOF)\n\t    retval = -1;\n    }\n    return(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rectype",
            "\"princ\""
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%100s\\t\"",
            "rectype"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nprocess_k5beta7_record(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n   void *pol_db;\n{\n     int nread;\n     char rectype[100];\n\n     nread = fscanf(filep, \"%100s\\t\", rectype);\n     if (nread == EOF)\n\t  return -1;\n     else if (nread != 1)\n\t  return 1;\n     if (strcmp(rectype, \"princ\") == 0)\n\t  process_k5beta6_record(fname, kcontext, filep, verbose,\n\t\t\t\t linenop, pol_db);\n     else if (strcmp(rectype, \"policy\") == 0)\n\t  process_k5beta7_policy(fname, kcontext, filep, verbose,\n\t\t\t\t linenop, pol_db);\n     else {\n\t  fprintf(stderr, \"unknown record type \\\"%s\\\" on line %d\\n\",\n\t\t  rectype, *linenop);\n\t  return 1;\n     }\n\n     return 0;\n}"
  },
  {
    "function_name": "process_k5beta7_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "1923-1963",
    "snippet": "static int \nprocess_k5beta7_policy(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n    void *pol_db;\n{\n    osa_policy_ent_rec rec;\n    char namebuf[1024];\n    int nread, ret;\n\n    (*linenop)++;\n    rec.name = namebuf;\n\n    nread = fscanf(filep, \"%1024s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\", rec.name,\n\t\t   &rec.pw_min_life, &rec.pw_max_life,\n\t\t   &rec.pw_min_length, &rec.pw_min_classes,\n\t\t   &rec.pw_history_num, &rec.policy_refcnt);\n    if (nread == EOF)\n\t return -1;\n    else if (nread != 7) {\n\t fprintf(stderr, \"cannot parse policy on line %d (%d read)\\n\",\n\t\t *linenop, nread);\n\t return 1;\n    }\n\n    if ((ret = osa_adb_create_policy(pol_db, &rec))) {\n\t if (ret == OSA_ADB_DUP &&\n\t     ((ret = osa_adb_put_policy(pol_db, &rec)))) {\n\t      fprintf(stderr, \"cannot create policy on line %d: %s\\n\",\n\t\t      *linenop, error_message(ret));\n\t      return 1;\n\t }\n    }\n    if (verbose)\n\t fprintf(stderr, \"created policy %s\\n\", rec.name);\n    \n    return 0;\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"created policy %s\\n\"",
            "rec.name"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cannot create policy on line %d: %s\\n\"",
            "*linenop",
            "error_message(ret)"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_put_policy",
          "args": [
            "pol_db",
            "&rec"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_create_policy",
          "args": [
            "pol_db",
            "&rec"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"cannot parse policy on line %d (%d read)\\n\"",
            "*linenop",
            "nread"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%1024s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\"",
            "rec.name",
            "&rec.pw_min_life",
            "&rec.pw_max_life",
            "&rec.pw_min_length",
            "&rec.pw_min_classes",
            "&rec.pw_history_num",
            "&rec.policy_refcnt"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int \nprocess_k5beta7_policy(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n    void *pol_db;\n{\n    osa_policy_ent_rec rec;\n    char namebuf[1024];\n    int nread, ret;\n\n    (*linenop)++;\n    rec.name = namebuf;\n\n    nread = fscanf(filep, \"%1024s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\", rec.name,\n\t\t   &rec.pw_min_life, &rec.pw_max_life,\n\t\t   &rec.pw_min_length, &rec.pw_min_classes,\n\t\t   &rec.pw_history_num, &rec.policy_refcnt);\n    if (nread == EOF)\n\t return -1;\n    else if (nread != 7) {\n\t fprintf(stderr, \"cannot parse policy on line %d (%d read)\\n\",\n\t\t *linenop, nread);\n\t return 1;\n    }\n\n    if ((ret = osa_adb_create_policy(pol_db, &rec))) {\n\t if (ret == OSA_ADB_DUP &&\n\t     ((ret = osa_adb_put_policy(pol_db, &rec)))) {\n\t      fprintf(stderr, \"cannot create policy on line %d: %s\\n\",\n\t\t      *linenop, error_message(ret));\n\t      return 1;\n\t }\n    }\n    if (verbose)\n\t fprintf(stderr, \"created policy %s\\n\", rec.name);\n    \n    return 0;\n}"
  },
  {
    "function_name": "process_k5beta6_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "1666-1921",
    "snippet": "static int\nprocess_k5beta6_record(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n   void *pol_db;\n{\n    int\t\t\tretval;\n    krb5_db_entry\tdbentry;\n    krb5_int32\t\tt1, t2, t3, t4, t5, t6, t7, t8, t9;\n    int\t\t\tnread;\n    int\t\t\terror;\n    int\t\t\ti, j, one;\n    char\t\t*name;\n    krb5_key_data\t*kp, *kdatap;\n    krb5_tl_data\t**tlp, *tl;\n    krb5_octet \t\t*op;\n    krb5_error_code\tkret;\n    const char\t\t*try2read;\n\n    try2read = (char *) NULL;\n    memset((char *) &dbentry, 0, sizeof(dbentry));\n    (*linenop)++;\n    retval = 1;\n    name = (char *) NULL;\n    kp = (krb5_key_data *) NULL;\n    op = (krb5_octet *) NULL;\n    error = 0;\n    kret = 0;\n    nread = fscanf(filep, \"%d\\t%d\\t%d\\t%d\\t%d\\t\", &t1, &t2, &t3, &t4, &t5);\n    if (nread == 5) {\n\t/* Get memory for flattened principal name */\n\tif (!(name = (char *) malloc((size_t) t2 + 1)))\n\t    error++;\n\n\t/* Get memory for and form tagged data linked list */\n\ttlp = &dbentry.tl_data;\n\tfor (i=0; i<t3; i++) {\n\t    if ((*tlp = (krb5_tl_data *) malloc(sizeof(krb5_tl_data)))) {\n\t\tmemset(*tlp, 0, sizeof(krb5_tl_data));\n\t\ttlp = &((*tlp)->tl_data_next);\n\t\tdbentry.n_tl_data++;\n\t    }\n\t    else {\n\t\terror++;\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Get memory for key list */\n\tif (t4 && !(kp = (krb5_key_data *) malloc((size_t)\n\t\t\t\t\t\t  (t4*sizeof(krb5_key_data)))))\n\t    error++;\n\n\t/* Get memory for extra data */\n\tif (t5 && !(op = (krb5_octet *) malloc((size_t) t5)))\n\t    error++;\n\n\tif (!error) {\n\t    dbentry.len = t1;\n\t    dbentry.n_key_data = t4;\n\t    dbentry.e_length = t5;\n\t    if (kp) {\n\t\tmemset(kp, 0, (size_t) (t4*sizeof(krb5_key_data)));\n\t\tdbentry.key_data = kp;\n\t\tkp = (krb5_key_data *) NULL;\n\t    }\n\t    if (op) {\n\t\tmemset(op, 0, (size_t) t5);\n\t\tdbentry.e_data = op;\n\t\top = (krb5_octet *) NULL;\n\t    }\n\n\t    /* Read in and parse the principal name */\n\t    if (!read_string(filep, name, t2, linenop) &&\n\t\t!(kret = krb5_parse_name(kcontext, name, &dbentry.princ))) {\n\n\t\t/* Get the fixed principal attributes */\n\t\tnread = fscanf(filep, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t\t       &t2, &t3, &t4, &t5, &t6, &t7, &t8, &t9);\n\t\tif (nread == 8) {\n\t\t    dbentry.attributes = (krb5_flags) t2;\n\t\t    dbentry.max_life = (krb5_deltat) t3;\n\t\t    dbentry.max_renewable_life = (krb5_deltat) t4;\n\t\t    dbentry.expiration = (krb5_timestamp) t5;\n\t\t    dbentry.pw_expiration = (krb5_timestamp) t6;\n\t\t    dbentry.last_success = (krb5_timestamp) t7;\n\t\t    dbentry.last_failed = (krb5_timestamp) t8;\n\t\t    dbentry.fail_auth_count = (krb5_kvno) t9;\n\t\t} else {\n\t\t    try2read = read_nint_data;\n\t\t    error++;\n\t\t}\n\n\t\t/*\n\t\t * Get the tagged data.\n\t\t *\n\t\t * Really, this code ought to discard tl data types\n\t\t * that it knows are special to the current version\n\t\t * and were not supported in the previous version.\n\t\t * But it's a pain to implement that here, and doing\n\t\t * it at dump time has almost as good an effect, so\n\t\t * that's what I did.  [krb5-admin/89]\n\t\t */\n\t\tif (!error && dbentry.n_tl_data) {\n\t\t    for (tl = dbentry.tl_data; tl; tl = tl->tl_data_next) {\n\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t1, &t2);\n\t\t\tif (nread == 2) {\n\t\t\t    tl->tl_data_type = (krb5_int16) t1;\n\t\t\t    tl->tl_data_length = (krb5_int16) t2;\n\t\t\t    if (tl->tl_data_length) {\n\t\t\t\tif (!(tl->tl_data_contents =\n\t\t\t\t      (krb5_octet *) malloc((size_t) t2+1)) ||\n\t\t\t\t    read_octet_string(filep,\n\t\t\t\t\t\t      tl->tl_data_contents,\n\t\t\t\t\t\t      t2)) {\n\t\t\t\t    try2read = read_tcontents;\n\t\t\t\t    error++;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else {\n\t\t\t\t/* Should be a null field */\n\t\t\t\tnread = fscanf(filep, \"%d\", &t9);\n\t\t\t\tif ((nread != 1) || (t9 != -1)) {\n\t\t\t\t    error++;\n\t\t\t\t    try2read = read_tcontents;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\telse {\n\t\t\t    try2read = read_ttypelen;\n\t\t\t    error++;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/* Get the key data */\n\t\tif (!error && dbentry.n_key_data) {\n\t\t    for (i=0; !error && (i<dbentry.n_key_data); i++) {\n\t\t\tkdatap = &dbentry.key_data[i];\n\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t1, &t2);\n\t\t\tif (nread == 2) {\n\t\t\t    kdatap->key_data_ver = (krb5_int16) t1;\n\t\t\t    kdatap->key_data_kvno = (krb5_int16) t2;\n\n\t\t\t    for (j=0; j<t1; j++) {\n\t\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t3, &t4);\n\t\t\t\tif (nread == 2) {\n\t\t\t\t    kdatap->key_data_type[j] = t3;\n\t\t\t\t    kdatap->key_data_length[j] = t4;\n\t\t\t\t    if (t4) {\n\t\t\t\t\tif (!(kdatap->key_data_contents[j] =\n\t\t\t\t\t      (krb5_octet *)\n\t\t\t\t\t      malloc((size_t) t4+1)) ||\n\t\t\t\t\t    read_octet_string(filep,\n\t\t\t\t\t\t\t      kdatap->key_data_contents[j],\n\t\t\t\t\t\t\t      t4)) {\n\t\t\t\t\t    try2read = read_kcontents;\n\t\t\t\t\t    error++;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t\t/* Should be a null field */\n\t\t\t\t\tnread = fscanf(filep, \"%d\", &t9);\n\t\t\t\t\tif ((nread != 1) || (t9 != -1)) {\n\t\t\t\t\t    error++;\n\t\t\t\t\t    try2read = read_kcontents;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t    try2read = read_ktypelen;\n\t\t\t\t    error++;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/* Get the extra data */\n\t\tif (!error && dbentry.e_length) {\n\t\t    if (read_octet_string(filep,\n\t\t\t\t\t  dbentry.e_data,\n\t\t\t\t\t  (int) dbentry.e_length)) {\n\t\t\ttry2read = read_econtents;\n\t\t\terror++;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    nread = fscanf(filep, \"%d\", &t9);\n\t\t    if ((nread != 1) || (t9 != -1)) {\n\t\t\terror++;\n\t\t\ttry2read = read_econtents;\n\t\t    }\n\t\t}\n\n\t\t/* Finally, find the end of the record. */\n\t\tif (!error)\n\t\t    find_record_end(filep, fname, *linenop);\n\n\t\t/*\n\t\t * We have either read in all the data or choked.\n\t\t */\n\t\tif (!error) {\n\t\t    one = 1;\n\t\t    if ((kret = krb5_db_put_principal(kcontext,\n\t\t\t\t\t\t      &dbentry,\n\t\t\t\t\t\t      &one))) {\n\t\t\tfprintf(stderr, store_err_fmt,\n\t\t\t\tfname, *linenop,\n\t\t\t\tname, error_message(kret));\n\t\t    }\n\t\t    else {\n\t\t\tif (verbose)\n\t\t\t    fprintf(stderr, add_princ_fmt, name);\n\t\t\tretval = 0;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    fprintf(stderr, read_err_fmt, fname, *linenop, try2read);\n\t\t}\n\t    }\n\t    else {\n\t\tif (kret)\n\t\t    fprintf(stderr, parse_err_fmt,\n\t\t\t    fname, *linenop, name, error_message(kret));\n\t\telse\n\t\t    fprintf(stderr, no_mem_fmt, fname, *linenop);\n\t    }\n\t}\n\telse {\n\t    fprintf(stderr, rhead_err_fmt, fname, *linenop);\n\t}\n\n\tif (op)\n\t    free(op);\n\tif (kp)\n\t    free(kp);\n\tif (name)\n\t    free(name);\n\tkrb5_db_free_principal(kcontext, &dbentry, 1);\n    }\n    else {\n\tif (nread == EOF)\n\t    retval = -1;\n    }\n    return(retval);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define read_econtents\t\t\"extra data contents\"",
      "#define read_ktypelen\t\t\"key data type and length\"",
      "#define read_kcontents\t\t\"key data contents\"",
      "#define read_ttypelen\t\t\"tagged data type and length\"",
      "#define read_tcontents\t\t\"tagged data contents\"",
      "#define read_nint_data\t\t\"principal static attributes\"",
      "#define rhead_err_fmt\t\t\"%s(%d): cannot match size tokens\\n\"",
      "#define no_mem_fmt\t\t\"%s(%d): no memory for buffers\\n\"",
      "#define read_err_fmt\t\t\"%s(%d): cannot read %s\\n\"",
      "#define parse_err_fmt\t\t\"%s(%d): cannot parse %s (%s)\\n\"",
      "#define add_princ_fmt\t\t\"%s\\n\"",
      "#define store_err_fmt\t\t\"%s(%d): cannot store %s(%s)\\n\""
    ],
    "globals_used": [
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);",
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_db_free_principal",
          "args": [
            "kcontext",
            "&dbentry",
            "1"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "rhead_err_fmt",
            "fname",
            "*linenop"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "no_mem_fmt",
            "fname",
            "*linenop"
          ],
          "line": 1901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "parse_err_fmt",
            "fname",
            "*linenop",
            "name",
            "error_message(kret)"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "read_err_fmt",
            "fname",
            "*linenop",
            "try2read"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "add_princ_fmt",
            "name"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "store_err_fmt",
            "fname",
            "*linenop",
            "name",
            "error_message(kret)"
          ],
          "line": 1882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_put_principal",
          "args": [
            "kcontext",
            "&dbentry",
            "&one"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_record_end",
          "args": [
            "filep",
            "fname",
            "*linenop"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "find_record_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "1255-1271",
          "snippet": "static void\nfind_record_end(f, fn, lineno)\n    FILE\t*f;\n    char\t*fn;\n    int\t\tlineno;\n{\n    int\tch;\n\n    if (((ch = fgetc(f)) != ';') || ((ch = fgetc(f)) != '\\n')) {\n\tfprintf(stderr, trash_end_fmt, fn, lineno);\n\twhile (ch != '\\n') {\n\t    putc(ch, stderr);\n\t    ch = fgetc(f);\n\t}\n\tputc(ch, stderr);\n    }\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define trash_end_fmt\t\t\"%s(%d): ignoring trash at end of line: \""
          ],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define trash_end_fmt\t\t\"%s(%d): ignoring trash at end of line: \"\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic void\nfind_record_end(f, fn, lineno)\n    FILE\t*f;\n    char\t*fn;\n    int\t\tlineno;\n{\n    int\tch;\n\n    if (((ch = fgetc(f)) != ';') || ((ch = fgetc(f)) != '\\n')) {\n\tfprintf(stderr, trash_end_fmt, fn, lineno);\n\twhile (ch != '\\n') {\n\t    putc(ch, stderr);\n\t    ch = fgetc(f);\n\t}\n\tputc(ch, stderr);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%d\"",
            "&t9"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_octet_string",
          "args": [
            "filep",
            "dbentry.e_data",
            "(int) dbentry.e_length"
          ],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "read_octet_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "1232-1250",
          "snippet": "static int\nread_octet_string(f, buf, len)\n    FILE\t*f;\n    krb5_octet\t*buf;\n    int\t\tlen;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tif (fscanf(f, \"%02x\", &c) != 1) {\n\t    retval = 1;\n\t    break;\n\t}\n\tbuf[i] = (krb5_octet) c;\n    }\n    return(retval);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nread_octet_string(f, buf, len)\n    FILE\t*f;\n    krb5_octet\t*buf;\n    int\t\tlen;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tif (fscanf(f, \"%02x\", &c) != 1) {\n\t    retval = 1;\n\t    break;\n\t}\n\tbuf[i] = (krb5_octet) c;\n    }\n    return(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%d\"",
            "&t9"
          ],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) t4+1"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%d\\t%d\\t\"",
            "&t3",
            "&t4"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%d\\t%d\\t\"",
            "&t1",
            "&t2"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%d\"",
            "&t9"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) t2+1"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%d\\t%d\\t\"",
            "&t1",
            "&t2"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\"",
            "&t2",
            "&t3",
            "&t4",
            "&t5",
            "&t6",
            "&t7",
            "&t8",
            "&t9"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "kcontext",
            "name",
            "&dbentry.princ"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_string",
          "args": [
            "filep",
            "name",
            "t2",
            "linenop"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "read_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "1204-1227",
          "snippet": "static int\nread_string(f, buf, len, lp)\n    FILE\t*f;\n    char\t*buf;\n    int\t\tlen;\n    int\t\t*lp;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tc = fgetc(f);\n\tif (c < 0) {\n\t    retval = 1;\n\t    break;\n\t}\n\tif (c == '\\n')\n\t    (*lp)++;\n\tbuf[i] = (char) c;\n    }\n    buf[len] = '\\0';\n    return(retval);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nread_string(f, buf, len, lp)\n    FILE\t*f;\n    char\t*buf;\n    int\t\tlen;\n    int\t\t*lp;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tc = fgetc(f);\n\tif (c < 0) {\n\t    retval = 1;\n\t    break;\n\t}\n\tif (c == '\\n')\n\t    (*lp)++;\n\tbuf[i] = (char) c;\n    }\n    buf[len] = '\\0';\n    return(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "op",
            "0",
            "(size_t) t5"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "kp",
            "0",
            "(size_t) (t4*sizeof(krb5_key_data))"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) t5"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t)\n\t\t\t\t\t\t  (t4*sizeof(krb5_key_data))"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "*tlp",
            "0",
            "sizeof(krb5_tl_data)"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(krb5_tl_data)"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) t2 + 1"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%d\\t%d\\t%d\\t%d\\t%d\\t\"",
            "&t1",
            "&t2",
            "&t3",
            "&t4",
            "&t5"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *) &dbentry",
            "0",
            "sizeof(dbentry)"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define read_econtents\t\t\"extra data contents\"\n#define read_ktypelen\t\t\"key data type and length\"\n#define read_kcontents\t\t\"key data contents\"\n#define read_ttypelen\t\t\"tagged data type and length\"\n#define read_tcontents\t\t\"tagged data contents\"\n#define read_nint_data\t\t\"principal static attributes\"\n#define rhead_err_fmt\t\t\"%s(%d): cannot match size tokens\\n\"\n#define no_mem_fmt\t\t\"%s(%d): no memory for buffers\\n\"\n#define read_err_fmt\t\t\"%s(%d): cannot read %s\\n\"\n#define parse_err_fmt\t\t\"%s(%d): cannot parse %s (%s)\\n\"\n#define add_princ_fmt\t\t\"%s\\n\"\n#define store_err_fmt\t\t\"%s(%d): cannot store %s(%s)\\n\"\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nprocess_k5beta6_record(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n   void *pol_db;\n{\n    int\t\t\tretval;\n    krb5_db_entry\tdbentry;\n    krb5_int32\t\tt1, t2, t3, t4, t5, t6, t7, t8, t9;\n    int\t\t\tnread;\n    int\t\t\terror;\n    int\t\t\ti, j, one;\n    char\t\t*name;\n    krb5_key_data\t*kp, *kdatap;\n    krb5_tl_data\t**tlp, *tl;\n    krb5_octet \t\t*op;\n    krb5_error_code\tkret;\n    const char\t\t*try2read;\n\n    try2read = (char *) NULL;\n    memset((char *) &dbentry, 0, sizeof(dbentry));\n    (*linenop)++;\n    retval = 1;\n    name = (char *) NULL;\n    kp = (krb5_key_data *) NULL;\n    op = (krb5_octet *) NULL;\n    error = 0;\n    kret = 0;\n    nread = fscanf(filep, \"%d\\t%d\\t%d\\t%d\\t%d\\t\", &t1, &t2, &t3, &t4, &t5);\n    if (nread == 5) {\n\t/* Get memory for flattened principal name */\n\tif (!(name = (char *) malloc((size_t) t2 + 1)))\n\t    error++;\n\n\t/* Get memory for and form tagged data linked list */\n\ttlp = &dbentry.tl_data;\n\tfor (i=0; i<t3; i++) {\n\t    if ((*tlp = (krb5_tl_data *) malloc(sizeof(krb5_tl_data)))) {\n\t\tmemset(*tlp, 0, sizeof(krb5_tl_data));\n\t\ttlp = &((*tlp)->tl_data_next);\n\t\tdbentry.n_tl_data++;\n\t    }\n\t    else {\n\t\terror++;\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Get memory for key list */\n\tif (t4 && !(kp = (krb5_key_data *) malloc((size_t)\n\t\t\t\t\t\t  (t4*sizeof(krb5_key_data)))))\n\t    error++;\n\n\t/* Get memory for extra data */\n\tif (t5 && !(op = (krb5_octet *) malloc((size_t) t5)))\n\t    error++;\n\n\tif (!error) {\n\t    dbentry.len = t1;\n\t    dbentry.n_key_data = t4;\n\t    dbentry.e_length = t5;\n\t    if (kp) {\n\t\tmemset(kp, 0, (size_t) (t4*sizeof(krb5_key_data)));\n\t\tdbentry.key_data = kp;\n\t\tkp = (krb5_key_data *) NULL;\n\t    }\n\t    if (op) {\n\t\tmemset(op, 0, (size_t) t5);\n\t\tdbentry.e_data = op;\n\t\top = (krb5_octet *) NULL;\n\t    }\n\n\t    /* Read in and parse the principal name */\n\t    if (!read_string(filep, name, t2, linenop) &&\n\t\t!(kret = krb5_parse_name(kcontext, name, &dbentry.princ))) {\n\n\t\t/* Get the fixed principal attributes */\n\t\tnread = fscanf(filep, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t\t       &t2, &t3, &t4, &t5, &t6, &t7, &t8, &t9);\n\t\tif (nread == 8) {\n\t\t    dbentry.attributes = (krb5_flags) t2;\n\t\t    dbentry.max_life = (krb5_deltat) t3;\n\t\t    dbentry.max_renewable_life = (krb5_deltat) t4;\n\t\t    dbentry.expiration = (krb5_timestamp) t5;\n\t\t    dbentry.pw_expiration = (krb5_timestamp) t6;\n\t\t    dbentry.last_success = (krb5_timestamp) t7;\n\t\t    dbentry.last_failed = (krb5_timestamp) t8;\n\t\t    dbentry.fail_auth_count = (krb5_kvno) t9;\n\t\t} else {\n\t\t    try2read = read_nint_data;\n\t\t    error++;\n\t\t}\n\n\t\t/*\n\t\t * Get the tagged data.\n\t\t *\n\t\t * Really, this code ought to discard tl data types\n\t\t * that it knows are special to the current version\n\t\t * and were not supported in the previous version.\n\t\t * But it's a pain to implement that here, and doing\n\t\t * it at dump time has almost as good an effect, so\n\t\t * that's what I did.  [krb5-admin/89]\n\t\t */\n\t\tif (!error && dbentry.n_tl_data) {\n\t\t    for (tl = dbentry.tl_data; tl; tl = tl->tl_data_next) {\n\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t1, &t2);\n\t\t\tif (nread == 2) {\n\t\t\t    tl->tl_data_type = (krb5_int16) t1;\n\t\t\t    tl->tl_data_length = (krb5_int16) t2;\n\t\t\t    if (tl->tl_data_length) {\n\t\t\t\tif (!(tl->tl_data_contents =\n\t\t\t\t      (krb5_octet *) malloc((size_t) t2+1)) ||\n\t\t\t\t    read_octet_string(filep,\n\t\t\t\t\t\t      tl->tl_data_contents,\n\t\t\t\t\t\t      t2)) {\n\t\t\t\t    try2read = read_tcontents;\n\t\t\t\t    error++;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else {\n\t\t\t\t/* Should be a null field */\n\t\t\t\tnread = fscanf(filep, \"%d\", &t9);\n\t\t\t\tif ((nread != 1) || (t9 != -1)) {\n\t\t\t\t    error++;\n\t\t\t\t    try2read = read_tcontents;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t\telse {\n\t\t\t    try2read = read_ttypelen;\n\t\t\t    error++;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/* Get the key data */\n\t\tif (!error && dbentry.n_key_data) {\n\t\t    for (i=0; !error && (i<dbentry.n_key_data); i++) {\n\t\t\tkdatap = &dbentry.key_data[i];\n\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t1, &t2);\n\t\t\tif (nread == 2) {\n\t\t\t    kdatap->key_data_ver = (krb5_int16) t1;\n\t\t\t    kdatap->key_data_kvno = (krb5_int16) t2;\n\n\t\t\t    for (j=0; j<t1; j++) {\n\t\t\t\tnread = fscanf(filep, \"%d\\t%d\\t\", &t3, &t4);\n\t\t\t\tif (nread == 2) {\n\t\t\t\t    kdatap->key_data_type[j] = t3;\n\t\t\t\t    kdatap->key_data_length[j] = t4;\n\t\t\t\t    if (t4) {\n\t\t\t\t\tif (!(kdatap->key_data_contents[j] =\n\t\t\t\t\t      (krb5_octet *)\n\t\t\t\t\t      malloc((size_t) t4+1)) ||\n\t\t\t\t\t    read_octet_string(filep,\n\t\t\t\t\t\t\t      kdatap->key_data_contents[j],\n\t\t\t\t\t\t\t      t4)) {\n\t\t\t\t\t    try2read = read_kcontents;\n\t\t\t\t\t    error++;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t    else {\n\t\t\t\t\t/* Should be a null field */\n\t\t\t\t\tnread = fscanf(filep, \"%d\", &t9);\n\t\t\t\t\tif ((nread != 1) || (t9 != -1)) {\n\t\t\t\t\t    error++;\n\t\t\t\t\t    try2read = read_kcontents;\n\t\t\t\t\t    break;\n\t\t\t\t\t}\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t    try2read = read_ktypelen;\n\t\t\t\t    error++;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t\t/* Get the extra data */\n\t\tif (!error && dbentry.e_length) {\n\t\t    if (read_octet_string(filep,\n\t\t\t\t\t  dbentry.e_data,\n\t\t\t\t\t  (int) dbentry.e_length)) {\n\t\t\ttry2read = read_econtents;\n\t\t\terror++;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    nread = fscanf(filep, \"%d\", &t9);\n\t\t    if ((nread != 1) || (t9 != -1)) {\n\t\t\terror++;\n\t\t\ttry2read = read_econtents;\n\t\t    }\n\t\t}\n\n\t\t/* Finally, find the end of the record. */\n\t\tif (!error)\n\t\t    find_record_end(filep, fname, *linenop);\n\n\t\t/*\n\t\t * We have either read in all the data or choked.\n\t\t */\n\t\tif (!error) {\n\t\t    one = 1;\n\t\t    if ((kret = krb5_db_put_principal(kcontext,\n\t\t\t\t\t\t      &dbentry,\n\t\t\t\t\t\t      &one))) {\n\t\t\tfprintf(stderr, store_err_fmt,\n\t\t\t\tfname, *linenop,\n\t\t\t\tname, error_message(kret));\n\t\t    }\n\t\t    else {\n\t\t\tif (verbose)\n\t\t\t    fprintf(stderr, add_princ_fmt, name);\n\t\t\tretval = 0;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    fprintf(stderr, read_err_fmt, fname, *linenop, try2read);\n\t\t}\n\t    }\n\t    else {\n\t\tif (kret)\n\t\t    fprintf(stderr, parse_err_fmt,\n\t\t\t    fname, *linenop, name, error_message(kret));\n\t\telse\n\t\t    fprintf(stderr, no_mem_fmt, fname, *linenop);\n\t    }\n\t}\n\telse {\n\t    fprintf(stderr, rhead_err_fmt, fname, *linenop);\n\t}\n\n\tif (op)\n\t    free(op);\n\tif (kp)\n\t    free(kp);\n\tif (name)\n\t    free(name);\n\tkrb5_db_free_principal(kcontext, &dbentry, 1);\n    }\n    else {\n\tif (nread == EOF)\n\t    retval = -1;\n    }\n    return(retval);\n}"
  },
  {
    "function_name": "process_k5beta_record",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "1365-1659",
    "snippet": "static int\nprocess_k5beta_record(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n   void *pol_db;\n{\n    int\t\t\tnmatched;\n    int\t\t\tretval;\n    krb5_db_entry\tdbent;\n    int\t\t\tname_len, mod_name_len, key_len;\n    int\t\t\talt_key_len, salt_len, alt_salt_len;\n    char\t\t*name;\n    char\t\t*mod_name;\n    int\t\t\ttmpint1, tmpint2, tmpint3;\n    int\t\t\terror;\n    const char\t\t*try2read;\n    int\t\t\ti;\n    krb5_key_data\t*pkey, *akey;\n    krb5_timestamp\tlast_pwd_change, mod_date;\n    krb5_principal\tmod_princ;\n    krb5_error_code\tkret;\n\n    try2read = (char *) NULL;\n    (*linenop)++;\n    retval = 1;\n    memset((char *)&dbent, 0, sizeof(dbent));\n\n    /* Make sure we've got key_data entries */\n    if (krb5_dbe_create_key_data(kcontext, &dbent) ||\n\tkrb5_dbe_create_key_data(kcontext, &dbent)) {\n\tkrb5_db_free_principal(kcontext, &dbent, 1);\n\treturn(1);\n    }\n    pkey = &dbent.key_data[0];\n    akey = &dbent.key_data[1];\n\n    /*\n     * Match the sizes.  6 tokens to match.\n     */\n    nmatched = fscanf(filep, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t      &name_len, &mod_name_len, &key_len,\n\t\t      &alt_key_len, &salt_len, &alt_salt_len);\n    if (nmatched == 6) {\n        pkey->key_data_length[0] = key_len;\n\takey->key_data_length[0] = alt_key_len;\n\tpkey->key_data_length[1] = salt_len;\n\takey->key_data_length[1] = alt_salt_len;\n\tname = (char *) NULL;\n\tmod_name = (char *) NULL;\n\t/*\n\t * Get the memory for the variable length fields.\n\t */\n\tif ((name = (char *) malloc((size_t) (name_len + 1))) &&\n\t    (mod_name = (char *) malloc((size_t) (mod_name_len + 1))) &&\n\t    (!key_len ||\n\t     (pkey->key_data_contents[0] = \n\t      (krb5_octet *) malloc((size_t) (key_len + 1)))) &&\n\t    (!alt_key_len ||\n\t     (akey->key_data_contents[0] = \n\t      (krb5_octet *) malloc((size_t) (alt_key_len + 1)))) &&\n\t    (!salt_len ||\n\t     (pkey->key_data_contents[1] = \n\t      (krb5_octet *) malloc((size_t) (salt_len + 1)))) &&\n\t    (!alt_salt_len ||\n\t     (akey->key_data_contents[1] = \n\t      (krb5_octet *) malloc((size_t) (alt_salt_len + 1))))\n\t    ) {\n\t    error = 0;\n\n\t    /* Read the principal name */\n\t    if (read_string(filep, name, name_len, linenop)) {\n\t\ttry2read = read_name_string;\n\t\terror++;\n\t    }\n\t    /* Read the key type */\n\t    if (!error && (fscanf(filep, \"\\t%d\\t\", &tmpint1) != 1)) {\n\t\ttry2read = read_key_type;\n\t\terror++;\n\t    }\n\t    pkey->key_data_type[0] = tmpint1;\n\t    /* Read the old format key */\n\t    if (!error && read_octet_string(filep,\n\t\t\t\t\t    pkey->key_data_contents[0],\n\t\t\t\t\t    pkey->key_data_length[0])) {\n\t\ttry2read = read_key_data;\n\t\terror++;\n\t    }\n\t    /* convert to a new format key */\n\t    /* the encrypted version is stored as the unencrypted key length\n\t       (4 bytes, MSB first) followed by the encrypted key. */\n\t    if ((pkey->key_data_length[0] > 4)\n\t\t&& (pkey->key_data_contents[0][0] == 0)\n\t\t&& (pkey->key_data_contents[0][1] == 0)) {\n\t      /* this really does look like an old key, so drop and swap */\n\t      /* the *new* length is 2 bytes, LSB first, sigh. */\n\t      size_t shortlen = pkey->key_data_length[0]-4+2;\n\t      krb5_octet *shortcopy = (krb5_octet *) malloc(shortlen);\n\t      krb5_octet *origdata = pkey->key_data_contents[0];\n\t      shortcopy[0] = origdata[3];\n\t      shortcopy[1] = origdata[2];\n\t      memcpy(shortcopy+2,origdata+4,shortlen-2);\n\t      free(origdata);\n\t      pkey->key_data_length[0] = shortlen;\n\t      pkey->key_data_contents[0] = shortcopy;\n\t    }\n\t      \n\t    /* Read principal attributes */\n\t    if (!error && (fscanf(filep,\n\t\t\t\t  \"\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t\",\n\t\t\t\t  &tmpint1, &dbent.max_life,\n\t\t\t\t  &dbent.max_renewable_life,\n\t\t\t\t  &tmpint2, &dbent.expiration,\n\t\t\t\t  &dbent.pw_expiration, &last_pwd_change,\n\t\t\t\t  &dbent.last_success, &dbent.last_failed,\n\t\t\t\t  &tmpint3) != 10)) {\n\t\ttry2read = read_pr_data1;\n\t\terror++;\n\t    }\n\t    pkey->key_data_kvno = tmpint1;\n\t    dbent.fail_auth_count = tmpint3;\n\t    /* Read modifier name */\n\t    if (!error && read_string(filep,\n\t\t\t\t      mod_name,\n\t\t\t\t      mod_name_len,\n\t\t\t\t      linenop)) {\n\t\ttry2read = read_mod_name;\n\t\terror++;\n\t    }\n\t    /* Read second set of attributes */\n\t    if (!error && (fscanf(filep, \"\\t%u\\t%u\\t%u\\t\",\n\t\t\t\t  &mod_date, &dbent.attributes,\n\t\t\t\t  &tmpint1) != 3)) {\n\t\ttry2read = read_pr_data2;\n\t\terror++;\n\t    }\n\t    pkey->key_data_type[1] = tmpint1;\n\t    /* Read salt data */\n\t    if (!error && read_octet_string(filep,\n\t\t\t\t\t    pkey->key_data_contents[1],\n\t\t\t\t\t    pkey->key_data_length[1])) {\n\t\ttry2read = read_salt_data;\n\t\terror++;\n\t    }\n\t    /* Read alternate key type */\n\t    if (!error && (fscanf(filep, \"\\t%u\\t\", &tmpint1) != 1)) {\n\t\ttry2read = read_akey_type;\n\t\terror++;\n\t    }\n\t    akey->key_data_type[0] = tmpint1;\n\t    /* Read alternate key */\n\t    if (!error && read_octet_string(filep,\n\t\t\t\t\t    akey->key_data_contents[0],\n\t\t\t\t\t    akey->key_data_length[0])) {\n\t\ttry2read = read_akey_data;\n\t\terror++;\n\t    }\n\n\t    /* convert to a new format key */\n\t    /* the encrypted version is stored as the unencrypted key length\n\t       (4 bytes, MSB first) followed by the encrypted key. */\n\t    if ((akey->key_data_length[0] > 4)\n\t\t&& (akey->key_data_contents[0][0] == 0)\n\t\t&& (akey->key_data_contents[0][1] == 0)) {\n\t      /* this really does look like an old key, so drop and swap */\n\t      /* the *new* length is 2 bytes, LSB first, sigh. */\n\t      size_t shortlen = akey->key_data_length[0]-4+2;\n\t      krb5_octet *shortcopy = (krb5_octet *) malloc(shortlen);\n\t      krb5_octet *origdata = akey->key_data_contents[0];\n\t      shortcopy[0] = origdata[3];\n\t      shortcopy[1] = origdata[2];\n\t      memcpy(shortcopy+2,origdata+4,shortlen-2);\n\t      free(origdata);\n\t      akey->key_data_length[0] = shortlen;\n\t      akey->key_data_contents[0] = shortcopy;\n\t    }\n\t      \n\t    /* Read alternate salt type */\n\t    if (!error && (fscanf(filep, \"\\t%u\\t\", &tmpint1) != 1)) {\n\t\ttry2read = read_asalt_type;\n\t\terror++;\n\t    }\n\t    akey->key_data_type[1] = tmpint1;\n\t    /* Read alternate salt data */\n\t    if (!error && read_octet_string(filep,\n\t\t\t\t\t    akey->key_data_contents[1],\n\t\t\t\t\t    akey->key_data_length[1])) {\n\t\ttry2read = read_asalt_data;\n\t\terror++;\n\t    }\n\t    /* Read expansion data - discard it */\n\t    if (!error) {\n\t\tfor (i=0; i<8; i++) {\n\t\t    if (fscanf(filep, \"\\t%u\", &tmpint1) != 1) {\n\t\t\ttry2read = read_exp_data;\n\t\t\terror++;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!error)\n\t\t    find_record_end(filep, fname, *linenop);\n\t    }\n\t\n\t    /*\n\t     * If no error, then we're done reading.  Now parse the names\n\t     * and store the database dbent.\n\t     */\n\t    if (!error) {\n\t\tif (!(kret = krb5_parse_name(kcontext,\n\t\t\t\t\t     name,\n\t\t\t\t\t     &dbent.princ))) {\n\t\t    if (!(kret = krb5_parse_name(kcontext,\n\t\t\t\t\t\t mod_name,\n\t\t\t\t\t\t &mod_princ))) {\n\t\t\tif (!(kret =\n\t\t\t      krb5_dbe_update_mod_princ_data(kcontext,\n\t\t\t\t\t\t\t     &dbent,\n\t\t\t\t\t\t\t     mod_date,\n\t\t\t\t\t\t\t     mod_princ)) &&\n\t\t\t    !(kret =\n\t\t\t      krb5_dbe_update_last_pwd_change(kcontext,\n\t\t\t\t\t\t\t      &dbent,\n\t\t\t\t\t\t\t      last_pwd_change))) {\n\t\t\t    int one = 1;\n\n\t\t\t    dbent.len = KRB5_KDB_V1_BASE_LENGTH;\n\t\t\t    pkey->key_data_ver = (pkey->key_data_type[1] || pkey->key_data_length[1]) ?\n\t\t\t\t2 : 1;\n\t\t\t    akey->key_data_ver = (akey->key_data_type[1] || akey->key_data_length[1]) ?\n\t\t\t\t2 : 1;\n\t\t\t    if ((pkey->key_data_type[0] ==\n\t\t\t\t akey->key_data_type[0]) &&\n\t\t\t\t(pkey->key_data_type[1] ==\n\t\t\t\t akey->key_data_type[1]))\n\t\t\t\tdbent.n_key_data--;\n\t\t\t    else if ((akey->key_data_type[0] == 0)\n\t\t\t\t     && (akey->key_data_length[0] == 0)\n\t\t\t\t     && (akey->key_data_type[1] == 0)\n\t\t\t\t     && (akey->key_data_length[1] == 0))\n\t\t\t        dbent.n_key_data--;\n\t\t\t    if ((kret = krb5_db_put_principal(kcontext,\n\t\t\t\t\t\t\t      &dbent,\n\t\t\t\t\t\t\t      &one)) ||\n\t\t\t\t(one != 1)) {\n\t\t\t\tfprintf(stderr, store_err_fmt,\n\t\t\t\t\tfname, *linenop, name,\n\t\t\t\t\terror_message(kret));\n\t\t\t\terror++;\n\t\t\t    }\n\t\t\t    else {\n\t\t\t\tif (verbose)\n\t\t\t\t    fprintf(stderr, add_princ_fmt, name);\n\t\t\t\tretval = 0;\n\t\t\t    }\n\t\t\t    dbent.n_key_data = 2;\n\t\t\t}\n\t\t\tkrb5_free_principal(kcontext, mod_princ);\n\t\t    }\n\t\t    else {\n\t\t\tfprintf(stderr, parse_err_fmt, \n\t\t\t\tfname, *linenop, mod_name, \n\t\t\t\terror_message(kret));\n\t\t\terror++;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    fprintf(stderr, parse_err_fmt,\n\t\t\t    fname, *linenop, name, error_message(kret));\n\t\t    error++;\n\t\t}\n\t    }\n\t    else {\n\t\tfprintf(stderr, read_err_fmt, fname, *linenop, try2read);\n\t    }\n\t}\n\telse {\n\t    fprintf(stderr, no_mem_fmt, fname, *linenop);\n\t}\n\n\tkrb5_db_free_principal(kcontext, &dbent, 1);\n\tif (mod_name)\n\t    free(mod_name);\n\tif (name)\n\t    free(name);\n    }\n    else {\n\tif (nmatched != EOF)\n\t    fprintf(stderr, rhead_err_fmt, fname, *linenop);\n\telse\n\t    retval = -1;\n    }\n    return(retval);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define rhead_err_fmt\t\t\"%s(%d): cannot match size tokens\\n\"",
      "#define no_mem_fmt\t\t\"%s(%d): no memory for buffers\\n\"",
      "#define read_err_fmt\t\t\"%s(%d): cannot read %s\\n\"",
      "#define parse_err_fmt\t\t\"%s(%d): cannot parse %s (%s)\\n\"",
      "#define add_princ_fmt\t\t\"%s\\n\"",
      "#define store_err_fmt\t\t\"%s(%d): cannot store %s(%s)\\n\"",
      "#define read_exp_data\t\t\"expansion data\"",
      "#define read_asalt_data\t\t\"alternate salt data\"",
      "#define read_asalt_type\t\t\"alternate salt type\"",
      "#define read_akey_data\t\t\"alternate key data\"",
      "#define read_akey_type\t\t\"alternate key type\"",
      "#define read_salt_data\t\t\"salt data\"",
      "#define read_pr_data2\t\t\"second set of principal attributes\"",
      "#define read_mod_name\t\t\"modifier name\"",
      "#define read_pr_data1\t\t\"first set of principal attributes\"",
      "#define read_key_data\t\t\"key data\"",
      "#define read_key_type\t\t\"key type\"",
      "#define read_name_string\t\"name string\""
    ],
    "globals_used": [
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);",
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "rhead_err_fmt",
            "fname",
            "*linenop"
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_db_free_principal",
          "args": [
            "kcontext",
            "&dbent",
            "1"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "no_mem_fmt",
            "fname",
            "*linenop"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "read_err_fmt",
            "fname",
            "*linenop",
            "try2read"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "parse_err_fmt",
            "fname",
            "*linenop",
            "name",
            "error_message(kret)"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 1634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "parse_err_fmt",
            "fname",
            "*linenop",
            "mod_name",
            "error_message(kret)"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "kcontext",
            "mod_princ"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "add_princ_fmt",
            "name"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "store_err_fmt",
            "fname",
            "*linenop",
            "name",
            "error_message(kret)"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_put_principal",
          "args": [
            "kcontext",
            "&dbent",
            "&one"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_update_last_pwd_change",
          "args": [
            "kcontext",
            "&dbent",
            "last_pwd_change"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_update_mod_princ_data",
          "args": [
            "kcontext",
            "&dbent",
            "mod_date",
            "mod_princ"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "kcontext",
            "mod_name",
            "&mod_princ"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "kcontext",
            "name",
            "&dbent.princ"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_record_end",
          "args": [
            "filep",
            "fname",
            "*linenop"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "find_record_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "1255-1271",
          "snippet": "static void\nfind_record_end(f, fn, lineno)\n    FILE\t*f;\n    char\t*fn;\n    int\t\tlineno;\n{\n    int\tch;\n\n    if (((ch = fgetc(f)) != ';') || ((ch = fgetc(f)) != '\\n')) {\n\tfprintf(stderr, trash_end_fmt, fn, lineno);\n\twhile (ch != '\\n') {\n\t    putc(ch, stderr);\n\t    ch = fgetc(f);\n\t}\n\tputc(ch, stderr);\n    }\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define trash_end_fmt\t\t\"%s(%d): ignoring trash at end of line: \""
          ],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define trash_end_fmt\t\t\"%s(%d): ignoring trash at end of line: \"\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic void\nfind_record_end(f, fn, lineno)\n    FILE\t*f;\n    char\t*fn;\n    int\t\tlineno;\n{\n    int\tch;\n\n    if (((ch = fgetc(f)) != ';') || ((ch = fgetc(f)) != '\\n')) {\n\tfprintf(stderr, trash_end_fmt, fn, lineno);\n\twhile (ch != '\\n') {\n\t    putc(ch, stderr);\n\t    ch = fgetc(f);\n\t}\n\tputc(ch, stderr);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"\\t%u\"",
            "&tmpint1"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_octet_string",
          "args": [
            "filep",
            "akey->key_data_contents[1]",
            "akey->key_data_length[1]"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "read_octet_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "1232-1250",
          "snippet": "static int\nread_octet_string(f, buf, len)\n    FILE\t*f;\n    krb5_octet\t*buf;\n    int\t\tlen;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tif (fscanf(f, \"%02x\", &c) != 1) {\n\t    retval = 1;\n\t    break;\n\t}\n\tbuf[i] = (krb5_octet) c;\n    }\n    return(retval);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nread_octet_string(f, buf, len)\n    FILE\t*f;\n    krb5_octet\t*buf;\n    int\t\tlen;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tif (fscanf(f, \"%02x\", &c) != 1) {\n\t    retval = 1;\n\t    break;\n\t}\n\tbuf[i] = (krb5_octet) c;\n    }\n    return(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"\\t%u\\t\"",
            "&tmpint1"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "shortcopy+2",
            "origdata+4",
            "shortlen-2"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "shortlen"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"\\t%u\\t\"",
            "&tmpint1"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"\\t%u\\t%u\\t%u\\t\"",
            "&mod_date",
            "&dbent.attributes",
            "&tmpint1"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_string",
          "args": [
            "filep",
            "mod_name",
            "mod_name_len",
            "linenop"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "read_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "1204-1227",
          "snippet": "static int\nread_string(f, buf, len, lp)\n    FILE\t*f;\n    char\t*buf;\n    int\t\tlen;\n    int\t\t*lp;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tc = fgetc(f);\n\tif (c < 0) {\n\t    retval = 1;\n\t    break;\n\t}\n\tif (c == '\\n')\n\t    (*lp)++;\n\tbuf[i] = (char) c;\n    }\n    buf[len] = '\\0';\n    return(retval);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nread_string(f, buf, len, lp)\n    FILE\t*f;\n    char\t*buf;\n    int\t\tlen;\n    int\t\t*lp;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tc = fgetc(f);\n\tif (c < 0) {\n\t    retval = 1;\n\t    break;\n\t}\n\tif (c == '\\n')\n\t    (*lp)++;\n\tbuf[i] = (char) c;\n    }\n    buf[len] = '\\0';\n    return(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t\"",
            "&tmpint1",
            "&dbent.max_life",
            "&dbent.max_renewable_life",
            "&tmpint2",
            "&dbent.expiration",
            "&dbent.pw_expiration",
            "&last_pwd_change",
            "&dbent.last_success",
            "&dbent.last_failed",
            "&tmpint3"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "shortcopy+2",
            "origdata+4",
            "shortlen-2"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "shortlen"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"\\t%d\\t\"",
            "&tmpint1"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (alt_salt_len + 1)"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (salt_len + 1)"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (alt_key_len + 1)"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (key_len + 1)"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (mod_name_len + 1)"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(size_t) (name_len + 1)"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "filep",
            "\"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\"",
            "&name_len",
            "&mod_name_len",
            "&key_len",
            "&alt_key_len",
            "&salt_len",
            "&alt_salt_len"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_free_principal",
          "args": [
            "kcontext",
            "&dbent",
            "1"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_create_key_data",
          "args": [
            "kcontext",
            "&dbent"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_create_key_data",
          "args": [
            "kcontext",
            "&dbent"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&dbent",
            "0",
            "sizeof(dbent)"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define rhead_err_fmt\t\t\"%s(%d): cannot match size tokens\\n\"\n#define no_mem_fmt\t\t\"%s(%d): no memory for buffers\\n\"\n#define read_err_fmt\t\t\"%s(%d): cannot read %s\\n\"\n#define parse_err_fmt\t\t\"%s(%d): cannot parse %s (%s)\\n\"\n#define add_princ_fmt\t\t\"%s\\n\"\n#define store_err_fmt\t\t\"%s(%d): cannot store %s(%s)\\n\"\n#define read_exp_data\t\t\"expansion data\"\n#define read_asalt_data\t\t\"alternate salt data\"\n#define read_asalt_type\t\t\"alternate salt type\"\n#define read_akey_data\t\t\"alternate key data\"\n#define read_akey_type\t\t\"alternate key type\"\n#define read_salt_data\t\t\"salt data\"\n#define read_pr_data2\t\t\"second set of principal attributes\"\n#define read_mod_name\t\t\"modifier name\"\n#define read_pr_data1\t\t\"first set of principal attributes\"\n#define read_key_data\t\t\"key data\"\n#define read_key_type\t\t\"key type\"\n#define read_name_string\t\"name string\"\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nprocess_k5beta_record(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n   void *pol_db;\n{\n    int\t\t\tnmatched;\n    int\t\t\tretval;\n    krb5_db_entry\tdbent;\n    int\t\t\tname_len, mod_name_len, key_len;\n    int\t\t\talt_key_len, salt_len, alt_salt_len;\n    char\t\t*name;\n    char\t\t*mod_name;\n    int\t\t\ttmpint1, tmpint2, tmpint3;\n    int\t\t\terror;\n    const char\t\t*try2read;\n    int\t\t\ti;\n    krb5_key_data\t*pkey, *akey;\n    krb5_timestamp\tlast_pwd_change, mod_date;\n    krb5_principal\tmod_princ;\n    krb5_error_code\tkret;\n\n    try2read = (char *) NULL;\n    (*linenop)++;\n    retval = 1;\n    memset((char *)&dbent, 0, sizeof(dbent));\n\n    /* Make sure we've got key_data entries */\n    if (krb5_dbe_create_key_data(kcontext, &dbent) ||\n\tkrb5_dbe_create_key_data(kcontext, &dbent)) {\n\tkrb5_db_free_principal(kcontext, &dbent, 1);\n\treturn(1);\n    }\n    pkey = &dbent.key_data[0];\n    akey = &dbent.key_data[1];\n\n    /*\n     * Match the sizes.  6 tokens to match.\n     */\n    nmatched = fscanf(filep, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t      &name_len, &mod_name_len, &key_len,\n\t\t      &alt_key_len, &salt_len, &alt_salt_len);\n    if (nmatched == 6) {\n        pkey->key_data_length[0] = key_len;\n\takey->key_data_length[0] = alt_key_len;\n\tpkey->key_data_length[1] = salt_len;\n\takey->key_data_length[1] = alt_salt_len;\n\tname = (char *) NULL;\n\tmod_name = (char *) NULL;\n\t/*\n\t * Get the memory for the variable length fields.\n\t */\n\tif ((name = (char *) malloc((size_t) (name_len + 1))) &&\n\t    (mod_name = (char *) malloc((size_t) (mod_name_len + 1))) &&\n\t    (!key_len ||\n\t     (pkey->key_data_contents[0] = \n\t      (krb5_octet *) malloc((size_t) (key_len + 1)))) &&\n\t    (!alt_key_len ||\n\t     (akey->key_data_contents[0] = \n\t      (krb5_octet *) malloc((size_t) (alt_key_len + 1)))) &&\n\t    (!salt_len ||\n\t     (pkey->key_data_contents[1] = \n\t      (krb5_octet *) malloc((size_t) (salt_len + 1)))) &&\n\t    (!alt_salt_len ||\n\t     (akey->key_data_contents[1] = \n\t      (krb5_octet *) malloc((size_t) (alt_salt_len + 1))))\n\t    ) {\n\t    error = 0;\n\n\t    /* Read the principal name */\n\t    if (read_string(filep, name, name_len, linenop)) {\n\t\ttry2read = read_name_string;\n\t\terror++;\n\t    }\n\t    /* Read the key type */\n\t    if (!error && (fscanf(filep, \"\\t%d\\t\", &tmpint1) != 1)) {\n\t\ttry2read = read_key_type;\n\t\terror++;\n\t    }\n\t    pkey->key_data_type[0] = tmpint1;\n\t    /* Read the old format key */\n\t    if (!error && read_octet_string(filep,\n\t\t\t\t\t    pkey->key_data_contents[0],\n\t\t\t\t\t    pkey->key_data_length[0])) {\n\t\ttry2read = read_key_data;\n\t\terror++;\n\t    }\n\t    /* convert to a new format key */\n\t    /* the encrypted version is stored as the unencrypted key length\n\t       (4 bytes, MSB first) followed by the encrypted key. */\n\t    if ((pkey->key_data_length[0] > 4)\n\t\t&& (pkey->key_data_contents[0][0] == 0)\n\t\t&& (pkey->key_data_contents[0][1] == 0)) {\n\t      /* this really does look like an old key, so drop and swap */\n\t      /* the *new* length is 2 bytes, LSB first, sigh. */\n\t      size_t shortlen = pkey->key_data_length[0]-4+2;\n\t      krb5_octet *shortcopy = (krb5_octet *) malloc(shortlen);\n\t      krb5_octet *origdata = pkey->key_data_contents[0];\n\t      shortcopy[0] = origdata[3];\n\t      shortcopy[1] = origdata[2];\n\t      memcpy(shortcopy+2,origdata+4,shortlen-2);\n\t      free(origdata);\n\t      pkey->key_data_length[0] = shortlen;\n\t      pkey->key_data_contents[0] = shortcopy;\n\t    }\n\t      \n\t    /* Read principal attributes */\n\t    if (!error && (fscanf(filep,\n\t\t\t\t  \"\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t\",\n\t\t\t\t  &tmpint1, &dbent.max_life,\n\t\t\t\t  &dbent.max_renewable_life,\n\t\t\t\t  &tmpint2, &dbent.expiration,\n\t\t\t\t  &dbent.pw_expiration, &last_pwd_change,\n\t\t\t\t  &dbent.last_success, &dbent.last_failed,\n\t\t\t\t  &tmpint3) != 10)) {\n\t\ttry2read = read_pr_data1;\n\t\terror++;\n\t    }\n\t    pkey->key_data_kvno = tmpint1;\n\t    dbent.fail_auth_count = tmpint3;\n\t    /* Read modifier name */\n\t    if (!error && read_string(filep,\n\t\t\t\t      mod_name,\n\t\t\t\t      mod_name_len,\n\t\t\t\t      linenop)) {\n\t\ttry2read = read_mod_name;\n\t\terror++;\n\t    }\n\t    /* Read second set of attributes */\n\t    if (!error && (fscanf(filep, \"\\t%u\\t%u\\t%u\\t\",\n\t\t\t\t  &mod_date, &dbent.attributes,\n\t\t\t\t  &tmpint1) != 3)) {\n\t\ttry2read = read_pr_data2;\n\t\terror++;\n\t    }\n\t    pkey->key_data_type[1] = tmpint1;\n\t    /* Read salt data */\n\t    if (!error && read_octet_string(filep,\n\t\t\t\t\t    pkey->key_data_contents[1],\n\t\t\t\t\t    pkey->key_data_length[1])) {\n\t\ttry2read = read_salt_data;\n\t\terror++;\n\t    }\n\t    /* Read alternate key type */\n\t    if (!error && (fscanf(filep, \"\\t%u\\t\", &tmpint1) != 1)) {\n\t\ttry2read = read_akey_type;\n\t\terror++;\n\t    }\n\t    akey->key_data_type[0] = tmpint1;\n\t    /* Read alternate key */\n\t    if (!error && read_octet_string(filep,\n\t\t\t\t\t    akey->key_data_contents[0],\n\t\t\t\t\t    akey->key_data_length[0])) {\n\t\ttry2read = read_akey_data;\n\t\terror++;\n\t    }\n\n\t    /* convert to a new format key */\n\t    /* the encrypted version is stored as the unencrypted key length\n\t       (4 bytes, MSB first) followed by the encrypted key. */\n\t    if ((akey->key_data_length[0] > 4)\n\t\t&& (akey->key_data_contents[0][0] == 0)\n\t\t&& (akey->key_data_contents[0][1] == 0)) {\n\t      /* this really does look like an old key, so drop and swap */\n\t      /* the *new* length is 2 bytes, LSB first, sigh. */\n\t      size_t shortlen = akey->key_data_length[0]-4+2;\n\t      krb5_octet *shortcopy = (krb5_octet *) malloc(shortlen);\n\t      krb5_octet *origdata = akey->key_data_contents[0];\n\t      shortcopy[0] = origdata[3];\n\t      shortcopy[1] = origdata[2];\n\t      memcpy(shortcopy+2,origdata+4,shortlen-2);\n\t      free(origdata);\n\t      akey->key_data_length[0] = shortlen;\n\t      akey->key_data_contents[0] = shortcopy;\n\t    }\n\t      \n\t    /* Read alternate salt type */\n\t    if (!error && (fscanf(filep, \"\\t%u\\t\", &tmpint1) != 1)) {\n\t\ttry2read = read_asalt_type;\n\t\terror++;\n\t    }\n\t    akey->key_data_type[1] = tmpint1;\n\t    /* Read alternate salt data */\n\t    if (!error && read_octet_string(filep,\n\t\t\t\t\t    akey->key_data_contents[1],\n\t\t\t\t\t    akey->key_data_length[1])) {\n\t\ttry2read = read_asalt_data;\n\t\terror++;\n\t    }\n\t    /* Read expansion data - discard it */\n\t    if (!error) {\n\t\tfor (i=0; i<8; i++) {\n\t\t    if (fscanf(filep, \"\\t%u\", &tmpint1) != 1) {\n\t\t\ttry2read = read_exp_data;\n\t\t\terror++;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\tif (!error)\n\t\t    find_record_end(filep, fname, *linenop);\n\t    }\n\t\n\t    /*\n\t     * If no error, then we're done reading.  Now parse the names\n\t     * and store the database dbent.\n\t     */\n\t    if (!error) {\n\t\tif (!(kret = krb5_parse_name(kcontext,\n\t\t\t\t\t     name,\n\t\t\t\t\t     &dbent.princ))) {\n\t\t    if (!(kret = krb5_parse_name(kcontext,\n\t\t\t\t\t\t mod_name,\n\t\t\t\t\t\t &mod_princ))) {\n\t\t\tif (!(kret =\n\t\t\t      krb5_dbe_update_mod_princ_data(kcontext,\n\t\t\t\t\t\t\t     &dbent,\n\t\t\t\t\t\t\t     mod_date,\n\t\t\t\t\t\t\t     mod_princ)) &&\n\t\t\t    !(kret =\n\t\t\t      krb5_dbe_update_last_pwd_change(kcontext,\n\t\t\t\t\t\t\t      &dbent,\n\t\t\t\t\t\t\t      last_pwd_change))) {\n\t\t\t    int one = 1;\n\n\t\t\t    dbent.len = KRB5_KDB_V1_BASE_LENGTH;\n\t\t\t    pkey->key_data_ver = (pkey->key_data_type[1] || pkey->key_data_length[1]) ?\n\t\t\t\t2 : 1;\n\t\t\t    akey->key_data_ver = (akey->key_data_type[1] || akey->key_data_length[1]) ?\n\t\t\t\t2 : 1;\n\t\t\t    if ((pkey->key_data_type[0] ==\n\t\t\t\t akey->key_data_type[0]) &&\n\t\t\t\t(pkey->key_data_type[1] ==\n\t\t\t\t akey->key_data_type[1]))\n\t\t\t\tdbent.n_key_data--;\n\t\t\t    else if ((akey->key_data_type[0] == 0)\n\t\t\t\t     && (akey->key_data_length[0] == 0)\n\t\t\t\t     && (akey->key_data_type[1] == 0)\n\t\t\t\t     && (akey->key_data_length[1] == 0))\n\t\t\t        dbent.n_key_data--;\n\t\t\t    if ((kret = krb5_db_put_principal(kcontext,\n\t\t\t\t\t\t\t      &dbent,\n\t\t\t\t\t\t\t      &one)) ||\n\t\t\t\t(one != 1)) {\n\t\t\t\tfprintf(stderr, store_err_fmt,\n\t\t\t\t\tfname, *linenop, name,\n\t\t\t\t\terror_message(kret));\n\t\t\t\terror++;\n\t\t\t    }\n\t\t\t    else {\n\t\t\t\tif (verbose)\n\t\t\t\t    fprintf(stderr, add_princ_fmt, name);\n\t\t\t\tretval = 0;\n\t\t\t    }\n\t\t\t    dbent.n_key_data = 2;\n\t\t\t}\n\t\t\tkrb5_free_principal(kcontext, mod_princ);\n\t\t    }\n\t\t    else {\n\t\t\tfprintf(stderr, parse_err_fmt, \n\t\t\t\tfname, *linenop, mod_name, \n\t\t\t\terror_message(kret));\n\t\t\terror++;\n\t\t    }\n\t\t}\n\t\telse {\n\t\t    fprintf(stderr, parse_err_fmt,\n\t\t\t    fname, *linenop, name, error_message(kret));\n\t\t    error++;\n\t\t}\n\t    }\n\t    else {\n\t\tfprintf(stderr, read_err_fmt, fname, *linenop, try2read);\n\t    }\n\t}\n\telse {\n\t    fprintf(stderr, no_mem_fmt, fname, *linenop);\n\t}\n\n\tkrb5_db_free_principal(kcontext, &dbent, 1);\n\tif (mod_name)\n\t    free(mod_name);\n\tif (name)\n\t    free(name);\n    }\n    else {\n\tif (nmatched != EOF)\n\t    fprintf(stderr, rhead_err_fmt, fname, *linenop);\n\telse\n\t    retval = -1;\n    }\n    return(retval);\n}"
  },
  {
    "function_name": "update_tl_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "1277-1357",
    "snippet": "static krb5_error_code\nupdate_tl_data(kcontext, dbentp, mod_name, mod_date, last_pwd_change)\n    krb5_context\tkcontext;\n    krb5_db_entry\t*dbentp;\n    krb5_principal\tmod_name;\n    krb5_timestamp\tmod_date;\n    krb5_timestamp\tlast_pwd_change;\n{\n    krb5_error_code\tkret;\n\n    kret = 0 ;\n\n    /*\n     * Handle modification principal.\n     */\n    if (mod_name) {\n\tkrb5_tl_mod_princ\tmprinc;\n\n\tmemset(&mprinc, 0, sizeof(mprinc));\n\tif (!(kret = krb5_copy_principal(kcontext,\n\t\t\t\t\t mod_name,\n\t\t\t\t\t &mprinc.mod_princ))) {\n\t    mprinc.mod_date = mod_date;\n\t    kret = krb5_dbe_encode_mod_princ_data(kcontext,\n\t\t\t\t\t\t  &mprinc,\n\t\t\t\t\t\t  dbentp);\n\t}\n\tif (mprinc.mod_princ)\n\t    krb5_free_principal(kcontext, mprinc.mod_princ);\n    }\n\n    /*\n     * Handle last password change.\n     */\n    if (!kret) {\n\tkrb5_tl_data\t*pwchg;\n\tkrb5_boolean\tlinked;\n\n\t/* Find a previously existing entry */\n\tfor (pwchg = dbentp->tl_data;\n\t     (pwchg) && (pwchg->tl_data_type != KRB5_TL_LAST_PWD_CHANGE);\n\t     pwchg = pwchg->tl_data_next);\n\n\t/* Check to see if we found one. */\n\tlinked = 0;\n\tif (!pwchg) {\n\t    /* No, allocate a new one */\n\t    if ((pwchg = (krb5_tl_data *) malloc(sizeof(krb5_tl_data)))) {\n\t\tmemset(pwchg, 0, sizeof(krb5_tl_data));\n\t\tif (!(pwchg->tl_data_contents =\n\t\t      (krb5_octet *) malloc(sizeof(krb5_timestamp)))) {\n\t\t    free(pwchg);\n\t\t    pwchg = (krb5_tl_data *) NULL;\n\t\t}\n\t\telse {\n\t\t    pwchg->tl_data_type = KRB5_TL_LAST_PWD_CHANGE;\n\t\t    pwchg->tl_data_length =\n\t\t\t(krb5_int16) sizeof(krb5_timestamp);\n\t\t}\n\t    }\n\t}\n\telse\n\t    linked = 1;\n\n\t/* Do we have an entry? */\n\tif (pwchg && pwchg->tl_data_contents) {\n\t    /* Encode it */\n\t    krb5_kdb_encode_int32(last_pwd_change, pwchg->tl_data_contents);\n\t    /* Link it in if necessary */\n\t    if (!linked) {\n\t\tpwchg->tl_data_next = dbentp->tl_data;\n\t\tdbentp->tl_data = pwchg;\n\t\tdbentp->n_tl_data++;\n\t    }\n\t}\n\telse\n\t    kret = ENOMEM;\n    }\n\n    return(kret);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_kdb_encode_int32",
          "args": [
            "last_pwd_change",
            "pwchg->tl_data_contents"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "pwchg"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(krb5_timestamp)"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "pwchg",
            "0",
            "sizeof(krb5_tl_data)"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(krb5_tl_data)"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "kcontext",
            "mprinc.mod_princ"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_encode_mod_princ_data",
          "args": [
            "kcontext",
            "&mprinc",
            "dbentp"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_copy_principal",
          "args": [
            "kcontext",
            "mod_name",
            "&mprinc.mod_princ"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&mprinc",
            "0",
            "sizeof(mprinc)"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\nupdate_tl_data(kcontext, dbentp, mod_name, mod_date, last_pwd_change)\n    krb5_context\tkcontext;\n    krb5_db_entry\t*dbentp;\n    krb5_principal\tmod_name;\n    krb5_timestamp\tmod_date;\n    krb5_timestamp\tlast_pwd_change;\n{\n    krb5_error_code\tkret;\n\n    kret = 0 ;\n\n    /*\n     * Handle modification principal.\n     */\n    if (mod_name) {\n\tkrb5_tl_mod_princ\tmprinc;\n\n\tmemset(&mprinc, 0, sizeof(mprinc));\n\tif (!(kret = krb5_copy_principal(kcontext,\n\t\t\t\t\t mod_name,\n\t\t\t\t\t &mprinc.mod_princ))) {\n\t    mprinc.mod_date = mod_date;\n\t    kret = krb5_dbe_encode_mod_princ_data(kcontext,\n\t\t\t\t\t\t  &mprinc,\n\t\t\t\t\t\t  dbentp);\n\t}\n\tif (mprinc.mod_princ)\n\t    krb5_free_principal(kcontext, mprinc.mod_princ);\n    }\n\n    /*\n     * Handle last password change.\n     */\n    if (!kret) {\n\tkrb5_tl_data\t*pwchg;\n\tkrb5_boolean\tlinked;\n\n\t/* Find a previously existing entry */\n\tfor (pwchg = dbentp->tl_data;\n\t     (pwchg) && (pwchg->tl_data_type != KRB5_TL_LAST_PWD_CHANGE);\n\t     pwchg = pwchg->tl_data_next);\n\n\t/* Check to see if we found one. */\n\tlinked = 0;\n\tif (!pwchg) {\n\t    /* No, allocate a new one */\n\t    if ((pwchg = (krb5_tl_data *) malloc(sizeof(krb5_tl_data)))) {\n\t\tmemset(pwchg, 0, sizeof(krb5_tl_data));\n\t\tif (!(pwchg->tl_data_contents =\n\t\t      (krb5_octet *) malloc(sizeof(krb5_timestamp)))) {\n\t\t    free(pwchg);\n\t\t    pwchg = (krb5_tl_data *) NULL;\n\t\t}\n\t\telse {\n\t\t    pwchg->tl_data_type = KRB5_TL_LAST_PWD_CHANGE;\n\t\t    pwchg->tl_data_length =\n\t\t\t(krb5_int16) sizeof(krb5_timestamp);\n\t\t}\n\t    }\n\t}\n\telse\n\t    linked = 1;\n\n\t/* Do we have an entry? */\n\tif (pwchg && pwchg->tl_data_contents) {\n\t    /* Encode it */\n\t    krb5_kdb_encode_int32(last_pwd_change, pwchg->tl_data_contents);\n\t    /* Link it in if necessary */\n\t    if (!linked) {\n\t\tpwchg->tl_data_next = dbentp->tl_data;\n\t\tdbentp->tl_data = pwchg;\n\t\tdbentp->n_tl_data++;\n\t    }\n\t}\n\telse\n\t    kret = ENOMEM;\n    }\n\n    return(kret);\n}"
  },
  {
    "function_name": "find_record_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "1255-1271",
    "snippet": "static void\nfind_record_end(f, fn, lineno)\n    FILE\t*f;\n    char\t*fn;\n    int\t\tlineno;\n{\n    int\tch;\n\n    if (((ch = fgetc(f)) != ';') || ((ch = fgetc(f)) != '\\n')) {\n\tfprintf(stderr, trash_end_fmt, fn, lineno);\n\twhile (ch != '\\n') {\n\t    putc(ch, stderr);\n\t    ch = fgetc(f);\n\t}\n\tputc(ch, stderr);\n    }\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define trash_end_fmt\t\t\"%s(%d): ignoring trash at end of line: \""
    ],
    "globals_used": [
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "putc",
          "args": [
            "ch",
            "stderr"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "f"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putc",
          "args": [
            "ch",
            "stderr"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "trash_end_fmt",
            "fn",
            "lineno"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "f"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "f"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define trash_end_fmt\t\t\"%s(%d): ignoring trash at end of line: \"\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic void\nfind_record_end(f, fn, lineno)\n    FILE\t*f;\n    char\t*fn;\n    int\t\tlineno;\n{\n    int\tch;\n\n    if (((ch = fgetc(f)) != ';') || ((ch = fgetc(f)) != '\\n')) {\n\tfprintf(stderr, trash_end_fmt, fn, lineno);\n\twhile (ch != '\\n') {\n\t    putc(ch, stderr);\n\t    ch = fgetc(f);\n\t}\n\tputc(ch, stderr);\n    }\n}"
  },
  {
    "function_name": "read_octet_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "1232-1250",
    "snippet": "static int\nread_octet_string(f, buf, len)\n    FILE\t*f;\n    krb5_octet\t*buf;\n    int\t\tlen;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tif (fscanf(f, \"%02x\", &c) != 1) {\n\t    retval = 1;\n\t    break;\n\t}\n\tbuf[i] = (krb5_octet) c;\n    }\n    return(retval);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "f",
            "\"%02x\"",
            "&c"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nread_octet_string(f, buf, len)\n    FILE\t*f;\n    krb5_octet\t*buf;\n    int\t\tlen;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tif (fscanf(f, \"%02x\", &c) != 1) {\n\t    retval = 1;\n\t    break;\n\t}\n\tbuf[i] = (krb5_octet) c;\n    }\n    return(retval);\n}"
  },
  {
    "function_name": "read_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "1204-1227",
    "snippet": "static int\nread_string(f, buf, len, lp)\n    FILE\t*f;\n    char\t*buf;\n    int\t\tlen;\n    int\t\t*lp;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tc = fgetc(f);\n\tif (c < 0) {\n\t    retval = 1;\n\t    break;\n\t}\n\tif (c == '\\n')\n\t    (*lp)++;\n\tbuf[i] = (char) c;\n    }\n    buf[len] = '\\0';\n    return(retval);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fgetc",
          "args": [
            "f"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nread_string(f, buf, len, lp)\n    FILE\t*f;\n    char\t*buf;\n    int\t\tlen;\n    int\t\t*lp;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tc = fgetc(f);\n\tif (c < 0) {\n\t    retval = 1;\n\t    break;\n\t}\n\tif (c == '\\n')\n\t    (*lp)++;\n\tbuf[i] = (char) c;\n    }\n    buf[len] = '\\0';\n    return(retval);\n}"
  },
  {
    "function_name": "dump_db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "1011-1199",
    "snippet": "void\ndump_db(argc, argv)\n    int\t\targc;\n    char\t**argv;\n{\n    FILE\t\t*f;\n    struct dump_args\targlist;\n    char\t\t*programname;\n    char\t\t*ofile;\n    krb5_error_code\tkret, retval;\n    dump_version\t*dump;\n    int\t\t\taindex;\n    krb5_boolean\tlocked;\n    extern osa_adb_policy_t policy_db;\n    char\t\t*new_mkey_file = 0;\n\t\n    /*\n     * Parse the arguments.\n     */\n    programname = argv[0];\n    if (strrchr(programname, (int) '/'))\n\tprogramname = strrchr(argv[0], (int) '/') + 1;\n    ofile = (char *) NULL;\n    dump = &r1_3_version;\n    arglist.verbose = 0;\n    new_mkey_file = 0;\n    mkey_convert = 0;\n    backwards = 0;\n    recursive = 0;\n\n    /*\n     * Parse the qualifiers.\n     */\n    for (aindex = 1; aindex < argc; aindex++) {\n\tif (!strcmp(argv[aindex], oldoption))\n\t     dump = &old_version;\n\telse if (!strcmp(argv[aindex], b6option))\n\t     dump = &beta6_version;\n\telse if (!strcmp(argv[aindex], b7option))\n\t     dump = &beta7_version;\n\telse if (!strcmp(argv[aindex], ovoption))\n\t     dump = &ov_version;\n\telse if (!strcmp(argv[aindex], verboseoption))\n\t    arglist.verbose++;\n\telse if (!strcmp(argv[aindex], \"-mkey_convert\"))\n\t    mkey_convert = 1;\n\telse if (!strcmp(argv[aindex], \"-new_mkey_file\")) {\n\t    new_mkey_file = argv[++aindex];\n\t    mkey_convert = 1;\n        } else if (!strcmp(argv[aindex], \"-rev\"))\n\t    backwards = 1;\n\telse if (!strcmp(argv[aindex], \"-recurse\"))\n\t    recursive = 1;\n\telse\n\t    break;\n    }\n\n    arglist.names = (char **) NULL;\n    arglist.nnames = 0;\n    if (aindex < argc) {\n\tofile = argv[aindex];\n\taindex++;\n\tif (aindex < argc) {\n\t    arglist.names = &argv[aindex];\n\t    arglist.nnames = argc - aindex;\n\t}\n    }\n\n    /*\n     * Make sure the database is open.  The policy database only has\n     * to be opened if we try a dump that uses it.\n     */\n    if (!dbactive || (dump->dump_policy != NULL && policy_db == NULL)) {\n\tcom_err(argv[0], 0, Err_no_database);\n\texit_status++;\n\treturn;\n    }\n\n    /*\n     * If we're doing a master key conversion, set up for it.\n     */\n    if (mkey_convert) {\n\t    if (!valid_master_key) {\n\t\t    /* TRUE here means read the keyboard, but only once */\n\t\t    retval = krb5_db_fetch_mkey(util_context,\n\t\t\t\t\t\tmaster_princ,\n\t\t\t\t\t\tmaster_keyblock.enctype,\n\t\t\t\t\t\tTRUE, FALSE,\n\t\t\t\t\t\t(char *) NULL, 0,\n\t\t\t\t\t\t&master_keyblock);\n\t\t    if (retval) {\n\t\t\t    com_err(argv[0], retval,\n\t\t\t\t    \"while reading master key\");\n\t\t\t    exit(1);\n\t\t    }\n\t\t    retval = krb5_db_verify_master_key(util_context,\n\t\t\t\t\t\t       master_princ,\n\t\t\t\t\t\t       &master_keyblock);\n\t\t    if (retval) {\n\t\t\t    com_err(argv[0], retval,\n\t\t\t\t    \"while verifying master key\");\n\t\t\t    exit(1);\n\t\t    }\n\t    }\n\t    new_master_keyblock.enctype = global_params.enctype;\n\t    if (new_master_keyblock.enctype == ENCTYPE_UNKNOWN)\n\t\t    new_master_keyblock.enctype = DEFAULT_KDC_ENCTYPE;\n\t    if (!new_mkey_file)\n\t\t    printf(\"Please enter new master key....\\n\");\n\t    if ((retval = krb5_db_fetch_mkey(util_context, master_princ, \n\t\t\t\t\t     new_master_keyblock.enctype,\n\t\t\t\t\t     (new_mkey_file == 0) ? \n\t\t\t\t\t        (krb5_boolean) 1 : 0, \n\t\t\t\t\t     TRUE, \n\t\t\t\t\t     new_mkey_file, 0,\n\t\t\t\t\t     &new_master_keyblock))) { \n\t\t    com_err(argv[0], retval, \"while reading new master key\");\n\t\t    exit(1);\n\t    }\n    }\n\n    kret = 0;\n    locked = 0;\n    if (ofile && strcmp(ofile, \"-\")) {\n\t/*\n\t * Discourage accidental dumping to filenames beginning with '-'.\n\t */\n\tif (ofile[0] == '-')\n\t    usage();\n\t/*\n\t * Make sure that we don't open and truncate on the fopen,\n\t * since that may hose an on-going kprop process.\n\t * \n\t * We could also control this by opening for read and\n\t * write, doing an flock with LOCK_EX, and then\n\t * truncating the file once we have gotten the lock,\n\t * but that would involve more OS dependencies than I\n\t * want to get into.\n\t */\n\tunlink(ofile);\n\tif (!(f = fopen(ofile, \"w\"))) {\n\t    fprintf(stderr, ofopen_error,\n\t\t    programname, ofile, error_message(errno));\n\t    exit_status++;\n\t    return;\n       }\n\tif ((kret = krb5_lock_file(util_context,\n\t\t\t\t   fileno(f),\n\t\t\t\t   KRB5_LOCKMODE_EXCLUSIVE))) {\n\t    fprintf(stderr, oflock_error,\n\t\t    programname, ofile, error_message(kret));\n\t    exit_status++;\n\t}\n\telse\n\t    locked = 1;\n    } else {\n\tf = stdout;\n    }\n    if (f && !(kret)) {\n\targlist.programname = programname;\n\targlist.ofile = f;\n\targlist.kcontext = util_context;\n\tfprintf(arglist.ofile, \"%s\", dump->header);\n\tif (dump->header[strlen(dump->header)-1] != '\\n')\n\t     fputc('\\n', arglist.ofile);\n\t\n\tif ((kret = krb5_db_iterate_ext(util_context,\n\t\t\t\t\tdump->dump_princ,\n\t\t\t\t\t(krb5_pointer) &arglist,\n\t\t\t\t\tbackwards, recursive))) {\n\t     fprintf(stderr, dumprec_err,\n\t\t     programname, dump->name, error_message(kret));\n\t     exit_status++;\n\t}\n\tif (dump->dump_policy &&\n\t    (kret = osa_adb_iter_policy(policy_db, dump->dump_policy,\n\t\t\t\t\t&arglist))) { \n\t     fprintf(stderr, dumprec_err, programname, dump->name,\n\t\t     error_message(kret));\n\t     exit_status++;\n\t}\n\tif (ofile && f != stdout && !exit_status) {\n\t     fclose(f);\n\t     update_ok_file(ofile);\n\t}\n    }\n    if (locked)\n\t(void) krb5_lock_file(util_context, fileno(f), KRB5_LOCKMODE_UNLOCK);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define dumprec_err\t\t\"%s: error performing %s dump (%s)\\n\"",
      "#define oflock_error\t\t\"%s: cannot lock %s (%s)\\n\"",
      "#define ofopen_error\t\t\"%s: cannot open %s for writing (%s)\\n\""
    ],
    "globals_used": [
      "static int\t\t\tmkey_convert;",
      "static krb5_keyblock\t\tnew_master_keyblock;",
      "static int\tbackwards;",
      "static int\trecursive;",
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);",
      "dump_version old_version = {\n     \"Kerberos version 5 old format\",\n     \"kdb5_edit load_dump version 2.0\\n\",\n     0,\n     1,\n     dump_k5beta_iterator,\n     NULL,\n     process_k5beta_record,\n};",
      "dump_version beta6_version = {\n     \"Kerberos version 5 beta 6 format\",\n     \"kdb5_edit load_dump version 3.0\\n\",\n     0,\n     1,\n     dump_k5beta6_iterator,\n     NULL,\n     process_k5beta6_record,\n};",
      "dump_version beta7_version = {\n     \"Kerberos version 5\",\n     \"kdb5_util load_dump version 4\\n\",\n     0,\n     0,\n     dump_k5beta7_princ,\n     dump_k5beta7_policy,\n     process_k5beta7_record,\n};",
      "dump_version ov_version = {\n     \"OpenV*Secure V1.0\",\n     \"OpenV*Secure V1.0\\t\",\n     1,\n     1,\n     dump_ov_princ,\n     dump_k5beta7_policy,\n     process_ov_record,\n};",
      "dump_version r1_3_version = {\n     \"Kerberos version 5 release 1.3\",\n     \"kdb5_util load_dump version 5\\n\",\n     0,\n     0,\n     dump_k5beta7_princ_withpolicy,\n     dump_k5beta7_policy,\n     process_k5beta7_record,\n};",
      "extern krb5_boolean\tdbactive;",
      "extern int\t\texit_status;",
      "extern krb5_context\tutil_context;",
      "extern kadm5_config_params global_params;",
      "static const char oldoption[] = \"-old\";",
      "static const char b6option[] = \"-b6\";",
      "static const char b7option[] = \"-b7\";",
      "static const char verboseoption[] = \"-verbose\";",
      "static const char ovoption[] = \"-ov\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_lock_file",
          "args": [
            "util_context",
            "fileno(f)",
            "KRB5_LOCKMODE_UNLOCK"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "f"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_ok_file",
          "args": [
            "ofile"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "update_ok_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "297-332",
          "snippet": "void update_ok_file (file_name)\n     char *file_name;\n{\n\t/* handle slave locking/failure stuff */\n\tchar *file_ok;\n\tint fd;\n\tstatic char ok[]=\".dump_ok\";\n\n\tif ((file_ok = (char *)malloc(strlen(file_name) + strlen(ok) + 1))\n\t    == NULL) {\n\t\tcom_err(progname, ENOMEM,\n\t\t\t\"while allocating filename for update_ok_file\");\n\t\texit_status++;\n\t\treturn;\n\t}\n\tstrcpy(file_ok, file_name);\n\tstrcat(file_ok, ok);\n\tif ((fd = open(file_ok, O_WRONLY|O_CREAT|O_TRUNC, 0600)) < 0) {\n\t\tcom_err(progname, errno, \"while creating 'ok' file, '%s'\",\n\t\t\tfile_ok);\n\t\texit_status++;\n\t\tfree(file_ok);\n\t\treturn;\n\t}\n\tif (write(fd, \"\", 1) != 1) {\n\t    com_err(progname, errno, \"while writing to 'ok' file, '%s'\",\n\t\t    file_ok);\n\t     exit_status++;\n\t     free(file_ok);\n\t     return;\n\t}\n\n\tfree(file_ok);\n\tclose(fd);\n\treturn;\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\t\texit_status;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nextern int\t\texit_status;\n\nvoid update_ok_file (file_name)\n     char *file_name;\n{\n\t/* handle slave locking/failure stuff */\n\tchar *file_ok;\n\tint fd;\n\tstatic char ok[]=\".dump_ok\";\n\n\tif ((file_ok = (char *)malloc(strlen(file_name) + strlen(ok) + 1))\n\t    == NULL) {\n\t\tcom_err(progname, ENOMEM,\n\t\t\t\"while allocating filename for update_ok_file\");\n\t\texit_status++;\n\t\treturn;\n\t}\n\tstrcpy(file_ok, file_name);\n\tstrcat(file_ok, ok);\n\tif ((fd = open(file_ok, O_WRONLY|O_CREAT|O_TRUNC, 0600)) < 0) {\n\t\tcom_err(progname, errno, \"while creating 'ok' file, '%s'\",\n\t\t\tfile_ok);\n\t\texit_status++;\n\t\tfree(file_ok);\n\t\treturn;\n\t}\n\tif (write(fd, \"\", 1) != 1) {\n\t    com_err(progname, errno, \"while writing to 'ok' file, '%s'\",\n\t\t    file_ok);\n\t     exit_status++;\n\t     free(file_ok);\n\t     return;\n\t}\n\n\tfree(file_ok);\n\tclose(fd);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "dumprec_err",
            "programname",
            "dump->name",
            "error_message(kret)"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_iter_policy",
          "args": [
            "policy_db",
            "dump->dump_policy",
            "&arglist"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "dumprec_err",
            "programname",
            "dump->name",
            "error_message(kret)"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_iterate_ext",
          "args": [
            "util_context",
            "dump->dump_princ",
            "(krb5_pointer) &arglist",
            "backwards",
            "recursive"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "'\\n'",
            "arglist.ofile"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dump->header"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arglist.ofile",
            "\"%s\"",
            "dump->header"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "oflock_error",
            "programname",
            "ofile",
            "error_message(kret)"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "kret"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_lock_file",
          "args": [
            "util_context",
            "fileno(f)",
            "KRB5_LOCKMODE_EXCLUSIVE"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "f"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "ofopen_error",
            "programname",
            "ofile",
            "error_message(errno)"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "ofile",
            "\"w\""
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "ofile"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/kdb5_util.c",
          "lines": "82-98",
          "snippet": "void usage()\n{\n     fprintf(stderr, \"Usage: \"\n\t   \"kdb5_util [-r realm] [-d dbname] [-k mkeytype] [-M mkeyname]\\n\"\n\t     \"\\t        [-sf stashfilename] [-m] cmd [cmd_options]\\n\"\n\t     \"\\tcreate\t[-s]\\n\"\n\t     \"\\tdestroy\t[-f]\\n\"\n\t     \"\\tstash\t[-f keyfile]\\n\"\n\t     \"\\tdump\t[-old] [-ov] [-b6] [-verbose]\\n\"\n\t     \"\\t\t[-mkey_convert] [-new_mkey_file mkey_file]\\n\"\n\t     \"\\t\t[-rev] [-recurse] [filename [princs...]]\\n\"\n\t     \"\\tload\t[-old] [-ov] [-b6] [-verbose] [-update] filename\\n\"\n\t     \"\\tdump_v4\t[-S] [filename]\\n\"\n\t     \"\\tload_v4\t[-S] [-t] [-n] [-v] [-K] [-s stashfile] inputfile\\n\"\n\t     \"\\tark\t[-e etype_list] principal\\n\");\n     exit(1);\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <time.h>",
            "#include <kadm5/adb.h>",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <time.h>\n#include <kadm5/adb.h>\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nvoid usage()\n{\n     fprintf(stderr, \"Usage: \"\n\t   \"kdb5_util [-r realm] [-d dbname] [-k mkeytype] [-M mkeyname]\\n\"\n\t     \"\\t        [-sf stashfilename] [-m] cmd [cmd_options]\\n\"\n\t     \"\\tcreate\t[-s]\\n\"\n\t     \"\\tdestroy\t[-f]\\n\"\n\t     \"\\tstash\t[-f keyfile]\\n\"\n\t     \"\\tdump\t[-old] [-ov] [-b6] [-verbose]\\n\"\n\t     \"\\t\t[-mkey_convert] [-new_mkey_file mkey_file]\\n\"\n\t     \"\\t\t[-rev] [-recurse] [filename [princs...]]\\n\"\n\t     \"\\tload\t[-old] [-ov] [-b6] [-verbose] [-update] filename\\n\"\n\t     \"\\tdump_v4\t[-S] [filename]\\n\"\n\t     \"\\tload_v4\t[-S] [-t] [-n] [-v] [-K] [-s stashfile] inputfile\\n\"\n\t     \"\\tark\t[-e etype_list] principal\\n\");\n     exit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ofile",
            "\"-\""
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while reading new master key\""
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_fetch_mkey",
          "args": [
            "util_context",
            "master_princ",
            "new_master_keyblock.enctype",
            "(new_mkey_file == 0) ? \n\t\t\t\t\t        (krb5_boolean) 1 : 0",
            "TRUE",
            "new_mkey_file",
            "0",
            "&new_master_keyblock"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Please enter new master key....\\n\""
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while verifying master key\""
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_verify_master_key",
          "args": [
            "util_context",
            "master_princ",
            "&master_keyblock"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while reading master key\""
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_fetch_mkey",
          "args": [
            "util_context",
            "master_princ",
            "master_keyblock.enctype",
            "TRUE",
            "FALSE",
            "(char *) NULL",
            "0",
            "&master_keyblock"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "0",
            "Err_no_database"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "\"-recurse\""
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "\"-rev\""
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "\"-new_mkey_file\""
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "\"-mkey_convert\""
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "verboseoption"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "ovoption"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "b7option"
          ],
          "line": 1049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "b6option"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[aindex]",
            "oldoption"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "(int) '/'"
          ],
          "line": 1032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "programname",
            "(int) '/'"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define dumprec_err\t\t\"%s: error performing %s dump (%s)\\n\"\n#define oflock_error\t\t\"%s: cannot lock %s (%s)\\n\"\n#define ofopen_error\t\t\"%s: cannot open %s for writing (%s)\\n\"\n\nstatic int\t\t\tmkey_convert;\nstatic krb5_keyblock\t\tnew_master_keyblock;\nstatic int\tbackwards;\nstatic int\trecursive;\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\ndump_version old_version = {\n     \"Kerberos version 5 old format\",\n     \"kdb5_edit load_dump version 2.0\\n\",\n     0,\n     1,\n     dump_k5beta_iterator,\n     NULL,\n     process_k5beta_record,\n};\ndump_version beta6_version = {\n     \"Kerberos version 5 beta 6 format\",\n     \"kdb5_edit load_dump version 3.0\\n\",\n     0,\n     1,\n     dump_k5beta6_iterator,\n     NULL,\n     process_k5beta6_record,\n};\ndump_version beta7_version = {\n     \"Kerberos version 5\",\n     \"kdb5_util load_dump version 4\\n\",\n     0,\n     0,\n     dump_k5beta7_princ,\n     dump_k5beta7_policy,\n     process_k5beta7_record,\n};\ndump_version ov_version = {\n     \"OpenV*Secure V1.0\",\n     \"OpenV*Secure V1.0\\t\",\n     1,\n     1,\n     dump_ov_princ,\n     dump_k5beta7_policy,\n     process_ov_record,\n};\ndump_version r1_3_version = {\n     \"Kerberos version 5 release 1.3\",\n     \"kdb5_util load_dump version 5\\n\",\n     0,\n     0,\n     dump_k5beta7_princ_withpolicy,\n     dump_k5beta7_policy,\n     process_k5beta7_record,\n};\nextern krb5_boolean\tdbactive;\nextern int\t\texit_status;\nextern krb5_context\tutil_context;\nextern kadm5_config_params global_params;\nstatic const char oldoption[] = \"-old\";\nstatic const char b6option[] = \"-b6\";\nstatic const char b7option[] = \"-b7\";\nstatic const char verboseoption[] = \"-verbose\";\nstatic const char ovoption[] = \"-ov\";\n\nvoid\ndump_db(argc, argv)\n    int\t\targc;\n    char\t**argv;\n{\n    FILE\t\t*f;\n    struct dump_args\targlist;\n    char\t\t*programname;\n    char\t\t*ofile;\n    krb5_error_code\tkret, retval;\n    dump_version\t*dump;\n    int\t\t\taindex;\n    krb5_boolean\tlocked;\n    extern osa_adb_policy_t policy_db;\n    char\t\t*new_mkey_file = 0;\n\t\n    /*\n     * Parse the arguments.\n     */\n    programname = argv[0];\n    if (strrchr(programname, (int) '/'))\n\tprogramname = strrchr(argv[0], (int) '/') + 1;\n    ofile = (char *) NULL;\n    dump = &r1_3_version;\n    arglist.verbose = 0;\n    new_mkey_file = 0;\n    mkey_convert = 0;\n    backwards = 0;\n    recursive = 0;\n\n    /*\n     * Parse the qualifiers.\n     */\n    for (aindex = 1; aindex < argc; aindex++) {\n\tif (!strcmp(argv[aindex], oldoption))\n\t     dump = &old_version;\n\telse if (!strcmp(argv[aindex], b6option))\n\t     dump = &beta6_version;\n\telse if (!strcmp(argv[aindex], b7option))\n\t     dump = &beta7_version;\n\telse if (!strcmp(argv[aindex], ovoption))\n\t     dump = &ov_version;\n\telse if (!strcmp(argv[aindex], verboseoption))\n\t    arglist.verbose++;\n\telse if (!strcmp(argv[aindex], \"-mkey_convert\"))\n\t    mkey_convert = 1;\n\telse if (!strcmp(argv[aindex], \"-new_mkey_file\")) {\n\t    new_mkey_file = argv[++aindex];\n\t    mkey_convert = 1;\n        } else if (!strcmp(argv[aindex], \"-rev\"))\n\t    backwards = 1;\n\telse if (!strcmp(argv[aindex], \"-recurse\"))\n\t    recursive = 1;\n\telse\n\t    break;\n    }\n\n    arglist.names = (char **) NULL;\n    arglist.nnames = 0;\n    if (aindex < argc) {\n\tofile = argv[aindex];\n\taindex++;\n\tif (aindex < argc) {\n\t    arglist.names = &argv[aindex];\n\t    arglist.nnames = argc - aindex;\n\t}\n    }\n\n    /*\n     * Make sure the database is open.  The policy database only has\n     * to be opened if we try a dump that uses it.\n     */\n    if (!dbactive || (dump->dump_policy != NULL && policy_db == NULL)) {\n\tcom_err(argv[0], 0, Err_no_database);\n\texit_status++;\n\treturn;\n    }\n\n    /*\n     * If we're doing a master key conversion, set up for it.\n     */\n    if (mkey_convert) {\n\t    if (!valid_master_key) {\n\t\t    /* TRUE here means read the keyboard, but only once */\n\t\t    retval = krb5_db_fetch_mkey(util_context,\n\t\t\t\t\t\tmaster_princ,\n\t\t\t\t\t\tmaster_keyblock.enctype,\n\t\t\t\t\t\tTRUE, FALSE,\n\t\t\t\t\t\t(char *) NULL, 0,\n\t\t\t\t\t\t&master_keyblock);\n\t\t    if (retval) {\n\t\t\t    com_err(argv[0], retval,\n\t\t\t\t    \"while reading master key\");\n\t\t\t    exit(1);\n\t\t    }\n\t\t    retval = krb5_db_verify_master_key(util_context,\n\t\t\t\t\t\t       master_princ,\n\t\t\t\t\t\t       &master_keyblock);\n\t\t    if (retval) {\n\t\t\t    com_err(argv[0], retval,\n\t\t\t\t    \"while verifying master key\");\n\t\t\t    exit(1);\n\t\t    }\n\t    }\n\t    new_master_keyblock.enctype = global_params.enctype;\n\t    if (new_master_keyblock.enctype == ENCTYPE_UNKNOWN)\n\t\t    new_master_keyblock.enctype = DEFAULT_KDC_ENCTYPE;\n\t    if (!new_mkey_file)\n\t\t    printf(\"Please enter new master key....\\n\");\n\t    if ((retval = krb5_db_fetch_mkey(util_context, master_princ, \n\t\t\t\t\t     new_master_keyblock.enctype,\n\t\t\t\t\t     (new_mkey_file == 0) ? \n\t\t\t\t\t        (krb5_boolean) 1 : 0, \n\t\t\t\t\t     TRUE, \n\t\t\t\t\t     new_mkey_file, 0,\n\t\t\t\t\t     &new_master_keyblock))) { \n\t\t    com_err(argv[0], retval, \"while reading new master key\");\n\t\t    exit(1);\n\t    }\n    }\n\n    kret = 0;\n    locked = 0;\n    if (ofile && strcmp(ofile, \"-\")) {\n\t/*\n\t * Discourage accidental dumping to filenames beginning with '-'.\n\t */\n\tif (ofile[0] == '-')\n\t    usage();\n\t/*\n\t * Make sure that we don't open and truncate on the fopen,\n\t * since that may hose an on-going kprop process.\n\t * \n\t * We could also control this by opening for read and\n\t * write, doing an flock with LOCK_EX, and then\n\t * truncating the file once we have gotten the lock,\n\t * but that would involve more OS dependencies than I\n\t * want to get into.\n\t */\n\tunlink(ofile);\n\tif (!(f = fopen(ofile, \"w\"))) {\n\t    fprintf(stderr, ofopen_error,\n\t\t    programname, ofile, error_message(errno));\n\t    exit_status++;\n\t    return;\n       }\n\tif ((kret = krb5_lock_file(util_context,\n\t\t\t\t   fileno(f),\n\t\t\t\t   KRB5_LOCKMODE_EXCLUSIVE))) {\n\t    fprintf(stderr, oflock_error,\n\t\t    programname, ofile, error_message(kret));\n\t    exit_status++;\n\t}\n\telse\n\t    locked = 1;\n    } else {\n\tf = stdout;\n    }\n    if (f && !(kret)) {\n\targlist.programname = programname;\n\targlist.ofile = f;\n\targlist.kcontext = util_context;\n\tfprintf(arglist.ofile, \"%s\", dump->header);\n\tif (dump->header[strlen(dump->header)-1] != '\\n')\n\t     fputc('\\n', arglist.ofile);\n\t\n\tif ((kret = krb5_db_iterate_ext(util_context,\n\t\t\t\t\tdump->dump_princ,\n\t\t\t\t\t(krb5_pointer) &arglist,\n\t\t\t\t\tbackwards, recursive))) {\n\t     fprintf(stderr, dumprec_err,\n\t\t     programname, dump->name, error_message(kret));\n\t     exit_status++;\n\t}\n\tif (dump->dump_policy &&\n\t    (kret = osa_adb_iter_policy(policy_db, dump->dump_policy,\n\t\t\t\t\t&arglist))) { \n\t     fprintf(stderr, dumprec_err, programname, dump->name,\n\t\t     error_message(kret));\n\t     exit_status++;\n\t}\n\tif (ofile && f != stdout && !exit_status) {\n\t     fclose(f);\n\t     update_ok_file(ofile);\n\t}\n    }\n    if (locked)\n\t(void) krb5_lock_file(util_context, fileno(f), KRB5_LOCKMODE_UNLOCK);\n}"
  },
  {
    "function_name": "dump_ov_princ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "933-1003",
    "snippet": "static krb5_error_code dump_ov_princ(krb5_pointer ptr, krb5_db_entry *kdb)\n{\n    char *princstr;\n    int\tx, y, foundcrc;\n    struct dump_args *arg;\n    krb5_tl_data tl_data;\n    osa_princ_ent_rec adb;\n    XDR xdrs;\n\n    arg = (struct dump_args *) ptr;\n    /*\n     * XXX Currently, lookup_tl_data always returns zero; it sets\n     * tl_data->tl_data_length to zero if the type isn't found.\n     * This should be fixed...\n     */\n    /*\n     * XXX Should this function do nothing for a principal with no\n     * admin data, or print a record of \"default\" values?   See\n     * comment in server_kdb.c to help decide.\n     */\n    tl_data.tl_data_type = KRB5_TL_KADM_DATA;\n    if (krb5_dbe_lookup_tl_data(arg->kcontext, kdb, &tl_data)\n\t|| (tl_data.tl_data_length == 0))\n\t return 0;\n\n    memset(&adb, 0, sizeof(adb));\n    xdrmem_create(&xdrs, tl_data.tl_data_contents,\n\t\t  tl_data.tl_data_length, XDR_DECODE);\n    if (! xdr_osa_princ_ent_rec(&xdrs, &adb)) {\n\t xdr_destroy(&xdrs);\n\t return(OSA_ADB_XDR_FAILURE);\n    }\n    xdr_destroy(&xdrs);\n    \n    krb5_unparse_name(arg->kcontext, kdb->princ, &princstr);\n    fprintf(arg->ofile, \"princ\\t%s\\t\", princstr);\n    if(adb.policy == NULL)\n\tfputc('\\t', arg->ofile);\n    else\n\tfprintf(arg->ofile, \"%s\\t\", adb.policy);\n    fprintf(arg->ofile, \"%lx\\t%d\\t%d\\t%d\", adb.aux_attributes,\n\t    adb.old_key_len,adb.old_key_next, adb.admin_history_kvno);\n\n    for (x = 0; x < adb.old_key_len; x++) {\n\t foundcrc = 0;\n\t for (y = 0; y < adb.old_keys[x].n_key_data; y++) {\n\t      krb5_key_data *key_data = &adb.old_keys[x].key_data[y];\n\n\t      if (key_data->key_data_type[0] != ENCTYPE_DES_CBC_CRC)\n\t\t   continue;\n\t      if (foundcrc) {\n\t\t   fprintf(stderr, \"Warning!  Multiple DES-CBC-CRC keys \"\n\t\t\t   \"for principal %s; skipping duplicates.\\n\",\n\t\t\t   princstr);\n\t\t   continue;\n\t      }\n\t      foundcrc++;\n\n\t      fputc('\\t', arg->ofile);\n\t      print_key_data(arg->ofile, key_data);\n\t }\n\t if (!foundcrc)\n\t      fprintf(stderr, \"Warning!  No DES-CBC-CRC key for principal \"\n\t\t      \"%s, cannot generate OV-compatible record; skipping\\n\",\n\t\t      princstr);\n    }\n\n    fputc('\\n', arg->ofile);\n    free(princstr);\n    return 0;\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "princstr"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "'\\n'",
            "arg->ofile"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning!  No DES-CBC-CRC key for principal \"\n\t\t      \"%s, cannot generate OV-compatible record; skipping\\n\"",
            "princstr"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_key_data",
          "args": [
            "arg->ofile",
            "key_data"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "print_key_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "899-908",
          "snippet": "static void print_key_data(FILE *f, krb5_key_data *key_data)\n{\n     int c;\n     \n     fprintf(f, \"%d\\t%d\\t\", key_data->key_data_type[0],\n\t     key_data->key_data_length[0]);\n     for(c = 0; c < key_data->key_data_length[0]; c++) \n\t  fprintf(f, \"%02x \",\n\t\t  key_data->key_data_contents[0][c]);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic void print_key_data(FILE *f, krb5_key_data *key_data)\n{\n     int c;\n     \n     fprintf(f, \"%d\\t%d\\t\", key_data->key_data_type[0],\n\t     key_data->key_data_length[0]);\n     for(c = 0; c < key_data->key_data_length[0]; c++) \n\t  fprintf(f, \"%02x \",\n\t\t  key_data->key_data_contents[0][c]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "'\\t'",
            "arg->ofile"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Warning!  Multiple DES-CBC-CRC keys \"\n\t\t\t   \"for principal %s; skipping duplicates.\\n\"",
            "princstr"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%lx\\t%d\\t%d\\t%d\"",
            "adb.aux_attributes",
            "adb.old_key_len",
            "adb.old_key_next",
            "adb.admin_history_kvno"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%s\\t\"",
            "adb.policy"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "'\\t'",
            "arg->ofile"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"princ\\t%s\\t\"",
            "princstr"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "arg->kcontext",
            "kdb->princ",
            "&princstr"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdrs"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdrs"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_osa_princ_ent_rec",
          "args": [
            "&xdrs",
            "&adb"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdrmem_create",
          "args": [
            "&xdrs",
            "tl_data.tl_data_contents",
            "tl_data.tl_data_length",
            "XDR_DECODE"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&adb",
            "0",
            "sizeof(adb)"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_lookup_tl_data",
          "args": [
            "arg->kcontext",
            "kdb",
            "&tl_data"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code dump_ov_princ(krb5_pointer ptr, krb5_db_entry *kdb)\n{\n    char *princstr;\n    int\tx, y, foundcrc;\n    struct dump_args *arg;\n    krb5_tl_data tl_data;\n    osa_princ_ent_rec adb;\n    XDR xdrs;\n\n    arg = (struct dump_args *) ptr;\n    /*\n     * XXX Currently, lookup_tl_data always returns zero; it sets\n     * tl_data->tl_data_length to zero if the type isn't found.\n     * This should be fixed...\n     */\n    /*\n     * XXX Should this function do nothing for a principal with no\n     * admin data, or print a record of \"default\" values?   See\n     * comment in server_kdb.c to help decide.\n     */\n    tl_data.tl_data_type = KRB5_TL_KADM_DATA;\n    if (krb5_dbe_lookup_tl_data(arg->kcontext, kdb, &tl_data)\n\t|| (tl_data.tl_data_length == 0))\n\t return 0;\n\n    memset(&adb, 0, sizeof(adb));\n    xdrmem_create(&xdrs, tl_data.tl_data_contents,\n\t\t  tl_data.tl_data_length, XDR_DECODE);\n    if (! xdr_osa_princ_ent_rec(&xdrs, &adb)) {\n\t xdr_destroy(&xdrs);\n\t return(OSA_ADB_XDR_FAILURE);\n    }\n    xdr_destroy(&xdrs);\n    \n    krb5_unparse_name(arg->kcontext, kdb->princ, &princstr);\n    fprintf(arg->ofile, \"princ\\t%s\\t\", princstr);\n    if(adb.policy == NULL)\n\tfputc('\\t', arg->ofile);\n    else\n\tfprintf(arg->ofile, \"%s\\t\", adb.policy);\n    fprintf(arg->ofile, \"%lx\\t%d\\t%d\\t%d\", adb.aux_attributes,\n\t    adb.old_key_len,adb.old_key_next, adb.admin_history_kvno);\n\n    for (x = 0; x < adb.old_key_len; x++) {\n\t foundcrc = 0;\n\t for (y = 0; y < adb.old_keys[x].n_key_data; y++) {\n\t      krb5_key_data *key_data = &adb.old_keys[x].key_data[y];\n\n\t      if (key_data->key_data_type[0] != ENCTYPE_DES_CBC_CRC)\n\t\t   continue;\n\t      if (foundcrc) {\n\t\t   fprintf(stderr, \"Warning!  Multiple DES-CBC-CRC keys \"\n\t\t\t   \"for principal %s; skipping duplicates.\\n\",\n\t\t\t   princstr);\n\t\t   continue;\n\t      }\n\t      foundcrc++;\n\n\t      fputc('\\t', arg->ofile);\n\t      print_key_data(arg->ofile, key_data);\n\t }\n\t if (!foundcrc)\n\t      fprintf(stderr, \"Warning!  No DES-CBC-CRC key for principal \"\n\t\t      \"%s, cannot generate OV-compatible record; skipping\\n\",\n\t\t      princstr);\n    }\n\n    fputc('\\n', arg->ofile);\n    free(princstr);\n    return 0;\n}"
  },
  {
    "function_name": "print_key_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "899-908",
    "snippet": "static void print_key_data(FILE *f, krb5_key_data *key_data)\n{\n     int c;\n     \n     fprintf(f, \"%d\\t%d\\t\", key_data->key_data_type[0],\n\t     key_data->key_data_length[0]);\n     for(c = 0; c < key_data->key_data_length[0]; c++) \n\t  fprintf(f, \"%02x \",\n\t\t  key_data->key_data_contents[0][c]);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
      "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
      "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%02x \"",
            "key_data->key_data_contents[0][c]"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%d\\t%d\\t\"",
            "key_data->key_data_type[0]",
            "key_data->key_data_length[0]"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic void print_key_data(FILE *f, krb5_key_data *key_data)\n{\n     int c;\n     \n     fprintf(f, \"%d\\t%d\\t\", key_data->key_data_type[0],\n\t     key_data->key_data_length[0]);\n     for(c = 0; c < key_data->key_data_length[0]; c++) \n\t  fprintf(f, \"%02x \",\n\t\t  key_data->key_data_contents[0][c]);\n}"
  },
  {
    "function_name": "dump_k5beta7_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "888-897",
    "snippet": "void dump_k5beta7_policy(void *data, osa_policy_ent_t entry)\n{\n     struct dump_args *arg;\n\n     arg = (struct dump_args *) data;\n     fprintf(arg->ofile, \"policy\\t%s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\n\", entry->name,\n\t     entry->pw_min_life, entry->pw_max_life, entry->pw_min_length,\n\t     entry->pw_min_classes, entry->pw_history_num,\n\t     entry->policy_refcnt);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void dump_k5beta7_policy (void *, osa_policy_ent_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"policy\\t%s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\n\"",
            "entry->name",
            "entry->pw_min_life",
            "entry->pw_max_life",
            "entry->pw_min_length",
            "entry->pw_min_classes",
            "entry->pw_history_num",
            "entry->policy_refcnt"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic void dump_k5beta7_policy (void *, osa_policy_ent_t);\n\nvoid dump_k5beta7_policy(void *data, osa_policy_ent_t entry)\n{\n     struct dump_args *arg;\n\n     arg = (struct dump_args *) data;\n     fprintf(arg->ofile, \"policy\\t%s\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\n\", entry->name,\n\t     entry->pw_min_life, entry->pw_max_life, entry->pw_min_length,\n\t     entry->pw_min_classes, entry->pw_history_num,\n\t     entry->policy_refcnt);\n}"
  },
  {
    "function_name": "dump_k5beta7_princ_withpolicy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "880-886",
    "snippet": "static krb5_error_code\ndump_k5beta7_princ_withpolicy(ptr, entry)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n{\n    return dump_k5beta7_princ_ext(ptr, entry, 1);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_k5beta7_princ_ext",
          "args": [
            "ptr",
            "entry",
            "1"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "dump_k5beta7_princ_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "837-878",
          "snippet": "static krb5_error_code\ndump_k5beta7_princ_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n     krb5_error_code retval;\n     struct dump_args *arg;\n     char *name;\n     int tmp_nnames;\n\n     /* Initialize */\n     arg = (struct dump_args *) ptr;\n     name = (char *) NULL;\n\n     /*\n      * Flatten the principal name.\n      */\n     if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t     entry->princ,\n\t\t\t\t     &name))) {\n\t  fprintf(stderr, pname_unp_err, \n\t\t  arg->programname, error_message(retval));\n\t  return(retval);\n     }\n     /*\n      * If we don't have any match strings, or if our name matches, then\n      * proceed with the dump, otherwise, just forget about it.\n      */\n     if (!arg->nnames || name_matches(name, arg)) {\n\t  fprintf(arg->ofile, \"princ\\t\");\n\t  \n\t  /* save the callee from matching the name again */\n\t  tmp_nnames = arg->nnames;\n\t  arg->nnames = 0;\n\t  retval = dump_k5beta6_iterator_ext(ptr, entry, kadm);\n\t  arg->nnames = tmp_nnames;\n     }\n\n     free(name);\n     return retval;\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\""
          ],
          "globals_used": [
            "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
            "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
            "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
            "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
            "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\"\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\ndump_k5beta7_princ_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n     krb5_error_code retval;\n     struct dump_args *arg;\n     char *name;\n     int tmp_nnames;\n\n     /* Initialize */\n     arg = (struct dump_args *) ptr;\n     name = (char *) NULL;\n\n     /*\n      * Flatten the principal name.\n      */\n     if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t     entry->princ,\n\t\t\t\t     &name))) {\n\t  fprintf(stderr, pname_unp_err, \n\t\t  arg->programname, error_message(retval));\n\t  return(retval);\n     }\n     /*\n      * If we don't have any match strings, or if our name matches, then\n      * proceed with the dump, otherwise, just forget about it.\n      */\n     if (!arg->nnames || name_matches(name, arg)) {\n\t  fprintf(arg->ofile, \"princ\\t\");\n\t  \n\t  /* save the callee from matching the name again */\n\t  tmp_nnames = arg->nnames;\n\t  arg->nnames = 0;\n\t  retval = dump_k5beta6_iterator_ext(ptr, entry, kadm);\n\t  arg->nnames = tmp_nnames;\n     }\n\n     free(name);\n     return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\ndump_k5beta7_princ_withpolicy(ptr, entry)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n{\n    return dump_k5beta7_princ_ext(ptr, entry, 1);\n}"
  },
  {
    "function_name": "dump_k5beta7_princ_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "837-878",
    "snippet": "static krb5_error_code\ndump_k5beta7_princ_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n     krb5_error_code retval;\n     struct dump_args *arg;\n     char *name;\n     int tmp_nnames;\n\n     /* Initialize */\n     arg = (struct dump_args *) ptr;\n     name = (char *) NULL;\n\n     /*\n      * Flatten the principal name.\n      */\n     if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t     entry->princ,\n\t\t\t\t     &name))) {\n\t  fprintf(stderr, pname_unp_err, \n\t\t  arg->programname, error_message(retval));\n\t  return(retval);\n     }\n     /*\n      * If we don't have any match strings, or if our name matches, then\n      * proceed with the dump, otherwise, just forget about it.\n      */\n     if (!arg->nnames || name_matches(name, arg)) {\n\t  fprintf(arg->ofile, \"princ\\t\");\n\t  \n\t  /* save the callee from matching the name again */\n\t  tmp_nnames = arg->nnames;\n\t  arg->nnames = 0;\n\t  retval = dump_k5beta6_iterator_ext(ptr, entry, kadm);\n\t  arg->nnames = tmp_nnames;\n     }\n\n     free(name);\n     return retval;\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\""
    ],
    "globals_used": [
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_k5beta6_iterator_ext",
          "args": [
            "ptr",
            "entry",
            "kadm"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "dump_k5beta6_iterator_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "662-824",
          "snippet": "static krb5_error_code\ndump_k5beta6_iterator_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n    krb5_error_code\tretval;\n    struct dump_args\t*arg;\n    char\t\t*name;\n    krb5_tl_data\t*tlp;\n    krb5_key_data\t*kdata;\n    int\t\t\tcounter, skip, i, j;\n\n    /* Initialize */\n    arg = (struct dump_args *) ptr;\n    name = (char *) NULL;\n\n    /*\n     * Flatten the principal name.\n     */\n    if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t    entry->princ,\n\t\t\t\t    &name))) {\n\tfprintf(stderr, pname_unp_err, \n\t\targ->programname, error_message(retval));\n\treturn(retval);\n    }\n\n    /*\n     * Re-encode the keys in the new master key, if necessary.\n     */\n    if (mkey_convert) {\n\tretval = master_key_convert(arg->kcontext, entry);\n\tif (retval) {\n\t    com_err(arg->programname, retval, remaster_err_fmt, name);\n\t    return retval;\n\t}\n    }\n    \n    /*\n     * If we don't have any match strings, or if our name matches, then\n     * proceed with the dump, otherwise, just forget about it.\n     */\n    if (!arg->nnames || name_matches(name, arg)) {\n\t/*\n\t * We'd like to just blast out the contents as they would appear in\n\t * the database so that we can just suck it back in, but it doesn't\n\t * lend itself to easy editing.\n\t */\n\n\t/*\n\t * The dump format is as follows:\n\t *\tlen strlen(name) n_tl_data n_key_data e_length\n\t *\tname\n\t *\tattributes max_life max_renewable_life expiration\n\t *\tpw_expiration last_success last_failed fail_auth_count\n\t *\tn_tl_data*[type length <contents>]\n\t *\tn_key_data*[ver kvno ver*(type length <contents>)]\n\t *\t<e_data>\n\t * Fields which are not encapsulated by angle-brackets are to appear\n\t * verbatim.  A bracketed field's absence is indicated by a -1 in its\n\t * place\n\t */\n\n\t/*\n\t * Make sure that the tagged list is reasonably correct.\n\t */\n\tcounter = skip = 0;\n\tfor (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t     /*\n\t      * don't dump tl data types we know aren't understood by\n\t      * earlier revisions [krb5-admin/89]\n\t      */\n\t     switch (tlp->tl_data_type) {\n\t     case KRB5_TL_KADM_DATA:\n\t\t  if (kadm)\n\t\t      counter++;\n\t\t  else\n\t\t      skip++;\n\t\t  break;\n\t     default:\n\t\t  counter++;\n\t\t  break;\n\t     }\n\t}\n\t\n\tif (counter + skip == entry->n_tl_data) {\n\t    /* Pound out header */\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%s\\t\",\n\t\t    (int) entry->len,\n\t\t    strlen(name),\n\t\t    counter,\n\t\t    (int) entry->n_key_data,\n\t\t    (int) entry->e_length,\n\t\t    name);\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t    entry->attributes,\n\t\t    entry->max_life,\n\t\t    entry->max_renewable_life,\n\t\t    entry->expiration,\n\t\t    entry->pw_expiration,\n\t\t    entry->last_success,\n\t\t    entry->last_failed,\n\t\t    entry->fail_auth_count);\n\t    /* Pound out tagged data. */\n\t    for (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t\tif (tlp->tl_data_type == KRB5_TL_KADM_DATA && !kadm)\n\t\t     continue; /* see above, [krb5-admin/89] */\n\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) tlp->tl_data_type,\n\t\t\t(int) tlp->tl_data_length);\n\t\tif (tlp->tl_data_length)\n\t\t    for (i=0; i<tlp->tl_data_length; i++)\n\t\t\tfprintf(arg->ofile, \"%02x\", tlp->tl_data_contents[i]);\n\t\telse\n\t\t    fprintf(arg->ofile, \"%d\", -1);\n\t\tfprintf(arg->ofile, \"\\t\");\n\t    }\n\n\t    /* Pound out key data */\n\t    for (counter=0; counter<entry->n_key_data; counter++) {\n\t\tkdata = &entry->key_data[counter];\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) kdata->key_data_ver,\n\t\t\t(int) kdata->key_data_kvno);\n\t\tfor (i=0; i<kdata->key_data_ver; i++) {\n\t\t    fprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t    kdata->key_data_type[i],\n\t\t\t    kdata->key_data_length[i]);\n\t\t    if (kdata->key_data_length[i])\n\t\t\tfor (j=0; j<kdata->key_data_length[i]; j++)\n\t\t\t    fprintf(arg->ofile, \"%02x\",\n\t\t\t\t    kdata->key_data_contents[i][j]);\n\t\t    else\n\t\t\tfprintf(arg->ofile, \"%d\", -1);\n\t\t    fprintf(arg->ofile, \"\\t\");\n\t\t}\n\t    }\n\n\t    /* Pound out extra data */\n\t    if (entry->e_length)\n\t\tfor (i=0; i<entry->e_length; i++)\n\t\t    fprintf(arg->ofile, \"%02x\", entry->e_data[i]);\n\t    else\n\t\tfprintf(arg->ofile, \"%d\", -1);\n\n\t    /* Print trailer */\n\t    fprintf(arg->ofile, \";\\n\");\n\n\t    if (arg->verbose)\n\t\tfprintf(stderr, \"%s\\n\", name);\n\t}\n\telse {\n\t    fprintf(stderr, sdump_tl_inc_err,\n\t\t    arg->programname, name, counter+skip,\n\t\t    (int) entry->n_tl_data); \n\t    retval = EINVAL;\n\t}\n    }\n    krb5_xfree(name);\n    return(retval);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define remaster_err_fmt\t\"while re-encoding keys for principal %s with new master key\"",
            "#define sdump_tl_inc_err\t\"%s: tagged data list inconsistency for %s (counted %d, stored %d)\\n\"",
            "#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\""
          ],
          "globals_used": [
            "static int\t\t\tmkey_convert;",
            "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
            "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
            "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
            "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
            "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define remaster_err_fmt\t\"while re-encoding keys for principal %s with new master key\"\n#define sdump_tl_inc_err\t\"%s: tagged data list inconsistency for %s (counted %d, stored %d)\\n\"\n#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\"\n\nstatic int\t\t\tmkey_convert;\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\ndump_k5beta6_iterator_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n    krb5_error_code\tretval;\n    struct dump_args\t*arg;\n    char\t\t*name;\n    krb5_tl_data\t*tlp;\n    krb5_key_data\t*kdata;\n    int\t\t\tcounter, skip, i, j;\n\n    /* Initialize */\n    arg = (struct dump_args *) ptr;\n    name = (char *) NULL;\n\n    /*\n     * Flatten the principal name.\n     */\n    if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t    entry->princ,\n\t\t\t\t    &name))) {\n\tfprintf(stderr, pname_unp_err, \n\t\targ->programname, error_message(retval));\n\treturn(retval);\n    }\n\n    /*\n     * Re-encode the keys in the new master key, if necessary.\n     */\n    if (mkey_convert) {\n\tretval = master_key_convert(arg->kcontext, entry);\n\tif (retval) {\n\t    com_err(arg->programname, retval, remaster_err_fmt, name);\n\t    return retval;\n\t}\n    }\n    \n    /*\n     * If we don't have any match strings, or if our name matches, then\n     * proceed with the dump, otherwise, just forget about it.\n     */\n    if (!arg->nnames || name_matches(name, arg)) {\n\t/*\n\t * We'd like to just blast out the contents as they would appear in\n\t * the database so that we can just suck it back in, but it doesn't\n\t * lend itself to easy editing.\n\t */\n\n\t/*\n\t * The dump format is as follows:\n\t *\tlen strlen(name) n_tl_data n_key_data e_length\n\t *\tname\n\t *\tattributes max_life max_renewable_life expiration\n\t *\tpw_expiration last_success last_failed fail_auth_count\n\t *\tn_tl_data*[type length <contents>]\n\t *\tn_key_data*[ver kvno ver*(type length <contents>)]\n\t *\t<e_data>\n\t * Fields which are not encapsulated by angle-brackets are to appear\n\t * verbatim.  A bracketed field's absence is indicated by a -1 in its\n\t * place\n\t */\n\n\t/*\n\t * Make sure that the tagged list is reasonably correct.\n\t */\n\tcounter = skip = 0;\n\tfor (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t     /*\n\t      * don't dump tl data types we know aren't understood by\n\t      * earlier revisions [krb5-admin/89]\n\t      */\n\t     switch (tlp->tl_data_type) {\n\t     case KRB5_TL_KADM_DATA:\n\t\t  if (kadm)\n\t\t      counter++;\n\t\t  else\n\t\t      skip++;\n\t\t  break;\n\t     default:\n\t\t  counter++;\n\t\t  break;\n\t     }\n\t}\n\t\n\tif (counter + skip == entry->n_tl_data) {\n\t    /* Pound out header */\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%s\\t\",\n\t\t    (int) entry->len,\n\t\t    strlen(name),\n\t\t    counter,\n\t\t    (int) entry->n_key_data,\n\t\t    (int) entry->e_length,\n\t\t    name);\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t    entry->attributes,\n\t\t    entry->max_life,\n\t\t    entry->max_renewable_life,\n\t\t    entry->expiration,\n\t\t    entry->pw_expiration,\n\t\t    entry->last_success,\n\t\t    entry->last_failed,\n\t\t    entry->fail_auth_count);\n\t    /* Pound out tagged data. */\n\t    for (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t\tif (tlp->tl_data_type == KRB5_TL_KADM_DATA && !kadm)\n\t\t     continue; /* see above, [krb5-admin/89] */\n\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) tlp->tl_data_type,\n\t\t\t(int) tlp->tl_data_length);\n\t\tif (tlp->tl_data_length)\n\t\t    for (i=0; i<tlp->tl_data_length; i++)\n\t\t\tfprintf(arg->ofile, \"%02x\", tlp->tl_data_contents[i]);\n\t\telse\n\t\t    fprintf(arg->ofile, \"%d\", -1);\n\t\tfprintf(arg->ofile, \"\\t\");\n\t    }\n\n\t    /* Pound out key data */\n\t    for (counter=0; counter<entry->n_key_data; counter++) {\n\t\tkdata = &entry->key_data[counter];\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) kdata->key_data_ver,\n\t\t\t(int) kdata->key_data_kvno);\n\t\tfor (i=0; i<kdata->key_data_ver; i++) {\n\t\t    fprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t    kdata->key_data_type[i],\n\t\t\t    kdata->key_data_length[i]);\n\t\t    if (kdata->key_data_length[i])\n\t\t\tfor (j=0; j<kdata->key_data_length[i]; j++)\n\t\t\t    fprintf(arg->ofile, \"%02x\",\n\t\t\t\t    kdata->key_data_contents[i][j]);\n\t\t    else\n\t\t\tfprintf(arg->ofile, \"%d\", -1);\n\t\t    fprintf(arg->ofile, \"\\t\");\n\t\t}\n\t    }\n\n\t    /* Pound out extra data */\n\t    if (entry->e_length)\n\t\tfor (i=0; i<entry->e_length; i++)\n\t\t    fprintf(arg->ofile, \"%02x\", entry->e_data[i]);\n\t    else\n\t\tfprintf(arg->ofile, \"%d\", -1);\n\n\t    /* Print trailer */\n\t    fprintf(arg->ofile, \";\\n\");\n\n\t    if (arg->verbose)\n\t\tfprintf(stderr, \"%s\\n\", name);\n\t}\n\telse {\n\t    fprintf(stderr, sdump_tl_inc_err,\n\t\t    arg->programname, name, counter+skip,\n\t\t    (int) entry->n_tl_data); \n\t    retval = EINVAL;\n\t}\n    }\n    krb5_xfree(name);\n    return(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"princ\\t\""
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_matches",
          "args": [
            "name",
            "arg"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "name_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "338-434",
          "snippet": "static int\nname_matches(name, arglist)\n    char\t\t*name;\n    struct dump_args\t*arglist;\n{\n#if\tHAVE_REGCOMP\n    regex_t\tmatch_exp;\n    regmatch_t\tmatch_match;\n    int\t\tmatch_error;\n    char\tmatch_errmsg[BUFSIZ];\n    size_t\terrmsg_size;\n#elif\tHAVE_REGEXP_H\n    char\tregexp_buffer[RE_BUF_SIZE];\n#elif\tHAVE_RE_COMP\n    extern char\t*re_comp();\n    char\t*re_result;\n#endif\t/* HAVE_RE_COMP */\n    int\t\ti, match;\n\n    /*\n     * Plow, brute force, through the list of names/regular expressions.\n     */\n    match = (arglist->nnames) ? 0 : 1;\n    for (i=0; i<arglist->nnames; i++) {\n#if\tHAVE_REGCOMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tmatch_error = regcomp(&match_exp, arglist->names[i], REG_EXTENDED);\n\tif (match_error) {\n\t    errmsg_size = regerror(match_error,\n\t\t\t\t   &match_exp,\n\t\t\t\t   match_errmsg,\n\t\t\t\t   sizeof(match_errmsg));\n\t    fprintf(stderr, regex_err, arglist->programname, match_errmsg);\n\t    break;\n\t}\n\t/*\n\t * See if we have a match.\n\t */\n\tmatch_error = regexec(&match_exp, name, 1, &match_match, 0);\n\tif (match_error) {\n\t    if (match_error != REG_NOMATCH) {\n\t\terrmsg_size = regerror(match_error,\n\t\t\t\t       &match_exp,\n\t\t\t\t       match_errmsg,\n\t\t\t\t       sizeof(match_errmsg));\n\t\tfprintf(stderr, regex_merr,\n\t\t\targlist->programname, match_errmsg);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    /*\n\t     * We have a match.  See if it matches the whole\n\t     * name.\n\t     */\n\t    if ((match_match.rm_so == 0) &&\n\t\t(match_match.rm_eo == strlen(name)))\n\t\tmatch = 1;\n\t}\n\tregfree(&match_exp);\n#elif\tHAVE_REGEXP_H\n\t/*\n\t * Compile the regular expression.\n\t */\n\tcompile(arglist->names[i],\n\t\tregexp_buffer, \n\t\t&regexp_buffer[RE_BUF_SIZE],\n\t\t'\\0');\n\tif (step(name, regexp_buffer)) {\n\t    if ((loc1 == name) &&\n\t\t(loc2 == &name[strlen(name)]))\n\t\tmatch = 1;\n\t}\n#elif\tHAVE_RE_COMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tif (re_result = re_comp(arglist->names[i])) {\n\t    fprintf(stderr, regex_err, arglist->programname, re_result);\n\t    break;\n\t}\n\tif (re_exec(name))\n\t    match = 1;\n#else\t/* HAVE_RE_COMP */\n\t/*\n\t * If no regular expression support, then just compare the strings.\n\t */\n\tif (!strcmp(arglist->names[i], name))\n\t    match = 1;\n#endif\t/* HAVE_REGCOMP */\n\tif (match)\n\t    break;\n    }\n    return(match);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define regex_merr\t\t\"%s: regular expression match error - %s\\n\"",
            "#define regex_err\t\t\"%s: regular expression error - %s\\n\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define regex_merr\t\t\"%s: regular expression match error - %s\\n\"\n#define regex_err\t\t\"%s: regular expression error - %s\\n\"\n\nstatic int\nname_matches(name, arglist)\n    char\t\t*name;\n    struct dump_args\t*arglist;\n{\n#if\tHAVE_REGCOMP\n    regex_t\tmatch_exp;\n    regmatch_t\tmatch_match;\n    int\t\tmatch_error;\n    char\tmatch_errmsg[BUFSIZ];\n    size_t\terrmsg_size;\n#elif\tHAVE_REGEXP_H\n    char\tregexp_buffer[RE_BUF_SIZE];\n#elif\tHAVE_RE_COMP\n    extern char\t*re_comp();\n    char\t*re_result;\n#endif\t/* HAVE_RE_COMP */\n    int\t\ti, match;\n\n    /*\n     * Plow, brute force, through the list of names/regular expressions.\n     */\n    match = (arglist->nnames) ? 0 : 1;\n    for (i=0; i<arglist->nnames; i++) {\n#if\tHAVE_REGCOMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tmatch_error = regcomp(&match_exp, arglist->names[i], REG_EXTENDED);\n\tif (match_error) {\n\t    errmsg_size = regerror(match_error,\n\t\t\t\t   &match_exp,\n\t\t\t\t   match_errmsg,\n\t\t\t\t   sizeof(match_errmsg));\n\t    fprintf(stderr, regex_err, arglist->programname, match_errmsg);\n\t    break;\n\t}\n\t/*\n\t * See if we have a match.\n\t */\n\tmatch_error = regexec(&match_exp, name, 1, &match_match, 0);\n\tif (match_error) {\n\t    if (match_error != REG_NOMATCH) {\n\t\terrmsg_size = regerror(match_error,\n\t\t\t\t       &match_exp,\n\t\t\t\t       match_errmsg,\n\t\t\t\t       sizeof(match_errmsg));\n\t\tfprintf(stderr, regex_merr,\n\t\t\targlist->programname, match_errmsg);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    /*\n\t     * We have a match.  See if it matches the whole\n\t     * name.\n\t     */\n\t    if ((match_match.rm_so == 0) &&\n\t\t(match_match.rm_eo == strlen(name)))\n\t\tmatch = 1;\n\t}\n\tregfree(&match_exp);\n#elif\tHAVE_REGEXP_H\n\t/*\n\t * Compile the regular expression.\n\t */\n\tcompile(arglist->names[i],\n\t\tregexp_buffer, \n\t\t&regexp_buffer[RE_BUF_SIZE],\n\t\t'\\0');\n\tif (step(name, regexp_buffer)) {\n\t    if ((loc1 == name) &&\n\t\t(loc2 == &name[strlen(name)]))\n\t\tmatch = 1;\n\t}\n#elif\tHAVE_RE_COMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tif (re_result = re_comp(arglist->names[i])) {\n\t    fprintf(stderr, regex_err, arglist->programname, re_result);\n\t    break;\n\t}\n\tif (re_exec(name))\n\t    match = 1;\n#else\t/* HAVE_RE_COMP */\n\t/*\n\t * If no regular expression support, then just compare the strings.\n\t */\n\tif (!strcmp(arglist->names[i], name))\n\t    match = 1;\n#endif\t/* HAVE_REGCOMP */\n\tif (match)\n\t    break;\n    }\n    return(match);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "pname_unp_err",
            "arg->programname",
            "error_message(retval)"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "retval"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "arg->kcontext",
            "entry->princ",
            "&name"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\"\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\ndump_k5beta7_princ_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n     krb5_error_code retval;\n     struct dump_args *arg;\n     char *name;\n     int tmp_nnames;\n\n     /* Initialize */\n     arg = (struct dump_args *) ptr;\n     name = (char *) NULL;\n\n     /*\n      * Flatten the principal name.\n      */\n     if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t     entry->princ,\n\t\t\t\t     &name))) {\n\t  fprintf(stderr, pname_unp_err, \n\t\t  arg->programname, error_message(retval));\n\t  return(retval);\n     }\n     /*\n      * If we don't have any match strings, or if our name matches, then\n      * proceed with the dump, otherwise, just forget about it.\n      */\n     if (!arg->nnames || name_matches(name, arg)) {\n\t  fprintf(arg->ofile, \"princ\\t\");\n\t  \n\t  /* save the callee from matching the name again */\n\t  tmp_nnames = arg->nnames;\n\t  arg->nnames = 0;\n\t  retval = dump_k5beta6_iterator_ext(ptr, entry, kadm);\n\t  arg->nnames = tmp_nnames;\n     }\n\n     free(name);\n     return retval;\n}"
  },
  {
    "function_name": "dump_k5beta7_princ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "829-835",
    "snippet": "static krb5_error_code\ndump_k5beta7_princ(ptr, entry)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n{\n    return dump_k5beta7_princ_ext(ptr, entry, 0);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_k5beta7_princ_ext",
          "args": [
            "ptr",
            "entry",
            "0"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "dump_k5beta7_princ_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "837-878",
          "snippet": "static krb5_error_code\ndump_k5beta7_princ_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n     krb5_error_code retval;\n     struct dump_args *arg;\n     char *name;\n     int tmp_nnames;\n\n     /* Initialize */\n     arg = (struct dump_args *) ptr;\n     name = (char *) NULL;\n\n     /*\n      * Flatten the principal name.\n      */\n     if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t     entry->princ,\n\t\t\t\t     &name))) {\n\t  fprintf(stderr, pname_unp_err, \n\t\t  arg->programname, error_message(retval));\n\t  return(retval);\n     }\n     /*\n      * If we don't have any match strings, or if our name matches, then\n      * proceed with the dump, otherwise, just forget about it.\n      */\n     if (!arg->nnames || name_matches(name, arg)) {\n\t  fprintf(arg->ofile, \"princ\\t\");\n\t  \n\t  /* save the callee from matching the name again */\n\t  tmp_nnames = arg->nnames;\n\t  arg->nnames = 0;\n\t  retval = dump_k5beta6_iterator_ext(ptr, entry, kadm);\n\t  arg->nnames = tmp_nnames;\n     }\n\n     free(name);\n     return retval;\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\""
          ],
          "globals_used": [
            "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
            "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
            "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
            "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
            "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\"\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\ndump_k5beta7_princ_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n     krb5_error_code retval;\n     struct dump_args *arg;\n     char *name;\n     int tmp_nnames;\n\n     /* Initialize */\n     arg = (struct dump_args *) ptr;\n     name = (char *) NULL;\n\n     /*\n      * Flatten the principal name.\n      */\n     if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t     entry->princ,\n\t\t\t\t     &name))) {\n\t  fprintf(stderr, pname_unp_err, \n\t\t  arg->programname, error_message(retval));\n\t  return(retval);\n     }\n     /*\n      * If we don't have any match strings, or if our name matches, then\n      * proceed with the dump, otherwise, just forget about it.\n      */\n     if (!arg->nnames || name_matches(name, arg)) {\n\t  fprintf(arg->ofile, \"princ\\t\");\n\t  \n\t  /* save the callee from matching the name again */\n\t  tmp_nnames = arg->nnames;\n\t  arg->nnames = 0;\n\t  retval = dump_k5beta6_iterator_ext(ptr, entry, kadm);\n\t  arg->nnames = tmp_nnames;\n     }\n\n     free(name);\n     return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\ndump_k5beta7_princ(ptr, entry)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n{\n    return dump_k5beta7_princ_ext(ptr, entry, 0);\n}"
  },
  {
    "function_name": "dump_k5beta6_iterator_ext",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "662-824",
    "snippet": "static krb5_error_code\ndump_k5beta6_iterator_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n    krb5_error_code\tretval;\n    struct dump_args\t*arg;\n    char\t\t*name;\n    krb5_tl_data\t*tlp;\n    krb5_key_data\t*kdata;\n    int\t\t\tcounter, skip, i, j;\n\n    /* Initialize */\n    arg = (struct dump_args *) ptr;\n    name = (char *) NULL;\n\n    /*\n     * Flatten the principal name.\n     */\n    if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t    entry->princ,\n\t\t\t\t    &name))) {\n\tfprintf(stderr, pname_unp_err, \n\t\targ->programname, error_message(retval));\n\treturn(retval);\n    }\n\n    /*\n     * Re-encode the keys in the new master key, if necessary.\n     */\n    if (mkey_convert) {\n\tretval = master_key_convert(arg->kcontext, entry);\n\tif (retval) {\n\t    com_err(arg->programname, retval, remaster_err_fmt, name);\n\t    return retval;\n\t}\n    }\n    \n    /*\n     * If we don't have any match strings, or if our name matches, then\n     * proceed with the dump, otherwise, just forget about it.\n     */\n    if (!arg->nnames || name_matches(name, arg)) {\n\t/*\n\t * We'd like to just blast out the contents as they would appear in\n\t * the database so that we can just suck it back in, but it doesn't\n\t * lend itself to easy editing.\n\t */\n\n\t/*\n\t * The dump format is as follows:\n\t *\tlen strlen(name) n_tl_data n_key_data e_length\n\t *\tname\n\t *\tattributes max_life max_renewable_life expiration\n\t *\tpw_expiration last_success last_failed fail_auth_count\n\t *\tn_tl_data*[type length <contents>]\n\t *\tn_key_data*[ver kvno ver*(type length <contents>)]\n\t *\t<e_data>\n\t * Fields which are not encapsulated by angle-brackets are to appear\n\t * verbatim.  A bracketed field's absence is indicated by a -1 in its\n\t * place\n\t */\n\n\t/*\n\t * Make sure that the tagged list is reasonably correct.\n\t */\n\tcounter = skip = 0;\n\tfor (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t     /*\n\t      * don't dump tl data types we know aren't understood by\n\t      * earlier revisions [krb5-admin/89]\n\t      */\n\t     switch (tlp->tl_data_type) {\n\t     case KRB5_TL_KADM_DATA:\n\t\t  if (kadm)\n\t\t      counter++;\n\t\t  else\n\t\t      skip++;\n\t\t  break;\n\t     default:\n\t\t  counter++;\n\t\t  break;\n\t     }\n\t}\n\t\n\tif (counter + skip == entry->n_tl_data) {\n\t    /* Pound out header */\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%s\\t\",\n\t\t    (int) entry->len,\n\t\t    strlen(name),\n\t\t    counter,\n\t\t    (int) entry->n_key_data,\n\t\t    (int) entry->e_length,\n\t\t    name);\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t    entry->attributes,\n\t\t    entry->max_life,\n\t\t    entry->max_renewable_life,\n\t\t    entry->expiration,\n\t\t    entry->pw_expiration,\n\t\t    entry->last_success,\n\t\t    entry->last_failed,\n\t\t    entry->fail_auth_count);\n\t    /* Pound out tagged data. */\n\t    for (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t\tif (tlp->tl_data_type == KRB5_TL_KADM_DATA && !kadm)\n\t\t     continue; /* see above, [krb5-admin/89] */\n\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) tlp->tl_data_type,\n\t\t\t(int) tlp->tl_data_length);\n\t\tif (tlp->tl_data_length)\n\t\t    for (i=0; i<tlp->tl_data_length; i++)\n\t\t\tfprintf(arg->ofile, \"%02x\", tlp->tl_data_contents[i]);\n\t\telse\n\t\t    fprintf(arg->ofile, \"%d\", -1);\n\t\tfprintf(arg->ofile, \"\\t\");\n\t    }\n\n\t    /* Pound out key data */\n\t    for (counter=0; counter<entry->n_key_data; counter++) {\n\t\tkdata = &entry->key_data[counter];\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) kdata->key_data_ver,\n\t\t\t(int) kdata->key_data_kvno);\n\t\tfor (i=0; i<kdata->key_data_ver; i++) {\n\t\t    fprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t    kdata->key_data_type[i],\n\t\t\t    kdata->key_data_length[i]);\n\t\t    if (kdata->key_data_length[i])\n\t\t\tfor (j=0; j<kdata->key_data_length[i]; j++)\n\t\t\t    fprintf(arg->ofile, \"%02x\",\n\t\t\t\t    kdata->key_data_contents[i][j]);\n\t\t    else\n\t\t\tfprintf(arg->ofile, \"%d\", -1);\n\t\t    fprintf(arg->ofile, \"\\t\");\n\t\t}\n\t    }\n\n\t    /* Pound out extra data */\n\t    if (entry->e_length)\n\t\tfor (i=0; i<entry->e_length; i++)\n\t\t    fprintf(arg->ofile, \"%02x\", entry->e_data[i]);\n\t    else\n\t\tfprintf(arg->ofile, \"%d\", -1);\n\n\t    /* Print trailer */\n\t    fprintf(arg->ofile, \";\\n\");\n\n\t    if (arg->verbose)\n\t\tfprintf(stderr, \"%s\\n\", name);\n\t}\n\telse {\n\t    fprintf(stderr, sdump_tl_inc_err,\n\t\t    arg->programname, name, counter+skip,\n\t\t    (int) entry->n_tl_data); \n\t    retval = EINVAL;\n\t}\n    }\n    krb5_xfree(name);\n    return(retval);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define remaster_err_fmt\t\"while re-encoding keys for principal %s with new master key\"",
      "#define sdump_tl_inc_err\t\"%s: tagged data list inconsistency for %s (counted %d, stored %d)\\n\"",
      "#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\""
    ],
    "globals_used": [
      "static int\t\t\tmkey_convert;",
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "name"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "sdump_tl_inc_err",
            "arg->programname",
            "name",
            "counter+skip",
            "(int) entry->n_tl_data"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "name"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\";\\n\""
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%d\"",
            "-1"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%02x\"",
            "entry->e_data[i]"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"\\t\""
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%d\"",
            "-1"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%02x\"",
            "kdata->key_data_contents[i][j]"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%d\\t%d\\t\"",
            "kdata->key_data_type[i]",
            "kdata->key_data_length[i]"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%d\\t%d\\t\"",
            "(int) kdata->key_data_ver",
            "(int) kdata->key_data_kvno"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"\\t\""
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%d\"",
            "-1"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%02x\"",
            "tlp->tl_data_contents[i]"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%d\\t%d\\t\"",
            "(int) tlp->tl_data_type",
            "(int) tlp->tl_data_length"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\"",
            "entry->attributes",
            "entry->max_life",
            "entry->max_renewable_life",
            "entry->expiration",
            "entry->pw_expiration",
            "entry->last_success",
            "entry->last_failed",
            "entry->fail_auth_count"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%d\\t%d\\t%d\\t%d\\t%d\\t%s\\t\"",
            "(int) entry->len",
            "strlen(name)",
            "counter",
            "(int) entry->n_key_data",
            "(int) entry->e_length",
            "name"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_matches",
          "args": [
            "name",
            "arg"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "name_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "338-434",
          "snippet": "static int\nname_matches(name, arglist)\n    char\t\t*name;\n    struct dump_args\t*arglist;\n{\n#if\tHAVE_REGCOMP\n    regex_t\tmatch_exp;\n    regmatch_t\tmatch_match;\n    int\t\tmatch_error;\n    char\tmatch_errmsg[BUFSIZ];\n    size_t\terrmsg_size;\n#elif\tHAVE_REGEXP_H\n    char\tregexp_buffer[RE_BUF_SIZE];\n#elif\tHAVE_RE_COMP\n    extern char\t*re_comp();\n    char\t*re_result;\n#endif\t/* HAVE_RE_COMP */\n    int\t\ti, match;\n\n    /*\n     * Plow, brute force, through the list of names/regular expressions.\n     */\n    match = (arglist->nnames) ? 0 : 1;\n    for (i=0; i<arglist->nnames; i++) {\n#if\tHAVE_REGCOMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tmatch_error = regcomp(&match_exp, arglist->names[i], REG_EXTENDED);\n\tif (match_error) {\n\t    errmsg_size = regerror(match_error,\n\t\t\t\t   &match_exp,\n\t\t\t\t   match_errmsg,\n\t\t\t\t   sizeof(match_errmsg));\n\t    fprintf(stderr, regex_err, arglist->programname, match_errmsg);\n\t    break;\n\t}\n\t/*\n\t * See if we have a match.\n\t */\n\tmatch_error = regexec(&match_exp, name, 1, &match_match, 0);\n\tif (match_error) {\n\t    if (match_error != REG_NOMATCH) {\n\t\terrmsg_size = regerror(match_error,\n\t\t\t\t       &match_exp,\n\t\t\t\t       match_errmsg,\n\t\t\t\t       sizeof(match_errmsg));\n\t\tfprintf(stderr, regex_merr,\n\t\t\targlist->programname, match_errmsg);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    /*\n\t     * We have a match.  See if it matches the whole\n\t     * name.\n\t     */\n\t    if ((match_match.rm_so == 0) &&\n\t\t(match_match.rm_eo == strlen(name)))\n\t\tmatch = 1;\n\t}\n\tregfree(&match_exp);\n#elif\tHAVE_REGEXP_H\n\t/*\n\t * Compile the regular expression.\n\t */\n\tcompile(arglist->names[i],\n\t\tregexp_buffer, \n\t\t&regexp_buffer[RE_BUF_SIZE],\n\t\t'\\0');\n\tif (step(name, regexp_buffer)) {\n\t    if ((loc1 == name) &&\n\t\t(loc2 == &name[strlen(name)]))\n\t\tmatch = 1;\n\t}\n#elif\tHAVE_RE_COMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tif (re_result = re_comp(arglist->names[i])) {\n\t    fprintf(stderr, regex_err, arglist->programname, re_result);\n\t    break;\n\t}\n\tif (re_exec(name))\n\t    match = 1;\n#else\t/* HAVE_RE_COMP */\n\t/*\n\t * If no regular expression support, then just compare the strings.\n\t */\n\tif (!strcmp(arglist->names[i], name))\n\t    match = 1;\n#endif\t/* HAVE_REGCOMP */\n\tif (match)\n\t    break;\n    }\n    return(match);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define regex_merr\t\t\"%s: regular expression match error - %s\\n\"",
            "#define regex_err\t\t\"%s: regular expression error - %s\\n\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define regex_merr\t\t\"%s: regular expression match error - %s\\n\"\n#define regex_err\t\t\"%s: regular expression error - %s\\n\"\n\nstatic int\nname_matches(name, arglist)\n    char\t\t*name;\n    struct dump_args\t*arglist;\n{\n#if\tHAVE_REGCOMP\n    regex_t\tmatch_exp;\n    regmatch_t\tmatch_match;\n    int\t\tmatch_error;\n    char\tmatch_errmsg[BUFSIZ];\n    size_t\terrmsg_size;\n#elif\tHAVE_REGEXP_H\n    char\tregexp_buffer[RE_BUF_SIZE];\n#elif\tHAVE_RE_COMP\n    extern char\t*re_comp();\n    char\t*re_result;\n#endif\t/* HAVE_RE_COMP */\n    int\t\ti, match;\n\n    /*\n     * Plow, brute force, through the list of names/regular expressions.\n     */\n    match = (arglist->nnames) ? 0 : 1;\n    for (i=0; i<arglist->nnames; i++) {\n#if\tHAVE_REGCOMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tmatch_error = regcomp(&match_exp, arglist->names[i], REG_EXTENDED);\n\tif (match_error) {\n\t    errmsg_size = regerror(match_error,\n\t\t\t\t   &match_exp,\n\t\t\t\t   match_errmsg,\n\t\t\t\t   sizeof(match_errmsg));\n\t    fprintf(stderr, regex_err, arglist->programname, match_errmsg);\n\t    break;\n\t}\n\t/*\n\t * See if we have a match.\n\t */\n\tmatch_error = regexec(&match_exp, name, 1, &match_match, 0);\n\tif (match_error) {\n\t    if (match_error != REG_NOMATCH) {\n\t\terrmsg_size = regerror(match_error,\n\t\t\t\t       &match_exp,\n\t\t\t\t       match_errmsg,\n\t\t\t\t       sizeof(match_errmsg));\n\t\tfprintf(stderr, regex_merr,\n\t\t\targlist->programname, match_errmsg);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    /*\n\t     * We have a match.  See if it matches the whole\n\t     * name.\n\t     */\n\t    if ((match_match.rm_so == 0) &&\n\t\t(match_match.rm_eo == strlen(name)))\n\t\tmatch = 1;\n\t}\n\tregfree(&match_exp);\n#elif\tHAVE_REGEXP_H\n\t/*\n\t * Compile the regular expression.\n\t */\n\tcompile(arglist->names[i],\n\t\tregexp_buffer, \n\t\t&regexp_buffer[RE_BUF_SIZE],\n\t\t'\\0');\n\tif (step(name, regexp_buffer)) {\n\t    if ((loc1 == name) &&\n\t\t(loc2 == &name[strlen(name)]))\n\t\tmatch = 1;\n\t}\n#elif\tHAVE_RE_COMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tif (re_result = re_comp(arglist->names[i])) {\n\t    fprintf(stderr, regex_err, arglist->programname, re_result);\n\t    break;\n\t}\n\tif (re_exec(name))\n\t    match = 1;\n#else\t/* HAVE_RE_COMP */\n\t/*\n\t * If no regular expression support, then just compare the strings.\n\t */\n\tif (!strcmp(arglist->names[i], name))\n\t    match = 1;\n#endif\t/* HAVE_REGCOMP */\n\tif (match)\n\t    break;\n    }\n    return(match);\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "arg->programname",
            "retval",
            "remaster_err_fmt",
            "name"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "master_key_convert",
          "args": [
            "arg->kcontext",
            "entry"
          ],
          "line": 694
        },
        "resolved": true,
        "details": {
          "function_name": "master_key_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "248-292",
          "snippet": "static krb5_error_code master_key_convert(context, db_entry)\n    krb5_context\t  context;\n    krb5_db_entry\t* db_entry;\n{\n    krb5_error_code\tretval;\n    krb5_keyblock \tv5plainkey, *key_ptr;\n    krb5_keysalt \tkeysalt;\n    int\t      i, j;\n    krb5_key_data\tnew_key_data, *key_data;\n    krb5_boolean\tis_mkey;\n\n    is_mkey = krb5_principal_compare(context, master_princ, db_entry->princ);\n\n    if (is_mkey && db_entry->n_key_data != 1)\n\t    fprintf(stderr,\n\t\t    \"Master key db entry has %d keys, expecting only 1!\\n\",\n\t\t    db_entry->n_key_data);\n    for (i=0; i < db_entry->n_key_data; i++) {\n\tkey_data = &db_entry->key_data[i];\n\tif (key_data->key_data_length == 0)\n\t    continue;\n\tretval = krb5_dbekd_decrypt_key_data(context, &master_keyblock,\n\t\t\t\t\t     key_data, &v5plainkey,\n\t\t\t\t\t     &keysalt);\n\tif (retval)\n\t\treturn retval;\n\n\tmemset(&new_key_data, 0, sizeof(new_key_data));\n\tkey_ptr = is_mkey ? &new_master_keyblock : &v5plainkey;\n\tretval = krb5_dbekd_encrypt_key_data(context, &new_master_keyblock,\n\t\t\t\t\t     key_ptr, &keysalt,\n\t\t\t\t\t     key_data->key_data_kvno,\n\t\t\t\t\t     &new_key_data);\n\tif (retval)\n\t\treturn retval;\n\tkrb5_free_keyblock_contents(context, &v5plainkey);\n\tfor (j = 0; j < key_data->key_data_ver; j++) {\n\t    if (key_data->key_data_length[j]) {\n\t\tfree(key_data->key_data_contents[j]);\n\t    }\n\t}\n\t*key_data = new_key_data;\n    }\n    return 0;\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_keyblock\t\tnew_master_keyblock;",
            "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
            "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
            "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
            "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
            "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic krb5_keyblock\t\tnew_master_keyblock;\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code master_key_convert(context, db_entry)\n    krb5_context\t  context;\n    krb5_db_entry\t* db_entry;\n{\n    krb5_error_code\tretval;\n    krb5_keyblock \tv5plainkey, *key_ptr;\n    krb5_keysalt \tkeysalt;\n    int\t      i, j;\n    krb5_key_data\tnew_key_data, *key_data;\n    krb5_boolean\tis_mkey;\n\n    is_mkey = krb5_principal_compare(context, master_princ, db_entry->princ);\n\n    if (is_mkey && db_entry->n_key_data != 1)\n\t    fprintf(stderr,\n\t\t    \"Master key db entry has %d keys, expecting only 1!\\n\",\n\t\t    db_entry->n_key_data);\n    for (i=0; i < db_entry->n_key_data; i++) {\n\tkey_data = &db_entry->key_data[i];\n\tif (key_data->key_data_length == 0)\n\t    continue;\n\tretval = krb5_dbekd_decrypt_key_data(context, &master_keyblock,\n\t\t\t\t\t     key_data, &v5plainkey,\n\t\t\t\t\t     &keysalt);\n\tif (retval)\n\t\treturn retval;\n\n\tmemset(&new_key_data, 0, sizeof(new_key_data));\n\tkey_ptr = is_mkey ? &new_master_keyblock : &v5plainkey;\n\tretval = krb5_dbekd_encrypt_key_data(context, &new_master_keyblock,\n\t\t\t\t\t     key_ptr, &keysalt,\n\t\t\t\t\t     key_data->key_data_kvno,\n\t\t\t\t\t     &new_key_data);\n\tif (retval)\n\t\treturn retval;\n\tkrb5_free_keyblock_contents(context, &v5plainkey);\n\tfor (j = 0; j < key_data->key_data_ver; j++) {\n\t    if (key_data->key_data_length[j]) {\n\t\tfree(key_data->key_data_contents[j]);\n\t    }\n\t}\n\t*key_data = new_key_data;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "pname_unp_err",
            "arg->programname",
            "error_message(retval)"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "retval"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "arg->kcontext",
            "entry->princ",
            "&name"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define remaster_err_fmt\t\"while re-encoding keys for principal %s with new master key\"\n#define sdump_tl_inc_err\t\"%s: tagged data list inconsistency for %s (counted %d, stored %d)\\n\"\n#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\"\n\nstatic int\t\t\tmkey_convert;\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\ndump_k5beta6_iterator_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n    krb5_error_code\tretval;\n    struct dump_args\t*arg;\n    char\t\t*name;\n    krb5_tl_data\t*tlp;\n    krb5_key_data\t*kdata;\n    int\t\t\tcounter, skip, i, j;\n\n    /* Initialize */\n    arg = (struct dump_args *) ptr;\n    name = (char *) NULL;\n\n    /*\n     * Flatten the principal name.\n     */\n    if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t    entry->princ,\n\t\t\t\t    &name))) {\n\tfprintf(stderr, pname_unp_err, \n\t\targ->programname, error_message(retval));\n\treturn(retval);\n    }\n\n    /*\n     * Re-encode the keys in the new master key, if necessary.\n     */\n    if (mkey_convert) {\n\tretval = master_key_convert(arg->kcontext, entry);\n\tif (retval) {\n\t    com_err(arg->programname, retval, remaster_err_fmt, name);\n\t    return retval;\n\t}\n    }\n    \n    /*\n     * If we don't have any match strings, or if our name matches, then\n     * proceed with the dump, otherwise, just forget about it.\n     */\n    if (!arg->nnames || name_matches(name, arg)) {\n\t/*\n\t * We'd like to just blast out the contents as they would appear in\n\t * the database so that we can just suck it back in, but it doesn't\n\t * lend itself to easy editing.\n\t */\n\n\t/*\n\t * The dump format is as follows:\n\t *\tlen strlen(name) n_tl_data n_key_data e_length\n\t *\tname\n\t *\tattributes max_life max_renewable_life expiration\n\t *\tpw_expiration last_success last_failed fail_auth_count\n\t *\tn_tl_data*[type length <contents>]\n\t *\tn_key_data*[ver kvno ver*(type length <contents>)]\n\t *\t<e_data>\n\t * Fields which are not encapsulated by angle-brackets are to appear\n\t * verbatim.  A bracketed field's absence is indicated by a -1 in its\n\t * place\n\t */\n\n\t/*\n\t * Make sure that the tagged list is reasonably correct.\n\t */\n\tcounter = skip = 0;\n\tfor (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t     /*\n\t      * don't dump tl data types we know aren't understood by\n\t      * earlier revisions [krb5-admin/89]\n\t      */\n\t     switch (tlp->tl_data_type) {\n\t     case KRB5_TL_KADM_DATA:\n\t\t  if (kadm)\n\t\t      counter++;\n\t\t  else\n\t\t      skip++;\n\t\t  break;\n\t     default:\n\t\t  counter++;\n\t\t  break;\n\t     }\n\t}\n\t\n\tif (counter + skip == entry->n_tl_data) {\n\t    /* Pound out header */\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%s\\t\",\n\t\t    (int) entry->len,\n\t\t    strlen(name),\n\t\t    counter,\n\t\t    (int) entry->n_key_data,\n\t\t    (int) entry->e_length,\n\t\t    name);\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t    entry->attributes,\n\t\t    entry->max_life,\n\t\t    entry->max_renewable_life,\n\t\t    entry->expiration,\n\t\t    entry->pw_expiration,\n\t\t    entry->last_success,\n\t\t    entry->last_failed,\n\t\t    entry->fail_auth_count);\n\t    /* Pound out tagged data. */\n\t    for (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t\tif (tlp->tl_data_type == KRB5_TL_KADM_DATA && !kadm)\n\t\t     continue; /* see above, [krb5-admin/89] */\n\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) tlp->tl_data_type,\n\t\t\t(int) tlp->tl_data_length);\n\t\tif (tlp->tl_data_length)\n\t\t    for (i=0; i<tlp->tl_data_length; i++)\n\t\t\tfprintf(arg->ofile, \"%02x\", tlp->tl_data_contents[i]);\n\t\telse\n\t\t    fprintf(arg->ofile, \"%d\", -1);\n\t\tfprintf(arg->ofile, \"\\t\");\n\t    }\n\n\t    /* Pound out key data */\n\t    for (counter=0; counter<entry->n_key_data; counter++) {\n\t\tkdata = &entry->key_data[counter];\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) kdata->key_data_ver,\n\t\t\t(int) kdata->key_data_kvno);\n\t\tfor (i=0; i<kdata->key_data_ver; i++) {\n\t\t    fprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t    kdata->key_data_type[i],\n\t\t\t    kdata->key_data_length[i]);\n\t\t    if (kdata->key_data_length[i])\n\t\t\tfor (j=0; j<kdata->key_data_length[i]; j++)\n\t\t\t    fprintf(arg->ofile, \"%02x\",\n\t\t\t\t    kdata->key_data_contents[i][j]);\n\t\t    else\n\t\t\tfprintf(arg->ofile, \"%d\", -1);\n\t\t    fprintf(arg->ofile, \"\\t\");\n\t\t}\n\t    }\n\n\t    /* Pound out extra data */\n\t    if (entry->e_length)\n\t\tfor (i=0; i<entry->e_length; i++)\n\t\t    fprintf(arg->ofile, \"%02x\", entry->e_data[i]);\n\t    else\n\t\tfprintf(arg->ofile, \"%d\", -1);\n\n\t    /* Print trailer */\n\t    fprintf(arg->ofile, \";\\n\");\n\n\t    if (arg->verbose)\n\t\tfprintf(stderr, \"%s\\n\", name);\n\t}\n\telse {\n\t    fprintf(stderr, sdump_tl_inc_err,\n\t\t    arg->programname, name, counter+skip,\n\t\t    (int) entry->n_tl_data); \n\t    retval = EINVAL;\n\t}\n    }\n    krb5_xfree(name);\n    return(retval);\n}"
  },
  {
    "function_name": "dump_k5beta6_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "654-660",
    "snippet": "static krb5_error_code\ndump_k5beta6_iterator(ptr, entry)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n{\n    return dump_k5beta6_iterator_ext(ptr, entry, 0);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_k5beta6_iterator_ext",
          "args": [
            "ptr",
            "entry",
            "0"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "dump_k5beta6_iterator_ext",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "662-824",
          "snippet": "static krb5_error_code\ndump_k5beta6_iterator_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n    krb5_error_code\tretval;\n    struct dump_args\t*arg;\n    char\t\t*name;\n    krb5_tl_data\t*tlp;\n    krb5_key_data\t*kdata;\n    int\t\t\tcounter, skip, i, j;\n\n    /* Initialize */\n    arg = (struct dump_args *) ptr;\n    name = (char *) NULL;\n\n    /*\n     * Flatten the principal name.\n     */\n    if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t    entry->princ,\n\t\t\t\t    &name))) {\n\tfprintf(stderr, pname_unp_err, \n\t\targ->programname, error_message(retval));\n\treturn(retval);\n    }\n\n    /*\n     * Re-encode the keys in the new master key, if necessary.\n     */\n    if (mkey_convert) {\n\tretval = master_key_convert(arg->kcontext, entry);\n\tif (retval) {\n\t    com_err(arg->programname, retval, remaster_err_fmt, name);\n\t    return retval;\n\t}\n    }\n    \n    /*\n     * If we don't have any match strings, or if our name matches, then\n     * proceed with the dump, otherwise, just forget about it.\n     */\n    if (!arg->nnames || name_matches(name, arg)) {\n\t/*\n\t * We'd like to just blast out the contents as they would appear in\n\t * the database so that we can just suck it back in, but it doesn't\n\t * lend itself to easy editing.\n\t */\n\n\t/*\n\t * The dump format is as follows:\n\t *\tlen strlen(name) n_tl_data n_key_data e_length\n\t *\tname\n\t *\tattributes max_life max_renewable_life expiration\n\t *\tpw_expiration last_success last_failed fail_auth_count\n\t *\tn_tl_data*[type length <contents>]\n\t *\tn_key_data*[ver kvno ver*(type length <contents>)]\n\t *\t<e_data>\n\t * Fields which are not encapsulated by angle-brackets are to appear\n\t * verbatim.  A bracketed field's absence is indicated by a -1 in its\n\t * place\n\t */\n\n\t/*\n\t * Make sure that the tagged list is reasonably correct.\n\t */\n\tcounter = skip = 0;\n\tfor (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t     /*\n\t      * don't dump tl data types we know aren't understood by\n\t      * earlier revisions [krb5-admin/89]\n\t      */\n\t     switch (tlp->tl_data_type) {\n\t     case KRB5_TL_KADM_DATA:\n\t\t  if (kadm)\n\t\t      counter++;\n\t\t  else\n\t\t      skip++;\n\t\t  break;\n\t     default:\n\t\t  counter++;\n\t\t  break;\n\t     }\n\t}\n\t\n\tif (counter + skip == entry->n_tl_data) {\n\t    /* Pound out header */\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%s\\t\",\n\t\t    (int) entry->len,\n\t\t    strlen(name),\n\t\t    counter,\n\t\t    (int) entry->n_key_data,\n\t\t    (int) entry->e_length,\n\t\t    name);\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t    entry->attributes,\n\t\t    entry->max_life,\n\t\t    entry->max_renewable_life,\n\t\t    entry->expiration,\n\t\t    entry->pw_expiration,\n\t\t    entry->last_success,\n\t\t    entry->last_failed,\n\t\t    entry->fail_auth_count);\n\t    /* Pound out tagged data. */\n\t    for (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t\tif (tlp->tl_data_type == KRB5_TL_KADM_DATA && !kadm)\n\t\t     continue; /* see above, [krb5-admin/89] */\n\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) tlp->tl_data_type,\n\t\t\t(int) tlp->tl_data_length);\n\t\tif (tlp->tl_data_length)\n\t\t    for (i=0; i<tlp->tl_data_length; i++)\n\t\t\tfprintf(arg->ofile, \"%02x\", tlp->tl_data_contents[i]);\n\t\telse\n\t\t    fprintf(arg->ofile, \"%d\", -1);\n\t\tfprintf(arg->ofile, \"\\t\");\n\t    }\n\n\t    /* Pound out key data */\n\t    for (counter=0; counter<entry->n_key_data; counter++) {\n\t\tkdata = &entry->key_data[counter];\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) kdata->key_data_ver,\n\t\t\t(int) kdata->key_data_kvno);\n\t\tfor (i=0; i<kdata->key_data_ver; i++) {\n\t\t    fprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t    kdata->key_data_type[i],\n\t\t\t    kdata->key_data_length[i]);\n\t\t    if (kdata->key_data_length[i])\n\t\t\tfor (j=0; j<kdata->key_data_length[i]; j++)\n\t\t\t    fprintf(arg->ofile, \"%02x\",\n\t\t\t\t    kdata->key_data_contents[i][j]);\n\t\t    else\n\t\t\tfprintf(arg->ofile, \"%d\", -1);\n\t\t    fprintf(arg->ofile, \"\\t\");\n\t\t}\n\t    }\n\n\t    /* Pound out extra data */\n\t    if (entry->e_length)\n\t\tfor (i=0; i<entry->e_length; i++)\n\t\t    fprintf(arg->ofile, \"%02x\", entry->e_data[i]);\n\t    else\n\t\tfprintf(arg->ofile, \"%d\", -1);\n\n\t    /* Print trailer */\n\t    fprintf(arg->ofile, \";\\n\");\n\n\t    if (arg->verbose)\n\t\tfprintf(stderr, \"%s\\n\", name);\n\t}\n\telse {\n\t    fprintf(stderr, sdump_tl_inc_err,\n\t\t    arg->programname, name, counter+skip,\n\t\t    (int) entry->n_tl_data); \n\t    retval = EINVAL;\n\t}\n    }\n    krb5_xfree(name);\n    return(retval);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define remaster_err_fmt\t\"while re-encoding keys for principal %s with new master key\"",
            "#define sdump_tl_inc_err\t\"%s: tagged data list inconsistency for %s (counted %d, stored %d)\\n\"",
            "#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\""
          ],
          "globals_used": [
            "static int\t\t\tmkey_convert;",
            "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
            "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
            "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
            "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
            "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define remaster_err_fmt\t\"while re-encoding keys for principal %s with new master key\"\n#define sdump_tl_inc_err\t\"%s: tagged data list inconsistency for %s (counted %d, stored %d)\\n\"\n#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\"\n\nstatic int\t\t\tmkey_convert;\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\ndump_k5beta6_iterator_ext(ptr, entry, kadm)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n    int\t\t\tkadm;\n{\n    krb5_error_code\tretval;\n    struct dump_args\t*arg;\n    char\t\t*name;\n    krb5_tl_data\t*tlp;\n    krb5_key_data\t*kdata;\n    int\t\t\tcounter, skip, i, j;\n\n    /* Initialize */\n    arg = (struct dump_args *) ptr;\n    name = (char *) NULL;\n\n    /*\n     * Flatten the principal name.\n     */\n    if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t    entry->princ,\n\t\t\t\t    &name))) {\n\tfprintf(stderr, pname_unp_err, \n\t\targ->programname, error_message(retval));\n\treturn(retval);\n    }\n\n    /*\n     * Re-encode the keys in the new master key, if necessary.\n     */\n    if (mkey_convert) {\n\tretval = master_key_convert(arg->kcontext, entry);\n\tif (retval) {\n\t    com_err(arg->programname, retval, remaster_err_fmt, name);\n\t    return retval;\n\t}\n    }\n    \n    /*\n     * If we don't have any match strings, or if our name matches, then\n     * proceed with the dump, otherwise, just forget about it.\n     */\n    if (!arg->nnames || name_matches(name, arg)) {\n\t/*\n\t * We'd like to just blast out the contents as they would appear in\n\t * the database so that we can just suck it back in, but it doesn't\n\t * lend itself to easy editing.\n\t */\n\n\t/*\n\t * The dump format is as follows:\n\t *\tlen strlen(name) n_tl_data n_key_data e_length\n\t *\tname\n\t *\tattributes max_life max_renewable_life expiration\n\t *\tpw_expiration last_success last_failed fail_auth_count\n\t *\tn_tl_data*[type length <contents>]\n\t *\tn_key_data*[ver kvno ver*(type length <contents>)]\n\t *\t<e_data>\n\t * Fields which are not encapsulated by angle-brackets are to appear\n\t * verbatim.  A bracketed field's absence is indicated by a -1 in its\n\t * place\n\t */\n\n\t/*\n\t * Make sure that the tagged list is reasonably correct.\n\t */\n\tcounter = skip = 0;\n\tfor (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t     /*\n\t      * don't dump tl data types we know aren't understood by\n\t      * earlier revisions [krb5-admin/89]\n\t      */\n\t     switch (tlp->tl_data_type) {\n\t     case KRB5_TL_KADM_DATA:\n\t\t  if (kadm)\n\t\t      counter++;\n\t\t  else\n\t\t      skip++;\n\t\t  break;\n\t     default:\n\t\t  counter++;\n\t\t  break;\n\t     }\n\t}\n\t\n\tif (counter + skip == entry->n_tl_data) {\n\t    /* Pound out header */\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%s\\t\",\n\t\t    (int) entry->len,\n\t\t    strlen(name),\n\t\t    counter,\n\t\t    (int) entry->n_key_data,\n\t\t    (int) entry->e_length,\n\t\t    name);\n\t    fprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t\",\n\t\t    entry->attributes,\n\t\t    entry->max_life,\n\t\t    entry->max_renewable_life,\n\t\t    entry->expiration,\n\t\t    entry->pw_expiration,\n\t\t    entry->last_success,\n\t\t    entry->last_failed,\n\t\t    entry->fail_auth_count);\n\t    /* Pound out tagged data. */\n\t    for (tlp = entry->tl_data; tlp; tlp = tlp->tl_data_next) {\n\t\tif (tlp->tl_data_type == KRB5_TL_KADM_DATA && !kadm)\n\t\t     continue; /* see above, [krb5-admin/89] */\n\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) tlp->tl_data_type,\n\t\t\t(int) tlp->tl_data_length);\n\t\tif (tlp->tl_data_length)\n\t\t    for (i=0; i<tlp->tl_data_length; i++)\n\t\t\tfprintf(arg->ofile, \"%02x\", tlp->tl_data_contents[i]);\n\t\telse\n\t\t    fprintf(arg->ofile, \"%d\", -1);\n\t\tfprintf(arg->ofile, \"\\t\");\n\t    }\n\n\t    /* Pound out key data */\n\t    for (counter=0; counter<entry->n_key_data; counter++) {\n\t\tkdata = &entry->key_data[counter];\n\t\tfprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t(int) kdata->key_data_ver,\n\t\t\t(int) kdata->key_data_kvno);\n\t\tfor (i=0; i<kdata->key_data_ver; i++) {\n\t\t    fprintf(arg->ofile, \"%d\\t%d\\t\",\n\t\t\t    kdata->key_data_type[i],\n\t\t\t    kdata->key_data_length[i]);\n\t\t    if (kdata->key_data_length[i])\n\t\t\tfor (j=0; j<kdata->key_data_length[i]; j++)\n\t\t\t    fprintf(arg->ofile, \"%02x\",\n\t\t\t\t    kdata->key_data_contents[i][j]);\n\t\t    else\n\t\t\tfprintf(arg->ofile, \"%d\", -1);\n\t\t    fprintf(arg->ofile, \"\\t\");\n\t\t}\n\t    }\n\n\t    /* Pound out extra data */\n\t    if (entry->e_length)\n\t\tfor (i=0; i<entry->e_length; i++)\n\t\t    fprintf(arg->ofile, \"%02x\", entry->e_data[i]);\n\t    else\n\t\tfprintf(arg->ofile, \"%d\", -1);\n\n\t    /* Print trailer */\n\t    fprintf(arg->ofile, \";\\n\");\n\n\t    if (arg->verbose)\n\t\tfprintf(stderr, \"%s\\n\", name);\n\t}\n\telse {\n\t    fprintf(stderr, sdump_tl_inc_err,\n\t\t    arg->programname, name, counter+skip,\n\t\t    (int) entry->n_tl_data); \n\t    retval = EINVAL;\n\t}\n    }\n    krb5_xfree(name);\n    return(retval);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\ndump_k5beta6_iterator(ptr, entry)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n{\n    return dump_k5beta6_iterator_ext(ptr, entry, 0);\n}"
  },
  {
    "function_name": "dump_k5beta_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "484-649",
    "snippet": "static krb5_error_code\ndump_k5beta_iterator(ptr, entry)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n{\n    krb5_error_code\tretval;\n    struct dump_args\t*arg;\n    char\t\t*name, *mod_name;\n    krb5_principal\tmod_princ;\n    krb5_key_data\t*pkey, *akey, nullkey;\n    krb5_timestamp\tmod_date, last_pwd_change;\n    int\t\t\ti;\n\n    /* Initialize */\n    arg = (struct dump_args *) ptr;\n    name = (char *) NULL;\n    mod_name = (char *) NULL;\n    memset(&nullkey, 0, sizeof(nullkey));\n\n    /*\n     * Flatten the principal name.\n     */\n    if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t    entry->princ,\n\t\t\t\t    &name))) {\n\tfprintf(stderr, pname_unp_err, \n\t\targ->programname, error_message(retval));\n\treturn(retval);\n    }\n\n    /*\n     * Re-encode the keys in the new master key, if necessary.\n     */\n    if (mkey_convert) {\n\tretval = master_key_convert(arg->kcontext, entry);\n\tif (retval) {\n\t    com_err(arg->programname, retval, remaster_err_fmt, name);\n\t    return retval;\n\t}\n    }\n    \n    /*\n     * If we don't have any match strings, or if our name matches, then\n     * proceed with the dump, otherwise, just forget about it.\n     */\n    if (!arg->nnames || name_matches(name, arg)) {\n\t/*\n\t * Deserialize the modifier record.\n\t */\n\tmod_name = (char *) NULL;\n\tmod_princ = NULL;\n\tlast_pwd_change = mod_date = 0;\n\tpkey = akey = (krb5_key_data *) NULL;\n\tif (!(retval = krb5_dbe_lookup_mod_princ_data(arg->kcontext,\n\t\t\t\t\t\t      entry,\n\t\t\t\t\t\t      &mod_date,\n\t\t\t\t\t\t      &mod_princ))) {\n\t    if (mod_princ) {\n\t\t/*\n\t\t * Flatten the modifier name.\n\t\t */\n\t\tif ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t\t\tmod_princ,\n\t\t\t\t\t\t&mod_name)))\n\t\t    fprintf(stderr, mname_unp_err, arg->programname,\n\t\t\t    error_message(retval));\n\t\tkrb5_free_principal(arg->kcontext, mod_princ);\n\t    }\n\t}\n\tif (!mod_name)\n\t    mod_name = strdup(null_mprinc_name);\n\n\t/*\n\t * Find the last password change record and set it straight.\n\t */\n\tif ((retval =\n\t     krb5_dbe_lookup_last_pwd_change(arg->kcontext, entry,\n\t\t\t\t\t     &last_pwd_change))) {\n\t    fprintf(stderr, nokeys_err, arg->programname, name);\n\t    krb5_xfree(mod_name);\n\t    krb5_xfree(name);\n\t    return(retval);\n\t}\n\n\t/*\n\t * Find the 'primary' key and the 'alternate' key.\n\t */\n\tif ((retval = find_enctype(entry,\n\t\t\t\t   ENCTYPE_DES_CBC_CRC,\n\t\t\t\t   KRB5_KDB_SALTTYPE_NORMAL,\n\t\t\t\t   &pkey)) &&\n\t    (retval = find_enctype(entry,\n\t\t\t\t   ENCTYPE_DES_CBC_CRC,\n\t\t\t\t   KRB5_KDB_SALTTYPE_V4,\n\t\t\t\t   &akey))) {\n\t    fprintf(stderr, nokeys_err, arg->programname, name);\n\t    krb5_xfree(mod_name);\n\t    krb5_xfree(name);\n\t    return(retval);\n\t}\n\n\t/* If we only have one type, then ship it out as the primary. */\n\tif (!pkey && akey) {\n\t    pkey = akey;\n\t    akey = &nullkey;\n\t}\n\telse {\n\t    if (!akey)\n\t\takey = &nullkey;\n\t}\n\n\t/*\n\t * First put out strings representing the length of the variable\n\t * length data in this record, then the name and the primary key type.\n\t */\n\tfprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%s\\t%d\\t\", strlen(name),\n\t\tstrlen(mod_name),\n\t\t(krb5_int32) pkey->key_data_length[0],\n\t\t(krb5_int32) akey->key_data_length[0],\n\t\t(krb5_int32) pkey->key_data_length[1],\n\t\t(krb5_int32) akey->key_data_length[1],\n\t\tname,\n\t\t(krb5_int32) pkey->key_data_type[0]);\n\tfor (i=0; i<pkey->key_data_length[0]; i++) {\n\t    fprintf(arg->ofile, \"%02x\", pkey->key_data_contents[0][i]);\n\t}\n\t/*\n\t * Second, print out strings representing the standard integer\n\t * data in this record.\n\t */\n\tfprintf(arg->ofile,\n\t\t\"\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%s\\t%u\\t%u\\t%u\\t\",\n\t\t(krb5_int32) pkey->key_data_kvno,\n\t\tentry->max_life, entry->max_renewable_life,\n\t\t1 /* Fake mkvno */, entry->expiration, entry->pw_expiration,\n\t\tlast_pwd_change, entry->last_success, entry->last_failed,\n\t\tentry->fail_auth_count, mod_name, mod_date,\n\t\tentry->attributes, pkey->key_data_type[1]);\n\n\t/* Pound out the salt data, if present. */\n\tfor (i=0; i<pkey->key_data_length[1]; i++) {\n\t    fprintf(arg->ofile, \"%02x\", pkey->key_data_contents[1][i]);\n\t}\n\t/* Pound out the alternate key type and contents */\n\tfprintf(arg->ofile, \"\\t%u\\t\", akey->key_data_type[0]);\n\tfor (i=0; i<akey->key_data_length[0]; i++) {\n\t    fprintf(arg->ofile, \"%02x\", akey->key_data_contents[0][i]);\n\t}\n\t/* Pound out the alternate salt type and contents */\n\tfprintf(arg->ofile, \"\\t%u\\t\", akey->key_data_type[1]);\n\tfor (i=0; i<akey->key_data_length[1]; i++) {\n\t    fprintf(arg->ofile, \"%02x\", akey->key_data_contents[1][i]);\n\t}\n\t/* Pound out the expansion data. (is null) */\n\tfor (i=0; i < 8; i++) {\n\t    fprintf(arg->ofile, \"\\t%u\", 0);\n\t}\n\tfprintf(arg->ofile, \";\\n\");\n\t/* If we're blabbing, do it */\n\tif (arg->verbose)\n\t    fprintf(stderr, \"%s\\n\", name);\n\tkrb5_xfree(mod_name);\n    }\n    krb5_xfree(name);\n    return(0);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define remaster_err_fmt\t\"while re-encoding keys for principal %s with new master key\"",
      "#define nokeys_err\t\t\"%s: cannot find any standard key for %s\\n\"",
      "#define mname_unp_err\t\t\"%s: cannot unparse modifier name (%s)\\n\"",
      "#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\""
    ],
    "globals_used": [
      "static int\t\t\tmkey_convert;",
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);",
      "static const char null_mprinc_name[] = \"kdb5_dump@MISSING\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "name"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "mod_name"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s\\n\"",
            "name"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\";\\n\""
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"\\t%u\"",
            "0"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%02x\"",
            "akey->key_data_contents[1][i]"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"\\t%u\\t\"",
            "akey->key_data_type[1]"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%02x\"",
            "akey->key_data_contents[0][i]"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"\\t%u\\t\"",
            "akey->key_data_type[0]"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%02x\"",
            "pkey->key_data_contents[1][i]"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%s\\t%u\\t%u\\t%u\\t\"",
            "(krb5_int32) pkey->key_data_kvno",
            "entry->max_life",
            "entry->max_renewable_life",
            "1/* Fake mkvno */",
            "entry->expiration",
            "entry->pw_expiration",
            "last_pwd_change",
            "entry->last_success",
            "entry->last_failed",
            "entry->fail_auth_count",
            "mod_name",
            "mod_date",
            "entry->attributes",
            "pkey->key_data_type[1]"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%02x\"",
            "pkey->key_data_contents[0][i]"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->ofile",
            "\"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%s\\t%d\\t\"",
            "strlen(name)",
            "strlen(mod_name)",
            "(krb5_int32) pkey->key_data_length[0]",
            "(krb5_int32) akey->key_data_length[0]",
            "(krb5_int32) pkey->key_data_length[1]",
            "(krb5_int32) akey->key_data_length[1]",
            "name",
            "(krb5_int32) pkey->key_data_type[0]"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "mod_name"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "name"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "mod_name"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "nokeys_err",
            "arg->programname",
            "name"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_enctype",
          "args": [
            "entry",
            "ENCTYPE_DES_CBC_CRC",
            "KRB5_KDB_SALTTYPE_V4",
            "&akey"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "find_enctype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "436-462",
          "snippet": "static krb5_error_code\nfind_enctype(dbentp, enctype, salttype, kentp)\n    krb5_db_entry\t*dbentp;\n    krb5_enctype\tenctype;\n    krb5_int32\t\tsalttype;\n    krb5_key_data\t**kentp;\n{\n    int\t\t\ti;\n    int\t\t\tmaxkvno;\n    krb5_key_data\t*datap;\n\n    maxkvno = -1;\n    datap = (krb5_key_data *) NULL;\n    for (i=0; i<dbentp->n_key_data; i++) {\n\tif (( (krb5_enctype)dbentp->key_data[i].key_data_type[0] == enctype) &&\n\t    ((dbentp->key_data[i].key_data_type[1] == salttype) ||\n\t     (salttype < 0))) {\n\t    maxkvno = dbentp->key_data[i].key_data_kvno;\n\t    datap = &dbentp->key_data[i];\n\t}\n    }\n    if (maxkvno >= 0) {\n\t*kentp = datap;\n\treturn(0);\n    }\n    return(ENOENT);    \n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
            "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
            "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
            "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
            "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\nfind_enctype(dbentp, enctype, salttype, kentp)\n    krb5_db_entry\t*dbentp;\n    krb5_enctype\tenctype;\n    krb5_int32\t\tsalttype;\n    krb5_key_data\t**kentp;\n{\n    int\t\t\ti;\n    int\t\t\tmaxkvno;\n    krb5_key_data\t*datap;\n\n    maxkvno = -1;\n    datap = (krb5_key_data *) NULL;\n    for (i=0; i<dbentp->n_key_data; i++) {\n\tif (( (krb5_enctype)dbentp->key_data[i].key_data_type[0] == enctype) &&\n\t    ((dbentp->key_data[i].key_data_type[1] == salttype) ||\n\t     (salttype < 0))) {\n\t    maxkvno = dbentp->key_data[i].key_data_kvno;\n\t    datap = &dbentp->key_data[i];\n\t}\n    }\n    if (maxkvno >= 0) {\n\t*kentp = datap;\n\treturn(0);\n    }\n    return(ENOENT);    \n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "name"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "mod_name"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "nokeys_err",
            "arg->programname",
            "name"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_lookup_last_pwd_change",
          "args": [
            "arg->kcontext",
            "entry",
            "&last_pwd_change"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "null_mprinc_name"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "arg->kcontext",
            "mod_princ"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "mname_unp_err",
            "arg->programname",
            "error_message(retval)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "retval"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "arg->kcontext",
            "mod_princ",
            "&mod_name"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_lookup_mod_princ_data",
          "args": [
            "arg->kcontext",
            "entry",
            "&mod_date",
            "&mod_princ"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "name_matches",
          "args": [
            "name",
            "arg"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "name_matches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "338-434",
          "snippet": "static int\nname_matches(name, arglist)\n    char\t\t*name;\n    struct dump_args\t*arglist;\n{\n#if\tHAVE_REGCOMP\n    regex_t\tmatch_exp;\n    regmatch_t\tmatch_match;\n    int\t\tmatch_error;\n    char\tmatch_errmsg[BUFSIZ];\n    size_t\terrmsg_size;\n#elif\tHAVE_REGEXP_H\n    char\tregexp_buffer[RE_BUF_SIZE];\n#elif\tHAVE_RE_COMP\n    extern char\t*re_comp();\n    char\t*re_result;\n#endif\t/* HAVE_RE_COMP */\n    int\t\ti, match;\n\n    /*\n     * Plow, brute force, through the list of names/regular expressions.\n     */\n    match = (arglist->nnames) ? 0 : 1;\n    for (i=0; i<arglist->nnames; i++) {\n#if\tHAVE_REGCOMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tmatch_error = regcomp(&match_exp, arglist->names[i], REG_EXTENDED);\n\tif (match_error) {\n\t    errmsg_size = regerror(match_error,\n\t\t\t\t   &match_exp,\n\t\t\t\t   match_errmsg,\n\t\t\t\t   sizeof(match_errmsg));\n\t    fprintf(stderr, regex_err, arglist->programname, match_errmsg);\n\t    break;\n\t}\n\t/*\n\t * See if we have a match.\n\t */\n\tmatch_error = regexec(&match_exp, name, 1, &match_match, 0);\n\tif (match_error) {\n\t    if (match_error != REG_NOMATCH) {\n\t\terrmsg_size = regerror(match_error,\n\t\t\t\t       &match_exp,\n\t\t\t\t       match_errmsg,\n\t\t\t\t       sizeof(match_errmsg));\n\t\tfprintf(stderr, regex_merr,\n\t\t\targlist->programname, match_errmsg);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    /*\n\t     * We have a match.  See if it matches the whole\n\t     * name.\n\t     */\n\t    if ((match_match.rm_so == 0) &&\n\t\t(match_match.rm_eo == strlen(name)))\n\t\tmatch = 1;\n\t}\n\tregfree(&match_exp);\n#elif\tHAVE_REGEXP_H\n\t/*\n\t * Compile the regular expression.\n\t */\n\tcompile(arglist->names[i],\n\t\tregexp_buffer, \n\t\t&regexp_buffer[RE_BUF_SIZE],\n\t\t'\\0');\n\tif (step(name, regexp_buffer)) {\n\t    if ((loc1 == name) &&\n\t\t(loc2 == &name[strlen(name)]))\n\t\tmatch = 1;\n\t}\n#elif\tHAVE_RE_COMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tif (re_result = re_comp(arglist->names[i])) {\n\t    fprintf(stderr, regex_err, arglist->programname, re_result);\n\t    break;\n\t}\n\tif (re_exec(name))\n\t    match = 1;\n#else\t/* HAVE_RE_COMP */\n\t/*\n\t * If no regular expression support, then just compare the strings.\n\t */\n\tif (!strcmp(arglist->names[i], name))\n\t    match = 1;\n#endif\t/* HAVE_REGCOMP */\n\tif (match)\n\t    break;\n    }\n    return(match);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define regex_merr\t\t\"%s: regular expression match error - %s\\n\"",
            "#define regex_err\t\t\"%s: regular expression error - %s\\n\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define regex_merr\t\t\"%s: regular expression match error - %s\\n\"\n#define regex_err\t\t\"%s: regular expression error - %s\\n\"\n\nstatic int\nname_matches(name, arglist)\n    char\t\t*name;\n    struct dump_args\t*arglist;\n{\n#if\tHAVE_REGCOMP\n    regex_t\tmatch_exp;\n    regmatch_t\tmatch_match;\n    int\t\tmatch_error;\n    char\tmatch_errmsg[BUFSIZ];\n    size_t\terrmsg_size;\n#elif\tHAVE_REGEXP_H\n    char\tregexp_buffer[RE_BUF_SIZE];\n#elif\tHAVE_RE_COMP\n    extern char\t*re_comp();\n    char\t*re_result;\n#endif\t/* HAVE_RE_COMP */\n    int\t\ti, match;\n\n    /*\n     * Plow, brute force, through the list of names/regular expressions.\n     */\n    match = (arglist->nnames) ? 0 : 1;\n    for (i=0; i<arglist->nnames; i++) {\n#if\tHAVE_REGCOMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tmatch_error = regcomp(&match_exp, arglist->names[i], REG_EXTENDED);\n\tif (match_error) {\n\t    errmsg_size = regerror(match_error,\n\t\t\t\t   &match_exp,\n\t\t\t\t   match_errmsg,\n\t\t\t\t   sizeof(match_errmsg));\n\t    fprintf(stderr, regex_err, arglist->programname, match_errmsg);\n\t    break;\n\t}\n\t/*\n\t * See if we have a match.\n\t */\n\tmatch_error = regexec(&match_exp, name, 1, &match_match, 0);\n\tif (match_error) {\n\t    if (match_error != REG_NOMATCH) {\n\t\terrmsg_size = regerror(match_error,\n\t\t\t\t       &match_exp,\n\t\t\t\t       match_errmsg,\n\t\t\t\t       sizeof(match_errmsg));\n\t\tfprintf(stderr, regex_merr,\n\t\t\targlist->programname, match_errmsg);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    /*\n\t     * We have a match.  See if it matches the whole\n\t     * name.\n\t     */\n\t    if ((match_match.rm_so == 0) &&\n\t\t(match_match.rm_eo == strlen(name)))\n\t\tmatch = 1;\n\t}\n\tregfree(&match_exp);\n#elif\tHAVE_REGEXP_H\n\t/*\n\t * Compile the regular expression.\n\t */\n\tcompile(arglist->names[i],\n\t\tregexp_buffer, \n\t\t&regexp_buffer[RE_BUF_SIZE],\n\t\t'\\0');\n\tif (step(name, regexp_buffer)) {\n\t    if ((loc1 == name) &&\n\t\t(loc2 == &name[strlen(name)]))\n\t\tmatch = 1;\n\t}\n#elif\tHAVE_RE_COMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tif (re_result = re_comp(arglist->names[i])) {\n\t    fprintf(stderr, regex_err, arglist->programname, re_result);\n\t    break;\n\t}\n\tif (re_exec(name))\n\t    match = 1;\n#else\t/* HAVE_RE_COMP */\n\t/*\n\t * If no regular expression support, then just compare the strings.\n\t */\n\tif (!strcmp(arglist->names[i], name))\n\t    match = 1;\n#endif\t/* HAVE_REGCOMP */\n\tif (match)\n\t    break;\n    }\n    return(match);\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "arg->programname",
            "retval",
            "remaster_err_fmt",
            "name"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "master_key_convert",
          "args": [
            "arg->kcontext",
            "entry"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "master_key_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "248-292",
          "snippet": "static krb5_error_code master_key_convert(context, db_entry)\n    krb5_context\t  context;\n    krb5_db_entry\t* db_entry;\n{\n    krb5_error_code\tretval;\n    krb5_keyblock \tv5plainkey, *key_ptr;\n    krb5_keysalt \tkeysalt;\n    int\t      i, j;\n    krb5_key_data\tnew_key_data, *key_data;\n    krb5_boolean\tis_mkey;\n\n    is_mkey = krb5_principal_compare(context, master_princ, db_entry->princ);\n\n    if (is_mkey && db_entry->n_key_data != 1)\n\t    fprintf(stderr,\n\t\t    \"Master key db entry has %d keys, expecting only 1!\\n\",\n\t\t    db_entry->n_key_data);\n    for (i=0; i < db_entry->n_key_data; i++) {\n\tkey_data = &db_entry->key_data[i];\n\tif (key_data->key_data_length == 0)\n\t    continue;\n\tretval = krb5_dbekd_decrypt_key_data(context, &master_keyblock,\n\t\t\t\t\t     key_data, &v5plainkey,\n\t\t\t\t\t     &keysalt);\n\tif (retval)\n\t\treturn retval;\n\n\tmemset(&new_key_data, 0, sizeof(new_key_data));\n\tkey_ptr = is_mkey ? &new_master_keyblock : &v5plainkey;\n\tretval = krb5_dbekd_encrypt_key_data(context, &new_master_keyblock,\n\t\t\t\t\t     key_ptr, &keysalt,\n\t\t\t\t\t     key_data->key_data_kvno,\n\t\t\t\t\t     &new_key_data);\n\tif (retval)\n\t\treturn retval;\n\tkrb5_free_keyblock_contents(context, &v5plainkey);\n\tfor (j = 0; j < key_data->key_data_ver; j++) {\n\t    if (key_data->key_data_length[j]) {\n\t\tfree(key_data->key_data_contents[j]);\n\t    }\n\t}\n\t*key_data = new_key_data;\n    }\n    return 0;\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_keyblock\t\tnew_master_keyblock;",
            "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
            "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
            "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
            "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
            "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
            "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic krb5_keyblock\t\tnew_master_keyblock;\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code master_key_convert(context, db_entry)\n    krb5_context\t  context;\n    krb5_db_entry\t* db_entry;\n{\n    krb5_error_code\tretval;\n    krb5_keyblock \tv5plainkey, *key_ptr;\n    krb5_keysalt \tkeysalt;\n    int\t      i, j;\n    krb5_key_data\tnew_key_data, *key_data;\n    krb5_boolean\tis_mkey;\n\n    is_mkey = krb5_principal_compare(context, master_princ, db_entry->princ);\n\n    if (is_mkey && db_entry->n_key_data != 1)\n\t    fprintf(stderr,\n\t\t    \"Master key db entry has %d keys, expecting only 1!\\n\",\n\t\t    db_entry->n_key_data);\n    for (i=0; i < db_entry->n_key_data; i++) {\n\tkey_data = &db_entry->key_data[i];\n\tif (key_data->key_data_length == 0)\n\t    continue;\n\tretval = krb5_dbekd_decrypt_key_data(context, &master_keyblock,\n\t\t\t\t\t     key_data, &v5plainkey,\n\t\t\t\t\t     &keysalt);\n\tif (retval)\n\t\treturn retval;\n\n\tmemset(&new_key_data, 0, sizeof(new_key_data));\n\tkey_ptr = is_mkey ? &new_master_keyblock : &v5plainkey;\n\tretval = krb5_dbekd_encrypt_key_data(context, &new_master_keyblock,\n\t\t\t\t\t     key_ptr, &keysalt,\n\t\t\t\t\t     key_data->key_data_kvno,\n\t\t\t\t\t     &new_key_data);\n\tif (retval)\n\t\treturn retval;\n\tkrb5_free_keyblock_contents(context, &v5plainkey);\n\tfor (j = 0; j < key_data->key_data_ver; j++) {\n\t    if (key_data->key_data_length[j]) {\n\t\tfree(key_data->key_data_contents[j]);\n\t    }\n\t}\n\t*key_data = new_key_data;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "pname_unp_err",
            "arg->programname",
            "error_message(retval)"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "retval"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "arg->kcontext",
            "entry->princ",
            "&name"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&nullkey",
            "0",
            "sizeof(nullkey)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define remaster_err_fmt\t\"while re-encoding keys for principal %s with new master key\"\n#define nokeys_err\t\t\"%s: cannot find any standard key for %s\\n\"\n#define mname_unp_err\t\t\"%s: cannot unparse modifier name (%s)\\n\"\n#define pname_unp_err\t\t\"%s: cannot unparse principal name (%s)\\n\"\n\nstatic int\t\t\tmkey_convert;\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\nstatic const char null_mprinc_name[] = \"kdb5_dump@MISSING\";\n\nstatic krb5_error_code\ndump_k5beta_iterator(ptr, entry)\n    krb5_pointer\tptr;\n    krb5_db_entry\t*entry;\n{\n    krb5_error_code\tretval;\n    struct dump_args\t*arg;\n    char\t\t*name, *mod_name;\n    krb5_principal\tmod_princ;\n    krb5_key_data\t*pkey, *akey, nullkey;\n    krb5_timestamp\tmod_date, last_pwd_change;\n    int\t\t\ti;\n\n    /* Initialize */\n    arg = (struct dump_args *) ptr;\n    name = (char *) NULL;\n    mod_name = (char *) NULL;\n    memset(&nullkey, 0, sizeof(nullkey));\n\n    /*\n     * Flatten the principal name.\n     */\n    if ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t    entry->princ,\n\t\t\t\t    &name))) {\n\tfprintf(stderr, pname_unp_err, \n\t\targ->programname, error_message(retval));\n\treturn(retval);\n    }\n\n    /*\n     * Re-encode the keys in the new master key, if necessary.\n     */\n    if (mkey_convert) {\n\tretval = master_key_convert(arg->kcontext, entry);\n\tif (retval) {\n\t    com_err(arg->programname, retval, remaster_err_fmt, name);\n\t    return retval;\n\t}\n    }\n    \n    /*\n     * If we don't have any match strings, or if our name matches, then\n     * proceed with the dump, otherwise, just forget about it.\n     */\n    if (!arg->nnames || name_matches(name, arg)) {\n\t/*\n\t * Deserialize the modifier record.\n\t */\n\tmod_name = (char *) NULL;\n\tmod_princ = NULL;\n\tlast_pwd_change = mod_date = 0;\n\tpkey = akey = (krb5_key_data *) NULL;\n\tif (!(retval = krb5_dbe_lookup_mod_princ_data(arg->kcontext,\n\t\t\t\t\t\t      entry,\n\t\t\t\t\t\t      &mod_date,\n\t\t\t\t\t\t      &mod_princ))) {\n\t    if (mod_princ) {\n\t\t/*\n\t\t * Flatten the modifier name.\n\t\t */\n\t\tif ((retval = krb5_unparse_name(arg->kcontext,\n\t\t\t\t\t\tmod_princ,\n\t\t\t\t\t\t&mod_name)))\n\t\t    fprintf(stderr, mname_unp_err, arg->programname,\n\t\t\t    error_message(retval));\n\t\tkrb5_free_principal(arg->kcontext, mod_princ);\n\t    }\n\t}\n\tif (!mod_name)\n\t    mod_name = strdup(null_mprinc_name);\n\n\t/*\n\t * Find the last password change record and set it straight.\n\t */\n\tif ((retval =\n\t     krb5_dbe_lookup_last_pwd_change(arg->kcontext, entry,\n\t\t\t\t\t     &last_pwd_change))) {\n\t    fprintf(stderr, nokeys_err, arg->programname, name);\n\t    krb5_xfree(mod_name);\n\t    krb5_xfree(name);\n\t    return(retval);\n\t}\n\n\t/*\n\t * Find the 'primary' key and the 'alternate' key.\n\t */\n\tif ((retval = find_enctype(entry,\n\t\t\t\t   ENCTYPE_DES_CBC_CRC,\n\t\t\t\t   KRB5_KDB_SALTTYPE_NORMAL,\n\t\t\t\t   &pkey)) &&\n\t    (retval = find_enctype(entry,\n\t\t\t\t   ENCTYPE_DES_CBC_CRC,\n\t\t\t\t   KRB5_KDB_SALTTYPE_V4,\n\t\t\t\t   &akey))) {\n\t    fprintf(stderr, nokeys_err, arg->programname, name);\n\t    krb5_xfree(mod_name);\n\t    krb5_xfree(name);\n\t    return(retval);\n\t}\n\n\t/* If we only have one type, then ship it out as the primary. */\n\tif (!pkey && akey) {\n\t    pkey = akey;\n\t    akey = &nullkey;\n\t}\n\telse {\n\t    if (!akey)\n\t\takey = &nullkey;\n\t}\n\n\t/*\n\t * First put out strings representing the length of the variable\n\t * length data in this record, then the name and the primary key type.\n\t */\n\tfprintf(arg->ofile, \"%d\\t%d\\t%d\\t%d\\t%d\\t%d\\t%s\\t%d\\t\", strlen(name),\n\t\tstrlen(mod_name),\n\t\t(krb5_int32) pkey->key_data_length[0],\n\t\t(krb5_int32) akey->key_data_length[0],\n\t\t(krb5_int32) pkey->key_data_length[1],\n\t\t(krb5_int32) akey->key_data_length[1],\n\t\tname,\n\t\t(krb5_int32) pkey->key_data_type[0]);\n\tfor (i=0; i<pkey->key_data_length[0]; i++) {\n\t    fprintf(arg->ofile, \"%02x\", pkey->key_data_contents[0][i]);\n\t}\n\t/*\n\t * Second, print out strings representing the standard integer\n\t * data in this record.\n\t */\n\tfprintf(arg->ofile,\n\t\t\"\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%u\\t%s\\t%u\\t%u\\t%u\\t\",\n\t\t(krb5_int32) pkey->key_data_kvno,\n\t\tentry->max_life, entry->max_renewable_life,\n\t\t1 /* Fake mkvno */, entry->expiration, entry->pw_expiration,\n\t\tlast_pwd_change, entry->last_success, entry->last_failed,\n\t\tentry->fail_auth_count, mod_name, mod_date,\n\t\tentry->attributes, pkey->key_data_type[1]);\n\n\t/* Pound out the salt data, if present. */\n\tfor (i=0; i<pkey->key_data_length[1]; i++) {\n\t    fprintf(arg->ofile, \"%02x\", pkey->key_data_contents[1][i]);\n\t}\n\t/* Pound out the alternate key type and contents */\n\tfprintf(arg->ofile, \"\\t%u\\t\", akey->key_data_type[0]);\n\tfor (i=0; i<akey->key_data_length[0]; i++) {\n\t    fprintf(arg->ofile, \"%02x\", akey->key_data_contents[0][i]);\n\t}\n\t/* Pound out the alternate salt type and contents */\n\tfprintf(arg->ofile, \"\\t%u\\t\", akey->key_data_type[1]);\n\tfor (i=0; i<akey->key_data_length[1]; i++) {\n\t    fprintf(arg->ofile, \"%02x\", akey->key_data_contents[1][i]);\n\t}\n\t/* Pound out the expansion data. (is null) */\n\tfor (i=0; i < 8; i++) {\n\t    fprintf(arg->ofile, \"\\t%u\", 0);\n\t}\n\tfprintf(arg->ofile, \";\\n\");\n\t/* If we're blabbing, do it */\n\tif (arg->verbose)\n\t    fprintf(stderr, \"%s\\n\", name);\n\tkrb5_xfree(mod_name);\n    }\n    krb5_xfree(name);\n    return(0);\n}"
  },
  {
    "function_name": "dump_k5beta_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "469-476",
    "snippet": "static krb5_error_code\ndump_k5beta_header(arglist)\n    struct dump_args *arglist;\n{\n    /* The old header consists of the leading string */\n    fprintf(arglist->ofile, k5beta_dump_header);\n    return(0);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define k5beta_dump_header\t\"kdb5_edit load_dump version 2.0\\n\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arglist->ofile",
            "k5beta_dump_header"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define k5beta_dump_header\t\"kdb5_edit load_dump version 2.0\\n\"\n\nstatic krb5_error_code\ndump_k5beta_header(arglist)\n    struct dump_args *arglist;\n{\n    /* The old header consists of the leading string */\n    fprintf(arglist->ofile, k5beta_dump_header);\n    return(0);\n}"
  },
  {
    "function_name": "find_enctype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "436-462",
    "snippet": "static krb5_error_code\nfind_enctype(dbentp, enctype, salttype, kentp)\n    krb5_db_entry\t*dbentp;\n    krb5_enctype\tenctype;\n    krb5_int32\t\tsalttype;\n    krb5_key_data\t**kentp;\n{\n    int\t\t\ti;\n    int\t\t\tmaxkvno;\n    krb5_key_data\t*datap;\n\n    maxkvno = -1;\n    datap = (krb5_key_data *) NULL;\n    for (i=0; i<dbentp->n_key_data; i++) {\n\tif (( (krb5_enctype)dbentp->key_data[i].key_data_type[0] == enctype) &&\n\t    ((dbentp->key_data[i].key_data_type[1] == salttype) ||\n\t     (salttype < 0))) {\n\t    maxkvno = dbentp->key_data[i].key_data_kvno;\n\t    datap = &dbentp->key_data[i];\n\t}\n    }\n    if (maxkvno >= 0) {\n\t*kentp = datap;\n\treturn(0);\n    }\n    return(ENOENT);    \n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code\nfind_enctype(dbentp, enctype, salttype, kentp)\n    krb5_db_entry\t*dbentp;\n    krb5_enctype\tenctype;\n    krb5_int32\t\tsalttype;\n    krb5_key_data\t**kentp;\n{\n    int\t\t\ti;\n    int\t\t\tmaxkvno;\n    krb5_key_data\t*datap;\n\n    maxkvno = -1;\n    datap = (krb5_key_data *) NULL;\n    for (i=0; i<dbentp->n_key_data; i++) {\n\tif (( (krb5_enctype)dbentp->key_data[i].key_data_type[0] == enctype) &&\n\t    ((dbentp->key_data[i].key_data_type[1] == salttype) ||\n\t     (salttype < 0))) {\n\t    maxkvno = dbentp->key_data[i].key_data_kvno;\n\t    datap = &dbentp->key_data[i];\n\t}\n    }\n    if (maxkvno >= 0) {\n\t*kentp = datap;\n\treturn(0);\n    }\n    return(ENOENT);    \n}"
  },
  {
    "function_name": "name_matches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "338-434",
    "snippet": "static int\nname_matches(name, arglist)\n    char\t\t*name;\n    struct dump_args\t*arglist;\n{\n#if\tHAVE_REGCOMP\n    regex_t\tmatch_exp;\n    regmatch_t\tmatch_match;\n    int\t\tmatch_error;\n    char\tmatch_errmsg[BUFSIZ];\n    size_t\terrmsg_size;\n#elif\tHAVE_REGEXP_H\n    char\tregexp_buffer[RE_BUF_SIZE];\n#elif\tHAVE_RE_COMP\n    extern char\t*re_comp();\n    char\t*re_result;\n#endif\t/* HAVE_RE_COMP */\n    int\t\ti, match;\n\n    /*\n     * Plow, brute force, through the list of names/regular expressions.\n     */\n    match = (arglist->nnames) ? 0 : 1;\n    for (i=0; i<arglist->nnames; i++) {\n#if\tHAVE_REGCOMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tmatch_error = regcomp(&match_exp, arglist->names[i], REG_EXTENDED);\n\tif (match_error) {\n\t    errmsg_size = regerror(match_error,\n\t\t\t\t   &match_exp,\n\t\t\t\t   match_errmsg,\n\t\t\t\t   sizeof(match_errmsg));\n\t    fprintf(stderr, regex_err, arglist->programname, match_errmsg);\n\t    break;\n\t}\n\t/*\n\t * See if we have a match.\n\t */\n\tmatch_error = regexec(&match_exp, name, 1, &match_match, 0);\n\tif (match_error) {\n\t    if (match_error != REG_NOMATCH) {\n\t\terrmsg_size = regerror(match_error,\n\t\t\t\t       &match_exp,\n\t\t\t\t       match_errmsg,\n\t\t\t\t       sizeof(match_errmsg));\n\t\tfprintf(stderr, regex_merr,\n\t\t\targlist->programname, match_errmsg);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    /*\n\t     * We have a match.  See if it matches the whole\n\t     * name.\n\t     */\n\t    if ((match_match.rm_so == 0) &&\n\t\t(match_match.rm_eo == strlen(name)))\n\t\tmatch = 1;\n\t}\n\tregfree(&match_exp);\n#elif\tHAVE_REGEXP_H\n\t/*\n\t * Compile the regular expression.\n\t */\n\tcompile(arglist->names[i],\n\t\tregexp_buffer, \n\t\t&regexp_buffer[RE_BUF_SIZE],\n\t\t'\\0');\n\tif (step(name, regexp_buffer)) {\n\t    if ((loc1 == name) &&\n\t\t(loc2 == &name[strlen(name)]))\n\t\tmatch = 1;\n\t}\n#elif\tHAVE_RE_COMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tif (re_result = re_comp(arglist->names[i])) {\n\t    fprintf(stderr, regex_err, arglist->programname, re_result);\n\t    break;\n\t}\n\tif (re_exec(name))\n\t    match = 1;\n#else\t/* HAVE_RE_COMP */\n\t/*\n\t * If no regular expression support, then just compare the strings.\n\t */\n\tif (!strcmp(arglist->names[i], name))\n\t    match = 1;\n#endif\t/* HAVE_REGCOMP */\n\tif (match)\n\t    break;\n    }\n    return(match);\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [
      "#define regex_merr\t\t\"%s: regular expression match error - %s\\n\"",
      "#define regex_err\t\t\"%s: regular expression error - %s\\n\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "arglist->names[i]",
            "name"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re_exec",
          "args": [
            "name"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "regex_err",
            "arglist->programname",
            "re_result"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re_comp",
          "args": [
            "arglist->names[i]"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "step",
          "args": [
            "name",
            "regexp_buffer"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compile",
          "args": [
            "arglist->names[i]",
            "regexp_buffer",
            "&regexp_buffer[RE_BUF_SIZE]",
            "'\\0'"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regfree",
          "args": [
            "&match_exp"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "regex_merr",
            "arglist->programname",
            "match_errmsg"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regerror",
          "args": [
            "match_error",
            "&match_exp",
            "match_errmsg",
            "sizeof(match_errmsg)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regexec",
          "args": [
            "&match_exp",
            "name",
            "1",
            "&match_match",
            "0"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "regex_err",
            "arglist->programname",
            "match_errmsg"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regerror",
          "args": [
            "match_error",
            "&match_exp",
            "match_errmsg",
            "sizeof(match_errmsg)"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "regcomp",
          "args": [
            "&match_exp",
            "arglist->names[i]",
            "REG_EXTENDED"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\n#define regex_merr\t\t\"%s: regular expression match error - %s\\n\"\n#define regex_err\t\t\"%s: regular expression error - %s\\n\"\n\nstatic int\nname_matches(name, arglist)\n    char\t\t*name;\n    struct dump_args\t*arglist;\n{\n#if\tHAVE_REGCOMP\n    regex_t\tmatch_exp;\n    regmatch_t\tmatch_match;\n    int\t\tmatch_error;\n    char\tmatch_errmsg[BUFSIZ];\n    size_t\terrmsg_size;\n#elif\tHAVE_REGEXP_H\n    char\tregexp_buffer[RE_BUF_SIZE];\n#elif\tHAVE_RE_COMP\n    extern char\t*re_comp();\n    char\t*re_result;\n#endif\t/* HAVE_RE_COMP */\n    int\t\ti, match;\n\n    /*\n     * Plow, brute force, through the list of names/regular expressions.\n     */\n    match = (arglist->nnames) ? 0 : 1;\n    for (i=0; i<arglist->nnames; i++) {\n#if\tHAVE_REGCOMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tmatch_error = regcomp(&match_exp, arglist->names[i], REG_EXTENDED);\n\tif (match_error) {\n\t    errmsg_size = regerror(match_error,\n\t\t\t\t   &match_exp,\n\t\t\t\t   match_errmsg,\n\t\t\t\t   sizeof(match_errmsg));\n\t    fprintf(stderr, regex_err, arglist->programname, match_errmsg);\n\t    break;\n\t}\n\t/*\n\t * See if we have a match.\n\t */\n\tmatch_error = regexec(&match_exp, name, 1, &match_match, 0);\n\tif (match_error) {\n\t    if (match_error != REG_NOMATCH) {\n\t\terrmsg_size = regerror(match_error,\n\t\t\t\t       &match_exp,\n\t\t\t\t       match_errmsg,\n\t\t\t\t       sizeof(match_errmsg));\n\t\tfprintf(stderr, regex_merr,\n\t\t\targlist->programname, match_errmsg);\n\t\tbreak;\n\t    }\n\t}\n\telse {\n\t    /*\n\t     * We have a match.  See if it matches the whole\n\t     * name.\n\t     */\n\t    if ((match_match.rm_so == 0) &&\n\t\t(match_match.rm_eo == strlen(name)))\n\t\tmatch = 1;\n\t}\n\tregfree(&match_exp);\n#elif\tHAVE_REGEXP_H\n\t/*\n\t * Compile the regular expression.\n\t */\n\tcompile(arglist->names[i],\n\t\tregexp_buffer, \n\t\t&regexp_buffer[RE_BUF_SIZE],\n\t\t'\\0');\n\tif (step(name, regexp_buffer)) {\n\t    if ((loc1 == name) &&\n\t\t(loc2 == &name[strlen(name)]))\n\t\tmatch = 1;\n\t}\n#elif\tHAVE_RE_COMP\n\t/*\n\t * Compile the regular expression.\n\t */\n\tif (re_result = re_comp(arglist->names[i])) {\n\t    fprintf(stderr, regex_err, arglist->programname, re_result);\n\t    break;\n\t}\n\tif (re_exec(name))\n\t    match = 1;\n#else\t/* HAVE_RE_COMP */\n\t/*\n\t * If no regular expression support, then just compare the strings.\n\t */\n\tif (!strcmp(arglist->names[i], name))\n\t    match = 1;\n#endif\t/* HAVE_REGCOMP */\n\tif (match)\n\t    break;\n    }\n    return(match);\n}"
  },
  {
    "function_name": "update_ok_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "297-332",
    "snippet": "void update_ok_file (file_name)\n     char *file_name;\n{\n\t/* handle slave locking/failure stuff */\n\tchar *file_ok;\n\tint fd;\n\tstatic char ok[]=\".dump_ok\";\n\n\tif ((file_ok = (char *)malloc(strlen(file_name) + strlen(ok) + 1))\n\t    == NULL) {\n\t\tcom_err(progname, ENOMEM,\n\t\t\t\"while allocating filename for update_ok_file\");\n\t\texit_status++;\n\t\treturn;\n\t}\n\tstrcpy(file_ok, file_name);\n\tstrcat(file_ok, ok);\n\tif ((fd = open(file_ok, O_WRONLY|O_CREAT|O_TRUNC, 0600)) < 0) {\n\t\tcom_err(progname, errno, \"while creating 'ok' file, '%s'\",\n\t\t\tfile_ok);\n\t\texit_status++;\n\t\tfree(file_ok);\n\t\treturn;\n\t}\n\tif (write(fd, \"\", 1) != 1) {\n\t    com_err(progname, errno, \"while writing to 'ok' file, '%s'\",\n\t\t    file_ok);\n\t     exit_status++;\n\t     free(file_ok);\n\t     return;\n\t}\n\n\tfree(file_ok);\n\tclose(fd);\n\treturn;\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern int\t\texit_status;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "file_ok"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "progname",
            "errno",
            "\"while writing to 'ok' file, '%s'\"",
            "file_ok"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "\"\"",
            "1"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_write_v4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
          "lines": "131-148",
          "snippet": "void ktutil_write_v4(argc, argv)\n    int argc;\n    char *argv[];\n{\n#ifdef KRB5_KRB4_COMPAT\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify srvtab to write\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_write_srvtab(kcontext, ktlist, argv[1]);\n    if (retval)\n\tcom_err(argv[0], retval, \"while writing srvtab \\\"%s\\\"\", argv[1]);\n#else\n    fprintf(stderr, \"%s: krb4 support not configured\\n\", argv[0]);\n#endif\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <ss/ss.h>",
            "#include \"adm_proto.h\"",
            "#include <com_err.h>",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "krb5_context kcontext;",
            "krb5_kt_list ktlist = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ss/ss.h>\n#include \"adm_proto.h\"\n#include <com_err.h>\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_context kcontext;\nkrb5_kt_list ktlist = NULL;\n\nvoid ktutil_write_v4(argc, argv)\n    int argc;\n    char *argv[];\n{\n#ifdef KRB5_KRB4_COMPAT\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify srvtab to write\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_write_srvtab(kcontext, ktlist, argv[1]);\n    if (retval)\n\tcom_err(argv[0], retval, \"while writing srvtab \\\"%s\\\"\", argv[1]);\n#else\n    fprintf(stderr, \"%s: krb4 support not configured\\n\", argv[0]);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "progname",
            "errno",
            "\"while creating 'ok' file, '%s'\"",
            "file_ok"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "file_ok",
            "O_WRONLY|O_CREAT|O_TRUNC",
            "0600"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "open_db_and_mkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/kdb5_util.c",
          "lines": "300-421",
          "snippet": "static int open_db_and_mkey()\n{\n    krb5_error_code retval;\n    int nentries;\n    krb5_boolean more;\n    krb5_data scratch, pwd, seed;\n\n    dbactive = FALSE;\n    valid_master_key = 0;\n\n    if ((retval = krb5_db_set_name(util_context, global_params.dbname))) {\n\tcom_err(progname, retval, \"while setting active database to '%s'\",\n\t\tglobal_params.dbname);\n\texit_status++;\n\treturn(1);\n    } \n    if ((retval = krb5_db_init(util_context))) {\n\tcom_err(progname, retval, \"while initializing database\");\n\texit_status++;\n\treturn(1);\n    }\n    if ((retval = osa_adb_open_policy(&policy_db, &global_params))) {\n\tcom_err(progname, retval, \"opening policy database\");\n\texit_status++;\n\treturn (1);\n    }\n\n   /* assemble & parse the master key name */\n\n    if ((retval = krb5_db_setup_mkey_name(util_context,\n\t\t\t\t\t  global_params.mkey_name,\n\t\t\t\t\t  global_params.realm, \n\t\t\t\t\t  0, &master_princ))) {\n\tcom_err(progname, retval, \"while setting up master key name\");\n\texit_status++;\n\treturn(1);\n    }\n    nentries = 1;\n    if ((retval = krb5_db_get_principal(util_context, master_princ, \n\t\t\t\t\t&master_entry, &nentries, &more))) {\n\tcom_err(progname, retval, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (more) {\n\tcom_err(progname, KRB5KDC_ERR_PRINCIPAL_NOT_UNIQUE,\n\t\t\"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (!nentries) {\n\tcom_err(progname, KRB5_KDB_NOENTRY, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    }\n\n    krb5_db_free_principal(util_context, &master_entry, nentries);\n\n    /* the databases are now open, and the master principal exists */\n    dbactive = TRUE;\n    \n    if (mkey_password) {\n\tpwd.data = mkey_password;\n\tpwd.length = strlen(mkey_password);\n\tretval = krb5_principal2salt(util_context, master_princ, &scratch);\n\tif (retval) {\n\t    com_err(progname, retval, \"while calculated master key salt\");\n\t    return(1);\n\t}\n\n\t/* If no encryption type is set, use the default */\n\tif (master_keyblock.enctype == ENCTYPE_UNKNOWN) {\n\t    master_keyblock.enctype = DEFAULT_KDC_ENCTYPE;\n\t    if (!krb5_c_valid_enctype(master_keyblock.enctype))\n\t\tcom_err(progname, KRB5_PROG_KEYTYPE_NOSUPP,\n\t\t\t\"while setting up enctype %d\",\n\t\t\tmaster_keyblock.enctype);\n\t}\n\n\tretval = krb5_c_string_to_key(util_context, master_keyblock.enctype, \n\t\t\t\t      &pwd, &scratch, &master_keyblock);\n\tif (retval) {\n\t    com_err(progname, retval,\n\t\t    \"while transforming master key from password\");\n\t    return(1);\n\t}\n\tfree(scratch.data);\n\tmkey_password = 0;\n    } else if ((retval = krb5_db_fetch_mkey(util_context, master_princ, \n\t\t\t\t\t    master_keyblock.enctype,\n\t\t\t\t\t    manual_mkey, FALSE,\n\t\t\t\t\t    global_params.stash_file,\n\t\t\t\t\t    0, &master_keyblock))) {\n\tcom_err(progname, retval, \"while reading master key\");\n\tcom_err(progname, 0, \"Warning: proceeding without master key\");\n\texit_status++;\n\treturn(0);\n    }\n    if ((retval = krb5_db_verify_master_key(util_context, master_princ, \n\t\t\t\t\t    &master_keyblock))) {\n\tcom_err(progname, retval, \"while verifying master key\");\n\texit_status++;\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    seed.length = master_keyblock.length;\n    seed.data = master_keyblock.contents;\n\n    if ((retval = krb5_c_random_seed(util_context, &seed))) {\n\tcom_err(progname, retval, \"while seeding random number generator\");\n\texit_status++;\n\tmemset((char *)master_keyblock.contents, 0, master_keyblock.length);\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    valid_master_key = 1;\n    dbactive = TRUE;\n    return 0;\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <time.h>",
            "#include <kadm5/adb.h>",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *mkey_password = 0;",
            "int exit_status = 0;",
            "krb5_context util_context;",
            "osa_adb_policy_t policy_db;",
            "kadm5_config_params global_params;",
            "extern krb5_keyblock master_keyblock;",
            "extern krb5_principal master_princ;",
            "krb5_db_entry master_entry;",
            "int\tvalid_master_key = 0;",
            "char *progname;",
            "krb5_boolean manual_mkey = FALSE;",
            "krb5_boolean dbactive = FALSE;",
            "static int open_db_and_mkey(void);",
            "static struct _cmd_table *cmd_lookup(name)\n   char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <time.h>\n#include <kadm5/adb.h>\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nchar *mkey_password = 0;\nint exit_status = 0;\nkrb5_context util_context;\nosa_adb_policy_t policy_db;\nkadm5_config_params global_params;\nextern krb5_keyblock master_keyblock;\nextern krb5_principal master_princ;\nkrb5_db_entry master_entry;\nint\tvalid_master_key = 0;\nchar *progname;\nkrb5_boolean manual_mkey = FALSE;\nkrb5_boolean dbactive = FALSE;\nstatic int open_db_and_mkey(void);\nstatic struct _cmd_table *cmd_lookup(name)\n   char *name;\n\nstatic int open_db_and_mkey()\n{\n    krb5_error_code retval;\n    int nentries;\n    krb5_boolean more;\n    krb5_data scratch, pwd, seed;\n\n    dbactive = FALSE;\n    valid_master_key = 0;\n\n    if ((retval = krb5_db_set_name(util_context, global_params.dbname))) {\n\tcom_err(progname, retval, \"while setting active database to '%s'\",\n\t\tglobal_params.dbname);\n\texit_status++;\n\treturn(1);\n    } \n    if ((retval = krb5_db_init(util_context))) {\n\tcom_err(progname, retval, \"while initializing database\");\n\texit_status++;\n\treturn(1);\n    }\n    if ((retval = osa_adb_open_policy(&policy_db, &global_params))) {\n\tcom_err(progname, retval, \"opening policy database\");\n\texit_status++;\n\treturn (1);\n    }\n\n   /* assemble & parse the master key name */\n\n    if ((retval = krb5_db_setup_mkey_name(util_context,\n\t\t\t\t\t  global_params.mkey_name,\n\t\t\t\t\t  global_params.realm, \n\t\t\t\t\t  0, &master_princ))) {\n\tcom_err(progname, retval, \"while setting up master key name\");\n\texit_status++;\n\treturn(1);\n    }\n    nentries = 1;\n    if ((retval = krb5_db_get_principal(util_context, master_princ, \n\t\t\t\t\t&master_entry, &nentries, &more))) {\n\tcom_err(progname, retval, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (more) {\n\tcom_err(progname, KRB5KDC_ERR_PRINCIPAL_NOT_UNIQUE,\n\t\t\"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (!nentries) {\n\tcom_err(progname, KRB5_KDB_NOENTRY, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    }\n\n    krb5_db_free_principal(util_context, &master_entry, nentries);\n\n    /* the databases are now open, and the master principal exists */\n    dbactive = TRUE;\n    \n    if (mkey_password) {\n\tpwd.data = mkey_password;\n\tpwd.length = strlen(mkey_password);\n\tretval = krb5_principal2salt(util_context, master_princ, &scratch);\n\tif (retval) {\n\t    com_err(progname, retval, \"while calculated master key salt\");\n\t    return(1);\n\t}\n\n\t/* If no encryption type is set, use the default */\n\tif (master_keyblock.enctype == ENCTYPE_UNKNOWN) {\n\t    master_keyblock.enctype = DEFAULT_KDC_ENCTYPE;\n\t    if (!krb5_c_valid_enctype(master_keyblock.enctype))\n\t\tcom_err(progname, KRB5_PROG_KEYTYPE_NOSUPP,\n\t\t\t\"while setting up enctype %d\",\n\t\t\tmaster_keyblock.enctype);\n\t}\n\n\tretval = krb5_c_string_to_key(util_context, master_keyblock.enctype, \n\t\t\t\t      &pwd, &scratch, &master_keyblock);\n\tif (retval) {\n\t    com_err(progname, retval,\n\t\t    \"while transforming master key from password\");\n\t    return(1);\n\t}\n\tfree(scratch.data);\n\tmkey_password = 0;\n    } else if ((retval = krb5_db_fetch_mkey(util_context, master_princ, \n\t\t\t\t\t    master_keyblock.enctype,\n\t\t\t\t\t    manual_mkey, FALSE,\n\t\t\t\t\t    global_params.stash_file,\n\t\t\t\t\t    0, &master_keyblock))) {\n\tcom_err(progname, retval, \"while reading master key\");\n\tcom_err(progname, 0, \"Warning: proceeding without master key\");\n\texit_status++;\n\treturn(0);\n    }\n    if ((retval = krb5_db_verify_master_key(util_context, master_princ, \n\t\t\t\t\t    &master_keyblock))) {\n\tcom_err(progname, retval, \"while verifying master key\");\n\texit_status++;\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    seed.length = master_keyblock.length;\n    seed.data = master_keyblock.contents;\n\n    if ((retval = krb5_c_random_seed(util_context, &seed))) {\n\tcom_err(progname, retval, \"while seeding random number generator\");\n\texit_status++;\n\tmemset((char *)master_keyblock.contents, 0, master_keyblock.length);\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    valid_master_key = 1;\n    dbactive = TRUE;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "file_ok",
            "ok"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "file_ok",
            "file_name"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "progname",
            "ENOMEM",
            "\"while allocating filename for update_ok_file\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(file_name) + strlen(ok) + 1"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ok"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "file_name"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nextern int\t\texit_status;\n\nvoid update_ok_file (file_name)\n     char *file_name;\n{\n\t/* handle slave locking/failure stuff */\n\tchar *file_ok;\n\tint fd;\n\tstatic char ok[]=\".dump_ok\";\n\n\tif ((file_ok = (char *)malloc(strlen(file_name) + strlen(ok) + 1))\n\t    == NULL) {\n\t\tcom_err(progname, ENOMEM,\n\t\t\t\"while allocating filename for update_ok_file\");\n\t\texit_status++;\n\t\treturn;\n\t}\n\tstrcpy(file_ok, file_name);\n\tstrcat(file_ok, ok);\n\tif ((fd = open(file_ok, O_WRONLY|O_CREAT|O_TRUNC, 0600)) < 0) {\n\t\tcom_err(progname, errno, \"while creating 'ok' file, '%s'\",\n\t\t\tfile_ok);\n\t\texit_status++;\n\t\tfree(file_ok);\n\t\treturn;\n\t}\n\tif (write(fd, \"\", 1) != 1) {\n\t    com_err(progname, errno, \"while writing to 'ok' file, '%s'\",\n\t\t    file_ok);\n\t     exit_status++;\n\t     free(file_ok);\n\t     return;\n\t}\n\n\tfree(file_ok);\n\tclose(fd);\n\treturn;\n}"
  },
  {
    "function_name": "master_key_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
    "lines": "248-292",
    "snippet": "static krb5_error_code master_key_convert(context, db_entry)\n    krb5_context\t  context;\n    krb5_db_entry\t* db_entry;\n{\n    krb5_error_code\tretval;\n    krb5_keyblock \tv5plainkey, *key_ptr;\n    krb5_keysalt \tkeysalt;\n    int\t      i, j;\n    krb5_key_data\tnew_key_data, *key_data;\n    krb5_boolean\tis_mkey;\n\n    is_mkey = krb5_principal_compare(context, master_princ, db_entry->princ);\n\n    if (is_mkey && db_entry->n_key_data != 1)\n\t    fprintf(stderr,\n\t\t    \"Master key db entry has %d keys, expecting only 1!\\n\",\n\t\t    db_entry->n_key_data);\n    for (i=0; i < db_entry->n_key_data; i++) {\n\tkey_data = &db_entry->key_data[i];\n\tif (key_data->key_data_length == 0)\n\t    continue;\n\tretval = krb5_dbekd_decrypt_key_data(context, &master_keyblock,\n\t\t\t\t\t     key_data, &v5plainkey,\n\t\t\t\t\t     &keysalt);\n\tif (retval)\n\t\treturn retval;\n\n\tmemset(&new_key_data, 0, sizeof(new_key_data));\n\tkey_ptr = is_mkey ? &new_master_keyblock : &v5plainkey;\n\tretval = krb5_dbekd_encrypt_key_data(context, &new_master_keyblock,\n\t\t\t\t\t     key_ptr, &keysalt,\n\t\t\t\t\t     key_data->key_data_kvno,\n\t\t\t\t\t     &new_key_data);\n\tif (retval)\n\t\treturn retval;\n\tkrb5_free_keyblock_contents(context, &v5plainkey);\n\tfor (j = 0; j < key_data->key_data_ver; j++) {\n\t    if (key_data->key_data_length[j]) {\n\t\tfree(key_data->key_data_contents[j]);\n\t    }\n\t}\n\t*key_data = new_key_data;\n    }\n    return 0;\n}",
    "includes": [
      "#include <regexp.h>",
      "#include <regex.h>",
      "#include \"kdb5_util.h\"",
      "#include <com_err.h>",
      "#include <kadm5/adb.h>",
      "#include <kadm5/admin.h>",
      "#include <k5-int.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_keyblock\t\tnew_master_keyblock;",
      "static krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);",
      "static krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);",
      "static krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);",
      "static krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);",
      "static krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);",
      "static krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "key_data->key_data_contents[j]"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_keyblock_contents",
          "args": [
            "context",
            "&v5plainkey"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbekd_encrypt_key_data",
          "args": [
            "context",
            "&new_master_keyblock",
            "key_ptr",
            "&keysalt",
            "key_data->key_data_kvno",
            "&new_key_data"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new_key_data",
            "0",
            "sizeof(new_key_data)"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbekd_decrypt_key_data",
          "args": [
            "context",
            "&master_keyblock",
            "key_data",
            "&v5plainkey",
            "&keysalt"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Master key db entry has %d keys, expecting only 1!\\n\"",
            "db_entry->n_key_data"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principal_compare",
          "args": [
            "context",
            "master_princ",
            "db_entry->princ"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic krb5_keyblock\t\tnew_master_keyblock;\nstatic krb5_error_code dump_k5beta_iterator (krb5_pointer,\n\t\t\t\t\t     krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator (krb5_pointer,\n\t\t\t\t\t      krb5_db_entry *);\nstatic krb5_error_code dump_k5beta6_iterator_ext (krb5_pointer,\n\t\t\t\t\t\t  krb5_db_entry *,\n\t\t\t\t\t\t  int);\nstatic krb5_error_code dump_k5beta7_princ (krb5_pointer,\n\t\t\t\t\t   krb5_db_entry *);\nstatic krb5_error_code dump_k5beta7_princ_ext (krb5_pointer,\n\t\t\t\t\t       krb5_db_entry *,\n\t\t\t\t\t       int);\nstatic krb5_error_code dump_k5beta7_princ_withpolicy\n\t\t\t(krb5_pointer, krb5_db_entry *);\nstatic krb5_error_code dump_ov_princ (krb5_pointer,\n\t\t\t\t      krb5_db_entry *);\n\nstatic krb5_error_code master_key_convert(context, db_entry)\n    krb5_context\t  context;\n    krb5_db_entry\t* db_entry;\n{\n    krb5_error_code\tretval;\n    krb5_keyblock \tv5plainkey, *key_ptr;\n    krb5_keysalt \tkeysalt;\n    int\t      i, j;\n    krb5_key_data\tnew_key_data, *key_data;\n    krb5_boolean\tis_mkey;\n\n    is_mkey = krb5_principal_compare(context, master_princ, db_entry->princ);\n\n    if (is_mkey && db_entry->n_key_data != 1)\n\t    fprintf(stderr,\n\t\t    \"Master key db entry has %d keys, expecting only 1!\\n\",\n\t\t    db_entry->n_key_data);\n    for (i=0; i < db_entry->n_key_data; i++) {\n\tkey_data = &db_entry->key_data[i];\n\tif (key_data->key_data_length == 0)\n\t    continue;\n\tretval = krb5_dbekd_decrypt_key_data(context, &master_keyblock,\n\t\t\t\t\t     key_data, &v5plainkey,\n\t\t\t\t\t     &keysalt);\n\tif (retval)\n\t\treturn retval;\n\n\tmemset(&new_key_data, 0, sizeof(new_key_data));\n\tkey_ptr = is_mkey ? &new_master_keyblock : &v5plainkey;\n\tretval = krb5_dbekd_encrypt_key_data(context, &new_master_keyblock,\n\t\t\t\t\t     key_ptr, &keysalt,\n\t\t\t\t\t     key_data->key_data_kvno,\n\t\t\t\t\t     &new_key_data);\n\tif (retval)\n\t\treturn retval;\n\tkrb5_free_keyblock_contents(context, &v5plainkey);\n\tfor (j = 0; j < key_data->key_data_ver; j++) {\n\t    if (key_data->key_data_length[j]) {\n\t\tfree(key_data->key_data_contents[j]);\n\t    }\n\t}\n\t*key_data = new_key_data;\n    }\n    return 0;\n}"
  }
]