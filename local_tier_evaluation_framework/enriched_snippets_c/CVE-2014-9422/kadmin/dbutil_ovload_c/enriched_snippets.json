[
  {
    "function_name": "process_ov_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/ovload.c",
    "lines": "95-210",
    "snippet": "int process_ov_principal(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n    void *pol_db;\n{\n    XDR\t\t\t    xdrs;\n    osa_princ_ent_t\t    rec;\n    osa_adb_ret_t\t    ret;\n    krb5_tl_data\t    tl_data;\n    krb5_principal\t    princ;\n    krb5_db_entry\t    kdb;\n    char\t\t    *current;\n    char\t\t    *cp;\n    int\t\t\t    x, one;\n    krb5_boolean\t    more;\n    char\t\t    line[LINESIZE];\n\n    if (fgets(line, LINESIZE, filep) == (char *) NULL) {\n\t return IMPORT_BAD_FILE;\n    }\n    if((cp = nstrtok(line, \"\\t\")) == NULL)\n\treturn IMPORT_BAD_FILE;\n    if((rec = (osa_princ_ent_t) malloc(sizeof(osa_princ_ent_rec))) == NULL)\n\treturn ENOMEM;\n    memset(rec, 0, sizeof(osa_princ_ent_rec));\n    if((ret = krb5_parse_name(kcontext, cp, &princ))) \n\tgoto done;\n    krb5_unparse_name(kcontext, princ, &current);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret =  IMPORT_FAILED;\n\tgoto done;\n    } else {\n\tif(strcmp(cp, \"\")) {\n\t    if((rec->policy = (char *) malloc(strlen(cp)+1)) == NULL)  {\n\t\tret = ENOMEM;\n\t\tgoto done;\n\t    }\n\t    strcpy(rec->policy, cp);\n\t} else rec->policy = NULL;\n    }\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->aux_attributes = strtol(cp, (char  **)NULL, 16);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->old_key_len = atoi(cp);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->old_key_next = atoi(cp);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->admin_history_kvno = atoi(cp);\n    if (! rec->old_key_len) {\n       rec->old_keys = NULL;\n    } else {\n       if(!(rec->old_keys = (osa_pw_hist_ent *)\n\t    malloc(sizeof(osa_pw_hist_ent) * rec->old_key_len))) {\n\t  ret = ENOMEM;\n\t  goto done;\n       }\n       memset(rec->old_keys,0,\n\t      sizeof(osa_pw_hist_ent) * rec->old_key_len);\n       for(x = 0; x < rec->old_key_len; x++)\n\t    parse_pw_hist_ent(current, &rec->old_keys[x]);\n    }\n\n    xdralloc_create(&xdrs, XDR_ENCODE);\n    if (! xdr_osa_princ_ent_rec(&xdrs, rec)) {\n\t xdr_destroy(&xdrs);\n\t ret = OSA_ADB_XDR_FAILURE;\n\t goto done;\n    }\n\n    tl_data.tl_data_type = KRB5_TL_KADM_DATA;\n    tl_data.tl_data_length = xdr_getpos(&xdrs);\n    tl_data.tl_data_contents = (krb5_octet *) xdralloc_getdata(&xdrs);\n\n    one = 1;\n    ret = krb5_db_get_principal(kcontext, princ, &kdb, &one, &more);\n    if (ret)\n\t goto done;\n    \n    ret = krb5_dbe_update_tl_data(kcontext, &kdb, &tl_data);\n    if (ret)\n\t goto done;\n\n    ret = krb5_db_put_principal(kcontext, &kdb, &one);\n    if (ret)\n\t goto done;\n\n    xdr_destroy(&xdrs);\n\n    (*linenop)++;\n\ndone:\n    free(current);\n    krb5_free_principal(kcontext, princ);\n    osa_free_princ_ent(rec);\n    return ret;\n}",
    "includes": [
      "#include    \"nstrtok.h\"",
      "#include    \"kdb5_util.h\"",
      "#include    \"import_err.h\"",
      "#include    <kadm5/adb.h>",
      "#include    <memory.h>",
      "#include    <stdlib.h>",
      "#include    <string.h>",
      "#include    <unistd.h>"
    ],
    "macros_used": [
      "#define LINESIZE\t32768 /* XXX */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "osa_free_princ_ent",
          "args": [
            "rec"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "kcontext",
            "princ"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "current"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdrs"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_put_principal",
          "args": [
            "kcontext",
            "&kdb",
            "&one"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_update_tl_data",
          "args": [
            "kcontext",
            "&kdb",
            "&tl_data"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_get_principal",
          "args": [
            "kcontext",
            "princ",
            "&kdb",
            "&one",
            "&more"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdralloc_getdata",
          "args": [
            "&xdrs"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_getpos",
          "args": [
            "&xdrs"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_destroy",
          "args": [
            "&xdrs"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_osa_princ_ent_rec",
          "args": [
            "&xdrs",
            "rec"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdralloc_create",
          "args": [
            "&xdrs",
            "XDR_ENCODE"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_pw_hist_ent",
          "args": [
            "current",
            "&rec->old_keys[x]"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "parse_pw_hist_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/ovload.c",
          "lines": "16-74",
          "snippet": "static int parse_pw_hist_ent(current, hist)\n   char *current;\n   osa_pw_hist_ent *hist;\n{\n     int tmp, i, j, ret;\n     char *cp;\n\n     ret = 0;\n     hist->n_key_data = 1;\n\n     hist->key_data = (krb5_key_data *) malloc(hist->n_key_data *\n\t\t\t\t\t       sizeof(krb5_key_data));\n     if (hist->key_data == NULL)\n\t  return ENOMEM;\n     memset(hist->key_data, 0, sizeof(krb5_key_data)*hist->n_key_data);\n\n     for (i = 0; i < hist->n_key_data; i++) {\n\t  krb5_key_data *key_data = &hist->key_data[i];\n\n\t  key_data->key_data_ver = 1;\n\t  \n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret = IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  key_data->key_data_type[0] = atoi(cp);\n\n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret =  IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  key_data->key_data_length[0] = atoi(cp);\n\t  \n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret = IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  if(!(key_data->key_data_contents[0] =\n\t       (krb5_octet *) malloc(key_data->key_data_length[0]+1))) {\n\t       ret = ENOMEM;\n\t       goto done;\n\t  }\n\t  for(j = 0; j < key_data->key_data_length[0]; j++) {\n\t       if(sscanf(cp, \"%02x\", &tmp) != 1) {\n\t\t    com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t\t    ret = IMPORT_FAILED;\n\t\t    goto done;\n\t       }\n\t       key_data->key_data_contents[0][j] = tmp;\n\t       cp = strchr(cp, ' ') + 1;\n\t  }\n     }\n     \ndone:\n     return ret;\n}",
          "includes": [
            "#include    \"nstrtok.h\"",
            "#include    \"kdb5_util.h\"",
            "#include    \"import_err.h\"",
            "#include    <kadm5/adb.h>",
            "#include    <memory.h>",
            "#include    <stdlib.h>",
            "#include    <string.h>",
            "#include    <unistd.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include    \"nstrtok.h\"\n#include    \"kdb5_util.h\"\n#include    \"import_err.h\"\n#include    <kadm5/adb.h>\n#include    <memory.h>\n#include    <stdlib.h>\n#include    <string.h>\n#include    <unistd.h>\n\nstatic int parse_pw_hist_ent(current, hist)\n   char *current;\n   osa_pw_hist_ent *hist;\n{\n     int tmp, i, j, ret;\n     char *cp;\n\n     ret = 0;\n     hist->n_key_data = 1;\n\n     hist->key_data = (krb5_key_data *) malloc(hist->n_key_data *\n\t\t\t\t\t       sizeof(krb5_key_data));\n     if (hist->key_data == NULL)\n\t  return ENOMEM;\n     memset(hist->key_data, 0, sizeof(krb5_key_data)*hist->n_key_data);\n\n     for (i = 0; i < hist->n_key_data; i++) {\n\t  krb5_key_data *key_data = &hist->key_data[i];\n\n\t  key_data->key_data_ver = 1;\n\t  \n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret = IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  key_data->key_data_type[0] = atoi(cp);\n\n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret =  IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  key_data->key_data_length[0] = atoi(cp);\n\t  \n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret = IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  if(!(key_data->key_data_contents[0] =\n\t       (krb5_octet *) malloc(key_data->key_data_length[0]+1))) {\n\t       ret = ENOMEM;\n\t       goto done;\n\t  }\n\t  for(j = 0; j < key_data->key_data_length[0]; j++) {\n\t       if(sscanf(cp, \"%02x\", &tmp) != 1) {\n\t\t    com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t\t    ret = IMPORT_FAILED;\n\t\t    goto done;\n\t       }\n\t       key_data->key_data_contents[0][j] = tmp;\n\t       cp = strchr(cp, ' ') + 1;\n\t  }\n     }\n     \ndone:\n     return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rec->old_keys",
            "0",
            "sizeof(osa_pw_hist_ent) * rec->old_key_len"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(osa_pw_hist_ent) * rec->old_key_len"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "cp"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "NULL",
            "IMPORT_BAD_RECORD",
            "\"%s\"",
            "current"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nstrtok",
          "args": [
            "(char *) NULL",
            "\"\\t\""
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "cp"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "NULL",
            "IMPORT_BAD_RECORD",
            "\"%s\"",
            "current"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nstrtok",
          "args": [
            "(char *) NULL",
            "\"\\t\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "cp"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "NULL",
            "IMPORT_BAD_RECORD",
            "\"%s\"",
            "current"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nstrtok",
          "args": [
            "(char *) NULL",
            "\"\\t\""
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "cp",
            "(char  **)NULL",
            "16"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "NULL",
            "IMPORT_BAD_RECORD",
            "\"%s\"",
            "current"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nstrtok",
          "args": [
            "(char *) NULL",
            "\"\\t\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "rec->policy",
            "cp"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(cp)+1"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cp",
            "\"\""
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "NULL",
            "IMPORT_BAD_RECORD",
            "\"%s\"",
            "current"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nstrtok",
          "args": [
            "(char *) NULL",
            "\"\\t\""
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "kcontext",
            "princ",
            "&current"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "kcontext",
            "cp",
            "&princ"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rec",
            "0",
            "sizeof(osa_princ_ent_rec)"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(osa_princ_ent_rec)"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nstrtok",
          "args": [
            "line",
            "\"\\t\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "line",
            "LINESIZE",
            "filep"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"nstrtok.h\"\n#include    \"kdb5_util.h\"\n#include    \"import_err.h\"\n#include    <kadm5/adb.h>\n#include    <memory.h>\n#include    <stdlib.h>\n#include    <string.h>\n#include    <unistd.h>\n\n#define LINESIZE\t32768 /* XXX */\n\nint process_ov_principal(fname, kcontext, filep, verbose, linenop, pol_db)\n    char\t\t*fname;\n    krb5_context\tkcontext;\n    FILE\t\t*filep;\n    int\t\t\tverbose;\n    int\t\t\t*linenop;\n    void *pol_db;\n{\n    XDR\t\t\t    xdrs;\n    osa_princ_ent_t\t    rec;\n    osa_adb_ret_t\t    ret;\n    krb5_tl_data\t    tl_data;\n    krb5_principal\t    princ;\n    krb5_db_entry\t    kdb;\n    char\t\t    *current;\n    char\t\t    *cp;\n    int\t\t\t    x, one;\n    krb5_boolean\t    more;\n    char\t\t    line[LINESIZE];\n\n    if (fgets(line, LINESIZE, filep) == (char *) NULL) {\n\t return IMPORT_BAD_FILE;\n    }\n    if((cp = nstrtok(line, \"\\t\")) == NULL)\n\treturn IMPORT_BAD_FILE;\n    if((rec = (osa_princ_ent_t) malloc(sizeof(osa_princ_ent_rec))) == NULL)\n\treturn ENOMEM;\n    memset(rec, 0, sizeof(osa_princ_ent_rec));\n    if((ret = krb5_parse_name(kcontext, cp, &princ))) \n\tgoto done;\n    krb5_unparse_name(kcontext, princ, &current);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret =  IMPORT_FAILED;\n\tgoto done;\n    } else {\n\tif(strcmp(cp, \"\")) {\n\t    if((rec->policy = (char *) malloc(strlen(cp)+1)) == NULL)  {\n\t\tret = ENOMEM;\n\t\tgoto done;\n\t    }\n\t    strcpy(rec->policy, cp);\n\t} else rec->policy = NULL;\n    }\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->aux_attributes = strtol(cp, (char  **)NULL, 16);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->old_key_len = atoi(cp);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->old_key_next = atoi(cp);\n    if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\tcom_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\tret = IMPORT_FAILED;\n\tgoto done;\n    }\n    rec->admin_history_kvno = atoi(cp);\n    if (! rec->old_key_len) {\n       rec->old_keys = NULL;\n    } else {\n       if(!(rec->old_keys = (osa_pw_hist_ent *)\n\t    malloc(sizeof(osa_pw_hist_ent) * rec->old_key_len))) {\n\t  ret = ENOMEM;\n\t  goto done;\n       }\n       memset(rec->old_keys,0,\n\t      sizeof(osa_pw_hist_ent) * rec->old_key_len);\n       for(x = 0; x < rec->old_key_len; x++)\n\t    parse_pw_hist_ent(current, &rec->old_keys[x]);\n    }\n\n    xdralloc_create(&xdrs, XDR_ENCODE);\n    if (! xdr_osa_princ_ent_rec(&xdrs, rec)) {\n\t xdr_destroy(&xdrs);\n\t ret = OSA_ADB_XDR_FAILURE;\n\t goto done;\n    }\n\n    tl_data.tl_data_type = KRB5_TL_KADM_DATA;\n    tl_data.tl_data_length = xdr_getpos(&xdrs);\n    tl_data.tl_data_contents = (krb5_octet *) xdralloc_getdata(&xdrs);\n\n    one = 1;\n    ret = krb5_db_get_principal(kcontext, princ, &kdb, &one, &more);\n    if (ret)\n\t goto done;\n    \n    ret = krb5_dbe_update_tl_data(kcontext, &kdb, &tl_data);\n    if (ret)\n\t goto done;\n\n    ret = krb5_db_put_principal(kcontext, &kdb, &one);\n    if (ret)\n\t goto done;\n\n    xdr_destroy(&xdrs);\n\n    (*linenop)++;\n\ndone:\n    free(current);\n    krb5_free_principal(kcontext, princ);\n    osa_free_princ_ent(rec);\n    return ret;\n}"
  },
  {
    "function_name": "parse_pw_hist_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/ovload.c",
    "lines": "16-74",
    "snippet": "static int parse_pw_hist_ent(current, hist)\n   char *current;\n   osa_pw_hist_ent *hist;\n{\n     int tmp, i, j, ret;\n     char *cp;\n\n     ret = 0;\n     hist->n_key_data = 1;\n\n     hist->key_data = (krb5_key_data *) malloc(hist->n_key_data *\n\t\t\t\t\t       sizeof(krb5_key_data));\n     if (hist->key_data == NULL)\n\t  return ENOMEM;\n     memset(hist->key_data, 0, sizeof(krb5_key_data)*hist->n_key_data);\n\n     for (i = 0; i < hist->n_key_data; i++) {\n\t  krb5_key_data *key_data = &hist->key_data[i];\n\n\t  key_data->key_data_ver = 1;\n\t  \n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret = IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  key_data->key_data_type[0] = atoi(cp);\n\n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret =  IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  key_data->key_data_length[0] = atoi(cp);\n\t  \n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret = IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  if(!(key_data->key_data_contents[0] =\n\t       (krb5_octet *) malloc(key_data->key_data_length[0]+1))) {\n\t       ret = ENOMEM;\n\t       goto done;\n\t  }\n\t  for(j = 0; j < key_data->key_data_length[0]; j++) {\n\t       if(sscanf(cp, \"%02x\", &tmp) != 1) {\n\t\t    com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t\t    ret = IMPORT_FAILED;\n\t\t    goto done;\n\t       }\n\t       key_data->key_data_contents[0][j] = tmp;\n\t       cp = strchr(cp, ' ') + 1;\n\t  }\n     }\n     \ndone:\n     return ret;\n}",
    "includes": [
      "#include    \"nstrtok.h\"",
      "#include    \"kdb5_util.h\"",
      "#include    \"import_err.h\"",
      "#include    <kadm5/adb.h>",
      "#include    <memory.h>",
      "#include    <stdlib.h>",
      "#include    <string.h>",
      "#include    <unistd.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "' '"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "NULL",
            "IMPORT_BAD_RECORD",
            "\"%s\"",
            "current"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cp",
            "\"%02x\"",
            "&tmp"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "key_data->key_data_length[0]+1"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "NULL",
            "IMPORT_BAD_RECORD",
            "\"%s\"",
            "current"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nstrtok",
          "args": [
            "(char *) NULL",
            "\"\\t\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "cp"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "NULL",
            "IMPORT_BAD_RECORD",
            "\"%s\"",
            "current"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nstrtok",
          "args": [
            "(char *) NULL",
            "\"\\t\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "cp"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "NULL",
            "IMPORT_BAD_RECORD",
            "\"%s\"",
            "current"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nstrtok",
          "args": [
            "(char *) NULL",
            "\"\\t\""
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "hist->key_data",
            "0",
            "sizeof(krb5_key_data)*hist->n_key_data"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "hist->n_key_data *\n\t\t\t\t\t       sizeof(krb5_key_data)"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"nstrtok.h\"\n#include    \"kdb5_util.h\"\n#include    \"import_err.h\"\n#include    <kadm5/adb.h>\n#include    <memory.h>\n#include    <stdlib.h>\n#include    <string.h>\n#include    <unistd.h>\n\nstatic int parse_pw_hist_ent(current, hist)\n   char *current;\n   osa_pw_hist_ent *hist;\n{\n     int tmp, i, j, ret;\n     char *cp;\n\n     ret = 0;\n     hist->n_key_data = 1;\n\n     hist->key_data = (krb5_key_data *) malloc(hist->n_key_data *\n\t\t\t\t\t       sizeof(krb5_key_data));\n     if (hist->key_data == NULL)\n\t  return ENOMEM;\n     memset(hist->key_data, 0, sizeof(krb5_key_data)*hist->n_key_data);\n\n     for (i = 0; i < hist->n_key_data; i++) {\n\t  krb5_key_data *key_data = &hist->key_data[i];\n\n\t  key_data->key_data_ver = 1;\n\t  \n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret = IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  key_data->key_data_type[0] = atoi(cp);\n\n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret =  IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  key_data->key_data_length[0] = atoi(cp);\n\t  \n\t  if((cp = nstrtok((char *) NULL, \"\\t\")) == NULL) {\n\t       com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t       ret = IMPORT_FAILED;\n\t       goto done;\n\t  }\n\t  if(!(key_data->key_data_contents[0] =\n\t       (krb5_octet *) malloc(key_data->key_data_length[0]+1))) {\n\t       ret = ENOMEM;\n\t       goto done;\n\t  }\n\t  for(j = 0; j < key_data->key_data_length[0]; j++) {\n\t       if(sscanf(cp, \"%02x\", &tmp) != 1) {\n\t\t    com_err(NULL, IMPORT_BAD_RECORD, \"%s\", current);\n\t\t    ret = IMPORT_FAILED;\n\t\t    goto done;\n\t       }\n\t       key_data->key_data_contents[0][j] = tmp;\n\t       cp = strchr(cp, ' ') + 1;\n\t  }\n     }\n     \ndone:\n     return ret;\n}"
  }
]