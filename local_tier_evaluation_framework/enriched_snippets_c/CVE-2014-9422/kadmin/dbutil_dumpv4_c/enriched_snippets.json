[
  {
    "function_name": "dump_v4db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dumpv4.c",
    "lines": "456-461",
    "snippet": "void dump_v4db(argc, argv)\n\tint\targc;\n\tchar\t**argv;\n{\n\tprintf(\"This version of krb5_edit does not support the V4 dump command.\\n\");\n}",
    "includes": [
      "#include \"kdb5_util.h\"",
      "#include <kadm5/admin.h>",
      "#include <stdio.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"This version of krb5_edit does not support the V4 dump command.\\n\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb5_util.h\"\n#include <kadm5/admin.h>\n#include <stdio.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nvoid dump_v4db(argc, argv)\n\tint\targc;\n\tchar\t**argv;\n{\n\tprintf(\"This version of krb5_edit does not support the V4 dump command.\\n\");\n}"
  },
  {
    "function_name": "handle_one_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dumpv4.c",
    "lines": "422-453",
    "snippet": "static krb5_error_code\nhandle_one_key(arg, v5mkey, v5key, v4key)\n    struct dump_record *arg;\n    krb5_keyblock *v5mkey;\n    krb5_key_data *v5key;\n    des_cblock v4key;\n{\n    krb5_error_code retval;\n\n    krb5_keyblock v5plainkey;\n    /* v4key is the actual v4 key from the file. */\n\n    retval = krb5_dbekd_decrypt_key_data(util_context, v5mkey, v5key, \n\t\t\t\t\t &v5plainkey, NULL);\n    if (retval) \n\treturn retval;\n\n    memcpy(v4key, v5plainkey.contents, sizeof(des_cblock));\n#ifndef\tKDB4_DISABLE\n    kdb_encrypt_key (v4key, v4key, \n\t\t     arg->v4_master_key, arg->v4_master_key_schedule, \n\t\t     ENCRYPT);\n#else\t/* KDB4_DISABLE */\n    pcbc_encrypt((C_Block *) v4key,\n\t\t (C_Block *) v4key,\n\t\t (long) sizeof(C_Block),\n\t\t arg->v4_master_key_schedule,\n\t\t (C_Block *) arg->v4_master_key,\n\t\t ENCRYPT);\n#endif\t/* KDB4_DISABLE */\n    return 0;\n}",
    "includes": [
      "#include \"kdb5_util.h\"",
      "#include <kadm5/admin.h>",
      "#include <stdio.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pcbc_encrypt",
          "args": [
            "(C_Block *) v4key",
            "(C_Block *) v4key",
            "(long) sizeof(C_Block)",
            "arg->v4_master_key_schedule",
            "(C_Block *) arg->v4_master_key",
            "ENCRYPT"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_encrypt_key",
          "args": [
            "v4key",
            "v4key",
            "arg->v4_master_key",
            "arg->v4_master_key_schedule",
            "ENCRYPT"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "v4key",
            "v5plainkey.contents",
            "sizeof(des_cblock)"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbekd_decrypt_key_data",
          "args": [
            "util_context",
            "v5mkey",
            "v5key",
            "&v5plainkey",
            "NULL"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb5_util.h\"\n#include <kadm5/admin.h>\n#include <stdio.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code\nhandle_one_key(arg, v5mkey, v5key, v4key)\n    struct dump_record *arg;\n    krb5_keyblock *v5mkey;\n    krb5_key_data *v5key;\n    des_cblock v4key;\n{\n    krb5_error_code retval;\n\n    krb5_keyblock v5plainkey;\n    /* v4key is the actual v4 key from the file. */\n\n    retval = krb5_dbekd_decrypt_key_data(util_context, v5mkey, v5key, \n\t\t\t\t\t &v5plainkey, NULL);\n    if (retval) \n\treturn retval;\n\n    memcpy(v4key, v5plainkey.contents, sizeof(des_cblock));\n#ifndef\tKDB4_DISABLE\n    kdb_encrypt_key (v4key, v4key, \n\t\t     arg->v4_master_key, arg->v4_master_key_schedule, \n\t\t     ENCRYPT);\n#else\t/* KDB4_DISABLE */\n    pcbc_encrypt((C_Block *) v4key,\n\t\t (C_Block *) v4key,\n\t\t (long) sizeof(C_Block),\n\t\t arg->v4_master_key_schedule,\n\t\t (C_Block *) arg->v4_master_key,\n\t\t ENCRYPT);\n#endif\t/* KDB4_DISABLE */\n    return 0;\n}"
  },
  {
    "function_name": "handle_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dumpv4.c",
    "lines": "387-420",
    "snippet": "static int handle_keys(arg)\n    struct dump_record *arg;\n{\n    krb5_error_code retval;\n    char *defrealm;\n    char *mkey_name = 0;\n    char *mkey_fullname;\n    krb5_principal l_master_princ;\n\n    if ((retval = krb5_get_default_realm(util_context, &defrealm))) {\n      com_err(arg->comerr_name, retval, \n\t      \"while retrieving default realm name\");\n      exit(1);\n    }\t    \n    arg->realm = defrealm;\n\n    /* assemble & parse the master key name */\n\n    if ((retval = krb5_db_setup_mkey_name(util_context, mkey_name, arg->realm, \n\t\t\t\t\t  &mkey_fullname, &l_master_princ))) {\n\tcom_err(arg->comerr_name, retval, \"while setting up master key name\");\n\texit(1);\n    }\n\n    if ((retval = krb5_db_fetch_mkey(util_context, l_master_princ, \n\t\t\t\t     master_keyblock.enctype, 0,\n\t\t\t\t     0, global_params.stash_file, 0,\n\t\t\t\t     &master_keyblock))) { \n\tcom_err(arg->comerr_name, retval, \"while reading master key\");\n\texit(1);\n    }\n    arg->v5mkey = &master_keyblock;\n    return(0);\n}",
    "includes": [
      "#include \"kdb5_util.h\"",
      "#include <kadm5/admin.h>",
      "#include <stdio.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "arg->comerr_name",
            "retval",
            "\"while reading master key\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_fetch_mkey",
          "args": [
            "util_context",
            "l_master_princ",
            "master_keyblock.enctype",
            "0",
            "0",
            "global_params.stash_file",
            "0",
            "&master_keyblock"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "arg->comerr_name",
            "retval",
            "\"while setting up master key name\""
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_setup_mkey_name",
          "args": [
            "util_context",
            "mkey_name",
            "arg->realm",
            "&mkey_fullname",
            "&l_master_princ"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "arg->comerr_name",
            "retval",
            "\"while retrieving default realm name\""
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_get_default_realm",
          "args": [
            "util_context",
            "&defrealm"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb5_util.h\"\n#include <kadm5/admin.h>\n#include <stdio.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic int handle_keys(arg)\n    struct dump_record *arg;\n{\n    krb5_error_code retval;\n    char *defrealm;\n    char *mkey_name = 0;\n    char *mkey_fullname;\n    krb5_principal l_master_princ;\n\n    if ((retval = krb5_get_default_realm(util_context, &defrealm))) {\n      com_err(arg->comerr_name, retval, \n\t      \"while retrieving default realm name\");\n      exit(1);\n    }\t    \n    arg->realm = defrealm;\n\n    /* assemble & parse the master key name */\n\n    if ((retval = krb5_db_setup_mkey_name(util_context, mkey_name, arg->realm, \n\t\t\t\t\t  &mkey_fullname, &l_master_princ))) {\n\tcom_err(arg->comerr_name, retval, \"while setting up master key name\");\n\texit(1);\n    }\n\n    if ((retval = krb5_db_fetch_mkey(util_context, l_master_princ, \n\t\t\t\t     master_keyblock.enctype, 0,\n\t\t\t\t     0, global_params.stash_file, 0,\n\t\t\t\t     &master_keyblock))) { \n\tcom_err(arg->comerr_name, retval, \"while reading master key\");\n\texit(1);\n    }\n    arg->v5mkey = &master_keyblock;\n    return(0);\n}"
  },
  {
    "function_name": "dump_v4db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dumpv4.c",
    "lines": "288-385",
    "snippet": "void dump_v4db(argc, argv)\n\tint\targc;\n\tchar\t**argv;\n{\n\tint\ti;\n\tchar\t*outname = NULL;\n\tFILE\t*f;\n\tstruct dump_record\targ;\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-S\")) {\n\t\t\tshortlife++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (argc - i > 1) {\n\t\tcom_err(argv[0], 0, \"Usage: %s [-S] filename\", argv[0]);\n\t\texit_status++;\n\t\treturn;\n\t}\n\tif (!dbactive) {\n\t\tcom_err(argv[0], 0, Err_no_database);\n\t\texit_status++;\n\t\treturn;\n\t}\n\tif (argc - i == 1) {\n\t\toutname = argv[i];\n\t\t/*\n\t\t * Make sure that we don't open and truncate on the fopen,\n\t\t * since that may hose an on-going kprop process.\n\t\t * \n\t\t * We could also control this by opening for read and\n\t\t * write, doing an flock with LOCK_EX, and then\n\t\t * truncating the file once we have gotten the lock,\n\t\t * but that would involve more OS dependancies than I\n\t\t * want to get into.\n\t\t */\n\t\tunlink(outname);\n\t\tif (!(f = fopen(outname, \"w\"))) {\n\t\t\tcom_err(argv[0], errno,\n\t\t\t\t\"While opening file %s for writing\", outname);\n\t\t\texit_status++;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tf = stdout;\n\t}\n\n\targ.comerr_name = argv[0];\n\targ.f = f;\n\tv4init(&arg, 0);\n\thandle_keys(&arg);\n\n\t/* special handling for K.M since it isn't preserved */\n\t{\n\t  des_cblock v4key;\n\t  int i2;\n\n\t  /* assume:\n\t     max lifetime (255)\n\t     key version == 1 (actually, should be whatever the v5 one is)\n\t     master key version == key version\n\t     args == 0 (none are preserved)\n\t     expiration date is the default 2000\n\t     last mod time is near zero (arbitrarily.)\n\t     creator is db_creation *\n\t     */\n\n\t  fprintf(f,\"K M 255 1 1 0 \");\n\t  \n#ifndef\tKDB4_DISABLE\n\t  kdb_encrypt_key (arg.v4_master_key, v4key, \n\t\t\t   arg.v4_master_key, arg.v4_master_key_schedule, \n\t\t\t   ENCRYPT);\n#else\t/* KDB4_DISABLE */\n\t  pcbc_encrypt((C_Block *) arg.v4_master_key,\n\t\t       (C_Block *) v4key,\n\t\t       (long) sizeof(C_Block),\n\t\t       arg.v4_master_key_schedule,\n\t\t       (C_Block *) arg.v4_master_key,\n\t\t       ENCRYPT);\n#endif\t/* KDB4_DISABLE */\n\n\t  for (i2=0; i2<8; i2++) {\n\t    fprintf(f, \"%02x\", ((unsigned char*)v4key)[i2]);\n\t    if (i2 == 3) fputc(' ', f);\n\t  }\n\t  fprintf(f,\" 200001010459 197001020000 db_creation *\\n\");\n\t}\n\n\t(void) krb5_db_iterate(util_context, dump_v4_iterator, \n\t\t\t       (krb5_pointer) &arg);\n\tif (argc == 2)\n\t\tfclose(f);\n\tif (outname)\n\t\tupdate_ok_file(outname);\n}",
    "includes": [
      "#include \"kdb5_util.h\"",
      "#include <kadm5/admin.h>",
      "#include <stdio.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_ok_file",
          "args": [
            "outname"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "update_ok_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "297-332",
          "snippet": "void update_ok_file (file_name)\n     char *file_name;\n{\n\t/* handle slave locking/failure stuff */\n\tchar *file_ok;\n\tint fd;\n\tstatic char ok[]=\".dump_ok\";\n\n\tif ((file_ok = (char *)malloc(strlen(file_name) + strlen(ok) + 1))\n\t    == NULL) {\n\t\tcom_err(progname, ENOMEM,\n\t\t\t\"while allocating filename for update_ok_file\");\n\t\texit_status++;\n\t\treturn;\n\t}\n\tstrcpy(file_ok, file_name);\n\tstrcat(file_ok, ok);\n\tif ((fd = open(file_ok, O_WRONLY|O_CREAT|O_TRUNC, 0600)) < 0) {\n\t\tcom_err(progname, errno, \"while creating 'ok' file, '%s'\",\n\t\t\tfile_ok);\n\t\texit_status++;\n\t\tfree(file_ok);\n\t\treturn;\n\t}\n\tif (write(fd, \"\", 1) != 1) {\n\t    com_err(progname, errno, \"while writing to 'ok' file, '%s'\",\n\t\t    file_ok);\n\t     exit_status++;\n\t     free(file_ok);\n\t     return;\n\t}\n\n\tfree(file_ok);\n\tclose(fd);\n\treturn;\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int\t\texit_status;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nextern int\t\texit_status;\n\nvoid update_ok_file (file_name)\n     char *file_name;\n{\n\t/* handle slave locking/failure stuff */\n\tchar *file_ok;\n\tint fd;\n\tstatic char ok[]=\".dump_ok\";\n\n\tif ((file_ok = (char *)malloc(strlen(file_name) + strlen(ok) + 1))\n\t    == NULL) {\n\t\tcom_err(progname, ENOMEM,\n\t\t\t\"while allocating filename for update_ok_file\");\n\t\texit_status++;\n\t\treturn;\n\t}\n\tstrcpy(file_ok, file_name);\n\tstrcat(file_ok, ok);\n\tif ((fd = open(file_ok, O_WRONLY|O_CREAT|O_TRUNC, 0600)) < 0) {\n\t\tcom_err(progname, errno, \"while creating 'ok' file, '%s'\",\n\t\t\tfile_ok);\n\t\texit_status++;\n\t\tfree(file_ok);\n\t\treturn;\n\t}\n\tif (write(fd, \"\", 1) != 1) {\n\t    com_err(progname, errno, \"while writing to 'ok' file, '%s'\",\n\t\t    file_ok);\n\t     exit_status++;\n\t     free(file_ok);\n\t     return;\n\t}\n\n\tfree(file_ok);\n\tclose(fd);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "f"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_iterate",
          "args": [
            "util_context",
            "dump_v4_iterator",
            "(krb5_pointer) &arg"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\" 200001010459 197001020000 db_creation *\\n\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "' '",
            "f"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"%02x\"",
            "((unsigned char*)v4key)[i2]"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcbc_encrypt",
          "args": [
            "(C_Block *) arg.v4_master_key",
            "(C_Block *) v4key",
            "(long) sizeof(C_Block)",
            "arg.v4_master_key_schedule",
            "(C_Block *) arg.v4_master_key",
            "ENCRYPT"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_encrypt_key",
          "args": [
            "arg.v4_master_key",
            "v4key",
            "arg.v4_master_key",
            "arg.v4_master_key_schedule",
            "ENCRYPT"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "f",
            "\"K M 255 1 1 0 \""
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_keys",
          "args": [
            "&arg"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "handle_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dumpv4.c",
          "lines": "387-420",
          "snippet": "static int handle_keys(arg)\n    struct dump_record *arg;\n{\n    krb5_error_code retval;\n    char *defrealm;\n    char *mkey_name = 0;\n    char *mkey_fullname;\n    krb5_principal l_master_princ;\n\n    if ((retval = krb5_get_default_realm(util_context, &defrealm))) {\n      com_err(arg->comerr_name, retval, \n\t      \"while retrieving default realm name\");\n      exit(1);\n    }\t    \n    arg->realm = defrealm;\n\n    /* assemble & parse the master key name */\n\n    if ((retval = krb5_db_setup_mkey_name(util_context, mkey_name, arg->realm, \n\t\t\t\t\t  &mkey_fullname, &l_master_princ))) {\n\tcom_err(arg->comerr_name, retval, \"while setting up master key name\");\n\texit(1);\n    }\n\n    if ((retval = krb5_db_fetch_mkey(util_context, l_master_princ, \n\t\t\t\t     master_keyblock.enctype, 0,\n\t\t\t\t     0, global_params.stash_file, 0,\n\t\t\t\t     &master_keyblock))) { \n\tcom_err(arg->comerr_name, retval, \"while reading master key\");\n\texit(1);\n    }\n    arg->v5mkey = &master_keyblock;\n    return(0);\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <kadm5/admin.h>",
            "#include <stdio.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <kadm5/admin.h>\n#include <stdio.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic int handle_keys(arg)\n    struct dump_record *arg;\n{\n    krb5_error_code retval;\n    char *defrealm;\n    char *mkey_name = 0;\n    char *mkey_fullname;\n    krb5_principal l_master_princ;\n\n    if ((retval = krb5_get_default_realm(util_context, &defrealm))) {\n      com_err(arg->comerr_name, retval, \n\t      \"while retrieving default realm name\");\n      exit(1);\n    }\t    \n    arg->realm = defrealm;\n\n    /* assemble & parse the master key name */\n\n    if ((retval = krb5_db_setup_mkey_name(util_context, mkey_name, arg->realm, \n\t\t\t\t\t  &mkey_fullname, &l_master_princ))) {\n\tcom_err(arg->comerr_name, retval, \"while setting up master key name\");\n\texit(1);\n    }\n\n    if ((retval = krb5_db_fetch_mkey(util_context, l_master_princ, \n\t\t\t\t     master_keyblock.enctype, 0,\n\t\t\t\t     0, global_params.stash_file, 0,\n\t\t\t\t     &master_keyblock))) { \n\tcom_err(arg->comerr_name, retval, \"while reading master key\");\n\texit(1);\n    }\n    arg->v5mkey = &master_keyblock;\n    return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "v4init",
          "args": [
            "&arg",
            "0"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "v4init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dumpv4.c",
          "lines": "98-122",
          "snippet": "static int\nv4init(arg, manual)\n    struct dump_record *arg;\n    int manual;\n{\n    int fd;\n    int ok = 0;\n\n    if (!manual) {\n\tfd = open(v4_mkeyfile, O_RDONLY, 0600);\n\tif (fd >= 0) {\n\t    if (read(fd,arg->v4_master_key,sizeof(C_Block)) == sizeof(C_Block))\n\t\tok = 1;\n\t    close(fd);\n\t}\n    }\n    if (!ok) {\n\tdes_read_password(&arg->v4_master_key, \"V4 Kerberos master key\", 1);\n\tprintf(\"\\n\");\n    }\n    arg->master_key_version = 1;\n    key_sched(arg->v4_master_key, arg->v4_master_key_schedule);\n\n    return 0;\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <kadm5/admin.h>",
            "#include <stdio.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <kadm5/admin.h>\n#include <stdio.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic int\nv4init(arg, manual)\n    struct dump_record *arg;\n    int manual;\n{\n    int fd;\n    int ok = 0;\n\n    if (!manual) {\n\tfd = open(v4_mkeyfile, O_RDONLY, 0600);\n\tif (fd >= 0) {\n\t    if (read(fd,arg->v4_master_key,sizeof(C_Block)) == sizeof(C_Block))\n\t\tok = 1;\n\t    close(fd);\n\t}\n    }\n    if (!ok) {\n\tdes_read_password(&arg->v4_master_key, \"V4 Kerberos master key\", 1);\n\tprintf(\"\\n\");\n    }\n    arg->master_key_version = 1;\n    key_sched(arg->v4_master_key, arg->v4_master_key_schedule);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "errno",
            "\"While opening file %s for writing\"",
            "outname"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "outname",
            "\"w\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "outname"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "0",
            "Err_no_database"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "0",
            "\"Usage: %s [-S] filename\"",
            "argv[0]"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\"-S\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb5_util.h\"\n#include <kadm5/admin.h>\n#include <stdio.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nvoid dump_v4db(argc, argv)\n\tint\targc;\n\tchar\t**argv;\n{\n\tint\ti;\n\tchar\t*outname = NULL;\n\tFILE\t*f;\n\tstruct dump_record\targ;\n\n\tfor (i = 1; i < argc; i++) {\n\t\tif (!strcmp(argv[i], \"-S\")) {\n\t\t\tshortlife++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (argc - i > 1) {\n\t\tcom_err(argv[0], 0, \"Usage: %s [-S] filename\", argv[0]);\n\t\texit_status++;\n\t\treturn;\n\t}\n\tif (!dbactive) {\n\t\tcom_err(argv[0], 0, Err_no_database);\n\t\texit_status++;\n\t\treturn;\n\t}\n\tif (argc - i == 1) {\n\t\toutname = argv[i];\n\t\t/*\n\t\t * Make sure that we don't open and truncate on the fopen,\n\t\t * since that may hose an on-going kprop process.\n\t\t * \n\t\t * We could also control this by opening for read and\n\t\t * write, doing an flock with LOCK_EX, and then\n\t\t * truncating the file once we have gotten the lock,\n\t\t * but that would involve more OS dependancies than I\n\t\t * want to get into.\n\t\t */\n\t\tunlink(outname);\n\t\tif (!(f = fopen(outname, \"w\"))) {\n\t\t\tcom_err(argv[0], errno,\n\t\t\t\t\"While opening file %s for writing\", outname);\n\t\t\texit_status++;\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tf = stdout;\n\t}\n\n\targ.comerr_name = argv[0];\n\targ.f = f;\n\tv4init(&arg, 0);\n\thandle_keys(&arg);\n\n\t/* special handling for K.M since it isn't preserved */\n\t{\n\t  des_cblock v4key;\n\t  int i2;\n\n\t  /* assume:\n\t     max lifetime (255)\n\t     key version == 1 (actually, should be whatever the v5 one is)\n\t     master key version == key version\n\t     args == 0 (none are preserved)\n\t     expiration date is the default 2000\n\t     last mod time is near zero (arbitrarily.)\n\t     creator is db_creation *\n\t     */\n\n\t  fprintf(f,\"K M 255 1 1 0 \");\n\t  \n#ifndef\tKDB4_DISABLE\n\t  kdb_encrypt_key (arg.v4_master_key, v4key, \n\t\t\t   arg.v4_master_key, arg.v4_master_key_schedule, \n\t\t\t   ENCRYPT);\n#else\t/* KDB4_DISABLE */\n\t  pcbc_encrypt((C_Block *) arg.v4_master_key,\n\t\t       (C_Block *) v4key,\n\t\t       (long) sizeof(C_Block),\n\t\t       arg.v4_master_key_schedule,\n\t\t       (C_Block *) arg.v4_master_key,\n\t\t       ENCRYPT);\n#endif\t/* KDB4_DISABLE */\n\n\t  for (i2=0; i2<8; i2++) {\n\t    fprintf(f, \"%02x\", ((unsigned char*)v4key)[i2]);\n\t    if (i2 == 3) fputc(' ', f);\n\t  }\n\t  fprintf(f,\" 200001010459 197001020000 db_creation *\\n\");\n\t}\n\n\t(void) krb5_db_iterate(util_context, dump_v4_iterator, \n\t\t\t       (krb5_pointer) &arg);\n\tif (argc == 2)\n\t\tfclose(f);\n\tif (outname)\n\t\tupdate_ok_file(outname);\n}"
  },
  {
    "function_name": "dump_v4_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dumpv4.c",
    "lines": "142-285",
    "snippet": "static krb5_error_code\ndump_v4_iterator(ptr, entry)\n    krb5_pointer ptr;\n    krb5_db_entry *entry;\n{\n    struct dump_record *arg = (struct dump_record *) ptr;\n    krb5_principal mod_princ;\n    krb5_timestamp mod_time;\n    krb5_error_code retval;\n    int\ti, max_kvno, ok_key;\n\n    struct v4princ {\n\tchar name[ANAME_SZ+1];\n\tchar instance[INST_SZ+1];\n\tchar realm[REALM_SZ+1];\n\tint max_life;\n\tint kdc_key_ver, key_version, attributes;\n\tchar mod_name[ANAME_SZ+1];\n\tchar mod_instance[INST_SZ+1];\n\tchar mod_realm[REALM_SZ+1];\n    } v4princ, *principal;\n    des_cblock v4key;\n    \n    principal = &v4princ;\n\n    if (strcmp(krb5_princ_realm(util_context, entry->princ)->data, arg->realm))\n\t/* skip this because it's a key for a different realm, probably\n\t * a paired krbtgt key */\n\treturn 0;\n\n    retval = krb5_524_conv_principal(util_context, entry->princ,\n\t\t\t\t     principal->name, principal->instance,\n\t\t\t\t     principal->realm);\n    if (retval)\n\t/* Skip invalid V4 principals */\n\treturn 0;\n\n    if (!strcmp(principal->name, \"K\") && !strcmp(principal->instance, \"M\"))\n\t/* The V4 master key is handled specially */\n\treturn 0;\n\n    if (! principal->name[0])\n\treturn 0;\n    if (! principal->instance[0])\n\tstrcpy(principal->instance, \"*\");\n\n    /* Now move to mod princ */\n    if ((retval = krb5_dbe_lookup_mod_princ_data(util_context,entry,\n\t\t\t\t\t\t &mod_time, &mod_princ))){\n\tcom_err(arg->comerr_name, retval, \"while unparsing db entry\");\n\texit_status++;\n\treturn retval;\n    }\n    retval = krb5_524_conv_principal(util_context, mod_princ,\n\t\t\t\t     principal->mod_name, principal->mod_instance,\n\t\t\t\t     principal->mod_realm);\n    if (retval) {\n\t/* Invalid V4 mod principal */\n\tprincipal->mod_name[0] = '\\0';\n\tprincipal->mod_instance[0] = '\\0';\n    }\n\n    if (! principal->mod_name[0])\n\tstrcpy(principal->mod_name, \"*\");\n    if (! principal->mod_instance[0])\n\tstrcpy(principal->mod_instance, \"*\");\n    \n    /* OK deal with the key now. */\n    for (max_kvno = i = 0; i < entry->n_key_data; i++) {\n\tif (max_kvno < entry->key_data[i].key_data_kvno) {\n\t     max_kvno = entry->key_data[i].key_data_kvno;\n\t     ok_key = i;\n\t}\n    }\n\n    i = ok_key;\n    while (ok_key < entry->n_key_data) {\n\tif (max_kvno == entry->key_data[ok_key].key_data_kvno) {\n\t    if (entry->key_data[ok_key].key_data_type[1]\n\t\t== KRB5_KDB_SALTTYPE_V4) {\n\t\tgoto found_one;\n\t    }\n\t}\n\tok_key++;\n    }\n\n    /* See if there are any DES keys that may be suitable */\n    ok_key = i;\n    while (ok_key < entry->n_key_data) {\n\tif (max_kvno == entry->key_data[ok_key].key_data_kvno) {\n\t    krb5_enctype enctype = entry->key_data[ok_key].key_data_type[0];\n\t    if ((enctype == ENCTYPE_DES_CBC_CRC) ||\n\t\t(enctype == ENCTYPE_DES_CBC_MD5) ||\n\t\t(enctype == ENCTYPE_DES_CBC_RAW))\n\t\tgoto found_one;\n\t}\n\tok_key++;\n    }\n    /* skip this because it's a new style key and we can't help it */\n    return 0;\n\nfound_one:;\n    principal->key_version = max_kvno;\n    if (!shortlife)\n\tprincipal->max_life = krb_time_to_life(0, entry->max_life);\n    else {\n\tprincipal->max_life = entry->max_life / (60 * 5);\n\tif (principal->max_life > 255)\n\t    principal->max_life = 255;\n    }\n\n    principal->kdc_key_ver = arg->master_key_version;\n    principal->attributes = 0;\t/* ??? not preserved either */\n\n    fprintf(arg->f, \"%s %s %d %d %d %d \",\n\t    principal->name,\n\t    principal->instance,\n\t    principal->max_life,\n\t    principal->kdc_key_ver,\n\t    principal->key_version,\n\t    principal->attributes);\n\n    handle_one_key(arg, arg->v5mkey, &entry->key_data[ok_key], v4key);\n\n    for (i = 0; i < 8; i++) {\n\tfprintf(arg->f, \"%02x\", ((unsigned char*)v4key)[i]);\n\tif (i == 3) fputc(' ', arg->f);\n    }\n\n    if (entry->expiration == 0) {\n        /* 0 means \"never\" expire. V4 didn't support that, so rather than\n\t   having everything appear to have expired in 1970, we nail in the\n\t   Cygnus 96q1 default value.  The value quoted here is directly \n\t   from src/admin/kdb_init.c in Cygnus CNS V4 96q1, and is\n\t   roughly 12/31/2009. */\n        v4_print_time(arg->f, 946702799+((365*10+3)*24*60*60));\n    } else {\n    v4_print_time(arg->f, entry->expiration);\n    }\n    v4_print_time(arg->f, mod_time);\n\n    fprintf(arg->f, \" %s %s\\n\", principal->mod_name, principal->mod_instance);\n    return 0;\n}",
    "includes": [
      "#include \"kdb5_util.h\"",
      "#include <kadm5/admin.h>",
      "#include <stdio.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [
      "#define INST_SZ 40",
      "#define ANAME_SZ 40"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->f",
            "\" %s %s\\n\"",
            "principal->mod_name",
            "principal->mod_instance"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4_print_time",
          "args": [
            "arg->f",
            "mod_time"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "v4_print_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dumpv4.c",
          "lines": "124-138",
          "snippet": "static void\nv4_print_time(file, timeval)\n    FILE   *file;\n    unsigned long timeval;\n{\n    struct tm *tm;\n    struct tm *gmtime();\n    tm = gmtime((time_t *)&timeval);\n    fprintf(file, \" %04d%02d%02d%02d%02d\",\n            tm->tm_year < 1900 ? tm->tm_year + 1900: tm->tm_year,\n            tm->tm_mon + 1,\n            tm->tm_mday,\n            tm->tm_hour,\n            tm->tm_min);\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <kadm5/admin.h>",
            "#include <stdio.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <kadm5/admin.h>\n#include <stdio.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic void\nv4_print_time(file, timeval)\n    FILE   *file;\n    unsigned long timeval;\n{\n    struct tm *tm;\n    struct tm *gmtime();\n    tm = gmtime((time_t *)&timeval);\n    fprintf(file, \" %04d%02d%02d%02d%02d\",\n            tm->tm_year < 1900 ? tm->tm_year + 1900: tm->tm_year,\n            tm->tm_mon + 1,\n            tm->tm_mday,\n            tm->tm_hour,\n            tm->tm_min);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fputc",
          "args": [
            "' '",
            "arg->f"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->f",
            "\"%02x\"",
            "((unsigned char*)v4key)[i]"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_one_key",
          "args": [
            "arg",
            "arg->v5mkey",
            "&entry->key_data[ok_key]",
            "v4key"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "handle_one_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dumpv4.c",
          "lines": "422-453",
          "snippet": "static krb5_error_code\nhandle_one_key(arg, v5mkey, v5key, v4key)\n    struct dump_record *arg;\n    krb5_keyblock *v5mkey;\n    krb5_key_data *v5key;\n    des_cblock v4key;\n{\n    krb5_error_code retval;\n\n    krb5_keyblock v5plainkey;\n    /* v4key is the actual v4 key from the file. */\n\n    retval = krb5_dbekd_decrypt_key_data(util_context, v5mkey, v5key, \n\t\t\t\t\t &v5plainkey, NULL);\n    if (retval) \n\treturn retval;\n\n    memcpy(v4key, v5plainkey.contents, sizeof(des_cblock));\n#ifndef\tKDB4_DISABLE\n    kdb_encrypt_key (v4key, v4key, \n\t\t     arg->v4_master_key, arg->v4_master_key_schedule, \n\t\t     ENCRYPT);\n#else\t/* KDB4_DISABLE */\n    pcbc_encrypt((C_Block *) v4key,\n\t\t (C_Block *) v4key,\n\t\t (long) sizeof(C_Block),\n\t\t arg->v4_master_key_schedule,\n\t\t (C_Block *) arg->v4_master_key,\n\t\t ENCRYPT);\n#endif\t/* KDB4_DISABLE */\n    return 0;\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <kadm5/admin.h>",
            "#include <stdio.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <kadm5/admin.h>\n#include <stdio.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code\nhandle_one_key(arg, v5mkey, v5key, v4key)\n    struct dump_record *arg;\n    krb5_keyblock *v5mkey;\n    krb5_key_data *v5key;\n    des_cblock v4key;\n{\n    krb5_error_code retval;\n\n    krb5_keyblock v5plainkey;\n    /* v4key is the actual v4 key from the file. */\n\n    retval = krb5_dbekd_decrypt_key_data(util_context, v5mkey, v5key, \n\t\t\t\t\t &v5plainkey, NULL);\n    if (retval) \n\treturn retval;\n\n    memcpy(v4key, v5plainkey.contents, sizeof(des_cblock));\n#ifndef\tKDB4_DISABLE\n    kdb_encrypt_key (v4key, v4key, \n\t\t     arg->v4_master_key, arg->v4_master_key_schedule, \n\t\t     ENCRYPT);\n#else\t/* KDB4_DISABLE */\n    pcbc_encrypt((C_Block *) v4key,\n\t\t (C_Block *) v4key,\n\t\t (long) sizeof(C_Block),\n\t\t arg->v4_master_key_schedule,\n\t\t (C_Block *) arg->v4_master_key,\n\t\t ENCRYPT);\n#endif\t/* KDB4_DISABLE */\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "arg->f",
            "\"%s %s %d %d %d %d \"",
            "principal->name",
            "principal->instance",
            "principal->max_life",
            "principal->kdc_key_ver",
            "principal->key_version",
            "principal->attributes"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb_time_to_life",
          "args": [
            "0",
            "entry->max_life"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "principal->mod_instance",
            "\"*\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "principal->mod_name",
            "\"*\""
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_524_conv_principal",
          "args": [
            "util_context",
            "mod_princ",
            "principal->mod_name",
            "principal->mod_instance",
            "principal->mod_realm"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "arg->comerr_name",
            "retval",
            "\"while unparsing db entry\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_lookup_mod_princ_data",
          "args": [
            "util_context",
            "entry",
            "&mod_time",
            "&mod_princ"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "principal->instance",
            "\"*\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "principal->instance",
            "\"M\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "principal->name",
            "\"K\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_524_conv_principal",
          "args": [
            "util_context",
            "entry->princ",
            "principal->name",
            "principal->instance",
            "principal->realm"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "krb5_princ_realm(util_context, entry->princ)->data",
            "arg->realm"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_princ_realm",
          "args": [
            "util_context",
            "entry->princ"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb5_util.h\"\n#include <kadm5/admin.h>\n#include <stdio.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\n#define INST_SZ 40\n#define ANAME_SZ 40\n\nstatic krb5_error_code\ndump_v4_iterator(ptr, entry)\n    krb5_pointer ptr;\n    krb5_db_entry *entry;\n{\n    struct dump_record *arg = (struct dump_record *) ptr;\n    krb5_principal mod_princ;\n    krb5_timestamp mod_time;\n    krb5_error_code retval;\n    int\ti, max_kvno, ok_key;\n\n    struct v4princ {\n\tchar name[ANAME_SZ+1];\n\tchar instance[INST_SZ+1];\n\tchar realm[REALM_SZ+1];\n\tint max_life;\n\tint kdc_key_ver, key_version, attributes;\n\tchar mod_name[ANAME_SZ+1];\n\tchar mod_instance[INST_SZ+1];\n\tchar mod_realm[REALM_SZ+1];\n    } v4princ, *principal;\n    des_cblock v4key;\n    \n    principal = &v4princ;\n\n    if (strcmp(krb5_princ_realm(util_context, entry->princ)->data, arg->realm))\n\t/* skip this because it's a key for a different realm, probably\n\t * a paired krbtgt key */\n\treturn 0;\n\n    retval = krb5_524_conv_principal(util_context, entry->princ,\n\t\t\t\t     principal->name, principal->instance,\n\t\t\t\t     principal->realm);\n    if (retval)\n\t/* Skip invalid V4 principals */\n\treturn 0;\n\n    if (!strcmp(principal->name, \"K\") && !strcmp(principal->instance, \"M\"))\n\t/* The V4 master key is handled specially */\n\treturn 0;\n\n    if (! principal->name[0])\n\treturn 0;\n    if (! principal->instance[0])\n\tstrcpy(principal->instance, \"*\");\n\n    /* Now move to mod princ */\n    if ((retval = krb5_dbe_lookup_mod_princ_data(util_context,entry,\n\t\t\t\t\t\t &mod_time, &mod_princ))){\n\tcom_err(arg->comerr_name, retval, \"while unparsing db entry\");\n\texit_status++;\n\treturn retval;\n    }\n    retval = krb5_524_conv_principal(util_context, mod_princ,\n\t\t\t\t     principal->mod_name, principal->mod_instance,\n\t\t\t\t     principal->mod_realm);\n    if (retval) {\n\t/* Invalid V4 mod principal */\n\tprincipal->mod_name[0] = '\\0';\n\tprincipal->mod_instance[0] = '\\0';\n    }\n\n    if (! principal->mod_name[0])\n\tstrcpy(principal->mod_name, \"*\");\n    if (! principal->mod_instance[0])\n\tstrcpy(principal->mod_instance, \"*\");\n    \n    /* OK deal with the key now. */\n    for (max_kvno = i = 0; i < entry->n_key_data; i++) {\n\tif (max_kvno < entry->key_data[i].key_data_kvno) {\n\t     max_kvno = entry->key_data[i].key_data_kvno;\n\t     ok_key = i;\n\t}\n    }\n\n    i = ok_key;\n    while (ok_key < entry->n_key_data) {\n\tif (max_kvno == entry->key_data[ok_key].key_data_kvno) {\n\t    if (entry->key_data[ok_key].key_data_type[1]\n\t\t== KRB5_KDB_SALTTYPE_V4) {\n\t\tgoto found_one;\n\t    }\n\t}\n\tok_key++;\n    }\n\n    /* See if there are any DES keys that may be suitable */\n    ok_key = i;\n    while (ok_key < entry->n_key_data) {\n\tif (max_kvno == entry->key_data[ok_key].key_data_kvno) {\n\t    krb5_enctype enctype = entry->key_data[ok_key].key_data_type[0];\n\t    if ((enctype == ENCTYPE_DES_CBC_CRC) ||\n\t\t(enctype == ENCTYPE_DES_CBC_MD5) ||\n\t\t(enctype == ENCTYPE_DES_CBC_RAW))\n\t\tgoto found_one;\n\t}\n\tok_key++;\n    }\n    /* skip this because it's a new style key and we can't help it */\n    return 0;\n\nfound_one:;\n    principal->key_version = max_kvno;\n    if (!shortlife)\n\tprincipal->max_life = krb_time_to_life(0, entry->max_life);\n    else {\n\tprincipal->max_life = entry->max_life / (60 * 5);\n\tif (principal->max_life > 255)\n\t    principal->max_life = 255;\n    }\n\n    principal->kdc_key_ver = arg->master_key_version;\n    principal->attributes = 0;\t/* ??? not preserved either */\n\n    fprintf(arg->f, \"%s %s %d %d %d %d \",\n\t    principal->name,\n\t    principal->instance,\n\t    principal->max_life,\n\t    principal->kdc_key_ver,\n\t    principal->key_version,\n\t    principal->attributes);\n\n    handle_one_key(arg, arg->v5mkey, &entry->key_data[ok_key], v4key);\n\n    for (i = 0; i < 8; i++) {\n\tfprintf(arg->f, \"%02x\", ((unsigned char*)v4key)[i]);\n\tif (i == 3) fputc(' ', arg->f);\n    }\n\n    if (entry->expiration == 0) {\n        /* 0 means \"never\" expire. V4 didn't support that, so rather than\n\t   having everything appear to have expired in 1970, we nail in the\n\t   Cygnus 96q1 default value.  The value quoted here is directly \n\t   from src/admin/kdb_init.c in Cygnus CNS V4 96q1, and is\n\t   roughly 12/31/2009. */\n        v4_print_time(arg->f, 946702799+((365*10+3)*24*60*60));\n    } else {\n    v4_print_time(arg->f, entry->expiration);\n    }\n    v4_print_time(arg->f, mod_time);\n\n    fprintf(arg->f, \" %s %s\\n\", principal->mod_name, principal->mod_instance);\n    return 0;\n}"
  },
  {
    "function_name": "v4_print_time",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dumpv4.c",
    "lines": "124-138",
    "snippet": "static void\nv4_print_time(file, timeval)\n    FILE   *file;\n    unsigned long timeval;\n{\n    struct tm *tm;\n    struct tm *gmtime();\n    tm = gmtime((time_t *)&timeval);\n    fprintf(file, \" %04d%02d%02d%02d%02d\",\n            tm->tm_year < 1900 ? tm->tm_year + 1900: tm->tm_year,\n            tm->tm_mon + 1,\n            tm->tm_mday,\n            tm->tm_hour,\n            tm->tm_min);\n}",
    "includes": [
      "#include \"kdb5_util.h\"",
      "#include <kadm5/admin.h>",
      "#include <stdio.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "file",
            "\" %04d%02d%02d%02d%02d\"",
            "tm->tm_year < 1900 ? tm->tm_year + 1900: tm->tm_year",
            "tm->tm_mon + 1",
            "tm->tm_mday",
            "tm->tm_hour",
            "tm->tm_min"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gmtime",
          "args": [
            "(time_t *)&timeval"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb5_util.h\"\n#include <kadm5/admin.h>\n#include <stdio.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic void\nv4_print_time(file, timeval)\n    FILE   *file;\n    unsigned long timeval;\n{\n    struct tm *tm;\n    struct tm *gmtime();\n    tm = gmtime((time_t *)&timeval);\n    fprintf(file, \" %04d%02d%02d%02d%02d\",\n            tm->tm_year < 1900 ? tm->tm_year + 1900: tm->tm_year,\n            tm->tm_mon + 1,\n            tm->tm_mday,\n            tm->tm_hour,\n            tm->tm_min);\n}"
  },
  {
    "function_name": "v4init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dumpv4.c",
    "lines": "98-122",
    "snippet": "static int\nv4init(arg, manual)\n    struct dump_record *arg;\n    int manual;\n{\n    int fd;\n    int ok = 0;\n\n    if (!manual) {\n\tfd = open(v4_mkeyfile, O_RDONLY, 0600);\n\tif (fd >= 0) {\n\t    if (read(fd,arg->v4_master_key,sizeof(C_Block)) == sizeof(C_Block))\n\t\tok = 1;\n\t    close(fd);\n\t}\n    }\n    if (!ok) {\n\tdes_read_password(&arg->v4_master_key, \"V4 Kerberos master key\", 1);\n\tprintf(\"\\n\");\n    }\n    arg->master_key_version = 1;\n    key_sched(arg->v4_master_key, arg->v4_master_key_schedule);\n\n    return 0;\n}",
    "includes": [
      "#include \"kdb5_util.h\"",
      "#include <kadm5/admin.h>",
      "#include <stdio.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_sched",
          "args": [
            "arg->v4_master_key",
            "arg->v4_master_key_schedule"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "des_read_password",
          "args": [
            "&arg->v4_master_key",
            "\"V4 Kerberos master key\"",
            "1"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "arg->v4_master_key",
            "sizeof(C_Block)"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "read_octet_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "1232-1250",
          "snippet": "static int\nread_octet_string(f, buf, len)\n    FILE\t*f;\n    krb5_octet\t*buf;\n    int\t\tlen;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tif (fscanf(f, \"%02x\", &c) != 1) {\n\t    retval = 1;\n\t    break;\n\t}\n\tbuf[i] = (krb5_octet) c;\n    }\n    return(retval);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nread_octet_string(f, buf, len)\n    FILE\t*f;\n    krb5_octet\t*buf;\n    int\t\tlen;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tif (fscanf(f, \"%02x\", &c) != 1) {\n\t    retval = 1;\n\t    break;\n\t}\n\tbuf[i] = (krb5_octet) c;\n    }\n    return(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "v4_mkeyfile",
            "O_RDONLY",
            "0600"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "open_db_and_mkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/kdb5_util.c",
          "lines": "300-421",
          "snippet": "static int open_db_and_mkey()\n{\n    krb5_error_code retval;\n    int nentries;\n    krb5_boolean more;\n    krb5_data scratch, pwd, seed;\n\n    dbactive = FALSE;\n    valid_master_key = 0;\n\n    if ((retval = krb5_db_set_name(util_context, global_params.dbname))) {\n\tcom_err(progname, retval, \"while setting active database to '%s'\",\n\t\tglobal_params.dbname);\n\texit_status++;\n\treturn(1);\n    } \n    if ((retval = krb5_db_init(util_context))) {\n\tcom_err(progname, retval, \"while initializing database\");\n\texit_status++;\n\treturn(1);\n    }\n    if ((retval = osa_adb_open_policy(&policy_db, &global_params))) {\n\tcom_err(progname, retval, \"opening policy database\");\n\texit_status++;\n\treturn (1);\n    }\n\n   /* assemble & parse the master key name */\n\n    if ((retval = krb5_db_setup_mkey_name(util_context,\n\t\t\t\t\t  global_params.mkey_name,\n\t\t\t\t\t  global_params.realm, \n\t\t\t\t\t  0, &master_princ))) {\n\tcom_err(progname, retval, \"while setting up master key name\");\n\texit_status++;\n\treturn(1);\n    }\n    nentries = 1;\n    if ((retval = krb5_db_get_principal(util_context, master_princ, \n\t\t\t\t\t&master_entry, &nentries, &more))) {\n\tcom_err(progname, retval, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (more) {\n\tcom_err(progname, KRB5KDC_ERR_PRINCIPAL_NOT_UNIQUE,\n\t\t\"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (!nentries) {\n\tcom_err(progname, KRB5_KDB_NOENTRY, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    }\n\n    krb5_db_free_principal(util_context, &master_entry, nentries);\n\n    /* the databases are now open, and the master principal exists */\n    dbactive = TRUE;\n    \n    if (mkey_password) {\n\tpwd.data = mkey_password;\n\tpwd.length = strlen(mkey_password);\n\tretval = krb5_principal2salt(util_context, master_princ, &scratch);\n\tif (retval) {\n\t    com_err(progname, retval, \"while calculated master key salt\");\n\t    return(1);\n\t}\n\n\t/* If no encryption type is set, use the default */\n\tif (master_keyblock.enctype == ENCTYPE_UNKNOWN) {\n\t    master_keyblock.enctype = DEFAULT_KDC_ENCTYPE;\n\t    if (!krb5_c_valid_enctype(master_keyblock.enctype))\n\t\tcom_err(progname, KRB5_PROG_KEYTYPE_NOSUPP,\n\t\t\t\"while setting up enctype %d\",\n\t\t\tmaster_keyblock.enctype);\n\t}\n\n\tretval = krb5_c_string_to_key(util_context, master_keyblock.enctype, \n\t\t\t\t      &pwd, &scratch, &master_keyblock);\n\tif (retval) {\n\t    com_err(progname, retval,\n\t\t    \"while transforming master key from password\");\n\t    return(1);\n\t}\n\tfree(scratch.data);\n\tmkey_password = 0;\n    } else if ((retval = krb5_db_fetch_mkey(util_context, master_princ, \n\t\t\t\t\t    master_keyblock.enctype,\n\t\t\t\t\t    manual_mkey, FALSE,\n\t\t\t\t\t    global_params.stash_file,\n\t\t\t\t\t    0, &master_keyblock))) {\n\tcom_err(progname, retval, \"while reading master key\");\n\tcom_err(progname, 0, \"Warning: proceeding without master key\");\n\texit_status++;\n\treturn(0);\n    }\n    if ((retval = krb5_db_verify_master_key(util_context, master_princ, \n\t\t\t\t\t    &master_keyblock))) {\n\tcom_err(progname, retval, \"while verifying master key\");\n\texit_status++;\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    seed.length = master_keyblock.length;\n    seed.data = master_keyblock.contents;\n\n    if ((retval = krb5_c_random_seed(util_context, &seed))) {\n\tcom_err(progname, retval, \"while seeding random number generator\");\n\texit_status++;\n\tmemset((char *)master_keyblock.contents, 0, master_keyblock.length);\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    valid_master_key = 1;\n    dbactive = TRUE;\n    return 0;\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <time.h>",
            "#include <kadm5/adb.h>",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *mkey_password = 0;",
            "int exit_status = 0;",
            "krb5_context util_context;",
            "osa_adb_policy_t policy_db;",
            "kadm5_config_params global_params;",
            "extern krb5_keyblock master_keyblock;",
            "extern krb5_principal master_princ;",
            "krb5_db_entry master_entry;",
            "int\tvalid_master_key = 0;",
            "char *progname;",
            "krb5_boolean manual_mkey = FALSE;",
            "krb5_boolean dbactive = FALSE;",
            "static int open_db_and_mkey(void);",
            "static struct _cmd_table *cmd_lookup(name)\n   char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <time.h>\n#include <kadm5/adb.h>\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nchar *mkey_password = 0;\nint exit_status = 0;\nkrb5_context util_context;\nosa_adb_policy_t policy_db;\nkadm5_config_params global_params;\nextern krb5_keyblock master_keyblock;\nextern krb5_principal master_princ;\nkrb5_db_entry master_entry;\nint\tvalid_master_key = 0;\nchar *progname;\nkrb5_boolean manual_mkey = FALSE;\nkrb5_boolean dbactive = FALSE;\nstatic int open_db_and_mkey(void);\nstatic struct _cmd_table *cmd_lookup(name)\n   char *name;\n\nstatic int open_db_and_mkey()\n{\n    krb5_error_code retval;\n    int nentries;\n    krb5_boolean more;\n    krb5_data scratch, pwd, seed;\n\n    dbactive = FALSE;\n    valid_master_key = 0;\n\n    if ((retval = krb5_db_set_name(util_context, global_params.dbname))) {\n\tcom_err(progname, retval, \"while setting active database to '%s'\",\n\t\tglobal_params.dbname);\n\texit_status++;\n\treturn(1);\n    } \n    if ((retval = krb5_db_init(util_context))) {\n\tcom_err(progname, retval, \"while initializing database\");\n\texit_status++;\n\treturn(1);\n    }\n    if ((retval = osa_adb_open_policy(&policy_db, &global_params))) {\n\tcom_err(progname, retval, \"opening policy database\");\n\texit_status++;\n\treturn (1);\n    }\n\n   /* assemble & parse the master key name */\n\n    if ((retval = krb5_db_setup_mkey_name(util_context,\n\t\t\t\t\t  global_params.mkey_name,\n\t\t\t\t\t  global_params.realm, \n\t\t\t\t\t  0, &master_princ))) {\n\tcom_err(progname, retval, \"while setting up master key name\");\n\texit_status++;\n\treturn(1);\n    }\n    nentries = 1;\n    if ((retval = krb5_db_get_principal(util_context, master_princ, \n\t\t\t\t\t&master_entry, &nentries, &more))) {\n\tcom_err(progname, retval, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (more) {\n\tcom_err(progname, KRB5KDC_ERR_PRINCIPAL_NOT_UNIQUE,\n\t\t\"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (!nentries) {\n\tcom_err(progname, KRB5_KDB_NOENTRY, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    }\n\n    krb5_db_free_principal(util_context, &master_entry, nentries);\n\n    /* the databases are now open, and the master principal exists */\n    dbactive = TRUE;\n    \n    if (mkey_password) {\n\tpwd.data = mkey_password;\n\tpwd.length = strlen(mkey_password);\n\tretval = krb5_principal2salt(util_context, master_princ, &scratch);\n\tif (retval) {\n\t    com_err(progname, retval, \"while calculated master key salt\");\n\t    return(1);\n\t}\n\n\t/* If no encryption type is set, use the default */\n\tif (master_keyblock.enctype == ENCTYPE_UNKNOWN) {\n\t    master_keyblock.enctype = DEFAULT_KDC_ENCTYPE;\n\t    if (!krb5_c_valid_enctype(master_keyblock.enctype))\n\t\tcom_err(progname, KRB5_PROG_KEYTYPE_NOSUPP,\n\t\t\t\"while setting up enctype %d\",\n\t\t\tmaster_keyblock.enctype);\n\t}\n\n\tretval = krb5_c_string_to_key(util_context, master_keyblock.enctype, \n\t\t\t\t      &pwd, &scratch, &master_keyblock);\n\tif (retval) {\n\t    com_err(progname, retval,\n\t\t    \"while transforming master key from password\");\n\t    return(1);\n\t}\n\tfree(scratch.data);\n\tmkey_password = 0;\n    } else if ((retval = krb5_db_fetch_mkey(util_context, master_princ, \n\t\t\t\t\t    master_keyblock.enctype,\n\t\t\t\t\t    manual_mkey, FALSE,\n\t\t\t\t\t    global_params.stash_file,\n\t\t\t\t\t    0, &master_keyblock))) {\n\tcom_err(progname, retval, \"while reading master key\");\n\tcom_err(progname, 0, \"Warning: proceeding without master key\");\n\texit_status++;\n\treturn(0);\n    }\n    if ((retval = krb5_db_verify_master_key(util_context, master_princ, \n\t\t\t\t\t    &master_keyblock))) {\n\tcom_err(progname, retval, \"while verifying master key\");\n\texit_status++;\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    seed.length = master_keyblock.length;\n    seed.data = master_keyblock.contents;\n\n    if ((retval = krb5_c_random_seed(util_context, &seed))) {\n\tcom_err(progname, retval, \"while seeding random number generator\");\n\texit_status++;\n\tmemset((char *)master_keyblock.contents, 0, master_keyblock.length);\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    valid_master_key = 1;\n    dbactive = TRUE;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb5_util.h\"\n#include <kadm5/admin.h>\n#include <stdio.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic int\nv4init(arg, manual)\n    struct dump_record *arg;\n    int manual;\n{\n    int fd;\n    int ok = 0;\n\n    if (!manual) {\n\tfd = open(v4_mkeyfile, O_RDONLY, 0600);\n\tif (fd >= 0) {\n\t    if (read(fd,arg->v4_master_key,sizeof(C_Block)) == sizeof(C_Block))\n\t\tok = 1;\n\t    close(fd);\n\t}\n    }\n    if (!ok) {\n\tdes_read_password(&arg->v4_master_key, \"V4 Kerberos master key\", 1);\n\tprintf(\"\\n\");\n    }\n    arg->master_key_version = 1;\n    key_sched(arg->v4_master_key, arg->v4_master_key_schedule);\n\n    return 0;\n}"
  }
]