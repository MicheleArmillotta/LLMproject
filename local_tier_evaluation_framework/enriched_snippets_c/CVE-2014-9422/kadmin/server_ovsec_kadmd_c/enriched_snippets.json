[
  {
    "function_name": "do_schpw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "1083-1176",
    "snippet": "void do_schpw(int s1, kadm5_config_params *params)\n{\n    krb5_error_code ret;\n    /* XXX buffer = ethernet mtu */\n    char req[1500];\n    int len;\n    struct sockaddr_in from;\n    socklen_t fromlen;\n    krb5_keytab kt;\n    krb5_data reqdata, repdata;\n    int s2;\n\n    fromlen = sizeof(from);\n    if ((len = recvfrom(s1, req, sizeof(req), 0, (struct sockaddr *)&from,\n\t\t\t&fromlen)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't receive request: %s\",\n\t\t\t error_message(errno));\n\treturn;\n    }\n\n    if ((ret = krb5_kt_resolve(context, \"KDB:\", &kt))) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't open admin keytab %s\",\n\t\t\t error_message(ret));\n\treturn;\n    }\n\n    reqdata.length = len;\n    reqdata.data = req;\n\n    /* this is really obscure.  s1 is used for all communications.  it\n       is left unconnected in case the server is multihomed and routes\n       are asymmetric.  s2 is connected to resolve routes and get\n       addresses.  this is the *only* way to get proper addresses for\n       multihomed hosts if routing is asymmetric.  \n\n       A related problem in the server, but not the client, is that\n       many os's have no way to disconnect a connected udp socket, so\n       the s2 socket needs to be closed and recreated for each\n       request.  The s1 socket must not be closed, or else queued\n       requests will be lost.\n\n       A \"naive\" client implementation (one socket, no connect,\n       hostname resolution to get the local ip addr) will work and\n       interoperate if the client is single-homed. */\n\n    if ((s2 = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"cannot create connecting socket: %s\",\n\t\t\t error_message(errno));\n\tfprintf(stderr, \"Cannot create connecting socket: %s\",\n\t\terror_message(errno));\n\tsvcauth_gssapi_unset_names();\n\tkadm5_destroy(global_server_handle);\n\tkrb5_klog_close(context);\t  \n\texit(1);\n    }\n\n    if (connect(s2, (struct sockaddr *) &from, sizeof(from)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't connect to client: %s\",\n\t\t\t error_message(errno));\n\tgoto cleanup;\n    }\n\n    if ((ret = process_chpw_request(context, global_server_handle,\n\t\t\t\t    params->realm, s2, kt, &from,\n\t\t\t\t    &reqdata, &repdata))) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Error processing request: %s\", \n\t\t\t error_message(ret));\n    }\n\n    close(s2);\n\n    if (repdata.length == 0) {\n\t/* just return.  This means something really bad happened */\n        goto cleanup;\n    }\n\n    len = sendto(s1, repdata.data, (int) repdata.length, 0,\n\t\t (struct sockaddr *) &from, sizeof(from));\n\n    if (len < (int) repdata.length) {\n\tkrb5_xfree(repdata.data);\n\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Error sending reply: %s\", \n\t\t\t error_message(errno));\n\tgoto cleanup;\n    }\n\n    krb5_xfree(repdata.data);\n\ncleanup:\n    krb5_kt_close(context, kt);\n\n    return;\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tkadm_svc_run(kadm5_config_params *params);",
      "void *global_server_handle;",
      "char *build_princ_name(char *name, char *realm);",
      "void log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);",
      "void log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *data);",
      "void log_miscerr(struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *error, char *data);",
      "void do_schpw(int s, kadm5_config_params *params);",
      "static krb5_context context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_kt_close",
          "args": [
            "context",
            "kt"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "repdata.data"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"chpw: Error sending reply: %s\"",
            "error_message(errno)"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "repdata.data"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sendto",
          "args": [
            "s1",
            "repdata.data",
            "(int) repdata.length",
            "0",
            "(struct sockaddr *) &from",
            "sizeof(from)"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s2"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"chpw: Error processing request: %s\"",
            "error_message(ret)"
          ],
          "line": 1148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_chpw_request",
          "args": [
            "context",
            "global_server_handle",
            "params->realm",
            "s2",
            "kt",
            "&from",
            "&reqdata",
            "&repdata"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "process_chpw_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/schpw.c",
          "lines": "15-407",
          "snippet": "krb5_error_code\nprocess_chpw_request(context, server_handle, realm, s, keytab, sockin, \n\t\t     req, rep)\n     krb5_context context;\n     void *server_handle;\n     char *realm;\n     int s;\n     krb5_keytab keytab;\n     struct sockaddr_in *sockin;\n     krb5_data *req;\n     krb5_data *rep;\n{\n    krb5_error_code ret;\n    char *ptr;\n    int plen, vno;\n    krb5_address local_kaddr, remote_kaddr;\n    int allocated_mem = 0;  \n    krb5_data ap_req, ap_rep;\n    krb5_auth_context auth_context;\n    krb5_principal changepw;\n    krb5_ticket *ticket;\n    krb5_data cipher, clear;\n    struct sockaddr local_addr, remote_addr;\n    GETSOCKNAME_ARG3_TYPE addrlen;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr;\n\n    ret = 0;\n    rep->length = 0;\n\n    auth_context = NULL;\n    changepw = NULL;\n    ap_rep.length = 0;\n    ticket = NULL;\n    clear.length = 0;\n    cipher.length = 0;\n\n    if (req->length < 4) {\n\t/* either this, or the server is printing bad messages,\n\t   or the caller passed in garbage */\n\tret = KRB5KRB_AP_ERR_MODIFIED;\n\tnumresult = KRB5_KPASSWD_MALFORMED;\n\tstrcpy(strresult, \"Request was truncated\");\n\tgoto chpwfail;\n    }\n\n    ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length)\n\treturn(KRB5KRB_AP_ERR_MODIFIED);\n\n    /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1) {\n\tret = KRB5KDC_ERR_BAD_PVNO;\n\tnumresult = KRB5_KPASSWD_BAD_VERSION;\n\tsprintf(strresult,\n\t\t\"Request contained unknown protocol version number %d\", vno);\n\tgoto chpwfail;\n    }\n\n    /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n\tret = KRB5KRB_AP_ERR_MODIFIED;\n\tnumresult = KRB5_KPASSWD_MALFORMED;\n\tstrcpy(strresult, \"Request was truncated in AP-REQ\");\n\tgoto chpwfail;\n    }\n\n    /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed initializing auth context\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n\t\t\t\t KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed initializing auth context\");\n\tgoto chpwfail;\n    }\n\t\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n\t\t\t       \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed building kadmin/changepw principal\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n\t\t      NULL, &ticket);\n\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Failed reading application request\");\n\tgoto chpwfail;\n    }\n\n    /* set up address info */\n\n    addrlen = sizeof(local_addr);\n\n    if (getsockname(s, &local_addr, &addrlen) < 0) {\n\tret = errno;\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed getting server internet address\");\n\tgoto chpwfail;\n    }\n\n    /* some brain-dead OS's don't return useful information from\n     * the getsockname call.  Namely, windows and solaris.  */\n\n    if (((struct sockaddr_in *)&local_addr)->sin_addr.s_addr != 0) {\n\tlocal_kaddr.addrtype = ADDRTYPE_INET;\n\tlocal_kaddr.length =\n\t    sizeof(((struct sockaddr_in *) &local_addr)->sin_addr);\n\tlocal_kaddr.contents = \n\t    (krb5_octet *) &(((struct sockaddr_in *) &local_addr)->sin_addr);\n    } else {\n\tkrb5_address **addrs;\n\n\tkrb5_os_localaddr(context, &addrs);\n\tlocal_kaddr.magic = addrs[0]->magic;\n\tlocal_kaddr.addrtype = addrs[0]->addrtype;\n\tlocal_kaddr.length = addrs[0]->length;\n\tlocal_kaddr.contents = malloc(addrs[0]->length);\n\tmemcpy(local_kaddr.contents, addrs[0]->contents, addrs[0]->length);\n\tallocated_mem++;\n\n\tkrb5_free_addresses(context, addrs);\n    }\n\n    addrlen = sizeof(remote_addr);\n\n    if (getpeername(s, &remote_addr, &addrlen) < 0) {\n\tret = errno;\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed getting client internet address\");\n\tgoto chpwfail;\n    }\n\n    remote_kaddr.addrtype = ADDRTYPE_INET;\n    remote_kaddr.length =\n\tsizeof(((struct sockaddr_in *) &remote_addr)->sin_addr);\n    remote_kaddr.contents = \n\t(krb5_octet *) &(((struct sockaddr_in *) &remote_addr)->sin_addr);\n    \n    remote_kaddr.addrtype = ADDRTYPE_INET;\n    remote_kaddr.length = sizeof(sockin->sin_addr);\n    remote_kaddr.contents = (krb5_octet *) &sockin->sin_addr;\n    \n    /* mk_priv requires that the local address be set.\n       getsockname is used for this.  rd_priv requires that the\n       remote address be set.  recvfrom is used for this.  If\n       rd_priv is given a local address, and the message has the\n       recipient addr in it, this will be checked.  However, there\n       is simply no way to know ahead of time what address the\n       message will be delivered *to*.  Therefore, it is important\n       that either no recipient address is in the messages when\n       mk_priv is called, or that no local address is passed to\n       rd_priv.  Both is a better idea, and I have done that.  In\n       summary, when mk_priv is called, *only* a local address is\n       specified.  when rd_priv is called, *only* a remote address\n       is specified.  Are we having fun yet?  */\n\n    ret = krb5_auth_con_setaddrs(context, auth_context, NULL,\n\t\t\t     &remote_kaddr);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed storing client internet address\");\n\tgoto chpwfail;\n    }\n\n    /* verify that this is an AS_REQ ticket */\n\n    if (!(ticket->enc_part2->flags & TKT_FLG_INITIAL)) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Ticket must be derived from a password\");\n\tgoto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Failed replying to application request\");\n\tgoto chpwfail;\n    }\n\n    /* decrypt the new password */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed decrypting request\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_unparse_name(context, ticket->enc_part2->client, &clientstr);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed unparsing client name for log\");\n\tgoto chpwfail;\n    }\n    /* change the password */\n\n    ptr = (char *) malloc(clear.length+1);\n    memcpy(ptr, clear.data, clear.length);\n    ptr[clear.length] = '\\0';\n\n    ret = kadm5_chpass_principal_util(server_handle, ticket->enc_part2->client,\n\t\t\t\t      ptr, NULL, strresult, sizeof(strresult));\n\n    /* zap the password */\n    memset(clear.data, 0, clear.length);\n    memset(ptr, 0, clear.length);\n    krb5_xfree(clear.data);\n    free(ptr);\n    clear.length = 0;\n\n    krb5_klog_syslog(LOG_NOTICE, \"chpw request from %s for %s: %s\",\n\t\t     inet_ntoa(((struct sockaddr_in *)&remote_addr)->sin_addr),\n\t\t     clientstr, ret ? error_message(ret) : \"success\");\n    krb5_free_unparsed_name(context, clientstr);\n\n    if (ret) {\n\tif ((ret != KADM5_PASS_Q_TOOSHORT) && \n\t    (ret != KADM5_PASS_REUSE) && (ret != KADM5_PASS_Q_CLASS) && \n\t    (ret != KADM5_PASS_Q_DICT) && (ret != KADM5_PASS_TOOSOON))\n\t    numresult = KRB5_KPASSWD_HARDERROR;\n\telse\n\t    numresult = KRB5_KPASSWD_SOFTERROR;\n\t/* strresult set by kadb5_chpass_principal_util() */\n\tgoto chpwfail;\n    }\n\n    /* success! */\n\n    numresult = KRB5_KPASSWD_SUCCESS;\n    strcpy(strresult, \"\");\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher.length = 0;\n\n    if (ap_rep.length) {\n\tret = krb5_auth_con_setaddrs(context, auth_context, &local_kaddr,\n\t\t\t\t     NULL);\n\tif (ret) {\n\t    numresult = KRB5_KPASSWD_HARDERROR;\n\t    strcpy(strresult,\n\t\t   \"Failed storing client and server internet addresses\");\n\t} else {\n\t    ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n\t\t\t       &replay);\n\t    if (ret) {\n\t\tnumresult = KRB5_KPASSWD_HARDERROR;\n\t\tstrcpy(strresult, \"Failed encrypting reply\");\n\t    }\n\t}\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n\t/* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n\tif (ap_rep.length) {\n\t    krb5_xfree(ap_rep.data);\n\t    ap_rep.length = 0;\n\t}\n\n\tkrberror.ctime = 0;\n\tkrberror.cusec = 0;\n\tkrberror.susec = 0;\n\tret = krb5_timeofday(context, &krberror.stime);\n\tif (ret)\n\t    goto bailout;\n\n\t/* this is really icky.  but it's what all the other callers\n\t   to mk_error do. */\n\tkrberror.error = ret;\n\tkrberror.error -= ERROR_TABLE_BASE_krb5;\n\tif (krberror.error < 0 || krberror.error > 128)\n\t    krberror.error = KRB_ERR_GENERIC;\n\n\tkrberror.client = NULL;\n\n\tret = krb5_build_principal(context, &krberror.server,\n\t\t\t\t   strlen(realm), realm,\n\t\t\t\t   \"kadmin\", \"changepw\", NULL);\n\tif (ret)\n\t    goto bailout;\n\tkrberror.text.length = 0;\n\tkrberror.e_data = clear;\n\n\tret = krb5_mk_error(context, &krberror, &cipher);\n\n\tkrb5_free_principal(context, krberror.server);\n\n\tif (ret)\n\t    goto bailout;\n    }\n\n    /* construct the reply */\n\n    rep->length = 6 + ap_rep.length + cipher.length;\n    rep->data = (char *) malloc(rep->length);\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n\tmemcpy(ptr, ap_rep.data, ap_rep.length);\n\tptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    if (auth_context)\n\tkrb5_auth_con_free(context, auth_context);\n    if (changepw)\n\tkrb5_free_principal(context, changepw);\n    if (ap_rep.length)\n\tkrb5_xfree(ap_rep.data);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if (clear.length)\n\tkrb5_xfree(clear.data);\n    if (cipher.length)\n\tkrb5_xfree(cipher.data);\n    if (allocated_mem) \n        krb5_xfree(local_kaddr.contents);\n\n    return(ret);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include <errno.h>",
            "#include <stdio.h>",
            "#include <krb5/adm_proto.h>\t/* krb5_klog_syslog */",
            "#include <syslog.h>",
            "#include <kadm5/admin.h>",
            "#include \"k5-int.h\""
          ],
          "macros_used": [
            "#define GETSOCKNAME_ARG3_TYPE int"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include <errno.h>\n#include <stdio.h>\n#include <krb5/adm_proto.h>\t/* krb5_klog_syslog */\n#include <syslog.h>\n#include <kadm5/admin.h>\n#include \"k5-int.h\"\n\n#define GETSOCKNAME_ARG3_TYPE int\n\nkrb5_error_code\nprocess_chpw_request(context, server_handle, realm, s, keytab, sockin, \n\t\t     req, rep)\n     krb5_context context;\n     void *server_handle;\n     char *realm;\n     int s;\n     krb5_keytab keytab;\n     struct sockaddr_in *sockin;\n     krb5_data *req;\n     krb5_data *rep;\n{\n    krb5_error_code ret;\n    char *ptr;\n    int plen, vno;\n    krb5_address local_kaddr, remote_kaddr;\n    int allocated_mem = 0;  \n    krb5_data ap_req, ap_rep;\n    krb5_auth_context auth_context;\n    krb5_principal changepw;\n    krb5_ticket *ticket;\n    krb5_data cipher, clear;\n    struct sockaddr local_addr, remote_addr;\n    GETSOCKNAME_ARG3_TYPE addrlen;\n    krb5_replay_data replay;\n    krb5_error krberror;\n    int numresult;\n    char strresult[1024];\n    char *clientstr;\n\n    ret = 0;\n    rep->length = 0;\n\n    auth_context = NULL;\n    changepw = NULL;\n    ap_rep.length = 0;\n    ticket = NULL;\n    clear.length = 0;\n    cipher.length = 0;\n\n    if (req->length < 4) {\n\t/* either this, or the server is printing bad messages,\n\t   or the caller passed in garbage */\n\tret = KRB5KRB_AP_ERR_MODIFIED;\n\tnumresult = KRB5_KPASSWD_MALFORMED;\n\tstrcpy(strresult, \"Request was truncated\");\n\tgoto chpwfail;\n    }\n\n    ptr = req->data;\n\n    /* verify length */\n\n    plen = (*ptr++ & 0xff);\n    plen = (plen<<8) | (*ptr++ & 0xff);\n\n    if (plen != req->length)\n\treturn(KRB5KRB_AP_ERR_MODIFIED);\n\n    /* verify version number */\n\n    vno = (*ptr++ & 0xff) ;\n    vno = (vno<<8) | (*ptr++ & 0xff);\n\n    if (vno != 1) {\n\tret = KRB5KDC_ERR_BAD_PVNO;\n\tnumresult = KRB5_KPASSWD_BAD_VERSION;\n\tsprintf(strresult,\n\t\t\"Request contained unknown protocol version number %d\", vno);\n\tgoto chpwfail;\n    }\n\n    /* read, check ap-req length */\n\n    ap_req.length = (*ptr++ & 0xff);\n    ap_req.length = (ap_req.length<<8) | (*ptr++ & 0xff);\n\n    if (ptr + ap_req.length >= req->data + req->length) {\n\tret = KRB5KRB_AP_ERR_MODIFIED;\n\tnumresult = KRB5_KPASSWD_MALFORMED;\n\tstrcpy(strresult, \"Request was truncated in AP-REQ\");\n\tgoto chpwfail;\n    }\n\n    /* verify ap_req */\n\n    ap_req.data = ptr;\n    ptr += ap_req.length;\n\n    ret = krb5_auth_con_init(context, &auth_context);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed initializing auth context\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_auth_con_setflags(context, auth_context,\n\t\t\t\t KRB5_AUTH_CONTEXT_DO_SEQUENCE);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed initializing auth context\");\n\tgoto chpwfail;\n    }\n\t\n    ret = krb5_build_principal(context, &changepw, strlen(realm), realm,\n\t\t\t       \"kadmin\", \"changepw\", NULL);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed building kadmin/changepw principal\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_rd_req(context, &auth_context, &ap_req, changepw, keytab,\n\t\t      NULL, &ticket);\n\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Failed reading application request\");\n\tgoto chpwfail;\n    }\n\n    /* set up address info */\n\n    addrlen = sizeof(local_addr);\n\n    if (getsockname(s, &local_addr, &addrlen) < 0) {\n\tret = errno;\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed getting server internet address\");\n\tgoto chpwfail;\n    }\n\n    /* some brain-dead OS's don't return useful information from\n     * the getsockname call.  Namely, windows and solaris.  */\n\n    if (((struct sockaddr_in *)&local_addr)->sin_addr.s_addr != 0) {\n\tlocal_kaddr.addrtype = ADDRTYPE_INET;\n\tlocal_kaddr.length =\n\t    sizeof(((struct sockaddr_in *) &local_addr)->sin_addr);\n\tlocal_kaddr.contents = \n\t    (krb5_octet *) &(((struct sockaddr_in *) &local_addr)->sin_addr);\n    } else {\n\tkrb5_address **addrs;\n\n\tkrb5_os_localaddr(context, &addrs);\n\tlocal_kaddr.magic = addrs[0]->magic;\n\tlocal_kaddr.addrtype = addrs[0]->addrtype;\n\tlocal_kaddr.length = addrs[0]->length;\n\tlocal_kaddr.contents = malloc(addrs[0]->length);\n\tmemcpy(local_kaddr.contents, addrs[0]->contents, addrs[0]->length);\n\tallocated_mem++;\n\n\tkrb5_free_addresses(context, addrs);\n    }\n\n    addrlen = sizeof(remote_addr);\n\n    if (getpeername(s, &remote_addr, &addrlen) < 0) {\n\tret = errno;\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed getting client internet address\");\n\tgoto chpwfail;\n    }\n\n    remote_kaddr.addrtype = ADDRTYPE_INET;\n    remote_kaddr.length =\n\tsizeof(((struct sockaddr_in *) &remote_addr)->sin_addr);\n    remote_kaddr.contents = \n\t(krb5_octet *) &(((struct sockaddr_in *) &remote_addr)->sin_addr);\n    \n    remote_kaddr.addrtype = ADDRTYPE_INET;\n    remote_kaddr.length = sizeof(sockin->sin_addr);\n    remote_kaddr.contents = (krb5_octet *) &sockin->sin_addr;\n    \n    /* mk_priv requires that the local address be set.\n       getsockname is used for this.  rd_priv requires that the\n       remote address be set.  recvfrom is used for this.  If\n       rd_priv is given a local address, and the message has the\n       recipient addr in it, this will be checked.  However, there\n       is simply no way to know ahead of time what address the\n       message will be delivered *to*.  Therefore, it is important\n       that either no recipient address is in the messages when\n       mk_priv is called, or that no local address is passed to\n       rd_priv.  Both is a better idea, and I have done that.  In\n       summary, when mk_priv is called, *only* a local address is\n       specified.  when rd_priv is called, *only* a remote address\n       is specified.  Are we having fun yet?  */\n\n    ret = krb5_auth_con_setaddrs(context, auth_context, NULL,\n\t\t\t     &remote_kaddr);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed storing client internet address\");\n\tgoto chpwfail;\n    }\n\n    /* verify that this is an AS_REQ ticket */\n\n    if (!(ticket->enc_part2->flags & TKT_FLG_INITIAL)) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Ticket must be derived from a password\");\n\tgoto chpwfail;\n    }\n\n    /* construct the ap-rep */\n\n    ret = krb5_mk_rep(context, auth_context, &ap_rep);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_AUTHERROR;\n\tstrcpy(strresult, \"Failed replying to application request\");\n\tgoto chpwfail;\n    }\n\n    /* decrypt the new password */\n\n    cipher.length = (req->data + req->length) - ptr;\n    cipher.data = ptr;\n\n    ret = krb5_rd_priv(context, auth_context, &cipher, &clear, &replay);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed decrypting request\");\n\tgoto chpwfail;\n    }\n\n    ret = krb5_unparse_name(context, ticket->enc_part2->client, &clientstr);\n    if (ret) {\n\tnumresult = KRB5_KPASSWD_HARDERROR;\n\tstrcpy(strresult, \"Failed unparsing client name for log\");\n\tgoto chpwfail;\n    }\n    /* change the password */\n\n    ptr = (char *) malloc(clear.length+1);\n    memcpy(ptr, clear.data, clear.length);\n    ptr[clear.length] = '\\0';\n\n    ret = kadm5_chpass_principal_util(server_handle, ticket->enc_part2->client,\n\t\t\t\t      ptr, NULL, strresult, sizeof(strresult));\n\n    /* zap the password */\n    memset(clear.data, 0, clear.length);\n    memset(ptr, 0, clear.length);\n    krb5_xfree(clear.data);\n    free(ptr);\n    clear.length = 0;\n\n    krb5_klog_syslog(LOG_NOTICE, \"chpw request from %s for %s: %s\",\n\t\t     inet_ntoa(((struct sockaddr_in *)&remote_addr)->sin_addr),\n\t\t     clientstr, ret ? error_message(ret) : \"success\");\n    krb5_free_unparsed_name(context, clientstr);\n\n    if (ret) {\n\tif ((ret != KADM5_PASS_Q_TOOSHORT) && \n\t    (ret != KADM5_PASS_REUSE) && (ret != KADM5_PASS_Q_CLASS) && \n\t    (ret != KADM5_PASS_Q_DICT) && (ret != KADM5_PASS_TOOSOON))\n\t    numresult = KRB5_KPASSWD_HARDERROR;\n\telse\n\t    numresult = KRB5_KPASSWD_SOFTERROR;\n\t/* strresult set by kadb5_chpass_principal_util() */\n\tgoto chpwfail;\n    }\n\n    /* success! */\n\n    numresult = KRB5_KPASSWD_SUCCESS;\n    strcpy(strresult, \"\");\n\nchpwfail:\n\n    clear.length = 2 + strlen(strresult);\n    clear.data = (char *) malloc(clear.length);\n\n    ptr = clear.data;\n\n    *ptr++ = (numresult>>8) & 0xff;\n    *ptr++ = numresult & 0xff;\n\n    memcpy(ptr, strresult, strlen(strresult));\n\n    cipher.length = 0;\n\n    if (ap_rep.length) {\n\tret = krb5_auth_con_setaddrs(context, auth_context, &local_kaddr,\n\t\t\t\t     NULL);\n\tif (ret) {\n\t    numresult = KRB5_KPASSWD_HARDERROR;\n\t    strcpy(strresult,\n\t\t   \"Failed storing client and server internet addresses\");\n\t} else {\n\t    ret = krb5_mk_priv(context, auth_context, &clear, &cipher,\n\t\t\t       &replay);\n\t    if (ret) {\n\t\tnumresult = KRB5_KPASSWD_HARDERROR;\n\t\tstrcpy(strresult, \"Failed encrypting reply\");\n\t    }\n\t}\n    }\n\n    /* if no KRB-PRIV was constructed, then we need a KRB-ERROR.\n       if this fails, just bail.  there's nothing else we can do. */\n\n    if (cipher.length == 0) {\n\t/* clear out ap_rep now, so that it won't be inserted in the\n           reply */\n\n\tif (ap_rep.length) {\n\t    krb5_xfree(ap_rep.data);\n\t    ap_rep.length = 0;\n\t}\n\n\tkrberror.ctime = 0;\n\tkrberror.cusec = 0;\n\tkrberror.susec = 0;\n\tret = krb5_timeofday(context, &krberror.stime);\n\tif (ret)\n\t    goto bailout;\n\n\t/* this is really icky.  but it's what all the other callers\n\t   to mk_error do. */\n\tkrberror.error = ret;\n\tkrberror.error -= ERROR_TABLE_BASE_krb5;\n\tif (krberror.error < 0 || krberror.error > 128)\n\t    krberror.error = KRB_ERR_GENERIC;\n\n\tkrberror.client = NULL;\n\n\tret = krb5_build_principal(context, &krberror.server,\n\t\t\t\t   strlen(realm), realm,\n\t\t\t\t   \"kadmin\", \"changepw\", NULL);\n\tif (ret)\n\t    goto bailout;\n\tkrberror.text.length = 0;\n\tkrberror.e_data = clear;\n\n\tret = krb5_mk_error(context, &krberror, &cipher);\n\n\tkrb5_free_principal(context, krberror.server);\n\n\tif (ret)\n\t    goto bailout;\n    }\n\n    /* construct the reply */\n\n    rep->length = 6 + ap_rep.length + cipher.length;\n    rep->data = (char *) malloc(rep->length);\n    ptr = rep->data;\n\n    /* length */\n\n    *ptr++ = (rep->length>>8) & 0xff;\n    *ptr++ = rep->length & 0xff;\n\n    /* version == 0x0001 big-endian */\n\n    *ptr++ = 0;\n    *ptr++ = 1;\n\n    /* ap_rep length, big-endian */\n\n    *ptr++ = (ap_rep.length>>8) & 0xff;\n    *ptr++ = ap_rep.length & 0xff;\n\n    /* ap-rep data */\n\n    if (ap_rep.length) {\n\tmemcpy(ptr, ap_rep.data, ap_rep.length);\n\tptr += ap_rep.length;\n    }\n\n    /* krb-priv or krb-error */\n\n    memcpy(ptr, cipher.data, cipher.length);\n\nbailout:\n    if (auth_context)\n\tkrb5_auth_con_free(context, auth_context);\n    if (changepw)\n\tkrb5_free_principal(context, changepw);\n    if (ap_rep.length)\n\tkrb5_xfree(ap_rep.data);\n    if (ticket)\n\tkrb5_free_ticket(context, ticket);\n    if (clear.length)\n\tkrb5_xfree(clear.data);\n    if (cipher.length)\n\tkrb5_xfree(cipher.data);\n    if (allocated_mem) \n        krb5_xfree(local_kaddr.contents);\n\n    return(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"chpw: Couldn't connect to client: %s\"",
            "error_message(errno)"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "connect",
          "args": [
            "s2",
            "(struct sockaddr *) &from",
            "sizeof(from)"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gssapi_unset_names",
          "args": [],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Cannot create connecting socket: %s\"",
            "error_message(errno)"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"cannot create connecting socket: %s\"",
            "error_message(errno)"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"chpw: Couldn't open admin keytab %s\"",
            "error_message(ret)"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_resolve",
          "args": [
            "context",
            "\"KDB:\"",
            "&kt"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"chpw: Couldn't receive request: %s\"",
            "error_message(errno)"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recvfrom",
          "args": [
            "s1",
            "req",
            "sizeof(req)",
            "0",
            "(struct sockaddr *)&from",
            "&fromlen"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid\tkadm_svc_run(kadm5_config_params *params);\nvoid *global_server_handle;\nchar *build_princ_name(char *name, char *realm);\nvoid log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);\nvoid log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *data);\nvoid log_miscerr(struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *error, char *data);\nvoid do_schpw(int s, kadm5_config_params *params);\nstatic krb5_context context;\n\nvoid do_schpw(int s1, kadm5_config_params *params)\n{\n    krb5_error_code ret;\n    /* XXX buffer = ethernet mtu */\n    char req[1500];\n    int len;\n    struct sockaddr_in from;\n    socklen_t fromlen;\n    krb5_keytab kt;\n    krb5_data reqdata, repdata;\n    int s2;\n\n    fromlen = sizeof(from);\n    if ((len = recvfrom(s1, req, sizeof(req), 0, (struct sockaddr *)&from,\n\t\t\t&fromlen)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't receive request: %s\",\n\t\t\t error_message(errno));\n\treturn;\n    }\n\n    if ((ret = krb5_kt_resolve(context, \"KDB:\", &kt))) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't open admin keytab %s\",\n\t\t\t error_message(ret));\n\treturn;\n    }\n\n    reqdata.length = len;\n    reqdata.data = req;\n\n    /* this is really obscure.  s1 is used for all communications.  it\n       is left unconnected in case the server is multihomed and routes\n       are asymmetric.  s2 is connected to resolve routes and get\n       addresses.  this is the *only* way to get proper addresses for\n       multihomed hosts if routing is asymmetric.  \n\n       A related problem in the server, but not the client, is that\n       many os's have no way to disconnect a connected udp socket, so\n       the s2 socket needs to be closed and recreated for each\n       request.  The s1 socket must not be closed, or else queued\n       requests will be lost.\n\n       A \"naive\" client implementation (one socket, no connect,\n       hostname resolution to get the local ip addr) will work and\n       interoperate if the client is single-homed. */\n\n    if ((s2 = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"cannot create connecting socket: %s\",\n\t\t\t error_message(errno));\n\tfprintf(stderr, \"Cannot create connecting socket: %s\",\n\t\terror_message(errno));\n\tsvcauth_gssapi_unset_names();\n\tkadm5_destroy(global_server_handle);\n\tkrb5_klog_close(context);\t  \n\texit(1);\n    }\n\n    if (connect(s2, (struct sockaddr *) &from, sizeof(from)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't connect to client: %s\",\n\t\t\t error_message(errno));\n\tgoto cleanup;\n    }\n\n    if ((ret = process_chpw_request(context, global_server_handle,\n\t\t\t\t    params->realm, s2, kt, &from,\n\t\t\t\t    &reqdata, &repdata))) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Error processing request: %s\", \n\t\t\t error_message(ret));\n    }\n\n    close(s2);\n\n    if (repdata.length == 0) {\n\t/* just return.  This means something really bad happened */\n        goto cleanup;\n    }\n\n    len = sendto(s1, repdata.data, (int) repdata.length, 0,\n\t\t (struct sockaddr *) &from, sizeof(from));\n\n    if (len < (int) repdata.length) {\n\tkrb5_xfree(repdata.data);\n\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Error sending reply: %s\", \n\t\t\t error_message(errno));\n\tgoto cleanup;\n    }\n\n    krb5_xfree(repdata.data);\n\ncleanup:\n    krb5_kt_close(context, kt);\n\n    return;\n}"
  },
  {
    "function_name": "log_badauth_display_status_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "1052-1081",
    "snippet": "void log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec)\n{\n     OM_uint32 gssstat, minor_stat;\n     gss_buffer_desc msg;\n     OM_uint32 msg_ctx;\n\n     msg_ctx = 0;\n     while (1) {\n\t  gssstat = gss_display_status(&minor_stat, code,\n\t\t\t\t       type, GSS_C_NULL_OID,\n\t\t\t\t       &msg_ctx, &msg);\n\t  if (gssstat != GSS_S_COMPLETE) {\n \t       if (!rec) {\n\t\t    log_badauth_display_status_1(m,gssstat,GSS_C_GSS_CODE,1); \n\t\t    log_badauth_display_status_1(m, minor_stat,\n\t\t\t\t\t\t GSS_C_MECH_CODE, 1);\n\t       } else\n\t\t    krb5_klog_syslog(LOG_ERR, \"GSS-API authentication error %s: \"\n\t\t\t   \"recursive failure!\", msg);\n\t       return;\n\t  }\n\n\t  krb5_klog_syslog(LOG_NOTICE, \"%s %s\", m, (char *)msg.value); \n\t  (void) gss_release_buffer(&minor_stat, &msg);\n\t  \n\t  if (!msg_ctx)\n\t       break;\n     }\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec);",
      "static void display_status_1(char *, OM_uint32, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_release_buffer",
          "args": [
            "&minor_stat",
            "&msg"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_NOTICE",
            "\"%s %s\"",
            "m",
            "(char *)msg.value"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"GSS-API authentication error %s: \"\n\t\t\t   \"recursive failure!\"",
            "msg"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_badauth_display_status_1",
          "args": [
            "m",
            "minor_stat",
            "GSS_C_MECH_CODE",
            "1"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "log_badauth_display_status_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "1052-1081",
          "snippet": "void log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec)\n{\n     OM_uint32 gssstat, minor_stat;\n     gss_buffer_desc msg;\n     OM_uint32 msg_ctx;\n\n     msg_ctx = 0;\n     while (1) {\n\t  gssstat = gss_display_status(&minor_stat, code,\n\t\t\t\t       type, GSS_C_NULL_OID,\n\t\t\t\t       &msg_ctx, &msg);\n\t  if (gssstat != GSS_S_COMPLETE) {\n \t       if (!rec) {\n\t\t    log_badauth_display_status_1(m,gssstat,GSS_C_GSS_CODE,1); \n\t\t    log_badauth_display_status_1(m, minor_stat,\n\t\t\t\t\t\t GSS_C_MECH_CODE, 1);\n\t       } else\n\t\t    krb5_klog_syslog(LOG_ERR, \"GSS-API authentication error %s: \"\n\t\t\t   \"recursive failure!\", msg);\n\t       return;\n\t  }\n\n\t  krb5_klog_syslog(LOG_NOTICE, \"%s %s\", m, (char *)msg.value); \n\t  (void) gss_release_buffer(&minor_stat, &msg);\n\t  \n\t  if (!msg_ctx)\n\t       break;\n     }\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "gss_display_status",
          "args": [
            "&minor_stat",
            "code",
            "type",
            "GSS_C_NULL_OID",
            "&msg_ctx",
            "&msg"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec);\nstatic void display_status_1(char *, OM_uint32, int);\n\nvoid log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec)\n{\n     OM_uint32 gssstat, minor_stat;\n     gss_buffer_desc msg;\n     OM_uint32 msg_ctx;\n\n     msg_ctx = 0;\n     while (1) {\n\t  gssstat = gss_display_status(&minor_stat, code,\n\t\t\t\t       type, GSS_C_NULL_OID,\n\t\t\t\t       &msg_ctx, &msg);\n\t  if (gssstat != GSS_S_COMPLETE) {\n \t       if (!rec) {\n\t\t    log_badauth_display_status_1(m,gssstat,GSS_C_GSS_CODE,1); \n\t\t    log_badauth_display_status_1(m, minor_stat,\n\t\t\t\t\t\t GSS_C_MECH_CODE, 1);\n\t       } else\n\t\t    krb5_klog_syslog(LOG_ERR, \"GSS-API authentication error %s: \"\n\t\t\t   \"recursive failure!\", msg);\n\t       return;\n\t  }\n\n\t  krb5_klog_syslog(LOG_NOTICE, \"%s %s\", m, (char *)msg.value); \n\t  (void) gss_release_buffer(&minor_stat, &msg);\n\t  \n\t  if (!msg_ctx)\n\t       break;\n     }\n}"
  },
  {
    "function_name": "log_badauth_display_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "1046-1050",
    "snippet": "void log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor)\n{\n     log_badauth_display_status_1(msg, major, GSS_C_GSS_CODE, 0);\n     log_badauth_display_status_1(msg, minor, GSS_C_MECH_CODE, 0);\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor);",
      "static void display_status_1(char *, OM_uint32, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "log_badauth_display_status_1",
          "args": [
            "msg",
            "minor",
            "GSS_C_MECH_CODE",
            "0"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "log_badauth_display_status_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "1052-1081",
          "snippet": "void log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec)\n{\n     OM_uint32 gssstat, minor_stat;\n     gss_buffer_desc msg;\n     OM_uint32 msg_ctx;\n\n     msg_ctx = 0;\n     while (1) {\n\t  gssstat = gss_display_status(&minor_stat, code,\n\t\t\t\t       type, GSS_C_NULL_OID,\n\t\t\t\t       &msg_ctx, &msg);\n\t  if (gssstat != GSS_S_COMPLETE) {\n \t       if (!rec) {\n\t\t    log_badauth_display_status_1(m,gssstat,GSS_C_GSS_CODE,1); \n\t\t    log_badauth_display_status_1(m, minor_stat,\n\t\t\t\t\t\t GSS_C_MECH_CODE, 1);\n\t       } else\n\t\t    krb5_klog_syslog(LOG_ERR, \"GSS-API authentication error %s: \"\n\t\t\t   \"recursive failure!\", msg);\n\t       return;\n\t  }\n\n\t  krb5_klog_syslog(LOG_NOTICE, \"%s %s\", m, (char *)msg.value); \n\t  (void) gss_release_buffer(&minor_stat, &msg);\n\t  \n\t  if (!msg_ctx)\n\t       break;\n     }\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec);",
            "static void display_status_1(char *, OM_uint32, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec);\nstatic void display_status_1(char *, OM_uint32, int);\n\nvoid log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec)\n{\n     OM_uint32 gssstat, minor_stat;\n     gss_buffer_desc msg;\n     OM_uint32 msg_ctx;\n\n     msg_ctx = 0;\n     while (1) {\n\t  gssstat = gss_display_status(&minor_stat, code,\n\t\t\t\t       type, GSS_C_NULL_OID,\n\t\t\t\t       &msg_ctx, &msg);\n\t  if (gssstat != GSS_S_COMPLETE) {\n \t       if (!rec) {\n\t\t    log_badauth_display_status_1(m,gssstat,GSS_C_GSS_CODE,1); \n\t\t    log_badauth_display_status_1(m, minor_stat,\n\t\t\t\t\t\t GSS_C_MECH_CODE, 1);\n\t       } else\n\t\t    krb5_klog_syslog(LOG_ERR, \"GSS-API authentication error %s: \"\n\t\t\t   \"recursive failure!\", msg);\n\t       return;\n\t  }\n\n\t  krb5_klog_syslog(LOG_NOTICE, \"%s %s\", m, (char *)msg.value); \n\t  (void) gss_release_buffer(&minor_stat, &msg);\n\t  \n\t  if (!msg_ctx)\n\t       break;\n     }\n}"
        }
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor);\nstatic void display_status_1(char *, OM_uint32, int);\n\nvoid log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor)\n{\n     log_badauth_display_status_1(msg, major, GSS_C_GSS_CODE, 0);\n     log_badauth_display_status_1(msg, minor, GSS_C_MECH_CODE, 0);\n}"
  },
  {
    "function_name": "log_badauth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "1030-1044",
    "snippet": "void log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data)\n{\n     char *a;\n     \n     /* Authentication attempt failed: <IP address>, <GSS-API error */\n     /* strings> */\n\n     a = inet_ntoa(addr->sin_addr);\n\n     krb5_klog_syslog(LOG_NOTICE, \"Authentication attempt failed: %s, GSS-API \"\n\t    \"error strings are:\", a);\n     log_badauth_display_status(\"   \", major, minor);\n     krb5_klog_syslog(LOG_NOTICE, \"   GSS-API error strings complete.\");\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);",
      "void log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *data);",
      "void log_miscerr(struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *error, char *data);",
      "void log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor);",
      "static void display_status_1(char *, OM_uint32, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_NOTICE",
            "\"   GSS-API error strings complete.\""
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_badauth_display_status",
          "args": [
            "\"   \"",
            "major",
            "minor"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "log_badauth_display_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "1046-1050",
          "snippet": "void log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor)\n{\n     log_badauth_display_status_1(msg, major, GSS_C_GSS_CODE, 0);\n     log_badauth_display_status_1(msg, minor, GSS_C_MECH_CODE, 0);\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor);",
            "static void display_status_1(char *, OM_uint32, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor);\nstatic void display_status_1(char *, OM_uint32, int);\n\nvoid log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor)\n{\n     log_badauth_display_status_1(msg, major, GSS_C_GSS_CODE, 0);\n     log_badauth_display_status_1(msg, minor, GSS_C_MECH_CODE, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_NOTICE",
            "\"Authentication attempt failed: %s, GSS-API \"\n\t    \"error strings are:\"",
            "a"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "addr->sin_addr"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);\nvoid log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *data);\nvoid log_miscerr(struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *error, char *data);\nvoid log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor);\nstatic void display_status_1(char *, OM_uint32, int);\n\nvoid log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data)\n{\n     char *a;\n     \n     /* Authentication attempt failed: <IP address>, <GSS-API error */\n     /* strings> */\n\n     a = inet_ntoa(addr->sin_addr);\n\n     krb5_klog_syslog(LOG_NOTICE, \"Authentication attempt failed: %s, GSS-API \"\n\t    \"error strings are:\", a);\n     log_badauth_display_status(\"   \", major, minor);\n     krb5_klog_syslog(LOG_NOTICE, \"   GSS-API error strings complete.\");\n}"
  },
  {
    "function_name": "log_miscerr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "1002-1009",
    "snippet": "void log_miscerr(struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *error, char *data)\n{\n     char *a;\n     \n     a = inet_ntoa(rqst->rq_xprt->xp_raddr.sin_addr);\n     krb5_klog_syslog(LOG_NOTICE, \"Miscellaneous RPC error: %s, %s\", a, error);\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);",
      "void log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *data);",
      "void log_miscerr(struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *error, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_NOTICE",
            "\"Miscellaneous RPC error: %s, %s\"",
            "a",
            "error"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "rqst->rq_xprt->xp_raddr.sin_addr"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);\nvoid log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *data);\nvoid log_miscerr(struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *error, char *data);\n\nvoid log_miscerr(struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *error, char *data)\n{\n     char *a;\n     \n     a = inet_ntoa(rqst->rq_xprt->xp_raddr.sin_addr);\n     krb5_klog_syslog(LOG_NOTICE, \"Miscellaneous RPC error: %s, %s\", a, error);\n}"
  },
  {
    "function_name": "log_badverf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "915-984",
    "snippet": "void log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *data)\n{\n     struct procnames {\n\t  rpc_u_int32 proc;\n\t  const char *proc_name;\n     };\n     static const struct procnames proc_names[] = {\n\t  {1, \"CREATE_PRINCIPAL\"},\n\t  {2, \"DELETE_PRINCIPAL\"},\n\t  {3, \"MODIFY_PRINCIPAL\"},\n\t  {4, \"RENAME_PRINCIPAL\"},\n\t  {5, \"GET_PRINCIPAL\"},\n\t  {6, \"CHPASS_PRINCIPAL\"},\n\t  {7, \"CHRAND_PRINCIPAL\"},\n\t  {8, \"CREATE_POLICY\"},\n\t  {9, \"DELETE_POLICY\"},\n\t  {10, \"MODIFY_POLICY\"},\n\t  {11, \"GET_POLICY\"},\n\t  {12, \"GET_PRIVS\"},\n\t  {13, \"INIT\"},\n\t  {14, \"GET_PRINCS\"},\n\t  {15, \"GET_POLS\"},\n\t  {16, \"SETKEY_PRINCIPAL\"},\n\t  {17, \"SETV4KEY_PRINCIPAL\"},\n\t  {18, \"CREATE_PRINCIPAL3\"},\n\t  {19, \"CHPASS_PRINCIPAL3\"},\n\t  {20, \"CHRAND_PRINCIPAL3\"},\n\t  {21, \"SETKEY_PRINCIPAL3\"}\n     };\n#define NPROCNAMES (sizeof (proc_names) / sizeof (struct procnames))\n     OM_uint32 minor;\n     gss_buffer_desc client, server;\n     gss_OID gss_type;\n     char *a;\n     rpc_u_int32 proc;\n     int i;\n     const char *procname;\n\n     (void) gss_display_name(&minor, client_name, &client, &gss_type);\n     (void) gss_display_name(&minor, server_name, &server, &gss_type);\n     if (client.value == NULL)\n\t client.value = \"(null)\";\n     if (server.value == NULL)\n\t server.value = \"(null)\";\n     a = inet_ntoa(rqst->rq_xprt->xp_raddr.sin_addr);\n\n     proc = msg->rm_call.cb_proc;\n     procname = NULL;\n     for (i = 0; i < NPROCNAMES; i++) {\n\t  if (proc_names[i].proc == proc) {\n\t       procname = proc_names[i].proc_name;\n\t       break;\n\t  }\n     }\n     if (procname != NULL)\n\t  krb5_klog_syslog(LOG_NOTICE, \"WARNING! Forged/garbled request: %s, \"\n\t\t\t   \"claimed client = %s, server = %s, addr = %s\",\n\t\t\t   procname, client.value,\n\t\t\t   server.value, a);\n     else\n\t  krb5_klog_syslog(LOG_NOTICE, \"WARNING! Forged/garbled request: %d, \"\n\t\t\t   \"claimed client = %s, server = %s, addr = %s\",\n\t\t\t   proc, client.value,\n\t\t\t   server.value, a);\n\n     (void) gss_release_buffer(&minor, &client);\n     (void) gss_release_buffer(&minor, &server);\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [
      "#define NPROCNAMES (sizeof (proc_names) / sizeof (struct procnames))"
    ],
    "globals_used": [
      "void log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);",
      "void log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *data);",
      "void log_miscerr(struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *error, char *data);",
      "void log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor);",
      "static void display_status_1(char *, OM_uint32, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_release_buffer",
          "args": [
            "&minor",
            "&server"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_release_buffer",
          "args": [
            "&minor",
            "&client"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_NOTICE",
            "\"WARNING! Forged/garbled request: %d, \"\n\t\t\t   \"claimed client = %s, server = %s, addr = %s\"",
            "proc",
            "client.value",
            "server.value",
            "a"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_NOTICE",
            "\"WARNING! Forged/garbled request: %s, \"\n\t\t\t   \"claimed client = %s, server = %s, addr = %s\"",
            "procname",
            "client.value",
            "server.value",
            "a"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "rqst->rq_xprt->xp_raddr.sin_addr"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_display_name",
          "args": [
            "&minor",
            "server_name",
            "&server",
            "&gss_type"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_display_name",
          "args": [
            "&minor",
            "client_name",
            "&client",
            "&gss_type"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\n#define NPROCNAMES (sizeof (proc_names) / sizeof (struct procnames))\n\nvoid log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);\nvoid log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *data);\nvoid log_miscerr(struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *error, char *data);\nvoid log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor);\nstatic void display_status_1(char *, OM_uint32, int);\n\nvoid log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *data)\n{\n     struct procnames {\n\t  rpc_u_int32 proc;\n\t  const char *proc_name;\n     };\n     static const struct procnames proc_names[] = {\n\t  {1, \"CREATE_PRINCIPAL\"},\n\t  {2, \"DELETE_PRINCIPAL\"},\n\t  {3, \"MODIFY_PRINCIPAL\"},\n\t  {4, \"RENAME_PRINCIPAL\"},\n\t  {5, \"GET_PRINCIPAL\"},\n\t  {6, \"CHPASS_PRINCIPAL\"},\n\t  {7, \"CHRAND_PRINCIPAL\"},\n\t  {8, \"CREATE_POLICY\"},\n\t  {9, \"DELETE_POLICY\"},\n\t  {10, \"MODIFY_POLICY\"},\n\t  {11, \"GET_POLICY\"},\n\t  {12, \"GET_PRIVS\"},\n\t  {13, \"INIT\"},\n\t  {14, \"GET_PRINCS\"},\n\t  {15, \"GET_POLS\"},\n\t  {16, \"SETKEY_PRINCIPAL\"},\n\t  {17, \"SETV4KEY_PRINCIPAL\"},\n\t  {18, \"CREATE_PRINCIPAL3\"},\n\t  {19, \"CHPASS_PRINCIPAL3\"},\n\t  {20, \"CHRAND_PRINCIPAL3\"},\n\t  {21, \"SETKEY_PRINCIPAL3\"}\n     };\n#define NPROCNAMES (sizeof (proc_names) / sizeof (struct procnames))\n     OM_uint32 minor;\n     gss_buffer_desc client, server;\n     gss_OID gss_type;\n     char *a;\n     rpc_u_int32 proc;\n     int i;\n     const char *procname;\n\n     (void) gss_display_name(&minor, client_name, &client, &gss_type);\n     (void) gss_display_name(&minor, server_name, &server, &gss_type);\n     if (client.value == NULL)\n\t client.value = \"(null)\";\n     if (server.value == NULL)\n\t server.value = \"(null)\";\n     a = inet_ntoa(rqst->rq_xprt->xp_raddr.sin_addr);\n\n     proc = msg->rm_call.cb_proc;\n     procname = NULL;\n     for (i = 0; i < NPROCNAMES; i++) {\n\t  if (proc_names[i].proc == proc) {\n\t       procname = proc_names[i].proc_name;\n\t       break;\n\t  }\n     }\n     if (procname != NULL)\n\t  krb5_klog_syslog(LOG_NOTICE, \"WARNING! Forged/garbled request: %s, \"\n\t\t\t   \"claimed client = %s, server = %s, addr = %s\",\n\t\t\t   procname, client.value,\n\t\t\t   server.value, a);\n     else\n\t  krb5_klog_syslog(LOG_NOTICE, \"WARNING! Forged/garbled request: %d, \"\n\t\t\t   \"claimed client = %s, server = %s, addr = %s\",\n\t\t\t   proc, client.value,\n\t\t\t   server.value, a);\n\n     (void) gss_release_buffer(&minor, &client);\n     (void) gss_release_buffer(&minor, &server);\n}"
  },
  {
    "function_name": "build_princ_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "882-895",
    "snippet": "char *build_princ_name(char *name, char *realm)\n{\n     char *fullname;\n\n     fullname = (char *) malloc(strlen(name) + 1 +\n\t\t\t\t(realm ? strlen(realm) + 1 : 0));\n     if (fullname == NULL)\n\t  return NULL;\n     if (realm)\n\t  sprintf(fullname, \"%s@%s\", name, realm);\n     else\n\t  strcpy(fullname, name);\n     return fullname;\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *build_princ_name(char *name, char *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "fullname",
            "name"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fullname",
            "\"%s@%s\"",
            "name",
            "realm"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(name) + 1 +\n\t\t\t\t(realm ? strlen(realm) + 1 : 0)"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "realm"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nchar *build_princ_name(char *name, char *realm);\n\nchar *build_princ_name(char *name, char *realm)\n{\n     char *fullname;\n\n     fullname = (char *) malloc(strlen(name) + 1 +\n\t\t\t\t(realm ? strlen(realm) + 1 : 0));\n     if (fullname == NULL)\n\t  return NULL;\n     if (realm)\n\t  sprintf(fullname, \"%s@%s\", name, realm);\n     else\n\t  strcpy(fullname, name);\n     return fullname;\n}"
  },
  {
    "function_name": "sig_pipe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "857-862",
    "snippet": "void sig_pipe(int unused)\n{\n     krb5_klog_syslog(LOG_NOTICE, \"Warning: Received a SIGPIPE; probably a \"\n\t    \"client aborted.  Continuing.\");\n     return;\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\tsig_pipe(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_NOTICE",
            "\"Warning: Received a SIGPIPE; probably a \"\n\t    \"client aborted.  Continuing.\""
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid\tsig_pipe(int);\n\nvoid sig_pipe(int unused)\n{\n     krb5_klog_syslog(LOG_NOTICE, \"Warning: Received a SIGPIPE; probably a \"\n\t    \"client aborted.  Continuing.\");\n     return;\n}"
  },
  {
    "function_name": "request_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "841-846",
    "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "volatile int\tsignal_request_exit = 0;",
      "void\trequest_exit(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_DEBUG",
            "\"Got signal to request exit\""
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
  },
  {
    "function_name": "reset_db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "808-823",
    "snippet": "void reset_db(void)\n{\n#ifdef notdef\n     kadm5_ret_t ret;\n     \n     if (ret = kadm5_flush(global_server_handle)) {\n\t  krb5_klog_syslog(LOG_ERR, \"FATAL ERROR!  %s while flushing databases.  \"\n\t\t \"Databases may be corrupt!  Aborting.\",\n\t\t error_message(ret));\n\t  krb5_klog_close(context);\n\t  exit(3);\n     }\n#endif\n\n     return;\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void\treset_db(void);",
      "void *global_server_handle;",
      "static krb5_context context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "3"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"FATAL ERROR!  %s while flushing databases.  \"\n\t\t \"Databases may be corrupt!  Aborting.\"",
            "error_message(ret)"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_flush",
          "args": [
            "global_server_handle"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid\treset_db(void);\nvoid *global_server_handle;\nstatic krb5_context context;\n\nvoid reset_db(void)\n{\n#ifdef notdef\n     kadm5_ret_t ret;\n     \n     if (ret = kadm5_flush(global_server_handle)) {\n\t  krb5_klog_syslog(LOG_ERR, \"FATAL ERROR!  %s while flushing databases.  \"\n\t\t \"Databases may be corrupt!  Aborting.\",\n\t\t error_message(ret));\n\t  krb5_klog_close(context);\n\t  exit(3);\n     }\n#endif\n\n     return;\n}"
  },
  {
    "function_name": "request_hup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "788-792",
    "snippet": "void request_hup(int signum)\n{\n     signal_request_hup = 1;\n     return;\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "volatile int\tsignal_request_hup = 0;",
      "void\trequest_hup(int);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_hup = 0;\nvoid\trequest_hup(int);\n\nvoid request_hup(int signum)\n{\n     signal_request_hup = 1;\n     return;\n}"
  },
  {
    "function_name": "request_pure_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "766-772",
    "snippet": "void request_pure_clear(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request a Purify report and clear the old Purify info\");\n     signal_pure_report = 1;\n     signal_pure_clear = 1;\n     return;\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_DEBUG",
            "\"Got signal to request a Purify report and clear the old Purify info\""
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid request_pure_clear(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request a Purify report and clear the old Purify info\");\n     signal_pure_report = 1;\n     signal_pure_clear = 1;\n     return;\n}"
  },
  {
    "function_name": "request_pure_report",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "744-749",
    "snippet": "void request_pure_report(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request a Purify report\");\n     signal_pure_report = 1;\n     return;\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_DEBUG",
            "\"Got signal to request a Purify report\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid request_pure_report(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request a Purify report\");\n     signal_pure_report = 1;\n     return;\n}"
  },
  {
    "function_name": "kadm_svc_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "681-728",
    "snippet": "void kadm_svc_run(params)\nkadm5_config_params *params;\n{\n     fd_set\trfd;\n     int\tsz = gssrpc__rpc_dtablesize();\n     struct\ttimeval\t    timeout;\n     \n     while(signal_request_exit == 0) {\n\t  if (signal_request_hup) {\n\t      reset_db();\n\t      krb5_klog_reopen(context);\n\t      signal_request_hup = 0;\n\t  }\n#ifdef PURIFY\n\t  if (signal_pure_report)\t/* check to see if a report */\n\t\t\t\t\t/* should be dumped... */\n\t    {\n\t      purify_new_reports();\n\t      signal_pure_report = 0;\n\t    }\n\t  if (signal_pure_clear)\t/* ...before checking whether */\n\t\t\t\t\t/* the info should be cleared. */\n\t    {\n\t      purify_clear_new_reports();\n\t      signal_pure_clear = 0;\n\t    }\n#endif /* PURIFY */\n\t  timeout.tv_sec = TIMEOUT;\n\t  timeout.tv_usec = 0;\n\t  rfd = svc_fdset;\n\t  FD_SET(schpw, &rfd);\n\t  switch(select(sz, (fd_set *) &rfd, NULL, NULL, &timeout)) {\n\t  case -1:\n\t       if(errno == EINTR)\n\t\t    continue;\n\t       perror(\"select\");\n\t       return;\n\t  case 0:\n\t       reset_db();\n\t       break;\n\t  default:\n\t      if (FD_ISSET(schpw, &rfd))\n\t\t  do_schpw(schpw, params);\n\t      else\n\t\t  svc_getreqset(&rfd);\n\t  }\n     }\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [
      "#define\tTIMEOUT\t15"
    ],
    "globals_used": [
      "volatile int\tsignal_request_exit = 0;",
      "volatile int\tsignal_request_hup = 0;",
      "void\treset_db(void);",
      "void\tkadm_svc_run(kadm5_config_params *params);",
      "int schpw;",
      "void do_schpw(int s, kadm5_config_params *params);",
      "static krb5_context context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svc_getreqset",
          "args": [
            "&rfd"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_schpw",
          "args": [
            "schpw",
            "params"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "do_schpw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "1083-1176",
          "snippet": "void do_schpw(int s1, kadm5_config_params *params)\n{\n    krb5_error_code ret;\n    /* XXX buffer = ethernet mtu */\n    char req[1500];\n    int len;\n    struct sockaddr_in from;\n    socklen_t fromlen;\n    krb5_keytab kt;\n    krb5_data reqdata, repdata;\n    int s2;\n\n    fromlen = sizeof(from);\n    if ((len = recvfrom(s1, req, sizeof(req), 0, (struct sockaddr *)&from,\n\t\t\t&fromlen)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't receive request: %s\",\n\t\t\t error_message(errno));\n\treturn;\n    }\n\n    if ((ret = krb5_kt_resolve(context, \"KDB:\", &kt))) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't open admin keytab %s\",\n\t\t\t error_message(ret));\n\treturn;\n    }\n\n    reqdata.length = len;\n    reqdata.data = req;\n\n    /* this is really obscure.  s1 is used for all communications.  it\n       is left unconnected in case the server is multihomed and routes\n       are asymmetric.  s2 is connected to resolve routes and get\n       addresses.  this is the *only* way to get proper addresses for\n       multihomed hosts if routing is asymmetric.  \n\n       A related problem in the server, but not the client, is that\n       many os's have no way to disconnect a connected udp socket, so\n       the s2 socket needs to be closed and recreated for each\n       request.  The s1 socket must not be closed, or else queued\n       requests will be lost.\n\n       A \"naive\" client implementation (one socket, no connect,\n       hostname resolution to get the local ip addr) will work and\n       interoperate if the client is single-homed. */\n\n    if ((s2 = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"cannot create connecting socket: %s\",\n\t\t\t error_message(errno));\n\tfprintf(stderr, \"Cannot create connecting socket: %s\",\n\t\terror_message(errno));\n\tsvcauth_gssapi_unset_names();\n\tkadm5_destroy(global_server_handle);\n\tkrb5_klog_close(context);\t  \n\texit(1);\n    }\n\n    if (connect(s2, (struct sockaddr *) &from, sizeof(from)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't connect to client: %s\",\n\t\t\t error_message(errno));\n\tgoto cleanup;\n    }\n\n    if ((ret = process_chpw_request(context, global_server_handle,\n\t\t\t\t    params->realm, s2, kt, &from,\n\t\t\t\t    &reqdata, &repdata))) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Error processing request: %s\", \n\t\t\t error_message(ret));\n    }\n\n    close(s2);\n\n    if (repdata.length == 0) {\n\t/* just return.  This means something really bad happened */\n        goto cleanup;\n    }\n\n    len = sendto(s1, repdata.data, (int) repdata.length, 0,\n\t\t (struct sockaddr *) &from, sizeof(from));\n\n    if (len < (int) repdata.length) {\n\tkrb5_xfree(repdata.data);\n\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Error sending reply: %s\", \n\t\t\t error_message(errno));\n\tgoto cleanup;\n    }\n\n    krb5_xfree(repdata.data);\n\ncleanup:\n    krb5_kt_close(context, kt);\n\n    return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\tkadm_svc_run(kadm5_config_params *params);",
            "void *global_server_handle;",
            "char *build_princ_name(char *name, char *realm);",
            "void log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);",
            "void log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *data);",
            "void log_miscerr(struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *error, char *data);",
            "void do_schpw(int s, kadm5_config_params *params);",
            "static krb5_context context;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid\tkadm_svc_run(kadm5_config_params *params);\nvoid *global_server_handle;\nchar *build_princ_name(char *name, char *realm);\nvoid log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);\nvoid log_badverf(gss_name_t client_name, gss_name_t server_name,\n\t\t struct svc_req *rqst, struct rpc_msg *msg,\n\t\t char *data);\nvoid log_miscerr(struct svc_req *rqst, struct rpc_msg *msg, char\n\t\t *error, char *data);\nvoid do_schpw(int s, kadm5_config_params *params);\nstatic krb5_context context;\n\nvoid do_schpw(int s1, kadm5_config_params *params)\n{\n    krb5_error_code ret;\n    /* XXX buffer = ethernet mtu */\n    char req[1500];\n    int len;\n    struct sockaddr_in from;\n    socklen_t fromlen;\n    krb5_keytab kt;\n    krb5_data reqdata, repdata;\n    int s2;\n\n    fromlen = sizeof(from);\n    if ((len = recvfrom(s1, req, sizeof(req), 0, (struct sockaddr *)&from,\n\t\t\t&fromlen)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't receive request: %s\",\n\t\t\t error_message(errno));\n\treturn;\n    }\n\n    if ((ret = krb5_kt_resolve(context, \"KDB:\", &kt))) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't open admin keytab %s\",\n\t\t\t error_message(ret));\n\treturn;\n    }\n\n    reqdata.length = len;\n    reqdata.data = req;\n\n    /* this is really obscure.  s1 is used for all communications.  it\n       is left unconnected in case the server is multihomed and routes\n       are asymmetric.  s2 is connected to resolve routes and get\n       addresses.  this is the *only* way to get proper addresses for\n       multihomed hosts if routing is asymmetric.  \n\n       A related problem in the server, but not the client, is that\n       many os's have no way to disconnect a connected udp socket, so\n       the s2 socket needs to be closed and recreated for each\n       request.  The s1 socket must not be closed, or else queued\n       requests will be lost.\n\n       A \"naive\" client implementation (one socket, no connect,\n       hostname resolution to get the local ip addr) will work and\n       interoperate if the client is single-homed. */\n\n    if ((s2 = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"cannot create connecting socket: %s\",\n\t\t\t error_message(errno));\n\tfprintf(stderr, \"Cannot create connecting socket: %s\",\n\t\terror_message(errno));\n\tsvcauth_gssapi_unset_names();\n\tkadm5_destroy(global_server_handle);\n\tkrb5_klog_close(context);\t  \n\texit(1);\n    }\n\n    if (connect(s2, (struct sockaddr *) &from, sizeof(from)) < 0) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Couldn't connect to client: %s\",\n\t\t\t error_message(errno));\n\tgoto cleanup;\n    }\n\n    if ((ret = process_chpw_request(context, global_server_handle,\n\t\t\t\t    params->realm, s2, kt, &from,\n\t\t\t\t    &reqdata, &repdata))) {\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Error processing request: %s\", \n\t\t\t error_message(ret));\n    }\n\n    close(s2);\n\n    if (repdata.length == 0) {\n\t/* just return.  This means something really bad happened */\n        goto cleanup;\n    }\n\n    len = sendto(s1, repdata.data, (int) repdata.length, 0,\n\t\t (struct sockaddr *) &from, sizeof(from));\n\n    if (len < (int) repdata.length) {\n\tkrb5_xfree(repdata.data);\n\n\tkrb5_klog_syslog(LOG_ERR, \"chpw: Error sending reply: %s\", \n\t\t\t error_message(errno));\n\tgoto cleanup;\n    }\n\n    krb5_xfree(repdata.data);\n\ncleanup:\n    krb5_kt_close(context, kt);\n\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FD_ISSET",
          "args": [
            "schpw",
            "&rfd"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reset_db",
          "args": [],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "reset_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "808-823",
          "snippet": "void reset_db(void)\n{\n#ifdef notdef\n     kadm5_ret_t ret;\n     \n     if (ret = kadm5_flush(global_server_handle)) {\n\t  krb5_klog_syslog(LOG_ERR, \"FATAL ERROR!  %s while flushing databases.  \"\n\t\t \"Databases may be corrupt!  Aborting.\",\n\t\t error_message(ret));\n\t  krb5_klog_close(context);\n\t  exit(3);\n     }\n#endif\n\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void\treset_db(void);",
            "void *global_server_handle;",
            "static krb5_context context;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid\treset_db(void);\nvoid *global_server_handle;\nstatic krb5_context context;\n\nvoid reset_db(void)\n{\n#ifdef notdef\n     kadm5_ret_t ret;\n     \n     if (ret = kadm5_flush(global_server_handle)) {\n\t  krb5_klog_syslog(LOG_ERR, \"FATAL ERROR!  %s while flushing databases.  \"\n\t\t \"Databases may be corrupt!  Aborting.\",\n\t\t error_message(ret));\n\t  krb5_klog_close(context);\n\t  exit(3);\n     }\n#endif\n\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perror",
          "args": [
            "\"select\""
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select",
          "args": [
            "sz",
            "(fd_set *) &rfd",
            "NULL",
            "NULL",
            "&timeout"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FD_SET",
          "args": [
            "schpw",
            "&rfd"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "purify_clear_new_reports",
          "args": [],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "purify_new_reports",
          "args": [],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_reopen",
          "args": [
            "context"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gssrpc__rpc_dtablesize",
          "args": [],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\n#define\tTIMEOUT\t15\n\nvolatile int\tsignal_request_exit = 0;\nvolatile int\tsignal_request_hup = 0;\nvoid\treset_db(void);\nvoid\tkadm_svc_run(kadm5_config_params *params);\nint schpw;\nvoid do_schpw(int s, kadm5_config_params *params);\nstatic krb5_context context;\n\nvoid kadm_svc_run(params)\nkadm5_config_params *params;\n{\n     fd_set\trfd;\n     int\tsz = gssrpc__rpc_dtablesize();\n     struct\ttimeval\t    timeout;\n     \n     while(signal_request_exit == 0) {\n\t  if (signal_request_hup) {\n\t      reset_db();\n\t      krb5_klog_reopen(context);\n\t      signal_request_hup = 0;\n\t  }\n#ifdef PURIFY\n\t  if (signal_pure_report)\t/* check to see if a report */\n\t\t\t\t\t/* should be dumped... */\n\t    {\n\t      purify_new_reports();\n\t      signal_pure_report = 0;\n\t    }\n\t  if (signal_pure_clear)\t/* ...before checking whether */\n\t\t\t\t\t/* the info should be cleared. */\n\t    {\n\t      purify_clear_new_reports();\n\t      signal_pure_clear = 0;\n\t    }\n#endif /* PURIFY */\n\t  timeout.tv_sec = TIMEOUT;\n\t  timeout.tv_usec = 0;\n\t  rfd = svc_fdset;\n\t  FD_SET(schpw, &rfd);\n\t  switch(select(sz, (fd_set *) &rfd, NULL, NULL, &timeout)) {\n\t  case -1:\n\t       if(errno == EINTR)\n\t\t    continue;\n\t       perror(\"select\");\n\t       return;\n\t  case 0:\n\t       reset_db();\n\t       break;\n\t  default:\n\t      if (FD_ISSET(schpw, &rfd))\n\t\t  do_schpw(schpw, params);\n\t      else\n\t\t  svc_getreqset(&rfd);\n\t  }\n     }\n}"
  },
  {
    "function_name": "setup_signal_handlers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "639-667",
    "snippet": "void setup_signal_handlers(void) {\n#ifdef POSIX_SIGNALS\n     (void) sigemptyset(&s_action.sa_mask);\n     s_action.sa_handler = request_exit;\n     (void) sigaction(SIGINT, &s_action, (struct sigaction *) NULL);\n     (void) sigaction(SIGTERM, &s_action, (struct sigaction *) NULL);\n     (void) sigaction(SIGQUIT, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = request_hup;\n     (void) sigaction(SIGHUP, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = sig_pipe;\n     (void) sigaction(SIGPIPE, &s_action, (struct sigaction *) NULL);\n#ifdef PURIFY\n     s_action.sa_handler = request_pure_report;\n     (void) sigaction(SIGUSR1, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = request_pure_clear;\n     (void) sigaction(SIGUSR2, &s_action, (struct sigaction *) NULL);\n#endif /* PURIFY */\n#else /* POSIX_SIGNALS */\n     signal(SIGINT, request_exit);\n     signal(SIGTERM, request_exit);\n     signal(SIGQUIT, request_exit);\n     signal(SIGHUP, request_hup);\n     signal(SIGPIPE, sig_pipe);\n#ifdef PURIFY\n     signal(SIGUSR1, request_pure_report);\n     signal(SIGUSR2, request_pure_clear);\n#endif /* PURIFY */\n#endif /* POSIX_SIGNALS */\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void    setup_signal_handlers(void);",
      "void\trequest_exit(int);",
      "void\trequest_hup(int);",
      "void\tsig_pipe(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGUSR2",
            "request_pure_clear"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGUSR1",
            "request_pure_report"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGPIPE",
            "sig_pipe"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGHUP",
            "request_hup"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGQUIT",
            "request_exit"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGTERM",
            "request_exit"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal",
          "args": [
            "SIGINT",
            "request_exit"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGUSR2",
            "&s_action",
            "(struct sigaction *) NULL"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGUSR1",
            "&s_action",
            "(struct sigaction *) NULL"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGPIPE",
            "&s_action",
            "(struct sigaction *) NULL"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGHUP",
            "&s_action",
            "(struct sigaction *) NULL"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGQUIT",
            "&s_action",
            "(struct sigaction *) NULL"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGTERM",
            "&s_action",
            "(struct sigaction *) NULL"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction",
          "args": [
            "SIGINT",
            "&s_action",
            "(struct sigaction *) NULL"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&s_action.sa_mask"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid    setup_signal_handlers(void);\nvoid\trequest_exit(int);\nvoid\trequest_hup(int);\nvoid\tsig_pipe(int);\n\nvoid setup_signal_handlers(void) {\n#ifdef POSIX_SIGNALS\n     (void) sigemptyset(&s_action.sa_mask);\n     s_action.sa_handler = request_exit;\n     (void) sigaction(SIGINT, &s_action, (struct sigaction *) NULL);\n     (void) sigaction(SIGTERM, &s_action, (struct sigaction *) NULL);\n     (void) sigaction(SIGQUIT, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = request_hup;\n     (void) sigaction(SIGHUP, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = sig_pipe;\n     (void) sigaction(SIGPIPE, &s_action, (struct sigaction *) NULL);\n#ifdef PURIFY\n     s_action.sa_handler = request_pure_report;\n     (void) sigaction(SIGUSR1, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = request_pure_clear;\n     (void) sigaction(SIGUSR2, &s_action, (struct sigaction *) NULL);\n#endif /* PURIFY */\n#else /* POSIX_SIGNALS */\n     signal(SIGINT, request_exit);\n     signal(SIGTERM, request_exit);\n     signal(SIGQUIT, request_exit);\n     signal(SIGHUP, request_hup);\n     signal(SIGPIPE, sig_pipe);\n#ifdef PURIFY\n     signal(SIGUSR1, request_pure_report);\n     signal(SIGUSR2, request_pure_clear);\n#endif /* PURIFY */\n#endif /* POSIX_SIGNALS */\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "198-630",
    "snippet": "int main(int argc, char *argv[])\n{\n     register\tSVCXPRT *transp;\n     extern\tchar *optarg;\n     extern\tint optind, opterr;\n     int ret, nofork, oldnames = 0;\n     OM_uint32 OMret, major_status, minor_status;\n     char *whoami;\n     gss_buffer_desc in_buf;\n     struct sockaddr_in addr;\n     int s;\n     auth_gssapi_name names[4];\n     gss_buffer_desc gssbuf;\n     gss_OID nt_krb5_name_oid;\n     kadm5_config_params params;\n\n     setvbuf(stderr, NULL, _IONBF, 0);\n\n     /* This is OID value the Krb5_Name NameType */\n     gssbuf.value = \"{1 2 840 113554 1 2 2 1}\";\n     gssbuf.length = strlen(gssbuf.value);\n     major_status = gss_str_to_oid(&minor_status, &gssbuf, &nt_krb5_name_oid);\n     if (major_status != GSS_S_COMPLETE) {\n\t     fprintf(stderr, \"Couldn't create KRB5 Name NameType OID\\n\");\n\t     display_status(\"str_to_oid\", major_status, minor_status);\n\t     exit(1);\n     }\n     \n     names[0].name = names[1].name = names[2].name = names[3].name = NULL;\n     names[0].type = names[1].type = names[2].type = names[3].type =\n\t     nt_krb5_name_oid;\n\n#ifdef PURIFY\n     purify_start_batch();\n#endif /* PURIFY */\n     whoami = (strrchr(argv[0], '/') ? strrchr(argv[0], '/')+1 : argv[0]);\n\n     nofork = 0;\n\n     memset((char *) &params, 0, sizeof(params));\n     \n     argc--; argv++;\n     while (argc) {\n\t  if (strcmp(*argv, \"-r\") == 0) {\n\t       argc--; argv++;\n\t       if (!argc)\n\t\t    usage();\n\t       params.realm = *argv;\n\t       params.mask |= KADM5_CONFIG_REALM;\n\t       argc--; argv++;\n\t       continue;\n\t  } else if (strcmp(*argv, \"-m\") == 0) {\n\t       params.mkey_from_kbd = 1;\n\t       params.mask |= KADM5_CONFIG_MKEY_FROM_KBD;\n\t  } else if (strcmp(*argv, \"-nofork\") == 0) {\n\t       nofork = 1;\n#ifdef USE_PASSWORD_SERVER\n          } else if (strcmp(*argv, \"-passwordserver\") == 0) {\n              kadm5_set_use_password_server ();\n#endif              \n\t  } else if(strcmp(*argv, \"-port\") == 0) {\n\t    argc--; argv++;\n\t    if(!argc)\n\t      usage();\n\t    params.kadmind_port = atoi(*argv);\n\t    params.mask |= KADM5_CONFIG_KADMIND_PORT;\n\t  } else\n\t       break;\n\t  argc--; argv++;\n     }\n     \n     if (argc != 0)\n\t  usage();\n\n     if ((ret = krb5_init_context(&context))) {\n\t  fprintf(stderr, \"%s: %s while initializing context, aborting\\n\",\n\t\t  whoami, error_message(ret));\n\t  exit(1);\n     }\n\n     krb5_klog_init(context, \"admin_server\", whoami, 1);\n\n\n     krb5_klog_syslog(LOG_INFO, \"Seeding random number generator\");\n          ret = krb5_c_random_os_entropy(context, 1, NULL);\n\t  if(ret) {\n\t    krb5_klog_syslog(LOG_ERR, \"Error getting random seed: %s, aborting\",\n\t\t\t     error_message(ret));\n\t    exit(1);\n\t  }\n\t  \n     if((ret = kadm5_init(\"kadmind\", NULL,\n\t\t\t  NULL, &params,\n\t\t\t  KADM5_STRUCT_VERSION,\n\t\t\t  KADM5_API_VERSION_2,\n\t\t\t  &global_server_handle)) != \n\tKADM5_OK) {\n\t  krb5_klog_syslog(LOG_ERR, \"%s while initializing, aborting\",\n\t\t error_message(ret));\n\t  fprintf(stderr, \"%s: %s while initializing, aborting\\n\",\n\t\t  whoami, error_message(ret));\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n     \n     if ((ret = kadm5_get_config_params(context, NULL, NULL, &params,\n\t\t\t\t\t&params))) {\n\t  krb5_klog_syslog(LOG_ERR, \"%s: %s while initializing, aborting\",\n\t\t\t   whoami, error_message(ret));\n\t  fprintf(stderr, \"%s: %s while initializing, aborting\\n\",\n\t\t  whoami, error_message(ret));\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n\n#define REQUIRED_PARAMS (KADM5_CONFIG_REALM | KADM5_CONFIG_ACL_FILE)\n\n     if ((params.mask & REQUIRED_PARAMS) != REQUIRED_PARAMS) {\n\t  krb5_klog_syslog(LOG_ERR, \"%s: Missing required configuration values \"\n\t\t\t   \"while initializing, aborting\", whoami,\n\t\t\t   (params.mask & REQUIRED_PARAMS) ^ REQUIRED_PARAMS);\n\t  fprintf(stderr, \"%s: Missing required configuration values \"\n\t\t  \"(%lx) while initializing, aborting\\n\", whoami,\n\t\t  (params.mask & REQUIRED_PARAMS) ^ REQUIRED_PARAMS);\n\t  krb5_klog_close(context);\n\t  kadm5_destroy(global_server_handle);\n\t  exit(1);\n     }\n\n     memset(&addr, 0, sizeof(addr));\n     addr.sin_family = AF_INET;\n     addr.sin_addr.s_addr = INADDR_ANY;\n     addr.sin_port = htons(params.kadmind_port);\n\n     if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot create TCP socket: %s\",\n\t\t\t   error_message(errno));\n\t  fprintf(stderr, \"Cannot create TCP socket: %s\",\n\t\t  error_message(errno));\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\t  \n\t  exit(1);\n     }\n\n     if ((schpw = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\t krb5_klog_syslog(LOG_ERR,\n\t\t\t   \"cannot create simple chpw socket: %s\",\n\t\t\t   error_message(errno));\n\t fprintf(stderr, \"Cannot create simple chpw socket: %s\",\n\t\t error_message(errno));\n\t kadm5_destroy(global_server_handle);\n\t krb5_klog_close(context);\n\t exit(1);\n     }\n\n#ifdef SO_REUSEADDR\n     /* the old admin server turned on SO_REUSEADDR for non-default\n\tport numbers.  this was necessary, on solaris, for the tests\n\tto work.  jhawk argues that the debug and production modes\n\tshould be the same.  I think I agree, so I'm always going to set\n\tSO_REUSEADDR.  The other option is to have the unit tests wait\n\tuntil the port is useable, or use a different port each time.  \n\t--marc */\n\n     {\n\t int\tallowed;\n\n\t allowed = 1;\n\t if (setsockopt(s,\n\t\t\tSOL_SOCKET,\n\t\t\tSO_REUSEADDR,\n\t\t\t(char *) &allowed,\n\t\t\tsizeof(allowed)) < 0) {\n\t     krb5_klog_syslog(LOG_ERR, \"Cannot set SO_REUSEADDR: %s\",\n\t\t\t      error_message(errno));\n\t     fprintf(stderr, \"Cannot set SO_REUSEADDR: %s\",\n\t\t     error_message(errno));\n\t     kadm5_destroy(global_server_handle);\n\t     krb5_klog_close(context);\t  \n\t     exit(1);\n\t }\n\t if (setsockopt(schpw, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t(char *) &allowed, sizeof(allowed)) < 0) {\n\t     krb5_klog_syslog(LOG_ERR, \"main\",\n\t\t\t      \"cannot set SO_REUSEADDR on simple chpw socket: %s\", \n\t\t\t      error_message(errno));\n\t     fprintf(stderr,\n\t\t     \"Cannot set SO_REUSEADDR on simple chpw socket: %s\",\n \t\t     error_message(errno));\n \t     kadm5_destroy(global_server_handle);\n \t     krb5_klog_close(context);\n\t }\n\n     }\n#endif /* SO_REUSEADDR */\n     memset(&addr, 0, sizeof(addr));\n     addr.sin_family = AF_INET;\n     addr.sin_addr.s_addr = INADDR_ANY;\n     addr.sin_port = htons(params.kadmind_port);\n\n     if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t  int oerrno = errno;\n\t  fprintf(stderr, \"%s: Cannot bind socket.\\n\", whoami);\n\t  fprintf(stderr, \"bind: %s\\n\", error_message(oerrno));\n\t  errno = oerrno;\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot bind socket: %s\",\n\t\t\t   error_message(errno));\n\t  if(oerrno == EADDRINUSE) {\n\t       char *w = strrchr(whoami, '/');\n\t       if (w) {\n\t\t    w++;\n\t       }\n\t       else {\n\t\t    w = whoami;\n\t       }\n\t       fprintf(stderr,\n\"This probably means that another %s process is already\\n\"\n\"running, or that another program is using the server port (number %d)\\n\"\n\"after being assigned it by the RPC portmap daemon.  If another\\n\"\n\"%s is already running, you should kill it before\\n\"\n\"restarting the server.  If, on the other hand, another program is\\n\"\n\"using the server port, you should kill it before running\\n\"\n\"%s, and ensure that the conflict does not occur in the\\n\"\n\"future by making sure that %s is started on reboot\\n\"\n\t\t       \"before portmap.\\n\", w, ntohs(addr.sin_port), w, w, w);\n\t       krb5_klog_syslog(LOG_ERR, \"Check for already-running %s or for \"\n\t\t      \"another process using port %d\", w,\n\t\t      htons(addr.sin_port));\n\t  }\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n     memset(&addr, 0, sizeof(addr));\n     addr.sin_family = AF_INET;\n     addr.sin_addr.s_addr = INADDR_ANY;\n     /* XXX */\n     addr.sin_port = htons(params.kpasswd_port);\n\n     if (bind(schpw, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t  char portbuf[32];\n\t  int oerrno = errno;\n\t  fprintf(stderr, \"%s: Cannot bind socket.\\n\", whoami);\n\t  fprintf(stderr, \"bind: %s\\n\", error_message(oerrno));\n\t  errno = oerrno;\n\t  sprintf(portbuf, \"%d\", ntohs(addr.sin_port));\n\t  krb5_klog_syslog(LOG_ERR, \"cannot bind simple chpw socket: %s\",\n\t\t\t   error_message(oerrno));\n\t  if(oerrno == EADDRINUSE) {\n\t       char *w = strrchr(whoami, '/');\n\t       if (w) {\n\t\t    w++;\n\t       }\n\t       else {\n\t\t    w = whoami;\n\t       }\n\t       fprintf(stderr,\n\"This probably means that another %s process is already\\n\"\n\"running, or that another program is using the server port (number %d).\\n\"\n\"If another %s is already running, you should kill it before\\n\"\n\"restarting the server.\\n\",\n\t\t       w, ntohs(addr.sin_port), w);\n \t  }\n \t  kadm5_destroy(global_server_handle);\n \t  krb5_klog_close(context);\n\t  exit(1);\n     }\n     \n     transp = svctcp_create(s, 0, 0);\n     if(transp == NULL) {\n\t  fprintf(stderr, \"%s: Cannot create RPC service.\\n\", whoami);\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot create RPC service: %m\");\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\t  \n\t  exit(1);\n     }\n     if(!svc_register(transp, KADM, KADMVERS, kadm_1, 0)) {\n\t  fprintf(stderr, \"%s: Cannot register RPC service.\\n\", whoami);\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot register RPC service, failing.\");\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\t  \n\t  exit(1);\n     }\n\n     names[0].name = build_princ_name(KADM5_ADMIN_SERVICE, params.realm);\n     names[1].name = build_princ_name(KADM5_CHANGEPW_SERVICE, params.realm);\n     names[2].name = build_princ_name(OVSEC_KADM_ADMIN_SERVICE, params.realm);\n     names[3].name = build_princ_name(OVSEC_KADM_CHANGEPW_SERVICE,\n\t\t\t\t      params.realm); \n     if (names[0].name == NULL || names[1].name == NULL ||\n\t names[2].name == NULL || names[3].name == NULL) {\n\t  krb5_klog_syslog(LOG_ERR,\n\t\t\t   \"Cannot build GSS-API authentication names, \"\n\t\t\t   \"failing.\");\n\t  fprintf(stderr, \"%s: Cannot build GSS-API authentication names.\\n\",\n\t\t  whoami);\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\t  \n\t  exit(1);\n     }\n\n     /*\n      * Go through some contortions to point gssapi at a kdb keytab.\n      * This prevents kadmind from needing to use an actual file-based\n      * keytab.\n      */\n     /* XXX extract kadm5's krb5_context */\n     hctx = ((kadm5_server_handle_t)global_server_handle)->context;\n     /* Set ktkdb's internal krb5_context. */\n     ret = krb5_ktkdb_set_context(hctx);\n     if (ret) {\n\t  krb5_klog_syslog(LOG_ERR, \"Can't set kdb keytab's internal context.\");\n\t  goto kterr;\n     }\n     /* XXX master_keyblock is in guts of lib/kadm5/server_kdb.c */\n     ret = krb5_db_set_mkey(hctx, &master_keyblock);\n     if (ret) {\n\t  krb5_klog_syslog(LOG_ERR, \"Can't set master key for kdb keytab.\");\n\t  goto kterr;\n     }\n     ret = krb5_kt_register(context, &krb5_kt_kdb_ops);\n     if (ret) {\n\t  krb5_klog_syslog(LOG_ERR, \"Can't register kdb keytab.\");\n\t  goto kterr;\n     }\n     /* Tell gssapi about the kdb keytab. */\n     ret = krb5_gss_register_acceptor_identity(\"KDB:\");\n     if (ret) {\n\t  krb5_klog_syslog(LOG_ERR, \"Can't register acceptor keytab.\");\n\t  goto kterr;\n     }\nkterr:\n     if (ret) {\n\t  krb5_klog_syslog(LOG_ERR, \"%s\", error_message(ret));\n\t  fprintf(stderr, \"%s: Can't set up keytab for RPC.\\n\", whoami);\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n\n     /*\n      * Try to acquire creds for the old OV services as well as the\n      * new names, but if that fails just fall back on the new names.\n      */\n     if (svcauth_gssapi_set_names(names, 4) == TRUE)\n\t  oldnames++;\n     if (!oldnames && svcauth_gssapi_set_names(names, 2) == FALSE) {\n\t  krb5_klog_syslog(LOG_ERR,\n\t\t\t   \"Cannot set GSS-API authentication names (keytab not present?), \"\n\t\t\t   \"failing.\");\n\t  fprintf(stderr, \"%s: Cannot set GSS-API authentication names.\\n\",\n\t\t  whoami);\n\t  svcauth_gssapi_unset_names();\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\t  \n\t  exit(1);\n     }\n\n     /* if set_names succeeded, this will too */\n     in_buf.value = names[1].name;\n     in_buf.length = strlen(names[1].name) + 1;\n     (void) gss_import_name(&OMret, &in_buf, nt_krb5_name_oid,\n\t\t\t    &gss_changepw_name);\n     if (oldnames) {\n\t  in_buf.value = names[3].name;\n\t  in_buf.length = strlen(names[3].name) + 1;\n\t  (void) gss_import_name(&OMret, &in_buf, nt_krb5_name_oid,\n\t\t\t\t &gss_oldchangepw_name);\n     }\n\n     svcauth_gssapi_set_log_badauth_func(log_badauth, NULL);\n     svcauth_gssapi_set_log_badverf_func(log_badverf, NULL);\n     svcauth_gssapi_set_log_miscerr_func(log_miscerr, NULL);\n     \n     svcauth_gss_set_log_badauth_func(log_badauth, NULL);\n     svcauth_gss_set_log_badverf_func(log_badverf, NULL);\n     svcauth_gss_set_log_miscerr_func(log_miscerr, NULL);\n     \n     if (svcauth_gss_set_svc_name(GSS_C_NO_NAME) != TRUE) {\n\t fprintf(stderr, \"%s: Cannot initialize RPCSEC_GSS service name.\\n\",\n\t\t whoami);\n\t exit(1);\n     }\n\n     if ((ret = acl_init(context, 0, params.acl_file))) {\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot initialize acl file: %s\",\n\t\t error_message(ret));\n\t  fprintf(stderr, \"%s: Cannot initialize acl file: %s\\n\",\n\t\t  whoami, error_message(ret));\n\t  svcauth_gssapi_unset_names();\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n\n     if (!nofork && (ret = daemon(0, 0))) {\n\t  ret = errno;\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot detach from tty: %s\", error_message(ret));\n\t  fprintf(stderr, \"%s: Cannot detach from tty: %s\\n\",\n\t\t  whoami, error_message(ret));\n\t  svcauth_gssapi_unset_names();\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n     \n     setup_signal_handlers();\n     krb5_klog_syslog(LOG_INFO, \"starting\");\n     kadm_svc_run(&params);\n     krb5_klog_syslog(LOG_INFO, \"finished, exiting\");\n\n     /* Clean up memory, etc */\n     svcauth_gssapi_unset_names();\n     kadm5_destroy(global_server_handle);\n     close(s);\n     acl_finish(context, 0);\n     if(gss_changepw_name) {\n          (void) gss_release_name(&OMret, &gss_changepw_name);\n     }\n     if(gss_oldchangepw_name) {\n          (void) gss_release_name(&OMret, &gss_oldchangepw_name);\n     }\n     for(s = 0 ; s < 4; s++) {\n          if (names[s].name) {\n\t        free(names[s].name);\n\t  }\n     }\n\n     krb5_klog_close(context);\n     krb5_free_context(context);\n     exit(2);\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [
      "#define REQUIRED_PARAMS (KADM5_CONFIG_REALM | KADM5_CONFIG_ACL_FILE)",
      "#define OVSEC_KADM_CHANGEPW_SERVICE\t\"ovsec_adm/changepw\"",
      "#define OVSEC_KADM_ADMIN_SERVICE\t\"ovsec_adm/admin\""
    ],
    "globals_used": [
      "void    setup_signal_handlers(void);",
      "void\tkadm_svc_run(kadm5_config_params *params);",
      "gss_name_t gss_changepw_name = NULL, gss_oldchangepw_name = NULL;",
      "void *global_server_handle;",
      "extern krb5_keyblock master_keyblock;",
      "char *build_princ_name(char *name, char *realm);",
      "int schpw;",
      "void do_schpw(int s, kadm5_config_params *params);",
      "static void display_status_1(char *, OM_uint32, int);",
      "static krb5_context context;",
      "static krb5_context hctx;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "2"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "names[s].name"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "free_server_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/server_stubs.c",
          "lines": "137-141",
          "snippet": "static void free_server_handle(kadm5_server_handle_t handle)\n{\n     krb5_free_principal(handle->context, handle->current_caller);\n     free(handle);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include <krb5/adm_proto.h>  /* krb5_klog_syslog */",
            "#include <arpa/inet.h>  /* inet_ntoa */",
            "#include <syslog.h>",
            "#include <kadm5/server_acl.h>",
            "#include <kadm5/server_internal.h>",
            "#include <kadm5/kadm_rpc.h>",
            "#include <kadm5/admin.h>",
            "#include <krb5.h>",
            "#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */",
            "#include <gssapi/gssapi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static gss_name_t acceptor_name(gss_ctx_id_t context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include <krb5/adm_proto.h>  /* krb5_klog_syslog */\n#include <arpa/inet.h>  /* inet_ntoa */\n#include <syslog.h>\n#include <kadm5/server_acl.h>\n#include <kadm5/server_internal.h>\n#include <kadm5/kadm_rpc.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */\n#include <gssapi/gssapi.h>\n\nstatic gss_name_t acceptor_name(gss_ctx_id_t context);\n\nstatic void free_server_handle(kadm5_server_handle_t handle)\n{\n     krb5_free_principal(handle->context, handle->current_caller);\n     free(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gss_release_name",
          "args": [
            "&OMret",
            "&gss_oldchangepw_name"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_release_name",
          "args": [
            "&OMret",
            "&gss_changepw_name"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acl_finish",
          "args": [
            "context",
            "0"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "s"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gssapi_unset_names",
          "args": [],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_INFO",
            "\"finished, exiting\""
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm_svc_run",
          "args": [
            "&params"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "kadm_svc_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "681-728",
          "snippet": "void kadm_svc_run(params)\nkadm5_config_params *params;\n{\n     fd_set\trfd;\n     int\tsz = gssrpc__rpc_dtablesize();\n     struct\ttimeval\t    timeout;\n     \n     while(signal_request_exit == 0) {\n\t  if (signal_request_hup) {\n\t      reset_db();\n\t      krb5_klog_reopen(context);\n\t      signal_request_hup = 0;\n\t  }\n#ifdef PURIFY\n\t  if (signal_pure_report)\t/* check to see if a report */\n\t\t\t\t\t/* should be dumped... */\n\t    {\n\t      purify_new_reports();\n\t      signal_pure_report = 0;\n\t    }\n\t  if (signal_pure_clear)\t/* ...before checking whether */\n\t\t\t\t\t/* the info should be cleared. */\n\t    {\n\t      purify_clear_new_reports();\n\t      signal_pure_clear = 0;\n\t    }\n#endif /* PURIFY */\n\t  timeout.tv_sec = TIMEOUT;\n\t  timeout.tv_usec = 0;\n\t  rfd = svc_fdset;\n\t  FD_SET(schpw, &rfd);\n\t  switch(select(sz, (fd_set *) &rfd, NULL, NULL, &timeout)) {\n\t  case -1:\n\t       if(errno == EINTR)\n\t\t    continue;\n\t       perror(\"select\");\n\t       return;\n\t  case 0:\n\t       reset_db();\n\t       break;\n\t  default:\n\t      if (FD_ISSET(schpw, &rfd))\n\t\t  do_schpw(schpw, params);\n\t      else\n\t\t  svc_getreqset(&rfd);\n\t  }\n     }\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [
            "#define\tTIMEOUT\t15"
          ],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "volatile int\tsignal_request_hup = 0;",
            "void\treset_db(void);",
            "void\tkadm_svc_run(kadm5_config_params *params);",
            "int schpw;",
            "void do_schpw(int s, kadm5_config_params *params);",
            "static krb5_context context;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\n#define\tTIMEOUT\t15\n\nvolatile int\tsignal_request_exit = 0;\nvolatile int\tsignal_request_hup = 0;\nvoid\treset_db(void);\nvoid\tkadm_svc_run(kadm5_config_params *params);\nint schpw;\nvoid do_schpw(int s, kadm5_config_params *params);\nstatic krb5_context context;\n\nvoid kadm_svc_run(params)\nkadm5_config_params *params;\n{\n     fd_set\trfd;\n     int\tsz = gssrpc__rpc_dtablesize();\n     struct\ttimeval\t    timeout;\n     \n     while(signal_request_exit == 0) {\n\t  if (signal_request_hup) {\n\t      reset_db();\n\t      krb5_klog_reopen(context);\n\t      signal_request_hup = 0;\n\t  }\n#ifdef PURIFY\n\t  if (signal_pure_report)\t/* check to see if a report */\n\t\t\t\t\t/* should be dumped... */\n\t    {\n\t      purify_new_reports();\n\t      signal_pure_report = 0;\n\t    }\n\t  if (signal_pure_clear)\t/* ...before checking whether */\n\t\t\t\t\t/* the info should be cleared. */\n\t    {\n\t      purify_clear_new_reports();\n\t      signal_pure_clear = 0;\n\t    }\n#endif /* PURIFY */\n\t  timeout.tv_sec = TIMEOUT;\n\t  timeout.tv_usec = 0;\n\t  rfd = svc_fdset;\n\t  FD_SET(schpw, &rfd);\n\t  switch(select(sz, (fd_set *) &rfd, NULL, NULL, &timeout)) {\n\t  case -1:\n\t       if(errno == EINTR)\n\t\t    continue;\n\t       perror(\"select\");\n\t       return;\n\t  case 0:\n\t       reset_db();\n\t       break;\n\t  default:\n\t      if (FD_ISSET(schpw, &rfd))\n\t\t  do_schpw(schpw, params);\n\t      else\n\t\t  svc_getreqset(&rfd);\n\t  }\n     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_INFO",
            "\"starting\""
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_signal_handlers",
          "args": [],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "setup_signal_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "639-667",
          "snippet": "void setup_signal_handlers(void) {\n#ifdef POSIX_SIGNALS\n     (void) sigemptyset(&s_action.sa_mask);\n     s_action.sa_handler = request_exit;\n     (void) sigaction(SIGINT, &s_action, (struct sigaction *) NULL);\n     (void) sigaction(SIGTERM, &s_action, (struct sigaction *) NULL);\n     (void) sigaction(SIGQUIT, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = request_hup;\n     (void) sigaction(SIGHUP, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = sig_pipe;\n     (void) sigaction(SIGPIPE, &s_action, (struct sigaction *) NULL);\n#ifdef PURIFY\n     s_action.sa_handler = request_pure_report;\n     (void) sigaction(SIGUSR1, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = request_pure_clear;\n     (void) sigaction(SIGUSR2, &s_action, (struct sigaction *) NULL);\n#endif /* PURIFY */\n#else /* POSIX_SIGNALS */\n     signal(SIGINT, request_exit);\n     signal(SIGTERM, request_exit);\n     signal(SIGQUIT, request_exit);\n     signal(SIGHUP, request_hup);\n     signal(SIGPIPE, sig_pipe);\n#ifdef PURIFY\n     signal(SIGUSR1, request_pure_report);\n     signal(SIGUSR2, request_pure_clear);\n#endif /* PURIFY */\n#endif /* POSIX_SIGNALS */\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void    setup_signal_handlers(void);",
            "void\trequest_exit(int);",
            "void\trequest_hup(int);",
            "void\tsig_pipe(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid    setup_signal_handlers(void);\nvoid\trequest_exit(int);\nvoid\trequest_hup(int);\nvoid\tsig_pipe(int);\n\nvoid setup_signal_handlers(void) {\n#ifdef POSIX_SIGNALS\n     (void) sigemptyset(&s_action.sa_mask);\n     s_action.sa_handler = request_exit;\n     (void) sigaction(SIGINT, &s_action, (struct sigaction *) NULL);\n     (void) sigaction(SIGTERM, &s_action, (struct sigaction *) NULL);\n     (void) sigaction(SIGQUIT, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = request_hup;\n     (void) sigaction(SIGHUP, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = sig_pipe;\n     (void) sigaction(SIGPIPE, &s_action, (struct sigaction *) NULL);\n#ifdef PURIFY\n     s_action.sa_handler = request_pure_report;\n     (void) sigaction(SIGUSR1, &s_action, (struct sigaction *) NULL);\n     s_action.sa_handler = request_pure_clear;\n     (void) sigaction(SIGUSR2, &s_action, (struct sigaction *) NULL);\n#endif /* PURIFY */\n#else /* POSIX_SIGNALS */\n     signal(SIGINT, request_exit);\n     signal(SIGTERM, request_exit);\n     signal(SIGQUIT, request_exit);\n     signal(SIGHUP, request_hup);\n     signal(SIGPIPE, sig_pipe);\n#ifdef PURIFY\n     signal(SIGUSR1, request_pure_report);\n     signal(SIGUSR2, request_pure_clear);\n#endif /* PURIFY */\n#endif /* POSIX_SIGNALS */\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gssapi_unset_names",
          "args": [],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Cannot detach from tty: %s\\n\"",
            "whoami",
            "error_message(ret)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Cannot detach from tty: %s\"",
            "error_message(ret)"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daemon",
          "args": [
            "0",
            "0"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gssapi_unset_names",
          "args": [],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Cannot initialize acl file: %s\\n\"",
            "whoami",
            "error_message(ret)"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Cannot initialize acl file: %s\"",
            "error_message(ret)"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acl_init",
          "args": [
            "context",
            "0",
            "params.acl_file"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Cannot initialize RPCSEC_GSS service name.\\n\"",
            "whoami"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gss_set_svc_name",
          "args": [
            "GSS_C_NO_NAME"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gss_set_log_miscerr_func",
          "args": [
            "log_miscerr",
            "NULL"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gss_set_log_badverf_func",
          "args": [
            "log_badverf",
            "NULL"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gss_set_log_badauth_func",
          "args": [
            "log_badauth",
            "NULL"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gssapi_set_log_miscerr_func",
          "args": [
            "log_miscerr",
            "NULL"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gssapi_set_log_badverf_func",
          "args": [
            "log_badverf",
            "NULL"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gssapi_set_log_badauth_func",
          "args": [
            "log_badauth",
            "NULL"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_import_name",
          "args": [
            "&OMret",
            "&in_buf",
            "nt_krb5_name_oid",
            "&gss_oldchangepw_name"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "names[3].name"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_import_name",
          "args": [
            "&OMret",
            "&in_buf",
            "nt_krb5_name_oid",
            "&gss_changepw_name"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "names[1].name"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gssapi_unset_names",
          "args": [],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Cannot set GSS-API authentication names.\\n\"",
            "whoami"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Cannot set GSS-API authentication names (keytab not present?), \"\n\t\t\t   \"failing.\""
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gssapi_set_names",
          "args": [
            "names",
            "2"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcauth_gssapi_set_names",
          "args": [
            "names",
            "4"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Can't set up keytab for RPC.\\n\"",
            "whoami"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"%s\"",
            "error_message(ret)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Can't register acceptor keytab.\""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_gss_register_acceptor_identity",
          "args": [
            "\"KDB:\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Can't register kdb keytab.\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_register",
          "args": [
            "context",
            "&krb5_kt_kdb_ops"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Can't set master key for kdb keytab.\""
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_set_mkey",
          "args": [
            "hctx",
            "&master_keyblock"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Can't set kdb keytab's internal context.\""
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_ktkdb_set_context",
          "args": [
            "hctx"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Cannot build GSS-API authentication names.\\n\"",
            "whoami"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Cannot build GSS-API authentication names, \"\n\t\t\t   \"failing.\""
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_princ_name",
          "args": [
            "OVSEC_KADM_CHANGEPW_SERVICE",
            "params.realm"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "build_princ_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "882-895",
          "snippet": "char *build_princ_name(char *name, char *realm)\n{\n     char *fullname;\n\n     fullname = (char *) malloc(strlen(name) + 1 +\n\t\t\t\t(realm ? strlen(realm) + 1 : 0));\n     if (fullname == NULL)\n\t  return NULL;\n     if (realm)\n\t  sprintf(fullname, \"%s@%s\", name, realm);\n     else\n\t  strcpy(fullname, name);\n     return fullname;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *build_princ_name(char *name, char *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nchar *build_princ_name(char *name, char *realm);\n\nchar *build_princ_name(char *name, char *realm)\n{\n     char *fullname;\n\n     fullname = (char *) malloc(strlen(name) + 1 +\n\t\t\t\t(realm ? strlen(realm) + 1 : 0));\n     if (fullname == NULL)\n\t  return NULL;\n     if (realm)\n\t  sprintf(fullname, \"%s@%s\", name, realm);\n     else\n\t  strcpy(fullname, name);\n     return fullname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Cannot register RPC service, failing.\""
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Cannot register RPC service.\\n\"",
            "whoami"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_register",
          "args": [
            "transp",
            "KADM",
            "KADMVERS",
            "kadm_1",
            "0"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Cannot create RPC service: %m\""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Cannot create RPC service.\\n\"",
            "whoami"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svctcp_create",
          "args": [
            "s",
            "0",
            "0"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"This probably means that another %s process is already\\n\"\n\"running, or that another program is using the server port (number %d).\\n\"\n\"If another %s is already running, you should kill it before\\n\"\n\"restarting the server.\\n\"",
            "w",
            "ntohs(addr.sin_port)",
            "w"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr.sin_port"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "whoami",
            "'/'"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"cannot bind simple chpw socket: %s\"",
            "error_message(oerrno)"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "oerrno"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "portbuf",
            "\"%d\"",
            "ntohs(addr.sin_port)"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr.sin_port"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bind: %s\\n\"",
            "error_message(oerrno)"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "oerrno"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Cannot bind socket.\\n\"",
            "whoami"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "schpw",
            "(struct sockaddr *)&addr",
            "sizeof(addr)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "params.kpasswd_port"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Check for already-running %s or for \"\n\t\t      \"another process using port %d\"",
            "w",
            "htons(addr.sin_port)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "addr.sin_port"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"This probably means that another %s process is already\\n\"\n\"running, or that another program is using the server port (number %d)\\n\"\n\"after being assigned it by the RPC portmap daemon.  If another\\n\"\n\"%s is already running, you should kill it before\\n\"\n\"restarting the server.  If, on the other hand, another program is\\n\"\n\"using the server port, you should kill it before running\\n\"\n\"%s, and ensure that the conflict does not occur in the\\n\"\n\"future by making sure that %s is started on reboot\\n\"\n\t\t       \"before portmap.\\n\"",
            "w",
            "ntohs(addr.sin_port)",
            "w",
            "w",
            "w"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr.sin_port"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "whoami",
            "'/'"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Cannot bind socket: %s\"",
            "error_message(errno)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"bind: %s\\n\"",
            "error_message(oerrno)"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "oerrno"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Cannot bind socket.\\n\"",
            "whoami"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "s",
            "(struct sockaddr *)&addr",
            "sizeof(addr)"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "params.kadmind_port"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Cannot set SO_REUSEADDR on simple chpw socket: %s\"",
            "error_message(errno)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"main\"",
            "\"cannot set SO_REUSEADDR on simple chpw socket: %s\"",
            "error_message(errno)"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "schpw",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(char *) &allowed",
            "sizeof(allowed)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Cannot set SO_REUSEADDR: %s\"",
            "error_message(errno)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Cannot set SO_REUSEADDR: %s\"",
            "error_message(errno)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsockopt",
          "args": [
            "s",
            "SOL_SOCKET",
            "SO_REUSEADDR",
            "(char *) &allowed",
            "sizeof(allowed)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Cannot create simple chpw socket: %s\"",
            "error_message(errno)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"cannot create simple chpw socket: %s\"",
            "error_message(errno)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_DGRAM",
            "0"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Cannot create TCP socket: %s\"",
            "error_message(errno)"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Cannot create TCP socket: %s\"",
            "error_message(errno)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "errno"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_INET",
            "SOCK_STREAM",
            "0"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "params.kadmind_port"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Missing required configuration values \"\n\t\t  \"(%lx) while initializing, aborting\\n\"",
            "whoami",
            "(params.mask & REQUIRED_PARAMS) ^ REQUIRED_PARAMS"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"%s: Missing required configuration values \"\n\t\t\t   \"while initializing, aborting\"",
            "whoami",
            "(params.mask & REQUIRED_PARAMS) ^ REQUIRED_PARAMS"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "global_server_handle"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s while initializing, aborting\\n\"",
            "whoami",
            "error_message(ret)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"%s: %s while initializing, aborting\"",
            "whoami",
            "error_message(ret)"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_get_config_params",
          "args": [
            "context",
            "NULL",
            "NULL",
            "&params",
            "&params"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_close",
          "args": [
            "context"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s while initializing, aborting\\n\"",
            "whoami",
            "error_message(ret)"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"%s while initializing, aborting\"",
            "error_message(ret)"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_init",
          "args": [
            "\"kadmind\"",
            "NULL",
            "NULL",
            "&params",
            "KADM5_STRUCT_VERSION",
            "KADM5_API_VERSION_2",
            "&global_server_handle"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Error getting random seed: %s, aborting\"",
            "error_message(ret)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_c_random_os_entropy",
          "args": [
            "context",
            "1",
            "NULL"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_INFO",
            "\"Seeding random number generator\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_init",
          "args": [
            "context",
            "\"admin_server\"",
            "whoami",
            "1"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: %s while initializing context, aborting\\n\"",
            "whoami",
            "error_message(ret)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "ret"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_init_context",
          "args": [
            "&context"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "131-139",
          "snippet": "static void usage()\n{\n     fprintf(stderr, \"Usage: kadmind [-r realm] [-m] [-nofork] \"\n#ifdef USE_PASSWORD_SERVER\n             \"[-passwordserver] \"\n#endif\n\t     \"[-port port-number]\\n\");\n     exit(1);\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *build_princ_name(char *name, char *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nchar *build_princ_name(char *name, char *realm);\n\nstatic void usage()\n{\n     fprintf(stderr, \"Usage: kadmind [-r realm] [-m] [-nofork] \"\n#ifdef USE_PASSWORD_SERVER\n             \"[-passwordserver] \"\n#endif\n\t     \"[-port port-number]\\n\");\n     exit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "*argv"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_set_use_password_server",
          "args": [],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"-passwordserver\""
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"-nofork\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"-m\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"-r\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *) &params",
            "0",
            "sizeof(params)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "purify_start_batch",
          "args": [],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "display_status",
          "args": [
            "\"str_to_oid\"",
            "major_status",
            "minor_status"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "log_badauth_display_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "1046-1050",
          "snippet": "void log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor)\n{\n     log_badauth_display_status_1(msg, major, GSS_C_GSS_CODE, 0);\n     log_badauth_display_status_1(msg, minor, GSS_C_MECH_CODE, 0);\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor);",
            "static void display_status_1(char *, OM_uint32, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor);\nstatic void display_status_1(char *, OM_uint32, int);\n\nvoid log_badauth_display_status(char *msg, OM_uint32 major, OM_uint32 minor)\n{\n     log_badauth_display_status_1(msg, major, GSS_C_GSS_CODE, 0);\n     log_badauth_display_status_1(msg, minor, GSS_C_MECH_CODE, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Couldn't create KRB5 Name NameType OID\\n\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_str_to_oid",
          "args": [
            "&minor_status",
            "&gssbuf",
            "&nt_krb5_name_oid"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "gssbuf.value"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setvbuf",
          "args": [
            "stderr",
            "NULL",
            "_IONBF",
            "0"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\n#define REQUIRED_PARAMS (KADM5_CONFIG_REALM | KADM5_CONFIG_ACL_FILE)\n#define OVSEC_KADM_CHANGEPW_SERVICE\t\"ovsec_adm/changepw\"\n#define OVSEC_KADM_ADMIN_SERVICE\t\"ovsec_adm/admin\"\n\nvoid    setup_signal_handlers(void);\nvoid\tkadm_svc_run(kadm5_config_params *params);\ngss_name_t gss_changepw_name = NULL, gss_oldchangepw_name = NULL;\nvoid *global_server_handle;\nextern krb5_keyblock master_keyblock;\nchar *build_princ_name(char *name, char *realm);\nint schpw;\nvoid do_schpw(int s, kadm5_config_params *params);\nstatic void display_status_1(char *, OM_uint32, int);\nstatic krb5_context context;\nstatic krb5_context hctx;\n\nint main(int argc, char *argv[])\n{\n     register\tSVCXPRT *transp;\n     extern\tchar *optarg;\n     extern\tint optind, opterr;\n     int ret, nofork, oldnames = 0;\n     OM_uint32 OMret, major_status, minor_status;\n     char *whoami;\n     gss_buffer_desc in_buf;\n     struct sockaddr_in addr;\n     int s;\n     auth_gssapi_name names[4];\n     gss_buffer_desc gssbuf;\n     gss_OID nt_krb5_name_oid;\n     kadm5_config_params params;\n\n     setvbuf(stderr, NULL, _IONBF, 0);\n\n     /* This is OID value the Krb5_Name NameType */\n     gssbuf.value = \"{1 2 840 113554 1 2 2 1}\";\n     gssbuf.length = strlen(gssbuf.value);\n     major_status = gss_str_to_oid(&minor_status, &gssbuf, &nt_krb5_name_oid);\n     if (major_status != GSS_S_COMPLETE) {\n\t     fprintf(stderr, \"Couldn't create KRB5 Name NameType OID\\n\");\n\t     display_status(\"str_to_oid\", major_status, minor_status);\n\t     exit(1);\n     }\n     \n     names[0].name = names[1].name = names[2].name = names[3].name = NULL;\n     names[0].type = names[1].type = names[2].type = names[3].type =\n\t     nt_krb5_name_oid;\n\n#ifdef PURIFY\n     purify_start_batch();\n#endif /* PURIFY */\n     whoami = (strrchr(argv[0], '/') ? strrchr(argv[0], '/')+1 : argv[0]);\n\n     nofork = 0;\n\n     memset((char *) &params, 0, sizeof(params));\n     \n     argc--; argv++;\n     while (argc) {\n\t  if (strcmp(*argv, \"-r\") == 0) {\n\t       argc--; argv++;\n\t       if (!argc)\n\t\t    usage();\n\t       params.realm = *argv;\n\t       params.mask |= KADM5_CONFIG_REALM;\n\t       argc--; argv++;\n\t       continue;\n\t  } else if (strcmp(*argv, \"-m\") == 0) {\n\t       params.mkey_from_kbd = 1;\n\t       params.mask |= KADM5_CONFIG_MKEY_FROM_KBD;\n\t  } else if (strcmp(*argv, \"-nofork\") == 0) {\n\t       nofork = 1;\n#ifdef USE_PASSWORD_SERVER\n          } else if (strcmp(*argv, \"-passwordserver\") == 0) {\n              kadm5_set_use_password_server ();\n#endif              \n\t  } else if(strcmp(*argv, \"-port\") == 0) {\n\t    argc--; argv++;\n\t    if(!argc)\n\t      usage();\n\t    params.kadmind_port = atoi(*argv);\n\t    params.mask |= KADM5_CONFIG_KADMIND_PORT;\n\t  } else\n\t       break;\n\t  argc--; argv++;\n     }\n     \n     if (argc != 0)\n\t  usage();\n\n     if ((ret = krb5_init_context(&context))) {\n\t  fprintf(stderr, \"%s: %s while initializing context, aborting\\n\",\n\t\t  whoami, error_message(ret));\n\t  exit(1);\n     }\n\n     krb5_klog_init(context, \"admin_server\", whoami, 1);\n\n\n     krb5_klog_syslog(LOG_INFO, \"Seeding random number generator\");\n          ret = krb5_c_random_os_entropy(context, 1, NULL);\n\t  if(ret) {\n\t    krb5_klog_syslog(LOG_ERR, \"Error getting random seed: %s, aborting\",\n\t\t\t     error_message(ret));\n\t    exit(1);\n\t  }\n\t  \n     if((ret = kadm5_init(\"kadmind\", NULL,\n\t\t\t  NULL, &params,\n\t\t\t  KADM5_STRUCT_VERSION,\n\t\t\t  KADM5_API_VERSION_2,\n\t\t\t  &global_server_handle)) != \n\tKADM5_OK) {\n\t  krb5_klog_syslog(LOG_ERR, \"%s while initializing, aborting\",\n\t\t error_message(ret));\n\t  fprintf(stderr, \"%s: %s while initializing, aborting\\n\",\n\t\t  whoami, error_message(ret));\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n     \n     if ((ret = kadm5_get_config_params(context, NULL, NULL, &params,\n\t\t\t\t\t&params))) {\n\t  krb5_klog_syslog(LOG_ERR, \"%s: %s while initializing, aborting\",\n\t\t\t   whoami, error_message(ret));\n\t  fprintf(stderr, \"%s: %s while initializing, aborting\\n\",\n\t\t  whoami, error_message(ret));\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n\n#define REQUIRED_PARAMS (KADM5_CONFIG_REALM | KADM5_CONFIG_ACL_FILE)\n\n     if ((params.mask & REQUIRED_PARAMS) != REQUIRED_PARAMS) {\n\t  krb5_klog_syslog(LOG_ERR, \"%s: Missing required configuration values \"\n\t\t\t   \"while initializing, aborting\", whoami,\n\t\t\t   (params.mask & REQUIRED_PARAMS) ^ REQUIRED_PARAMS);\n\t  fprintf(stderr, \"%s: Missing required configuration values \"\n\t\t  \"(%lx) while initializing, aborting\\n\", whoami,\n\t\t  (params.mask & REQUIRED_PARAMS) ^ REQUIRED_PARAMS);\n\t  krb5_klog_close(context);\n\t  kadm5_destroy(global_server_handle);\n\t  exit(1);\n     }\n\n     memset(&addr, 0, sizeof(addr));\n     addr.sin_family = AF_INET;\n     addr.sin_addr.s_addr = INADDR_ANY;\n     addr.sin_port = htons(params.kadmind_port);\n\n     if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) {\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot create TCP socket: %s\",\n\t\t\t   error_message(errno));\n\t  fprintf(stderr, \"Cannot create TCP socket: %s\",\n\t\t  error_message(errno));\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\t  \n\t  exit(1);\n     }\n\n     if ((schpw = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {\n\t krb5_klog_syslog(LOG_ERR,\n\t\t\t   \"cannot create simple chpw socket: %s\",\n\t\t\t   error_message(errno));\n\t fprintf(stderr, \"Cannot create simple chpw socket: %s\",\n\t\t error_message(errno));\n\t kadm5_destroy(global_server_handle);\n\t krb5_klog_close(context);\n\t exit(1);\n     }\n\n#ifdef SO_REUSEADDR\n     /* the old admin server turned on SO_REUSEADDR for non-default\n\tport numbers.  this was necessary, on solaris, for the tests\n\tto work.  jhawk argues that the debug and production modes\n\tshould be the same.  I think I agree, so I'm always going to set\n\tSO_REUSEADDR.  The other option is to have the unit tests wait\n\tuntil the port is useable, or use a different port each time.  \n\t--marc */\n\n     {\n\t int\tallowed;\n\n\t allowed = 1;\n\t if (setsockopt(s,\n\t\t\tSOL_SOCKET,\n\t\t\tSO_REUSEADDR,\n\t\t\t(char *) &allowed,\n\t\t\tsizeof(allowed)) < 0) {\n\t     krb5_klog_syslog(LOG_ERR, \"Cannot set SO_REUSEADDR: %s\",\n\t\t\t      error_message(errno));\n\t     fprintf(stderr, \"Cannot set SO_REUSEADDR: %s\",\n\t\t     error_message(errno));\n\t     kadm5_destroy(global_server_handle);\n\t     krb5_klog_close(context);\t  \n\t     exit(1);\n\t }\n\t if (setsockopt(schpw, SOL_SOCKET, SO_REUSEADDR,\n\t\t\t(char *) &allowed, sizeof(allowed)) < 0) {\n\t     krb5_klog_syslog(LOG_ERR, \"main\",\n\t\t\t      \"cannot set SO_REUSEADDR on simple chpw socket: %s\", \n\t\t\t      error_message(errno));\n\t     fprintf(stderr,\n\t\t     \"Cannot set SO_REUSEADDR on simple chpw socket: %s\",\n \t\t     error_message(errno));\n \t     kadm5_destroy(global_server_handle);\n \t     krb5_klog_close(context);\n\t }\n\n     }\n#endif /* SO_REUSEADDR */\n     memset(&addr, 0, sizeof(addr));\n     addr.sin_family = AF_INET;\n     addr.sin_addr.s_addr = INADDR_ANY;\n     addr.sin_port = htons(params.kadmind_port);\n\n     if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t  int oerrno = errno;\n\t  fprintf(stderr, \"%s: Cannot bind socket.\\n\", whoami);\n\t  fprintf(stderr, \"bind: %s\\n\", error_message(oerrno));\n\t  errno = oerrno;\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot bind socket: %s\",\n\t\t\t   error_message(errno));\n\t  if(oerrno == EADDRINUSE) {\n\t       char *w = strrchr(whoami, '/');\n\t       if (w) {\n\t\t    w++;\n\t       }\n\t       else {\n\t\t    w = whoami;\n\t       }\n\t       fprintf(stderr,\n\"This probably means that another %s process is already\\n\"\n\"running, or that another program is using the server port (number %d)\\n\"\n\"after being assigned it by the RPC portmap daemon.  If another\\n\"\n\"%s is already running, you should kill it before\\n\"\n\"restarting the server.  If, on the other hand, another program is\\n\"\n\"using the server port, you should kill it before running\\n\"\n\"%s, and ensure that the conflict does not occur in the\\n\"\n\"future by making sure that %s is started on reboot\\n\"\n\t\t       \"before portmap.\\n\", w, ntohs(addr.sin_port), w, w, w);\n\t       krb5_klog_syslog(LOG_ERR, \"Check for already-running %s or for \"\n\t\t      \"another process using port %d\", w,\n\t\t      htons(addr.sin_port));\n\t  }\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n     memset(&addr, 0, sizeof(addr));\n     addr.sin_family = AF_INET;\n     addr.sin_addr.s_addr = INADDR_ANY;\n     /* XXX */\n     addr.sin_port = htons(params.kpasswd_port);\n\n     if (bind(schpw, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n\t  char portbuf[32];\n\t  int oerrno = errno;\n\t  fprintf(stderr, \"%s: Cannot bind socket.\\n\", whoami);\n\t  fprintf(stderr, \"bind: %s\\n\", error_message(oerrno));\n\t  errno = oerrno;\n\t  sprintf(portbuf, \"%d\", ntohs(addr.sin_port));\n\t  krb5_klog_syslog(LOG_ERR, \"cannot bind simple chpw socket: %s\",\n\t\t\t   error_message(oerrno));\n\t  if(oerrno == EADDRINUSE) {\n\t       char *w = strrchr(whoami, '/');\n\t       if (w) {\n\t\t    w++;\n\t       }\n\t       else {\n\t\t    w = whoami;\n\t       }\n\t       fprintf(stderr,\n\"This probably means that another %s process is already\\n\"\n\"running, or that another program is using the server port (number %d).\\n\"\n\"If another %s is already running, you should kill it before\\n\"\n\"restarting the server.\\n\",\n\t\t       w, ntohs(addr.sin_port), w);\n \t  }\n \t  kadm5_destroy(global_server_handle);\n \t  krb5_klog_close(context);\n\t  exit(1);\n     }\n     \n     transp = svctcp_create(s, 0, 0);\n     if(transp == NULL) {\n\t  fprintf(stderr, \"%s: Cannot create RPC service.\\n\", whoami);\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot create RPC service: %m\");\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\t  \n\t  exit(1);\n     }\n     if(!svc_register(transp, KADM, KADMVERS, kadm_1, 0)) {\n\t  fprintf(stderr, \"%s: Cannot register RPC service.\\n\", whoami);\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot register RPC service, failing.\");\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\t  \n\t  exit(1);\n     }\n\n     names[0].name = build_princ_name(KADM5_ADMIN_SERVICE, params.realm);\n     names[1].name = build_princ_name(KADM5_CHANGEPW_SERVICE, params.realm);\n     names[2].name = build_princ_name(OVSEC_KADM_ADMIN_SERVICE, params.realm);\n     names[3].name = build_princ_name(OVSEC_KADM_CHANGEPW_SERVICE,\n\t\t\t\t      params.realm); \n     if (names[0].name == NULL || names[1].name == NULL ||\n\t names[2].name == NULL || names[3].name == NULL) {\n\t  krb5_klog_syslog(LOG_ERR,\n\t\t\t   \"Cannot build GSS-API authentication names, \"\n\t\t\t   \"failing.\");\n\t  fprintf(stderr, \"%s: Cannot build GSS-API authentication names.\\n\",\n\t\t  whoami);\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\t  \n\t  exit(1);\n     }\n\n     /*\n      * Go through some contortions to point gssapi at a kdb keytab.\n      * This prevents kadmind from needing to use an actual file-based\n      * keytab.\n      */\n     /* XXX extract kadm5's krb5_context */\n     hctx = ((kadm5_server_handle_t)global_server_handle)->context;\n     /* Set ktkdb's internal krb5_context. */\n     ret = krb5_ktkdb_set_context(hctx);\n     if (ret) {\n\t  krb5_klog_syslog(LOG_ERR, \"Can't set kdb keytab's internal context.\");\n\t  goto kterr;\n     }\n     /* XXX master_keyblock is in guts of lib/kadm5/server_kdb.c */\n     ret = krb5_db_set_mkey(hctx, &master_keyblock);\n     if (ret) {\n\t  krb5_klog_syslog(LOG_ERR, \"Can't set master key for kdb keytab.\");\n\t  goto kterr;\n     }\n     ret = krb5_kt_register(context, &krb5_kt_kdb_ops);\n     if (ret) {\n\t  krb5_klog_syslog(LOG_ERR, \"Can't register kdb keytab.\");\n\t  goto kterr;\n     }\n     /* Tell gssapi about the kdb keytab. */\n     ret = krb5_gss_register_acceptor_identity(\"KDB:\");\n     if (ret) {\n\t  krb5_klog_syslog(LOG_ERR, \"Can't register acceptor keytab.\");\n\t  goto kterr;\n     }\nkterr:\n     if (ret) {\n\t  krb5_klog_syslog(LOG_ERR, \"%s\", error_message(ret));\n\t  fprintf(stderr, \"%s: Can't set up keytab for RPC.\\n\", whoami);\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n\n     /*\n      * Try to acquire creds for the old OV services as well as the\n      * new names, but if that fails just fall back on the new names.\n      */\n     if (svcauth_gssapi_set_names(names, 4) == TRUE)\n\t  oldnames++;\n     if (!oldnames && svcauth_gssapi_set_names(names, 2) == FALSE) {\n\t  krb5_klog_syslog(LOG_ERR,\n\t\t\t   \"Cannot set GSS-API authentication names (keytab not present?), \"\n\t\t\t   \"failing.\");\n\t  fprintf(stderr, \"%s: Cannot set GSS-API authentication names.\\n\",\n\t\t  whoami);\n\t  svcauth_gssapi_unset_names();\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\t  \n\t  exit(1);\n     }\n\n     /* if set_names succeeded, this will too */\n     in_buf.value = names[1].name;\n     in_buf.length = strlen(names[1].name) + 1;\n     (void) gss_import_name(&OMret, &in_buf, nt_krb5_name_oid,\n\t\t\t    &gss_changepw_name);\n     if (oldnames) {\n\t  in_buf.value = names[3].name;\n\t  in_buf.length = strlen(names[3].name) + 1;\n\t  (void) gss_import_name(&OMret, &in_buf, nt_krb5_name_oid,\n\t\t\t\t &gss_oldchangepw_name);\n     }\n\n     svcauth_gssapi_set_log_badauth_func(log_badauth, NULL);\n     svcauth_gssapi_set_log_badverf_func(log_badverf, NULL);\n     svcauth_gssapi_set_log_miscerr_func(log_miscerr, NULL);\n     \n     svcauth_gss_set_log_badauth_func(log_badauth, NULL);\n     svcauth_gss_set_log_badverf_func(log_badverf, NULL);\n     svcauth_gss_set_log_miscerr_func(log_miscerr, NULL);\n     \n     if (svcauth_gss_set_svc_name(GSS_C_NO_NAME) != TRUE) {\n\t fprintf(stderr, \"%s: Cannot initialize RPCSEC_GSS service name.\\n\",\n\t\t whoami);\n\t exit(1);\n     }\n\n     if ((ret = acl_init(context, 0, params.acl_file))) {\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot initialize acl file: %s\",\n\t\t error_message(ret));\n\t  fprintf(stderr, \"%s: Cannot initialize acl file: %s\\n\",\n\t\t  whoami, error_message(ret));\n\t  svcauth_gssapi_unset_names();\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n\n     if (!nofork && (ret = daemon(0, 0))) {\n\t  ret = errno;\n\t  krb5_klog_syslog(LOG_ERR, \"Cannot detach from tty: %s\", error_message(ret));\n\t  fprintf(stderr, \"%s: Cannot detach from tty: %s\\n\",\n\t\t  whoami, error_message(ret));\n\t  svcauth_gssapi_unset_names();\n\t  kadm5_destroy(global_server_handle);\n\t  krb5_klog_close(context);\n\t  exit(1);\n     }\n     \n     setup_signal_handlers();\n     krb5_klog_syslog(LOG_INFO, \"starting\");\n     kadm_svc_run(&params);\n     krb5_klog_syslog(LOG_INFO, \"finished, exiting\");\n\n     /* Clean up memory, etc */\n     svcauth_gssapi_unset_names();\n     kadm5_destroy(global_server_handle);\n     close(s);\n     acl_finish(context, 0);\n     if(gss_changepw_name) {\n          (void) gss_release_name(&OMret, &gss_changepw_name);\n     }\n     if(gss_oldchangepw_name) {\n          (void) gss_release_name(&OMret, &gss_oldchangepw_name);\n     }\n     for(s = 0 ; s < 4; s++) {\n          if (names[s].name) {\n\t        free(names[s].name);\n\t  }\n     }\n\n     krb5_klog_close(context);\n     krb5_free_context(context);\n     exit(2);\n}"
  },
  {
    "function_name": "display_status_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "169-190",
    "snippet": "static void display_status_1(m, code, type)\n     char *m;\n     OM_uint32 code;\n     int type;\n{\n\tOM_uint32 maj_stat, min_stat;\n\tgss_buffer_desc msg;\n\tOM_uint32 msg_ctx;\n     \n\tmsg_ctx = 0;\n\twhile (1) {\n\t\tmaj_stat = gss_display_status(&min_stat, code,\n\t\t\t\t\t      type, GSS_C_NULL_OID,\n\t\t\t\t\t      &msg_ctx, &msg);\n\t\tfprintf(stderr, \"GSS-API error %s: %s\\n\", m,\n\t\t\t(char *)msg.value); \n\t\t(void) gss_release_buffer(&min_stat, &msg);\n\t  \n\t\tif (!msg_ctx)\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void display_status_1(char *, OM_uint32, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_release_buffer",
          "args": [
            "&min_stat",
            "&msg"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"GSS-API error %s: %s\\n\"",
            "m",
            "(char *)msg.value"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_display_status",
          "args": [
            "&min_stat",
            "code",
            "type",
            "GSS_C_NULL_OID",
            "&msg_ctx",
            "&msg"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nstatic void display_status_1(char *, OM_uint32, int);\n\nstatic void display_status_1(m, code, type)\n     char *m;\n     OM_uint32 code;\n     int type;\n{\n\tOM_uint32 maj_stat, min_stat;\n\tgss_buffer_desc msg;\n\tOM_uint32 msg_ctx;\n     \n\tmsg_ctx = 0;\n\twhile (1) {\n\t\tmaj_stat = gss_display_status(&min_stat, code,\n\t\t\t\t\t      type, GSS_C_NULL_OID,\n\t\t\t\t\t      &msg_ctx, &msg);\n\t\tfprintf(stderr, \"GSS-API error %s: %s\\n\", m,\n\t\t\t(char *)msg.value); \n\t\t(void) gss_release_buffer(&min_stat, &msg);\n\t  \n\t\tif (!msg_ctx)\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "display_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "160-167",
    "snippet": "static void display_status(msg, maj_stat, min_stat)\n     char *msg;\n     OM_uint32 maj_stat;\n     OM_uint32 min_stat;\n{\n     display_status_1(msg, maj_stat, GSS_C_GSS_CODE);\n     display_status_1(msg, min_stat, GSS_C_MECH_CODE);\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void display_status_1(char *, OM_uint32, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "display_status_1",
          "args": [
            "msg",
            "min_stat",
            "GSS_C_MECH_CODE"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "display_status_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "169-190",
          "snippet": "static void display_status_1(m, code, type)\n     char *m;\n     OM_uint32 code;\n     int type;\n{\n\tOM_uint32 maj_stat, min_stat;\n\tgss_buffer_desc msg;\n\tOM_uint32 msg_ctx;\n     \n\tmsg_ctx = 0;\n\twhile (1) {\n\t\tmaj_stat = gss_display_status(&min_stat, code,\n\t\t\t\t\t      type, GSS_C_NULL_OID,\n\t\t\t\t\t      &msg_ctx, &msg);\n\t\tfprintf(stderr, \"GSS-API error %s: %s\\n\", m,\n\t\t\t(char *)msg.value); \n\t\t(void) gss_release_buffer(&min_stat, &msg);\n\t  \n\t\tif (!msg_ctx)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void display_status_1(char *, OM_uint32, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nstatic void display_status_1(char *, OM_uint32, int);\n\nstatic void display_status_1(m, code, type)\n     char *m;\n     OM_uint32 code;\n     int type;\n{\n\tOM_uint32 maj_stat, min_stat;\n\tgss_buffer_desc msg;\n\tOM_uint32 msg_ctx;\n     \n\tmsg_ctx = 0;\n\twhile (1) {\n\t\tmaj_stat = gss_display_status(&min_stat, code,\n\t\t\t\t\t      type, GSS_C_NULL_OID,\n\t\t\t\t\t      &msg_ctx, &msg);\n\t\tfprintf(stderr, \"GSS-API error %s: %s\\n\", m,\n\t\t\t(char *)msg.value); \n\t\t(void) gss_release_buffer(&min_stat, &msg);\n\t  \n\t\tif (!msg_ctx)\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nstatic void display_status_1(char *, OM_uint32, int);\n\nstatic void display_status(msg, maj_stat, min_stat)\n     char *msg;\n     OM_uint32 maj_stat;\n     OM_uint32 min_stat;\n{\n     display_status_1(msg, maj_stat, GSS_C_GSS_CODE);\n     display_status_1(msg, min_stat, GSS_C_MECH_CODE);\n}"
  },
  {
    "function_name": "usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
    "lines": "131-139",
    "snippet": "static void usage()\n{\n     fprintf(stderr, \"Usage: kadmind [-r realm] [-m] [-nofork] \"\n#ifdef USE_PASSWORD_SERVER\n             \"[-passwordserver] \"\n#endif\n\t     \"[-port port-number]\\n\");\n     exit(1);\n}",
    "includes": [
      "#include    \"purify.h\"",
      "#include    \"misc.h\"",
      "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
      "#include    <string.h>",
      "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
      "#include    <krb5/adm_proto.h>",
      "#include    <kadm5/server_acl.h>",
      "#include    <kadm5/kadm_rpc.h>",
      "#include    <kadm5/admin.h>",
      "#include    <gssrpc/auth_gssapi.h>",
      "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
      "#include    <gssapi/gssapi.h>",
      "#include    <gssrpc/rpc.h>",
      "#include    <arpa/inet.h>  /* inet_ntoa */",
      "#include    <netinet/in.h>",
      "#include    <unistd.h>",
      "#include    <sys/socket.h>",
      "#include    <sys/time.h>",
      "#include    <sys/select.h>",
      "#include    <sys/types.h>",
      "#include    <syslog.h>",
      "#include    <signal.h>",
      "#include    <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *build_princ_name(char *name, char *realm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: kadmind [-r realm] [-m] [-nofork] \"\n#ifdef USE_PASSWORD_SERVER\n             \"[-passwordserver] \"\n#endif\"[-port port-number]\\n\""
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nchar *build_princ_name(char *name, char *realm);\n\nstatic void usage()\n{\n     fprintf(stderr, \"Usage: kadmind [-r realm] [-m] [-nofork] \"\n#ifdef USE_PASSWORD_SERVER\n             \"[-passwordserver] \"\n#endif\n\t     \"[-port port-number]\\n\");\n     exit(1);\n}"
  }
]