[
  {
    "function_name": "remove_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
    "lines": "325-449",
    "snippet": "int remove_principal(char *keytab_str, krb5_keytab keytab, char\n\t\t     *princ_str, char *kvno_str) \n{\n     krb5_principal princ;\n     krb5_keytab_entry entry;\n     krb5_kt_cursor cursor;\n     enum { UNDEF, SPEC, HIGH, ALL, OLD } mode;\n     int code, did_something;\n     krb5_kvno kvno;\n\n     code = krb5_parse_name(context, princ_str, &princ);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while parsing principal name %s\",\n\t\t  princ_str);\n\t  return code;\n     }\n\n     mode = UNDEF;\n     if (kvno_str == NULL) {\n\t  mode = HIGH;\n\t  kvno = 0;\n     } else if (strcmp(kvno_str, \"all\") == 0) {\n\t  mode = ALL;\n\t  kvno = 0;\n     } else if (strcmp(kvno_str, \"old\") == 0) {\n\t  mode = OLD;\n\t  kvno = 0;\n     } else {\n\t  mode = SPEC;\n\t  kvno = atoi(kvno_str);\n     }\n\n     /* kvno is set to specified value for SPEC, 0 otherwise */\n     code = krb5_kt_get_entry(context, keytab, princ, kvno, 0, &entry);\n     if (code != 0) {\n\t  if (code == ENOENT) {\n\t       fprintf(stderr, \"%s: Keytab %s does not exist.\\n\",\n\t\t       whoami, keytab_str);\n\t  } else if (code == KRB5_KT_NOTFOUND) {\n\t       if (mode != SPEC)\n\t\t    fprintf(stderr, \"%s: No entry for principal \"\n\t\t\t    \"%s exists in keytab %s\\n\",\n\t\t\t    whoami, princ_str, keytab_str);\n\t       else\n\t\t    fprintf(stderr, \"%s: No entry for principal \"\n\t\t\t    \"%s with kvno %d exists in keytab \"\n\t\t\t    \"%s.\\n\", whoami, princ_str, kvno,\n\t\t\t    keytab_str);\n\t  } else {\n\t       com_err(whoami, code, \"while retrieving highest kvno \"\n\t\t       \"from keytab\");\n\t  }\n\t  return code;\n     }\n\n     /* set kvno to spec'ed value for SPEC, highest kvno otherwise */\n     kvno = entry.vno;\n     krb5_kt_free_entry(context, &entry);\n\n     code = krb5_kt_start_seq_get(context, keytab, &cursor);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while starting keytab scan\");\n\t  return code;\n     }\n\n     did_something = 0;\n     while ((code = krb5_kt_next_entry(context, keytab, &entry, &cursor)) == 0) {\n\t  if (krb5_principal_compare(context, princ, entry.principal) &&\n\t      ((mode == ALL) ||\n\t       (mode == SPEC && entry.vno == kvno) ||\n\t       (mode == OLD && entry.vno != kvno) ||\n\t       (mode == HIGH && entry.vno == kvno))) {\n\n\t       /*\n\t\t* Ack!  What a kludge... the scanning functions lock\n\t\t* the keytab so entries cannot be removed while they\n\t\t* are operating.\n\t\t*/\n\t       code = krb5_kt_end_seq_get(context, keytab, &cursor);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while temporarily ending \"\n\t\t\t    \"keytab scan\");\n\t\t    return code;\n\t       }\n\t       code = krb5_kt_remove_entry(context, keytab, &entry);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while deleting entry from keytab\");\n\t\t    return code;\n\t       }\n\t       code = krb5_kt_start_seq_get(context, keytab, &cursor);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while restarting keytab scan\");\n\t\t    return code;\n\t       }\n\n\t       did_something++;\n\t       if (!quiet)\n\t\t    printf(\"Entry for principal %s with kvno %d \"\n\t\t\t   \"removed from keytab %s.\\n\", \n\t\t\t   princ_str, entry.vno, keytab_str);\n\t  }\n\t  krb5_kt_free_entry(context, &entry);\n     }\n     if (code && code != KRB5_KT_END) {\n\t  com_err(whoami, code, \"while scanning keytab\");\n\t  return code;\n     }\n     if ((code = krb5_kt_end_seq_get(context, keytab, &cursor))) {\n\t  com_err(whoami, code, \"while ending keytab scan\");\n\t  return code;\n     }\n\n     /*\n      * If !did_someting then mode must be OLD or we would have\n      * already returned with an error.  But check it anyway just to\n      * prevent unexpected error messages...\n      */\n     if (!did_something && mode == OLD) {\n\t  fprintf(stderr, \"%s: There is only one entry for principal \"\n\t\t  \"%s in keytab %s\\n\", whoami, princ_str, keytab_str);\n\t  return 1;\n     }\n     \n     return 0;\n}",
    "includes": [
      "#include \"kadmin.h\"",
      "#include <krb5/adm_proto.h>",
      "#include <kadm5/admin.h>",
      "#include <krb5.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t\t krb5_boolean keepold,\n\t\t\t int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n\t\t\t char *princ_str);",
      "static int remove_principal(char *keytab_str, krb5_keytab keytab, char\n\t\t\t    *princ_str, char *kvno_str);",
      "static int quiet;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: There is only one entry for principal \"\n\t\t  \"%s in keytab %s\\n\"",
            "whoami",
            "princ_str",
            "keytab_str"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while ending keytab scan\""
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_end_seq_get",
          "args": [
            "context",
            "keytab",
            "&cursor"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while scanning keytab\""
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_free_entry",
          "args": [
            "context",
            "&entry"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Entry for principal %s with kvno %d \"\n\t\t\t   \"removed from keytab %s.\\n\"",
            "princ_str",
            "entry.vno",
            "keytab_str"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while restarting keytab scan\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_start_seq_get",
          "args": [
            "context",
            "keytab",
            "&cursor"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while deleting entry from keytab\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_remove_entry",
          "args": [
            "context",
            "keytab",
            "&entry"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while temporarily ending \"\n\t\t\t    \"keytab scan\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_end_seq_get",
          "args": [
            "context",
            "keytab",
            "&cursor"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principal_compare",
          "args": [
            "context",
            "princ",
            "entry.principal"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_next_entry",
          "args": [
            "context",
            "keytab",
            "&entry",
            "&cursor"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while starting keytab scan\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_start_seq_get",
          "args": [
            "context",
            "keytab",
            "&cursor"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_free_entry",
          "args": [
            "context",
            "&entry"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while retrieving highest kvno \"\n\t\t       \"from keytab\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: No entry for principal \"\n\t\t\t    \"%s with kvno %d exists in keytab \"\n\t\t\t    \"%s.\\n\"",
            "whoami",
            "princ_str",
            "kvno",
            "keytab_str"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: No entry for principal \"\n\t\t\t    \"%s exists in keytab %s\\n\"",
            "whoami",
            "princ_str",
            "keytab_str"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Keytab %s does not exist.\\n\"",
            "whoami",
            "keytab_str"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_get_entry",
          "args": [
            "context",
            "keytab",
            "princ",
            "kvno",
            "0",
            "&entry"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "kvno_str"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kvno_str",
            "\"old\""
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kvno_str",
            "\"all\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while parsing principal name %s\"",
            "princ_str"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "princ_str",
            "&princ"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t\t krb5_boolean keepold,\n\t\t\t int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n\t\t\t char *princ_str);\nstatic int remove_principal(char *keytab_str, krb5_keytab keytab, char\n\t\t\t    *princ_str, char *kvno_str);\nstatic int quiet;\n\nint remove_principal(char *keytab_str, krb5_keytab keytab, char\n\t\t     *princ_str, char *kvno_str) \n{\n     krb5_principal princ;\n     krb5_keytab_entry entry;\n     krb5_kt_cursor cursor;\n     enum { UNDEF, SPEC, HIGH, ALL, OLD } mode;\n     int code, did_something;\n     krb5_kvno kvno;\n\n     code = krb5_parse_name(context, princ_str, &princ);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while parsing principal name %s\",\n\t\t  princ_str);\n\t  return code;\n     }\n\n     mode = UNDEF;\n     if (kvno_str == NULL) {\n\t  mode = HIGH;\n\t  kvno = 0;\n     } else if (strcmp(kvno_str, \"all\") == 0) {\n\t  mode = ALL;\n\t  kvno = 0;\n     } else if (strcmp(kvno_str, \"old\") == 0) {\n\t  mode = OLD;\n\t  kvno = 0;\n     } else {\n\t  mode = SPEC;\n\t  kvno = atoi(kvno_str);\n     }\n\n     /* kvno is set to specified value for SPEC, 0 otherwise */\n     code = krb5_kt_get_entry(context, keytab, princ, kvno, 0, &entry);\n     if (code != 0) {\n\t  if (code == ENOENT) {\n\t       fprintf(stderr, \"%s: Keytab %s does not exist.\\n\",\n\t\t       whoami, keytab_str);\n\t  } else if (code == KRB5_KT_NOTFOUND) {\n\t       if (mode != SPEC)\n\t\t    fprintf(stderr, \"%s: No entry for principal \"\n\t\t\t    \"%s exists in keytab %s\\n\",\n\t\t\t    whoami, princ_str, keytab_str);\n\t       else\n\t\t    fprintf(stderr, \"%s: No entry for principal \"\n\t\t\t    \"%s with kvno %d exists in keytab \"\n\t\t\t    \"%s.\\n\", whoami, princ_str, kvno,\n\t\t\t    keytab_str);\n\t  } else {\n\t       com_err(whoami, code, \"while retrieving highest kvno \"\n\t\t       \"from keytab\");\n\t  }\n\t  return code;\n     }\n\n     /* set kvno to spec'ed value for SPEC, highest kvno otherwise */\n     kvno = entry.vno;\n     krb5_kt_free_entry(context, &entry);\n\n     code = krb5_kt_start_seq_get(context, keytab, &cursor);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while starting keytab scan\");\n\t  return code;\n     }\n\n     did_something = 0;\n     while ((code = krb5_kt_next_entry(context, keytab, &entry, &cursor)) == 0) {\n\t  if (krb5_principal_compare(context, princ, entry.principal) &&\n\t      ((mode == ALL) ||\n\t       (mode == SPEC && entry.vno == kvno) ||\n\t       (mode == OLD && entry.vno != kvno) ||\n\t       (mode == HIGH && entry.vno == kvno))) {\n\n\t       /*\n\t\t* Ack!  What a kludge... the scanning functions lock\n\t\t* the keytab so entries cannot be removed while they\n\t\t* are operating.\n\t\t*/\n\t       code = krb5_kt_end_seq_get(context, keytab, &cursor);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while temporarily ending \"\n\t\t\t    \"keytab scan\");\n\t\t    return code;\n\t       }\n\t       code = krb5_kt_remove_entry(context, keytab, &entry);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while deleting entry from keytab\");\n\t\t    return code;\n\t       }\n\t       code = krb5_kt_start_seq_get(context, keytab, &cursor);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while restarting keytab scan\");\n\t\t    return code;\n\t       }\n\n\t       did_something++;\n\t       if (!quiet)\n\t\t    printf(\"Entry for principal %s with kvno %d \"\n\t\t\t   \"removed from keytab %s.\\n\", \n\t\t\t   princ_str, entry.vno, keytab_str);\n\t  }\n\t  krb5_kt_free_entry(context, &entry);\n     }\n     if (code && code != KRB5_KT_END) {\n\t  com_err(whoami, code, \"while scanning keytab\");\n\t  return code;\n     }\n     if ((code = krb5_kt_end_seq_get(context, keytab, &cursor))) {\n\t  com_err(whoami, code, \"while ending keytab scan\");\n\t  return code;\n     }\n\n     /*\n      * If !did_someting then mode must be OLD or we would have\n      * already returned with an error.  But check it anyway just to\n      * prevent unexpected error messages...\n      */\n     if (!did_something && mode == OLD) {\n\t  fprintf(stderr, \"%s: There is only one entry for principal \"\n\t\t  \"%s in keytab %s\\n\", whoami, princ_str, keytab_str);\n\t  return 1;\n     }\n     \n     return 0;\n}"
  },
  {
    "function_name": "add_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
    "lines": "238-323",
    "snippet": "static \nint add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t  krb5_boolean keepold, int n_ks_tuple,\n\t\t  krb5_key_salt_tuple *ks_tuple,\n\t\t  char *princ_str) \n{\n     kadm5_principal_ent_rec princ_rec;\n     krb5_principal princ;\n     krb5_keytab_entry new_entry;\n     krb5_keyblock *keys;\n     int code, nkeys, i;\n\n     (void) memset((char *)&princ_rec, 0, sizeof(princ_rec));\n\n     princ = NULL;\n     keys = NULL;\n     nkeys = 0;\n\n     code = krb5_parse_name(context, princ_str, &princ);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while parsing -add principal name %s\",\n\t\t  princ_str);\n\t  goto cleanup;\n     }\n\n     if (keepold || ks_tuple != NULL) {\n\t code = kadm5_randkey_principal_3(lhandle, princ,\n\t\t\t\t\t  keepold, n_ks_tuple, ks_tuple,\n\t\t\t\t\t  &keys, &nkeys);\n     } else {\n\t code = kadm5_randkey_principal(lhandle, princ, &keys, &nkeys);\n     }\n     if (code != 0) {\n\t  if (code == KADM5_UNK_PRINC) {\n\t       fprintf(stderr, \"%s: Principal %s does not exist.\\n\",\n\t\t       whoami, princ_str);\n\t  } else\n\t       com_err(whoami, code, \"while changing %s's key\",\n\t\t       princ_str);\n\t  goto cleanup;\n     }\n\n     code = kadm5_get_principal(lhandle, princ, &princ_rec,\n\t\t\t\tKADM5_PRINCIPAL_NORMAL_MASK);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while retrieving principal\");\n\t  goto cleanup;\n     }\n\n     for (i = 0; i < nkeys; i++) {\n\t  memset((char *) &new_entry, 0, sizeof(new_entry));\n\t  new_entry.principal = princ;\n\t  new_entry.key = keys[i];\n\t  new_entry.vno = princ_rec.kvno;\n\n\t  code = krb5_kt_add_entry(context, keytab, &new_entry);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while adding key to keytab\");\n\t       (void) kadm5_free_principal_ent(lhandle, &princ_rec);\n\t       goto cleanup;\n\t  }\n\n\t  if (!quiet)\n\t       printf(\"Entry for principal %s with kvno %d, \"\n\t\t      \"encryption type %s added to keytab %s.\\n\",\n\t\t      princ_str, princ_rec.kvno,\n\t\t      etype_string(keys[i].enctype), keytab_str);\n     }\n\n     code = kadm5_free_principal_ent(lhandle, &princ_rec);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while freeing principal entry\");\n\t  goto cleanup;\n     }\n\ncleanup:\n     if (nkeys) {\n\t  for (i = 0; i < nkeys; i++)\n\t       krb5_free_keyblock_contents(context, &keys[i]);\n\t  free(keys);\n     }\n     if (princ)\n\t  krb5_free_principal(context, princ);\n\n     return code;\n}",
    "includes": [
      "#include \"kadmin.h\"",
      "#include <krb5/adm_proto.h>",
      "#include <kadm5/admin.h>",
      "#include <krb5.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t\t krb5_boolean keepold,\n\t\t\t int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n\t\t\t char *princ_str);",
      "static char *etype_string(krb5_enctype enctype);",
      "static int quiet;",
      "static char *etype_string(enctype)\n    krb5_enctype enctype;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "princ"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keys"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_keyblock_contents",
          "args": [
            "context",
            "&keys[i]"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while freeing principal entry\""
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_free_principal_ent",
          "args": [
            "lhandle",
            "&princ_rec"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Entry for principal %s with kvno %d, \"\n\t\t      \"encryption type %s added to keytab %s.\\n\"",
            "princ_str",
            "princ_rec.kvno",
            "etype_string(keys[i].enctype)",
            "keytab_str"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "etype_string",
          "args": [
            "keys[i].enctype"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_free_principal_ent",
          "args": [
            "lhandle",
            "&princ_rec"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while adding key to keytab\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_add_entry",
          "args": [
            "context",
            "keytab",
            "&new_entry"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *) &new_entry",
            "0",
            "sizeof(new_entry)"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while retrieving principal\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_get_principal",
          "args": [
            "lhandle",
            "princ",
            "&princ_rec",
            "KADM5_PRINCIPAL_NORMAL_MASK"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "tcl_kadm5_get_principal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "2091-2163",
          "snippet": "static int tcl_kadm5_get_principal(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t   int argc, char *argv[])\n{\n     krb5_principal princ;\n     kadm5_principal_ent_rec ent;\n     Tcl_DString *ent_dstring = 0;\n     char *ent_var;\n     char *name;\n     krb5_error_code krb5_ret;\n     int tcl_ret;\n     kadm5_ret_t ret = -1;\n     krb5_int32 mask;\n     int retcode = TCL_OK;\n     \n     GET_HANDLE(3, 1);\n\n     if((tcl_ret = parse_str(interp, argv[0], &name)) != TCL_OK)\n\treturn tcl_ret;\n     if(name != NULL) {\n\tif ((krb5_ret = krb5_parse_name(context, name, &princ)) != 0) {\n\t    stash_error(interp, krb5_ret);\n\t    Tcl_AppendElement(interp, \"while parsing principal name\");\n\t    return TCL_ERROR;\n\t}\n     } else princ = NULL;\n\n     if ((tcl_ret = parse_str(interp, argv[1], &ent_var)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing entry variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((tcl_ret = parse_principal_mask(interp, argv[2], &mask)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing principal mask\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     \n     ret = kadm5_get_principal(server_handle, princ, ent_var ? &ent : 0,\n\t\t\t       mask);\n\n     if (ret == KADM5_OK) {\n\t  if (ent_var) {\n\t       ent_dstring = unparse_principal_ent(&ent, mask);\n\t       if (! Tcl_SetVar(interp, ent_var, ent_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting entry variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t       set_ok(interp, \"Principal retrieved.\");\n\t  }\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     if (ent_dstring) {\n\t  Tcl_DStringFree(ent_dstring);\n\t  free(ent_dstring);\n     }\n     if(princ != NULL)\n\tkrb5_free_principal(context, princ);\n     if (ret == KADM5_OK && ent_var &&\n\t (ret = kadm5_free_principal_ent(server_handle, &ent)) &&\n\t (retcode == TCL_OK)) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n     return retcode;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_context context;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic int tcl_kadm5_get_principal(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t   int argc, char *argv[])\n{\n     krb5_principal princ;\n     kadm5_principal_ent_rec ent;\n     Tcl_DString *ent_dstring = 0;\n     char *ent_var;\n     char *name;\n     krb5_error_code krb5_ret;\n     int tcl_ret;\n     kadm5_ret_t ret = -1;\n     krb5_int32 mask;\n     int retcode = TCL_OK;\n     \n     GET_HANDLE(3, 1);\n\n     if((tcl_ret = parse_str(interp, argv[0], &name)) != TCL_OK)\n\treturn tcl_ret;\n     if(name != NULL) {\n\tif ((krb5_ret = krb5_parse_name(context, name, &princ)) != 0) {\n\t    stash_error(interp, krb5_ret);\n\t    Tcl_AppendElement(interp, \"while parsing principal name\");\n\t    return TCL_ERROR;\n\t}\n     } else princ = NULL;\n\n     if ((tcl_ret = parse_str(interp, argv[1], &ent_var)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing entry variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((tcl_ret = parse_principal_mask(interp, argv[2], &mask)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing principal mask\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     \n     ret = kadm5_get_principal(server_handle, princ, ent_var ? &ent : 0,\n\t\t\t       mask);\n\n     if (ret == KADM5_OK) {\n\t  if (ent_var) {\n\t       ent_dstring = unparse_principal_ent(&ent, mask);\n\t       if (! Tcl_SetVar(interp, ent_var, ent_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting entry variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t       set_ok(interp, \"Principal retrieved.\");\n\t  }\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     if (ent_dstring) {\n\t  Tcl_DStringFree(ent_dstring);\n\t  free(ent_dstring);\n     }\n     if(princ != NULL)\n\tkrb5_free_principal(context, princ);\n     if (ret == KADM5_OK && ent_var &&\n\t (ret = kadm5_free_principal_ent(server_handle, &ent)) &&\n\t (retcode == TCL_OK)) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n     return retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while changing %s's key\"",
            "princ_str"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Principal %s does not exist.\\n\"",
            "whoami",
            "princ_str"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_randkey_principal",
          "args": [
            "lhandle",
            "princ",
            "&keys",
            "&nkeys"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "tcl_kadm5_randkey_principal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "2017-2087",
          "snippet": "static int tcl_kadm5_randkey_principal(ClientData clientData, \n\t\t\t\t       Tcl_Interp *interp,\n\t\t\t\t       int argc, char *argv[])\n{\n     krb5_principal princ;\n     krb5_keyblock *keyblocks;\n     int num_keys;\n     char *keyblock_var, *num_var, buf[50];\n     Tcl_DString *keyblock_dstring = 0;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(3, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal name\");\n\t  return TCL_ERROR;\n     }\n\n     if (parse_str(interp, argv[1], &keyblock_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keyblock variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if (parse_str(interp, argv[2], &num_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keyblock variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_randkey_principal(server_handle,\n\t\t\t\t   princ, keyblock_var ? &keyblocks : 0,\n\t\t\t\t   num_var ? &num_keys : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (keyblock_var) {\n\t       keyblock_dstring = unparse_keyblocks(keyblocks, num_keys);\n\t       if (! Tcl_SetVar(interp, keyblock_var,\n\t\t\t\tkeyblock_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting keyblock variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t  }\n\t  if (num_var) {\n\t       sprintf(buf, \"%d\", num_keys);\n\t       if (! Tcl_SetVar(interp, num_var, buf,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting num_keys variable\");\n\t       }\n\t  }\n\t  set_ok(interp, \"Key randomized.\");\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     krb5_free_principal(context, princ);\n     if (keyblock_dstring) {\n\t  Tcl_DStringFree(keyblock_dstring);\n\t  free(keyblock_dstring);\n     }\n     return retcode;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_context context;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic int tcl_kadm5_randkey_principal(ClientData clientData, \n\t\t\t\t       Tcl_Interp *interp,\n\t\t\t\t       int argc, char *argv[])\n{\n     krb5_principal princ;\n     krb5_keyblock *keyblocks;\n     int num_keys;\n     char *keyblock_var, *num_var, buf[50];\n     Tcl_DString *keyblock_dstring = 0;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(3, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal name\");\n\t  return TCL_ERROR;\n     }\n\n     if (parse_str(interp, argv[1], &keyblock_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keyblock variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if (parse_str(interp, argv[2], &num_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keyblock variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_randkey_principal(server_handle,\n\t\t\t\t   princ, keyblock_var ? &keyblocks : 0,\n\t\t\t\t   num_var ? &num_keys : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (keyblock_var) {\n\t       keyblock_dstring = unparse_keyblocks(keyblocks, num_keys);\n\t       if (! Tcl_SetVar(interp, keyblock_var,\n\t\t\t\tkeyblock_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting keyblock variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t  }\n\t  if (num_var) {\n\t       sprintf(buf, \"%d\", num_keys);\n\t       if (! Tcl_SetVar(interp, num_var, buf,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting num_keys variable\");\n\t       }\n\t  }\n\t  set_ok(interp, \"Key randomized.\");\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     krb5_free_principal(context, princ);\n     if (keyblock_dstring) {\n\t  Tcl_DStringFree(keyblock_dstring);\n\t  free(keyblock_dstring);\n     }\n     return retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_randkey_principal_3",
          "args": [
            "lhandle",
            "princ",
            "keepold",
            "n_ks_tuple",
            "ks_tuple",
            "&keys",
            "&nkeys"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while parsing -add principal name %s\"",
            "princ_str"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "princ_str",
            "&princ"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&princ_rec",
            "0",
            "sizeof(princ_rec)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t\t krb5_boolean keepold,\n\t\t\t int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n\t\t\t char *princ_str);\nstatic char *etype_string(krb5_enctype enctype);\nstatic int quiet;\nstatic char *etype_string(enctype)\n    krb5_enctype enctype;\n\nstatic \nint add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t  krb5_boolean keepold, int n_ks_tuple,\n\t\t  krb5_key_salt_tuple *ks_tuple,\n\t\t  char *princ_str) \n{\n     kadm5_principal_ent_rec princ_rec;\n     krb5_principal princ;\n     krb5_keytab_entry new_entry;\n     krb5_keyblock *keys;\n     int code, nkeys, i;\n\n     (void) memset((char *)&princ_rec, 0, sizeof(princ_rec));\n\n     princ = NULL;\n     keys = NULL;\n     nkeys = 0;\n\n     code = krb5_parse_name(context, princ_str, &princ);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while parsing -add principal name %s\",\n\t\t  princ_str);\n\t  goto cleanup;\n     }\n\n     if (keepold || ks_tuple != NULL) {\n\t code = kadm5_randkey_principal_3(lhandle, princ,\n\t\t\t\t\t  keepold, n_ks_tuple, ks_tuple,\n\t\t\t\t\t  &keys, &nkeys);\n     } else {\n\t code = kadm5_randkey_principal(lhandle, princ, &keys, &nkeys);\n     }\n     if (code != 0) {\n\t  if (code == KADM5_UNK_PRINC) {\n\t       fprintf(stderr, \"%s: Principal %s does not exist.\\n\",\n\t\t       whoami, princ_str);\n\t  } else\n\t       com_err(whoami, code, \"while changing %s's key\",\n\t\t       princ_str);\n\t  goto cleanup;\n     }\n\n     code = kadm5_get_principal(lhandle, princ, &princ_rec,\n\t\t\t\tKADM5_PRINCIPAL_NORMAL_MASK);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while retrieving principal\");\n\t  goto cleanup;\n     }\n\n     for (i = 0; i < nkeys; i++) {\n\t  memset((char *) &new_entry, 0, sizeof(new_entry));\n\t  new_entry.principal = princ;\n\t  new_entry.key = keys[i];\n\t  new_entry.vno = princ_rec.kvno;\n\n\t  code = krb5_kt_add_entry(context, keytab, &new_entry);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while adding key to keytab\");\n\t       (void) kadm5_free_principal_ent(lhandle, &princ_rec);\n\t       goto cleanup;\n\t  }\n\n\t  if (!quiet)\n\t       printf(\"Entry for principal %s with kvno %d, \"\n\t\t      \"encryption type %s added to keytab %s.\\n\",\n\t\t      princ_str, princ_rec.kvno,\n\t\t      etype_string(keys[i].enctype), keytab_str);\n     }\n\n     code = kadm5_free_principal_ent(lhandle, &princ_rec);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while freeing principal entry\");\n\t  goto cleanup;\n     }\n\ncleanup:\n     if (nkeys) {\n\t  for (i = 0; i < nkeys; i++)\n\t       krb5_free_keyblock_contents(context, &keys[i]);\n\t  free(keys);\n     }\n     if (princ)\n\t  krb5_free_principal(context, princ);\n\n     return code;\n}"
  },
  {
    "function_name": "kadmin_keytab_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
    "lines": "199-236",
    "snippet": "void kadmin_keytab_remove(int argc, char **argv)\n{\n     krb5_keytab keytab = 0;\n     char *keytab_str = NULL;\n     int code;\n\n     argc--; argv++;\n     quiet = 0;\n     while (argc) {\n\t  if (strncmp(*argv, \"-k\", 2) == 0) {\n\t       argc--; argv++;\n\t       if (!argc || keytab_str) {\n\t\t    rem_usage();\n\t\t    return;\n\t       }\n\t       keytab_str = *argv;\n\t  } else if (strcmp(*argv, \"-q\") == 0) {\n\t       quiet++;\n\t  } else\n\t       break;\n\t  argc--; argv++;\n     }\n\n     if (argc != 1 && argc != 2) {\n\t  rem_usage();\n\t  return;\n     }\n     if (process_keytab(context, &keytab_str, &keytab))\n\t  return;\n\n     (void) remove_principal(keytab_str, keytab, argv[0], argv[1]);\n\n     code = krb5_kt_close(context, keytab);\n     if (code != 0)\n\t  com_err(whoami, code, \"while closing keytab\");\n\n     free(keytab_str);\n}",
    "includes": [
      "#include \"kadmin.h\"",
      "#include <krb5/adm_proto.h>",
      "#include <kadm5/admin.h>",
      "#include <krb5.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quiet;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keytab_str"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while closing keytab\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_close",
          "args": [
            "context",
            "keytab"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_principal",
          "args": [
            "keytab_str",
            "keytab",
            "argv[0]",
            "argv[1]"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "remove_principal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
          "lines": "325-449",
          "snippet": "int remove_principal(char *keytab_str, krb5_keytab keytab, char\n\t\t     *princ_str, char *kvno_str) \n{\n     krb5_principal princ;\n     krb5_keytab_entry entry;\n     krb5_kt_cursor cursor;\n     enum { UNDEF, SPEC, HIGH, ALL, OLD } mode;\n     int code, did_something;\n     krb5_kvno kvno;\n\n     code = krb5_parse_name(context, princ_str, &princ);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while parsing principal name %s\",\n\t\t  princ_str);\n\t  return code;\n     }\n\n     mode = UNDEF;\n     if (kvno_str == NULL) {\n\t  mode = HIGH;\n\t  kvno = 0;\n     } else if (strcmp(kvno_str, \"all\") == 0) {\n\t  mode = ALL;\n\t  kvno = 0;\n     } else if (strcmp(kvno_str, \"old\") == 0) {\n\t  mode = OLD;\n\t  kvno = 0;\n     } else {\n\t  mode = SPEC;\n\t  kvno = atoi(kvno_str);\n     }\n\n     /* kvno is set to specified value for SPEC, 0 otherwise */\n     code = krb5_kt_get_entry(context, keytab, princ, kvno, 0, &entry);\n     if (code != 0) {\n\t  if (code == ENOENT) {\n\t       fprintf(stderr, \"%s: Keytab %s does not exist.\\n\",\n\t\t       whoami, keytab_str);\n\t  } else if (code == KRB5_KT_NOTFOUND) {\n\t       if (mode != SPEC)\n\t\t    fprintf(stderr, \"%s: No entry for principal \"\n\t\t\t    \"%s exists in keytab %s\\n\",\n\t\t\t    whoami, princ_str, keytab_str);\n\t       else\n\t\t    fprintf(stderr, \"%s: No entry for principal \"\n\t\t\t    \"%s with kvno %d exists in keytab \"\n\t\t\t    \"%s.\\n\", whoami, princ_str, kvno,\n\t\t\t    keytab_str);\n\t  } else {\n\t       com_err(whoami, code, \"while retrieving highest kvno \"\n\t\t       \"from keytab\");\n\t  }\n\t  return code;\n     }\n\n     /* set kvno to spec'ed value for SPEC, highest kvno otherwise */\n     kvno = entry.vno;\n     krb5_kt_free_entry(context, &entry);\n\n     code = krb5_kt_start_seq_get(context, keytab, &cursor);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while starting keytab scan\");\n\t  return code;\n     }\n\n     did_something = 0;\n     while ((code = krb5_kt_next_entry(context, keytab, &entry, &cursor)) == 0) {\n\t  if (krb5_principal_compare(context, princ, entry.principal) &&\n\t      ((mode == ALL) ||\n\t       (mode == SPEC && entry.vno == kvno) ||\n\t       (mode == OLD && entry.vno != kvno) ||\n\t       (mode == HIGH && entry.vno == kvno))) {\n\n\t       /*\n\t\t* Ack!  What a kludge... the scanning functions lock\n\t\t* the keytab so entries cannot be removed while they\n\t\t* are operating.\n\t\t*/\n\t       code = krb5_kt_end_seq_get(context, keytab, &cursor);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while temporarily ending \"\n\t\t\t    \"keytab scan\");\n\t\t    return code;\n\t       }\n\t       code = krb5_kt_remove_entry(context, keytab, &entry);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while deleting entry from keytab\");\n\t\t    return code;\n\t       }\n\t       code = krb5_kt_start_seq_get(context, keytab, &cursor);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while restarting keytab scan\");\n\t\t    return code;\n\t       }\n\n\t       did_something++;\n\t       if (!quiet)\n\t\t    printf(\"Entry for principal %s with kvno %d \"\n\t\t\t   \"removed from keytab %s.\\n\", \n\t\t\t   princ_str, entry.vno, keytab_str);\n\t  }\n\t  krb5_kt_free_entry(context, &entry);\n     }\n     if (code && code != KRB5_KT_END) {\n\t  com_err(whoami, code, \"while scanning keytab\");\n\t  return code;\n     }\n     if ((code = krb5_kt_end_seq_get(context, keytab, &cursor))) {\n\t  com_err(whoami, code, \"while ending keytab scan\");\n\t  return code;\n     }\n\n     /*\n      * If !did_someting then mode must be OLD or we would have\n      * already returned with an error.  But check it anyway just to\n      * prevent unexpected error messages...\n      */\n     if (!did_something && mode == OLD) {\n\t  fprintf(stderr, \"%s: There is only one entry for principal \"\n\t\t  \"%s in keytab %s\\n\", whoami, princ_str, keytab_str);\n\t  return 1;\n     }\n     \n     return 0;\n}",
          "includes": [
            "#include \"kadmin.h\"",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <krb5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t\t krb5_boolean keepold,\n\t\t\t int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n\t\t\t char *princ_str);",
            "static int remove_principal(char *keytab_str, krb5_keytab keytab, char\n\t\t\t    *princ_str, char *kvno_str);",
            "static int quiet;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t\t krb5_boolean keepold,\n\t\t\t int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n\t\t\t char *princ_str);\nstatic int remove_principal(char *keytab_str, krb5_keytab keytab, char\n\t\t\t    *princ_str, char *kvno_str);\nstatic int quiet;\n\nint remove_principal(char *keytab_str, krb5_keytab keytab, char\n\t\t     *princ_str, char *kvno_str) \n{\n     krb5_principal princ;\n     krb5_keytab_entry entry;\n     krb5_kt_cursor cursor;\n     enum { UNDEF, SPEC, HIGH, ALL, OLD } mode;\n     int code, did_something;\n     krb5_kvno kvno;\n\n     code = krb5_parse_name(context, princ_str, &princ);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while parsing principal name %s\",\n\t\t  princ_str);\n\t  return code;\n     }\n\n     mode = UNDEF;\n     if (kvno_str == NULL) {\n\t  mode = HIGH;\n\t  kvno = 0;\n     } else if (strcmp(kvno_str, \"all\") == 0) {\n\t  mode = ALL;\n\t  kvno = 0;\n     } else if (strcmp(kvno_str, \"old\") == 0) {\n\t  mode = OLD;\n\t  kvno = 0;\n     } else {\n\t  mode = SPEC;\n\t  kvno = atoi(kvno_str);\n     }\n\n     /* kvno is set to specified value for SPEC, 0 otherwise */\n     code = krb5_kt_get_entry(context, keytab, princ, kvno, 0, &entry);\n     if (code != 0) {\n\t  if (code == ENOENT) {\n\t       fprintf(stderr, \"%s: Keytab %s does not exist.\\n\",\n\t\t       whoami, keytab_str);\n\t  } else if (code == KRB5_KT_NOTFOUND) {\n\t       if (mode != SPEC)\n\t\t    fprintf(stderr, \"%s: No entry for principal \"\n\t\t\t    \"%s exists in keytab %s\\n\",\n\t\t\t    whoami, princ_str, keytab_str);\n\t       else\n\t\t    fprintf(stderr, \"%s: No entry for principal \"\n\t\t\t    \"%s with kvno %d exists in keytab \"\n\t\t\t    \"%s.\\n\", whoami, princ_str, kvno,\n\t\t\t    keytab_str);\n\t  } else {\n\t       com_err(whoami, code, \"while retrieving highest kvno \"\n\t\t       \"from keytab\");\n\t  }\n\t  return code;\n     }\n\n     /* set kvno to spec'ed value for SPEC, highest kvno otherwise */\n     kvno = entry.vno;\n     krb5_kt_free_entry(context, &entry);\n\n     code = krb5_kt_start_seq_get(context, keytab, &cursor);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while starting keytab scan\");\n\t  return code;\n     }\n\n     did_something = 0;\n     while ((code = krb5_kt_next_entry(context, keytab, &entry, &cursor)) == 0) {\n\t  if (krb5_principal_compare(context, princ, entry.principal) &&\n\t      ((mode == ALL) ||\n\t       (mode == SPEC && entry.vno == kvno) ||\n\t       (mode == OLD && entry.vno != kvno) ||\n\t       (mode == HIGH && entry.vno == kvno))) {\n\n\t       /*\n\t\t* Ack!  What a kludge... the scanning functions lock\n\t\t* the keytab so entries cannot be removed while they\n\t\t* are operating.\n\t\t*/\n\t       code = krb5_kt_end_seq_get(context, keytab, &cursor);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while temporarily ending \"\n\t\t\t    \"keytab scan\");\n\t\t    return code;\n\t       }\n\t       code = krb5_kt_remove_entry(context, keytab, &entry);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while deleting entry from keytab\");\n\t\t    return code;\n\t       }\n\t       code = krb5_kt_start_seq_get(context, keytab, &cursor);\n\t       if (code != 0) {\n\t\t    com_err(whoami, code, \"while restarting keytab scan\");\n\t\t    return code;\n\t       }\n\n\t       did_something++;\n\t       if (!quiet)\n\t\t    printf(\"Entry for principal %s with kvno %d \"\n\t\t\t   \"removed from keytab %s.\\n\", \n\t\t\t   princ_str, entry.vno, keytab_str);\n\t  }\n\t  krb5_kt_free_entry(context, &entry);\n     }\n     if (code && code != KRB5_KT_END) {\n\t  com_err(whoami, code, \"while scanning keytab\");\n\t  return code;\n     }\n     if ((code = krb5_kt_end_seq_get(context, keytab, &cursor))) {\n\t  com_err(whoami, code, \"while ending keytab scan\");\n\t  return code;\n     }\n\n     /*\n      * If !did_someting then mode must be OLD or we would have\n      * already returned with an error.  But check it anyway just to\n      * prevent unexpected error messages...\n      */\n     if (!did_something && mode == OLD) {\n\t  fprintf(stderr, \"%s: There is only one entry for principal \"\n\t\t  \"%s in keytab %s\\n\", whoami, princ_str, keytab_str);\n\t  return 1;\n     }\n     \n     return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "process_keytab",
          "args": [
            "context",
            "&keytab_str",
            "&keytab"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "process_keytab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
          "lines": "67-113",
          "snippet": "static int process_keytab(krb5_context my_context, char **keytab_str,\n\t\t   krb5_keytab *keytab) \n{\n     int code;\n     \n     if (*keytab_str == NULL) {\n\t  /* XXX krb5_defkeyname is an internal library global and\n             should go away */\n\t  if (! (*keytab_str = strdup(krb5_defkeyname))) {\n\t       com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t       return 1;\n\t  }\n\t  code = krb5_kt_default(my_context, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while opening default keytab\");\n\t       free(*keytab_str);\n\t       return 1;\n\t  }\n     } else {\n\t  if (strchr(*keytab_str, ':') != NULL) {\n\t       *keytab_str = strdup(*keytab_str);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t  } else {\n\t       char *tmp = *keytab_str;\n\n\t       *keytab_str = (char *)\n\t\t    malloc(strlen(\"WRFILE:\")+strlen(tmp)+1);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t       sprintf(*keytab_str, \"WRFILE:%s\", tmp);\n\t  }\n\t  \n\t  code = krb5_kt_resolve(my_context, *keytab_str, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while resolving keytab %s\", *keytab_str);\n\t       free(keytab_str);\n\t       return 1;\n\t  }\n     }\n     \n     return 0;\n}",
          "includes": [
            "#include \"kadmin.h\"",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <krb5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int process_keytab(krb5_context my_context, char **keytab_str,\n\t\t   krb5_keytab *keytab) \n{\n     int code;\n     \n     if (*keytab_str == NULL) {\n\t  /* XXX krb5_defkeyname is an internal library global and\n             should go away */\n\t  if (! (*keytab_str = strdup(krb5_defkeyname))) {\n\t       com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t       return 1;\n\t  }\n\t  code = krb5_kt_default(my_context, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while opening default keytab\");\n\t       free(*keytab_str);\n\t       return 1;\n\t  }\n     } else {\n\t  if (strchr(*keytab_str, ':') != NULL) {\n\t       *keytab_str = strdup(*keytab_str);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t  } else {\n\t       char *tmp = *keytab_str;\n\n\t       *keytab_str = (char *)\n\t\t    malloc(strlen(\"WRFILE:\")+strlen(tmp)+1);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t       sprintf(*keytab_str, \"WRFILE:%s\", tmp);\n\t  }\n\t  \n\t  code = krb5_kt_resolve(my_context, *keytab_str, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while resolving keytab %s\", *keytab_str);\n\t       free(keytab_str);\n\t       return 1;\n\t  }\n     }\n     \n     return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rem_usage",
          "args": [],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "rem_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
          "lines": "62-65",
          "snippet": "static void rem_usage()\n{\n     fprintf(stderr, \"Usage: ktremove [-k[eytab] keytab] [-q] principal [kvno|\\\"all\\\"|\\\"old\\\"]\\n\");\n}",
          "includes": [
            "#include \"kadmin.h\"",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <krb5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void rem_usage()\n{\n     fprintf(stderr, \"Usage: ktremove [-k[eytab] keytab] [-q] principal [kvno|\\\"all\\\"|\\\"old\\\"]\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"-q\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "*argv",
            "\"-k\"",
            "2"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int quiet;\n\nvoid kadmin_keytab_remove(int argc, char **argv)\n{\n     krb5_keytab keytab = 0;\n     char *keytab_str = NULL;\n     int code;\n\n     argc--; argv++;\n     quiet = 0;\n     while (argc) {\n\t  if (strncmp(*argv, \"-k\", 2) == 0) {\n\t       argc--; argv++;\n\t       if (!argc || keytab_str) {\n\t\t    rem_usage();\n\t\t    return;\n\t       }\n\t       keytab_str = *argv;\n\t  } else if (strcmp(*argv, \"-q\") == 0) {\n\t       quiet++;\n\t  } else\n\t       break;\n\t  argc--; argv++;\n     }\n\n     if (argc != 1 && argc != 2) {\n\t  rem_usage();\n\t  return;\n     }\n     if (process_keytab(context, &keytab_str, &keytab))\n\t  return;\n\n     (void) remove_principal(keytab_str, keytab, argv[0], argv[1]);\n\n     code = krb5_kt_close(context, keytab);\n     if (code != 0)\n\t  com_err(whoami, code, \"while closing keytab\");\n\n     free(keytab_str);\n}"
  },
  {
    "function_name": "kadmin_keytab_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
    "lines": "116-197",
    "snippet": "void kadmin_keytab_add(int argc, char **argv)\n{\n     krb5_keytab keytab = 0;\n     char *keytab_str = NULL, **princs;\n     int code, num, i;\n     krb5_error_code retval;\n     int n_ks_tuple = 0;\n     krb5_boolean keepold = FALSE;\n     krb5_key_salt_tuple *ks_tuple = NULL;\n\n     argc--; argv++;\n     quiet = 0;\n     while (argc) {\n\t  if (strncmp(*argv, \"-k\", 2) == 0) {\n\t       argc--; argv++;\n\t       if (!argc || keytab_str) {\n\t\t    add_usage();\n\t\t    return;\n\t       }\n\t       keytab_str = *argv;\n\t  } else if (strcmp(*argv, \"-q\") == 0) {\n\t       quiet++;\n\t  } else if (strcmp(*argv, \"-e\") == 0) {\n\t       argc--;\n\t       if (argc < 1) {\n\t\t    add_usage();\n\t\t    return;\n\t       }\n\t       retval = krb5_string_to_keysalts(*++argv, \", \\t\", \":.-\", 0,\n\t\t\t\t\t\t&ks_tuple, &n_ks_tuple);\n\t       if (retval) {\n\t\t    com_err(\"ktadd\", retval, \"while parsing keysalts %s\",\n\t\t\t    *argv);\n\n\t\t    return;\n\t       }\n\t  } else\n\t       break;\n\t  argc--; argv++;\n     }\n\n     if (argc == 0) {\n\t  add_usage();\n\t  return;\n     }\n\n     if (process_keytab(context, &keytab_str, &keytab))\n\t  return;\n     \n     while (*argv) {\n\t  if (strcmp(*argv, \"-glob\") == 0) {\n\t       if (*++argv == NULL) {\n\t\t    add_usage();\n\t\t    break;\n\t       }\n\t       \n\t       code = kadm5_get_principals(handle, *argv, &princs, &num);\n\t       if (code) {\n\t\t    com_err(whoami, code, \"while expanding expression \\\"%s\\\".\",\n\t\t\t    *argv);\n\t\t    argv++;\n\t\t    continue;\n\t       }\n\t       \n\t       for (i = 0; i < num; i++) \n\t\t    (void) add_principal(handle, keytab_str, keytab,\n\t\t\t\t\t keepold, n_ks_tuple, ks_tuple,\n\t\t\t\t\t princs[i]); \n\t       kadm5_free_name_list(handle, princs, num);\n\t  } else\n\t       (void) add_principal(handle, keytab_str, keytab,\n\t\t\t\t    keepold, n_ks_tuple, ks_tuple,\n\t\t\t\t    *argv);\n\t  argv++;\n     }\n\t  \n     code = krb5_kt_close(context, keytab);\n     if (code != 0)\n\t  com_err(whoami, code, \"while closing keytab\");\n\n     free(keytab_str);\n}",
    "includes": [
      "#include \"kadmin.h\"",
      "#include <krb5/adm_proto.h>",
      "#include <kadm5/admin.h>",
      "#include <krb5.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int quiet;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keytab_str"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while closing keytab\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_close",
          "args": [
            "context",
            "keytab"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_principal",
          "args": [
            "handle",
            "keytab_str",
            "keytab",
            "keepold",
            "n_ks_tuple",
            "ks_tuple",
            "*argv"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "add_principal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
          "lines": "238-323",
          "snippet": "static \nint add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t  krb5_boolean keepold, int n_ks_tuple,\n\t\t  krb5_key_salt_tuple *ks_tuple,\n\t\t  char *princ_str) \n{\n     kadm5_principal_ent_rec princ_rec;\n     krb5_principal princ;\n     krb5_keytab_entry new_entry;\n     krb5_keyblock *keys;\n     int code, nkeys, i;\n\n     (void) memset((char *)&princ_rec, 0, sizeof(princ_rec));\n\n     princ = NULL;\n     keys = NULL;\n     nkeys = 0;\n\n     code = krb5_parse_name(context, princ_str, &princ);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while parsing -add principal name %s\",\n\t\t  princ_str);\n\t  goto cleanup;\n     }\n\n     if (keepold || ks_tuple != NULL) {\n\t code = kadm5_randkey_principal_3(lhandle, princ,\n\t\t\t\t\t  keepold, n_ks_tuple, ks_tuple,\n\t\t\t\t\t  &keys, &nkeys);\n     } else {\n\t code = kadm5_randkey_principal(lhandle, princ, &keys, &nkeys);\n     }\n     if (code != 0) {\n\t  if (code == KADM5_UNK_PRINC) {\n\t       fprintf(stderr, \"%s: Principal %s does not exist.\\n\",\n\t\t       whoami, princ_str);\n\t  } else\n\t       com_err(whoami, code, \"while changing %s's key\",\n\t\t       princ_str);\n\t  goto cleanup;\n     }\n\n     code = kadm5_get_principal(lhandle, princ, &princ_rec,\n\t\t\t\tKADM5_PRINCIPAL_NORMAL_MASK);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while retrieving principal\");\n\t  goto cleanup;\n     }\n\n     for (i = 0; i < nkeys; i++) {\n\t  memset((char *) &new_entry, 0, sizeof(new_entry));\n\t  new_entry.principal = princ;\n\t  new_entry.key = keys[i];\n\t  new_entry.vno = princ_rec.kvno;\n\n\t  code = krb5_kt_add_entry(context, keytab, &new_entry);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while adding key to keytab\");\n\t       (void) kadm5_free_principal_ent(lhandle, &princ_rec);\n\t       goto cleanup;\n\t  }\n\n\t  if (!quiet)\n\t       printf(\"Entry for principal %s with kvno %d, \"\n\t\t      \"encryption type %s added to keytab %s.\\n\",\n\t\t      princ_str, princ_rec.kvno,\n\t\t      etype_string(keys[i].enctype), keytab_str);\n     }\n\n     code = kadm5_free_principal_ent(lhandle, &princ_rec);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while freeing principal entry\");\n\t  goto cleanup;\n     }\n\ncleanup:\n     if (nkeys) {\n\t  for (i = 0; i < nkeys; i++)\n\t       krb5_free_keyblock_contents(context, &keys[i]);\n\t  free(keys);\n     }\n     if (princ)\n\t  krb5_free_principal(context, princ);\n\n     return code;\n}",
          "includes": [
            "#include \"kadmin.h\"",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <krb5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t\t krb5_boolean keepold,\n\t\t\t int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n\t\t\t char *princ_str);",
            "static char *etype_string(krb5_enctype enctype);",
            "static int quiet;",
            "static char *etype_string(enctype)\n    krb5_enctype enctype;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t\t krb5_boolean keepold,\n\t\t\t int n_ks_tuple, krb5_key_salt_tuple *ks_tuple,\n\t\t\t char *princ_str);\nstatic char *etype_string(krb5_enctype enctype);\nstatic int quiet;\nstatic char *etype_string(enctype)\n    krb5_enctype enctype;\n\nstatic \nint add_principal(void *lhandle, char *keytab_str, krb5_keytab keytab,\n\t\t  krb5_boolean keepold, int n_ks_tuple,\n\t\t  krb5_key_salt_tuple *ks_tuple,\n\t\t  char *princ_str) \n{\n     kadm5_principal_ent_rec princ_rec;\n     krb5_principal princ;\n     krb5_keytab_entry new_entry;\n     krb5_keyblock *keys;\n     int code, nkeys, i;\n\n     (void) memset((char *)&princ_rec, 0, sizeof(princ_rec));\n\n     princ = NULL;\n     keys = NULL;\n     nkeys = 0;\n\n     code = krb5_parse_name(context, princ_str, &princ);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while parsing -add principal name %s\",\n\t\t  princ_str);\n\t  goto cleanup;\n     }\n\n     if (keepold || ks_tuple != NULL) {\n\t code = kadm5_randkey_principal_3(lhandle, princ,\n\t\t\t\t\t  keepold, n_ks_tuple, ks_tuple,\n\t\t\t\t\t  &keys, &nkeys);\n     } else {\n\t code = kadm5_randkey_principal(lhandle, princ, &keys, &nkeys);\n     }\n     if (code != 0) {\n\t  if (code == KADM5_UNK_PRINC) {\n\t       fprintf(stderr, \"%s: Principal %s does not exist.\\n\",\n\t\t       whoami, princ_str);\n\t  } else\n\t       com_err(whoami, code, \"while changing %s's key\",\n\t\t       princ_str);\n\t  goto cleanup;\n     }\n\n     code = kadm5_get_principal(lhandle, princ, &princ_rec,\n\t\t\t\tKADM5_PRINCIPAL_NORMAL_MASK);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while retrieving principal\");\n\t  goto cleanup;\n     }\n\n     for (i = 0; i < nkeys; i++) {\n\t  memset((char *) &new_entry, 0, sizeof(new_entry));\n\t  new_entry.principal = princ;\n\t  new_entry.key = keys[i];\n\t  new_entry.vno = princ_rec.kvno;\n\n\t  code = krb5_kt_add_entry(context, keytab, &new_entry);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while adding key to keytab\");\n\t       (void) kadm5_free_principal_ent(lhandle, &princ_rec);\n\t       goto cleanup;\n\t  }\n\n\t  if (!quiet)\n\t       printf(\"Entry for principal %s with kvno %d, \"\n\t\t      \"encryption type %s added to keytab %s.\\n\",\n\t\t      princ_str, princ_rec.kvno,\n\t\t      etype_string(keys[i].enctype), keytab_str);\n     }\n\n     code = kadm5_free_principal_ent(lhandle, &princ_rec);\n     if (code != 0) {\n\t  com_err(whoami, code, \"while freeing principal entry\");\n\t  goto cleanup;\n     }\n\ncleanup:\n     if (nkeys) {\n\t  for (i = 0; i < nkeys; i++)\n\t       krb5_free_keyblock_contents(context, &keys[i]);\n\t  free(keys);\n     }\n     if (princ)\n\t  krb5_free_principal(context, princ);\n\n     return code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_free_name_list",
          "args": [
            "handle",
            "princs",
            "num"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while expanding expression \\\"%s\\\".\"",
            "*argv"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_get_principals",
          "args": [
            "handle",
            "*argv",
            "&princs",
            "&num"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_usage",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "add_usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
          "lines": "57-60",
          "snippet": "static void add_usage()\n{\n     fprintf(stderr, \"Usage: ktadd [-k[eytab] keytab] [-q] [-e keysaltlist] [principal | -glob princ-exp] [...]\\n\");\n}",
          "includes": [
            "#include \"kadmin.h\"",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <krb5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void add_usage()\n{\n     fprintf(stderr, \"Usage: ktadd [-k[eytab] keytab] [-q] [-e keysaltlist] [principal | -glob princ-exp] [...]\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"-glob\""
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_keytab",
          "args": [
            "context",
            "&keytab_str",
            "&keytab"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "process_keytab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
          "lines": "67-113",
          "snippet": "static int process_keytab(krb5_context my_context, char **keytab_str,\n\t\t   krb5_keytab *keytab) \n{\n     int code;\n     \n     if (*keytab_str == NULL) {\n\t  /* XXX krb5_defkeyname is an internal library global and\n             should go away */\n\t  if (! (*keytab_str = strdup(krb5_defkeyname))) {\n\t       com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t       return 1;\n\t  }\n\t  code = krb5_kt_default(my_context, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while opening default keytab\");\n\t       free(*keytab_str);\n\t       return 1;\n\t  }\n     } else {\n\t  if (strchr(*keytab_str, ':') != NULL) {\n\t       *keytab_str = strdup(*keytab_str);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t  } else {\n\t       char *tmp = *keytab_str;\n\n\t       *keytab_str = (char *)\n\t\t    malloc(strlen(\"WRFILE:\")+strlen(tmp)+1);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t       sprintf(*keytab_str, \"WRFILE:%s\", tmp);\n\t  }\n\t  \n\t  code = krb5_kt_resolve(my_context, *keytab_str, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while resolving keytab %s\", *keytab_str);\n\t       free(keytab_str);\n\t       return 1;\n\t  }\n     }\n     \n     return 0;\n}",
          "includes": [
            "#include \"kadmin.h\"",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <krb5.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int process_keytab(krb5_context my_context, char **keytab_str,\n\t\t   krb5_keytab *keytab) \n{\n     int code;\n     \n     if (*keytab_str == NULL) {\n\t  /* XXX krb5_defkeyname is an internal library global and\n             should go away */\n\t  if (! (*keytab_str = strdup(krb5_defkeyname))) {\n\t       com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t       return 1;\n\t  }\n\t  code = krb5_kt_default(my_context, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while opening default keytab\");\n\t       free(*keytab_str);\n\t       return 1;\n\t  }\n     } else {\n\t  if (strchr(*keytab_str, ':') != NULL) {\n\t       *keytab_str = strdup(*keytab_str);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t  } else {\n\t       char *tmp = *keytab_str;\n\n\t       *keytab_str = (char *)\n\t\t    malloc(strlen(\"WRFILE:\")+strlen(tmp)+1);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t       sprintf(*keytab_str, \"WRFILE:%s\", tmp);\n\t  }\n\t  \n\t  code = krb5_kt_resolve(my_context, *keytab_str, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while resolving keytab %s\", *keytab_str);\n\t       free(keytab_str);\n\t       return 1;\n\t  }\n     }\n     \n     return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "\"ktadd\"",
            "retval",
            "\"while parsing keysalts %s\"",
            "*argv"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_string_to_keysalts",
          "args": [
            "*++argv",
            "\", \\t\"",
            "\":.-\"",
            "0",
            "&ks_tuple",
            "&n_ks_tuple"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"-e\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*argv",
            "\"-q\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "*argv",
            "\"-k\"",
            "2"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int quiet;\n\nvoid kadmin_keytab_add(int argc, char **argv)\n{\n     krb5_keytab keytab = 0;\n     char *keytab_str = NULL, **princs;\n     int code, num, i;\n     krb5_error_code retval;\n     int n_ks_tuple = 0;\n     krb5_boolean keepold = FALSE;\n     krb5_key_salt_tuple *ks_tuple = NULL;\n\n     argc--; argv++;\n     quiet = 0;\n     while (argc) {\n\t  if (strncmp(*argv, \"-k\", 2) == 0) {\n\t       argc--; argv++;\n\t       if (!argc || keytab_str) {\n\t\t    add_usage();\n\t\t    return;\n\t       }\n\t       keytab_str = *argv;\n\t  } else if (strcmp(*argv, \"-q\") == 0) {\n\t       quiet++;\n\t  } else if (strcmp(*argv, \"-e\") == 0) {\n\t       argc--;\n\t       if (argc < 1) {\n\t\t    add_usage();\n\t\t    return;\n\t       }\n\t       retval = krb5_string_to_keysalts(*++argv, \", \\t\", \":.-\", 0,\n\t\t\t\t\t\t&ks_tuple, &n_ks_tuple);\n\t       if (retval) {\n\t\t    com_err(\"ktadd\", retval, \"while parsing keysalts %s\",\n\t\t\t    *argv);\n\n\t\t    return;\n\t       }\n\t  } else\n\t       break;\n\t  argc--; argv++;\n     }\n\n     if (argc == 0) {\n\t  add_usage();\n\t  return;\n     }\n\n     if (process_keytab(context, &keytab_str, &keytab))\n\t  return;\n     \n     while (*argv) {\n\t  if (strcmp(*argv, \"-glob\") == 0) {\n\t       if (*++argv == NULL) {\n\t\t    add_usage();\n\t\t    break;\n\t       }\n\t       \n\t       code = kadm5_get_principals(handle, *argv, &princs, &num);\n\t       if (code) {\n\t\t    com_err(whoami, code, \"while expanding expression \\\"%s\\\".\",\n\t\t\t    *argv);\n\t\t    argv++;\n\t\t    continue;\n\t       }\n\t       \n\t       for (i = 0; i < num; i++) \n\t\t    (void) add_principal(handle, keytab_str, keytab,\n\t\t\t\t\t keepold, n_ks_tuple, ks_tuple,\n\t\t\t\t\t princs[i]); \n\t       kadm5_free_name_list(handle, princs, num);\n\t  } else\n\t       (void) add_principal(handle, keytab_str, keytab,\n\t\t\t\t    keepold, n_ks_tuple, ks_tuple,\n\t\t\t\t    *argv);\n\t  argv++;\n     }\n\t  \n     code = krb5_kt_close(context, keytab);\n     if (code != 0)\n\t  com_err(whoami, code, \"while closing keytab\");\n\n     free(keytab_str);\n}"
  },
  {
    "function_name": "process_keytab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
    "lines": "67-113",
    "snippet": "static int process_keytab(krb5_context my_context, char **keytab_str,\n\t\t   krb5_keytab *keytab) \n{\n     int code;\n     \n     if (*keytab_str == NULL) {\n\t  /* XXX krb5_defkeyname is an internal library global and\n             should go away */\n\t  if (! (*keytab_str = strdup(krb5_defkeyname))) {\n\t       com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t       return 1;\n\t  }\n\t  code = krb5_kt_default(my_context, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while opening default keytab\");\n\t       free(*keytab_str);\n\t       return 1;\n\t  }\n     } else {\n\t  if (strchr(*keytab_str, ':') != NULL) {\n\t       *keytab_str = strdup(*keytab_str);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t  } else {\n\t       char *tmp = *keytab_str;\n\n\t       *keytab_str = (char *)\n\t\t    malloc(strlen(\"WRFILE:\")+strlen(tmp)+1);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t       sprintf(*keytab_str, \"WRFILE:%s\", tmp);\n\t  }\n\t  \n\t  code = krb5_kt_resolve(my_context, *keytab_str, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while resolving keytab %s\", *keytab_str);\n\t       free(keytab_str);\n\t       return 1;\n\t  }\n     }\n     \n     return 0;\n}",
    "includes": [
      "#include \"kadmin.h\"",
      "#include <krb5/adm_proto.h>",
      "#include <kadm5/admin.h>",
      "#include <krb5.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keytab_str"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while resolving keytab %s\"",
            "*keytab_str"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_resolve",
          "args": [
            "my_context",
            "*keytab_str",
            "keytab"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "*keytab_str",
            "\"WRFILE:%s\"",
            "tmp"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "ENOMEM",
            "\"while creating keytab name\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "strlen(\"WRFILE:\")+strlen(tmp)+1"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tmp"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"WRFILE:\""
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "ENOMEM",
            "\"while creating keytab name\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "*keytab_str"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "*keytab_str",
            "':'"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "code",
            "\"while opening default keytab\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_default",
          "args": [
            "my_context",
            "keytab"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "ENOMEM",
            "\"while creating keytab name\""
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "krb5_defkeyname"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic int process_keytab(krb5_context my_context, char **keytab_str,\n\t\t   krb5_keytab *keytab) \n{\n     int code;\n     \n     if (*keytab_str == NULL) {\n\t  /* XXX krb5_defkeyname is an internal library global and\n             should go away */\n\t  if (! (*keytab_str = strdup(krb5_defkeyname))) {\n\t       com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t       return 1;\n\t  }\n\t  code = krb5_kt_default(my_context, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while opening default keytab\");\n\t       free(*keytab_str);\n\t       return 1;\n\t  }\n     } else {\n\t  if (strchr(*keytab_str, ':') != NULL) {\n\t       *keytab_str = strdup(*keytab_str);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t  } else {\n\t       char *tmp = *keytab_str;\n\n\t       *keytab_str = (char *)\n\t\t    malloc(strlen(\"WRFILE:\")+strlen(tmp)+1);\n\t       if (*keytab_str == NULL) {\n\t\t    com_err(whoami, ENOMEM, \"while creating keytab name\");\n\t\t    return 1;\n\t       }\n\t       sprintf(*keytab_str, \"WRFILE:%s\", tmp);\n\t  }\n\t  \n\t  code = krb5_kt_resolve(my_context, *keytab_str, keytab);\n\t  if (code != 0) {\n\t       com_err(whoami, code, \"while resolving keytab %s\", *keytab_str);\n\t       free(keytab_str);\n\t       return 1;\n\t  }\n     }\n     \n     return 0;\n}"
  },
  {
    "function_name": "rem_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
    "lines": "62-65",
    "snippet": "static void rem_usage()\n{\n     fprintf(stderr, \"Usage: ktremove [-k[eytab] keytab] [-q] principal [kvno|\\\"all\\\"|\\\"old\\\"]\\n\");\n}",
    "includes": [
      "#include \"kadmin.h\"",
      "#include <krb5/adm_proto.h>",
      "#include <kadm5/admin.h>",
      "#include <krb5.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: ktremove [-k[eytab] keytab] [-q] principal [kvno|\\\"all\\\"|\\\"old\\\"]\\n\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void rem_usage()\n{\n     fprintf(stderr, \"Usage: ktremove [-k[eytab] keytab] [-q] principal [kvno|\\\"all\\\"|\\\"old\\\"]\\n\");\n}"
  },
  {
    "function_name": "add_usage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/keytab.c",
    "lines": "57-60",
    "snippet": "static void add_usage()\n{\n     fprintf(stderr, \"Usage: ktadd [-k[eytab] keytab] [-q] [-e keysaltlist] [principal | -glob princ-exp] [...]\\n\");\n}",
    "includes": [
      "#include \"kadmin.h\"",
      "#include <krb5/adm_proto.h>",
      "#include <kadm5/admin.h>",
      "#include <krb5.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Usage: ktadd [-k[eytab] keytab] [-q] [-e keysaltlist] [principal | -glob princ-exp] [...]\\n\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kadmin.h\"\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void add_usage()\n{\n     fprintf(stderr, \"Usage: ktadd [-k[eytab] keytab] [-q] [-e keysaltlist] [principal | -glob princ-exp] [...]\\n\");\n}"
  }
]