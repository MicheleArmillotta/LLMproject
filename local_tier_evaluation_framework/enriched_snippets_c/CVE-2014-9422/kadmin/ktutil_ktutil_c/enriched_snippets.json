[
  {
    "function_name": "ktutil_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
    "lines": "209-285",
    "snippet": "void ktutil_list(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n    krb5_kt_list lp;\n    int show_time = 0, show_keys = 0, show_enctype = 0;\n    int i, j;\n    char *pname;\n\n    for (i = 1; i < argc; i++) {\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-t\", 2)) {\n\t    show_time++;\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-k\", 2)) {\n\t    show_keys++;\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-e\", 2)) {\n\t    show_enctype++;\n\t    continue;\n\t}\n\n\tfprintf(stderr, \"%s: usage: %s [-t] [-k] [-e]\\n\", argv[0], argv[0]);\n\treturn;\n    }\n    if (show_time) {\n\tprintf(\"slot KVNO Timestamp         Principal\\n\");\n\tprintf(\"---- ---- ----------------- ---------------------------------------------------\\n\");\n    } else {\n\tprintf(\"slot KVNO Principal\\n\");\n\tprintf(\"---- ---- ---------------------------------------------------------------------\\n\");\n    }\n    for (i = 1, lp = ktlist; lp; i++, lp = lp->next) {\n\tretval = krb5_unparse_name(kcontext, lp->entry->principal, &pname);\n\tif (retval) {\n\t    com_err(argv[0], retval, \"while unparsing principal name\");\n\t    return;\n\t}\n\tprintf(\"%4d %4d \", i, lp->entry->vno);\n\tif (show_time) {\n\t    char fmtbuf[18];\n\t    char fill;\n\t    time_t tstamp;\n\n\t    (void) localtime(&tstamp);\n\t    lp->entry->timestamp = tstamp;\n\t    fill = ' ';\n\t    if (!krb5_timestamp_to_sfstring((krb5_timestamp)lp->entry->\n\t\t\t\t\t    \ttimestamp,\n\t\t\t\t\t    fmtbuf,\n\t\t\t\t\t    sizeof(fmtbuf),\n\t\t\t\t\t    &fill))\n\t\tprintf(\"%s \", fmtbuf);\n\t}\n\tprintf(\"%40s\", pname);\n\tif (show_enctype) {\n\t    static char buf[256];\n\t\tif ((retval = krb5_enctype_to_string(\n\t\t    lp->entry->key.enctype, buf, 256))) {\n\t\t    com_err(argv[0], retval, \"While converting enctype to string\");\n\t\t    return;\n\t\t}\n\t    printf(\" (%s) \", buf);\n\t}\n\t\n\tif (show_keys) {\n\t    printf(\" (0x\");\n\t    for (j = 0; j < lp->entry->key.length; j++)\n\t\tprintf(\"%02x\", lp->entry->key.contents[j]);\n\t    printf(\")\");\n\t}\n\tprintf(\"\\n\");\n\tkrb5_xfree(pname);\n    }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ss/ss.h>",
      "#include \"adm_proto.h\"",
      "#include <com_err.h>",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "krb5_context kcontext;",
      "krb5_kt_list ktlist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_xfree",
          "args": [
            "pname"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\")\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%02x\"",
            "lp->entry->key.contents[j]"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" (0x\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\" (%s) \"",
            "buf"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"While converting enctype to string\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_enctype_to_string",
          "args": [
            "lp->entry->key.enctype",
            "buf",
            "256"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%40s\"",
            "pname"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s \"",
            "fmtbuf"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_timestamp_to_sfstring",
          "args": [
            "(krb5_timestamp)lp->entry->\n\t\t\t\t\t    \ttimestamp",
            "fmtbuf",
            "sizeof(fmtbuf)",
            "&fill"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime",
          "args": [
            "&tstamp"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%4d %4d \"",
            "i",
            "lp->entry->vno"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while unparsing principal name\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "kcontext",
            "lp->entry->principal",
            "&pname"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"---- ---- ---------------------------------------------------------------------\\n\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"slot KVNO Principal\\n\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"---- ---- ----------------- ---------------------------------------------------\\n\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"slot KVNO Timestamp         Principal\\n\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: usage: %s [-t] [-k] [-e]\\n\"",
            "argv[0]",
            "argv[0]"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"-e\"",
            "2"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"-k\"",
            "2"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"-t\"",
            "2"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ss/ss.h>\n#include \"adm_proto.h\"\n#include <com_err.h>\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_context kcontext;\nkrb5_kt_list ktlist = NULL;\n\nvoid ktutil_list(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n    krb5_kt_list lp;\n    int show_time = 0, show_keys = 0, show_enctype = 0;\n    int i, j;\n    char *pname;\n\n    for (i = 1; i < argc; i++) {\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-t\", 2)) {\n\t    show_time++;\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-k\", 2)) {\n\t    show_keys++;\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-e\", 2)) {\n\t    show_enctype++;\n\t    continue;\n\t}\n\n\tfprintf(stderr, \"%s: usage: %s [-t] [-k] [-e]\\n\", argv[0], argv[0]);\n\treturn;\n    }\n    if (show_time) {\n\tprintf(\"slot KVNO Timestamp         Principal\\n\");\n\tprintf(\"---- ---- ----------------- ---------------------------------------------------\\n\");\n    } else {\n\tprintf(\"slot KVNO Principal\\n\");\n\tprintf(\"---- ---- ---------------------------------------------------------------------\\n\");\n    }\n    for (i = 1, lp = ktlist; lp; i++, lp = lp->next) {\n\tretval = krb5_unparse_name(kcontext, lp->entry->principal, &pname);\n\tif (retval) {\n\t    com_err(argv[0], retval, \"while unparsing principal name\");\n\t    return;\n\t}\n\tprintf(\"%4d %4d \", i, lp->entry->vno);\n\tif (show_time) {\n\t    char fmtbuf[18];\n\t    char fill;\n\t    time_t tstamp;\n\n\t    (void) localtime(&tstamp);\n\t    lp->entry->timestamp = tstamp;\n\t    fill = ' ';\n\t    if (!krb5_timestamp_to_sfstring((krb5_timestamp)lp->entry->\n\t\t\t\t\t    \ttimestamp,\n\t\t\t\t\t    fmtbuf,\n\t\t\t\t\t    sizeof(fmtbuf),\n\t\t\t\t\t    &fill))\n\t\tprintf(\"%s \", fmtbuf);\n\t}\n\tprintf(\"%40s\", pname);\n\tif (show_enctype) {\n\t    static char buf[256];\n\t\tif ((retval = krb5_enctype_to_string(\n\t\t    lp->entry->key.enctype, buf, 256))) {\n\t\t    com_err(argv[0], retval, \"While converting enctype to string\");\n\t\t    return;\n\t\t}\n\t    printf(\" (%s) \", buf);\n\t}\n\t\n\tif (show_keys) {\n\t    printf(\" (0x\");\n\t    for (j = 0; j < lp->entry->key.length; j++)\n\t\tprintf(\"%02x\", lp->entry->key.contents[j]);\n\t    printf(\")\");\n\t}\n\tprintf(\"\\n\");\n\tkrb5_xfree(pname);\n    }\n}"
  },
  {
    "function_name": "ktutil_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
    "lines": "194-207",
    "snippet": "void ktutil_delete_entry(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify entry to delete\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_delete(kcontext, &ktlist, atoi(argv[1]));\n    if (retval)\n\tcom_err(argv[0], retval, \"while deleting entry %d\", atoi(argv[1]));\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ss/ss.h>",
      "#include \"adm_proto.h\"",
      "#include <com_err.h>",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "krb5_context kcontext;",
      "krb5_kt_list ktlist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while deleting entry %d\"",
            "atoi(argv[1])"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[1]"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktutil_delete",
          "args": [
            "kcontext",
            "&ktlist",
            "atoi(argv[1])"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_delete_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
          "lines": "194-207",
          "snippet": "void ktutil_delete_entry(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify entry to delete\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_delete(kcontext, &ktlist, atoi(argv[1]));\n    if (retval)\n\tcom_err(argv[0], retval, \"while deleting entry %d\", atoi(argv[1]));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[1]"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: must specify entry to delete\\n\"",
            "argv[0]"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ss/ss.h>\n#include \"adm_proto.h\"\n#include <com_err.h>\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_context kcontext;\nkrb5_kt_list ktlist = NULL;\n\nvoid ktutil_delete_entry(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify entry to delete\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_delete(kcontext, &ktlist, atoi(argv[1]));\n    if (retval)\n\tcom_err(argv[0], retval, \"while deleting entry %d\", atoi(argv[1]));\n}"
  },
  {
    "function_name": "ktutil_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
    "lines": "150-192",
    "snippet": "void ktutil_add_entry(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n    char *princ = NULL;\n    char *enctype = NULL;\n    krb5_kvno kvno = 0;\n    int use_pass = 0, use_key = 0, i;    \n\n    for (i = 1; i < argc; i++) {\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-p\", 2)) {\n\t    princ = argv[++i];\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-k\", 2)) {\n\t    kvno = (krb5_kvno) atoi(argv[++i]);\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-e\", 2)) {\n\t    enctype = argv[++i];\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 9) && !strncmp(argv[i], \"-password\", 9)) {\n\t    use_pass++;\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 4) && !strncmp(argv[i], \"-key\", 4)) {\n\t    use_key++;\n\t    continue;\n\t}\n    }\n\n    if (argc != 8 || !(princ && kvno && enctype) || (use_pass+use_key != 1)) {\n        fprintf(stderr, \"usage: %s (-key | -password) -p principal \"\n\t\t\"-k kvno -e enctype\\n\", argv[0]);\n\treturn;\n    }\n\n    retval = ktutil_add(kcontext, &ktlist, princ, kvno, enctype, use_pass);\n    if (retval)\n        com_err(argv[0], retval, \"while adding new entry\");\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ss/ss.h>",
      "#include \"adm_proto.h\"",
      "#include <com_err.h>",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "krb5_context kcontext;",
      "krb5_kt_list ktlist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while adding new entry\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktutil_add",
          "args": [
            "kcontext",
            "&ktlist",
            "princ",
            "kvno",
            "enctype",
            "use_pass"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
          "lines": "150-192",
          "snippet": "void ktutil_add_entry(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n    char *princ = NULL;\n    char *enctype = NULL;\n    krb5_kvno kvno = 0;\n    int use_pass = 0, use_key = 0, i;    \n\n    for (i = 1; i < argc; i++) {\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-p\", 2)) {\n\t    princ = argv[++i];\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-k\", 2)) {\n\t    kvno = (krb5_kvno) atoi(argv[++i]);\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-e\", 2)) {\n\t    enctype = argv[++i];\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 9) && !strncmp(argv[i], \"-password\", 9)) {\n\t    use_pass++;\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 4) && !strncmp(argv[i], \"-key\", 4)) {\n\t    use_key++;\n\t    continue;\n\t}\n    }\n\n    if (argc != 8 || !(princ && kvno && enctype) || (use_pass+use_key != 1)) {\n        fprintf(stderr, \"usage: %s (-key | -password) -p principal \"\n\t\t\"-k kvno -e enctype\\n\", argv[0]);\n\treturn;\n    }\n\n    retval = ktutil_add(kcontext, &ktlist, princ, kvno, enctype, use_pass);\n    if (retval)\n        com_err(argv[0], retval, \"while adding new entry\");\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"usage: %s (-key | -password) -p principal \"\n\t\t\"-k kvno -e enctype\\n\"",
            "argv[0]"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"-key\"",
            "4"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"-password\"",
            "9"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"-e\"",
            "2"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[++i]"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"-k\"",
            "2"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[i]",
            "\"-p\"",
            "2"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[i]"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ss/ss.h>\n#include \"adm_proto.h\"\n#include <com_err.h>\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_context kcontext;\nkrb5_kt_list ktlist = NULL;\n\nvoid ktutil_add_entry(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n    char *princ = NULL;\n    char *enctype = NULL;\n    krb5_kvno kvno = 0;\n    int use_pass = 0, use_key = 0, i;    \n\n    for (i = 1; i < argc; i++) {\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-p\", 2)) {\n\t    princ = argv[++i];\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-k\", 2)) {\n\t    kvno = (krb5_kvno) atoi(argv[++i]);\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 2) && !strncmp(argv[i], \"-e\", 2)) {\n\t    enctype = argv[++i];\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 9) && !strncmp(argv[i], \"-password\", 9)) {\n\t    use_pass++;\n\t    continue;\n\t}\n\tif ((strlen(argv[i]) == 4) && !strncmp(argv[i], \"-key\", 4)) {\n\t    use_key++;\n\t    continue;\n\t}\n    }\n\n    if (argc != 8 || !(princ && kvno && enctype) || (use_pass+use_key != 1)) {\n        fprintf(stderr, \"usage: %s (-key | -password) -p principal \"\n\t\t\"-k kvno -e enctype\\n\", argv[0]);\n\treturn;\n    }\n\n    retval = ktutil_add(kcontext, &ktlist, princ, kvno, enctype, use_pass);\n    if (retval)\n        com_err(argv[0], retval, \"while adding new entry\");\n}"
  },
  {
    "function_name": "ktutil_write_v4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
    "lines": "131-148",
    "snippet": "void ktutil_write_v4(argc, argv)\n    int argc;\n    char *argv[];\n{\n#ifdef KRB5_KRB4_COMPAT\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify srvtab to write\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_write_srvtab(kcontext, ktlist, argv[1]);\n    if (retval)\n\tcom_err(argv[0], retval, \"while writing srvtab \\\"%s\\\"\", argv[1]);\n#else\n    fprintf(stderr, \"%s: krb4 support not configured\\n\", argv[0]);\n#endif\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ss/ss.h>",
      "#include \"adm_proto.h\"",
      "#include <com_err.h>",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "krb5_context kcontext;",
      "krb5_kt_list ktlist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: krb4 support not configured\\n\"",
            "argv[0]"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while writing srvtab \\\"%s\\\"\"",
            "argv[1]"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktutil_write_srvtab",
          "args": [
            "kcontext",
            "ktlist",
            "argv[1]"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_write_srvtab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "462-555",
          "snippet": "krb5_error_code ktutil_write_srvtab(context, list, name)\n    krb5_context context;\n    krb5_kt_list list;\n    char *name;\n{\n    krb5_kt_list lp, lp1, prev, pruned = NULL;\n    krb5_error_code retval = 0;\n    FILE *fp;\n    char sname[SNAME_SZ];\n    char sinst[INST_SZ];\n    char srealm[REALM_SZ];\n\n    /* First do heinous stuff to prune the list. */\n    for (lp = list; lp; lp = lp->next) {\n\tif ((lp->entry->key.enctype != ENCTYPE_DES_CBC_CRC) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_MD5) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_MD4) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_RAW))\n\t    continue;\n\n\tfor (lp1 = pruned; lp1; prev = lp1, lp1 = lp1->next) {\n\t    /* Hunt for the current principal in the pruned list */\n\t    if (krb5_principal_compare(context,\n\t\t\t\t       lp->entry->principal,\n\t\t\t\t       lp1->entry->principal))\n\t\t    break;\n\t}\n\tif (!lp1) {\t\t/* need to add entry to tail of pruned list */\n\t    if (!pruned) {\n\t\tpruned = (krb5_kt_list) malloc(sizeof (*pruned));\n\t\tif (!pruned)\n\t\t    return ENOMEM;\n\t\tmemset((char *) pruned, 0, sizeof(*pruned));\n\t\tlp1 = pruned;\n\t    } else {\n\t\tprev->next\n\t\t    = (krb5_kt_list) malloc(sizeof (*pruned));\n\t\tif (!prev->next) {\n\t\t    retval = ENOMEM;\n\t\t    goto free_pruned;\n\t\t}\n\t\tmemset((char *) prev->next, 0, sizeof(*pruned));\n\t\tlp1 = prev->next;\n\t    }\n\t    lp1->entry = lp->entry;\n\t} else {\n\t    /* This heuristic should be roughly the same as in the\n\t       keytab-reading code in libkrb5.  */\n\t    int offset = 0;\n\t    if (lp1->entry->vno > 240 || lp->entry->vno > 240) {\n\t\toffset = 128;\n\t    }\n#define M(X) (((X) + offset) % 256)\n\t    if (M(lp1->entry->vno) < M(lp->entry->vno))\n\t\t/* Check if lp->entry is newer kvno; if so, update */\n\t\tlp1->entry = lp->entry;\n\t}\n    }\n    umask(0077); /*Changing umask for all of ktutil is OK\n\t\t  * We don't ever write out anything that should use\n\t\t  * default umask.*/\n    fp = fopen(name, \"w\");\n    if (!fp) {\n\tretval = EIO;\n\tgoto free_pruned;\n    }\n    for (lp = pruned; lp; lp = lp->next) {\n\tunsigned char  kvno;\n\tkvno = (unsigned char) lp->entry->vno;\n\tretval = krb5_524_conv_principal(context,\n\t\t\t\t\t lp->entry->principal,\n\t\t\t\t\t sname, sinst, srealm);\n\tif (retval)\n\t    break;\n\tfwrite(sname, strlen(sname) + 1, 1, fp);\n\tfwrite(sinst, strlen(sinst) + 1, 1, fp);\n\tfwrite(srealm, strlen(srealm) + 1, 1, fp);\n\tfwrite((char *)&kvno, 1, 1, fp);\n\tfwrite((char *)lp->entry->key.contents,\n\t       sizeof (des_cblock), 1, fp);\n    }\n    fclose(fp);\n free_pruned:\n    /*\n     * Loop over and free the pruned list; don't use free_kt_list\n     * because that kills the entries.\n     */\n    for (lp = pruned; lp;) {\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_write_srvtab(context, list, name)\n    krb5_context context;\n    krb5_kt_list list;\n    char *name;\n{\n    krb5_kt_list lp, lp1, prev, pruned = NULL;\n    krb5_error_code retval = 0;\n    FILE *fp;\n    char sname[SNAME_SZ];\n    char sinst[INST_SZ];\n    char srealm[REALM_SZ];\n\n    /* First do heinous stuff to prune the list. */\n    for (lp = list; lp; lp = lp->next) {\n\tif ((lp->entry->key.enctype != ENCTYPE_DES_CBC_CRC) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_MD5) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_MD4) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_RAW))\n\t    continue;\n\n\tfor (lp1 = pruned; lp1; prev = lp1, lp1 = lp1->next) {\n\t    /* Hunt for the current principal in the pruned list */\n\t    if (krb5_principal_compare(context,\n\t\t\t\t       lp->entry->principal,\n\t\t\t\t       lp1->entry->principal))\n\t\t    break;\n\t}\n\tif (!lp1) {\t\t/* need to add entry to tail of pruned list */\n\t    if (!pruned) {\n\t\tpruned = (krb5_kt_list) malloc(sizeof (*pruned));\n\t\tif (!pruned)\n\t\t    return ENOMEM;\n\t\tmemset((char *) pruned, 0, sizeof(*pruned));\n\t\tlp1 = pruned;\n\t    } else {\n\t\tprev->next\n\t\t    = (krb5_kt_list) malloc(sizeof (*pruned));\n\t\tif (!prev->next) {\n\t\t    retval = ENOMEM;\n\t\t    goto free_pruned;\n\t\t}\n\t\tmemset((char *) prev->next, 0, sizeof(*pruned));\n\t\tlp1 = prev->next;\n\t    }\n\t    lp1->entry = lp->entry;\n\t} else {\n\t    /* This heuristic should be roughly the same as in the\n\t       keytab-reading code in libkrb5.  */\n\t    int offset = 0;\n\t    if (lp1->entry->vno > 240 || lp->entry->vno > 240) {\n\t\toffset = 128;\n\t    }\n#define M(X) (((X) + offset) % 256)\n\t    if (M(lp1->entry->vno) < M(lp->entry->vno))\n\t\t/* Check if lp->entry is newer kvno; if so, update */\n\t\tlp1->entry = lp->entry;\n\t}\n    }\n    umask(0077); /*Changing umask for all of ktutil is OK\n\t\t  * We don't ever write out anything that should use\n\t\t  * default umask.*/\n    fp = fopen(name, \"w\");\n    if (!fp) {\n\tretval = EIO;\n\tgoto free_pruned;\n    }\n    for (lp = pruned; lp; lp = lp->next) {\n\tunsigned char  kvno;\n\tkvno = (unsigned char) lp->entry->vno;\n\tretval = krb5_524_conv_principal(context,\n\t\t\t\t\t lp->entry->principal,\n\t\t\t\t\t sname, sinst, srealm);\n\tif (retval)\n\t    break;\n\tfwrite(sname, strlen(sname) + 1, 1, fp);\n\tfwrite(sinst, strlen(sinst) + 1, 1, fp);\n\tfwrite(srealm, strlen(srealm) + 1, 1, fp);\n\tfwrite((char *)&kvno, 1, 1, fp);\n\tfwrite((char *)lp->entry->key.contents,\n\t       sizeof (des_cblock), 1, fp);\n    }\n    fclose(fp);\n free_pruned:\n    /*\n     * Loop over and free the pruned list; don't use free_kt_list\n     * because that kills the entries.\n     */\n    for (lp = pruned; lp;) {\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: must specify srvtab to write\\n\"",
            "argv[0]"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ss/ss.h>\n#include \"adm_proto.h\"\n#include <com_err.h>\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_context kcontext;\nkrb5_kt_list ktlist = NULL;\n\nvoid ktutil_write_v4(argc, argv)\n    int argc;\n    char *argv[];\n{\n#ifdef KRB5_KRB4_COMPAT\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify srvtab to write\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_write_srvtab(kcontext, ktlist, argv[1]);\n    if (retval)\n\tcom_err(argv[0], retval, \"while writing srvtab \\\"%s\\\"\", argv[1]);\n#else\n    fprintf(stderr, \"%s: krb4 support not configured\\n\", argv[0]);\n#endif\n}"
  },
  {
    "function_name": "ktutil_write_v5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
    "lines": "116-129",
    "snippet": "void ktutil_write_v5(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify keytab to write\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_write_keytab(kcontext, ktlist, argv[1]);\n    if (retval)\n\tcom_err(argv[0], retval, \"while writing keytab \\\"%s\\\"\", argv[1]);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ss/ss.h>",
      "#include \"adm_proto.h\"",
      "#include <com_err.h>",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "krb5_context kcontext;",
      "krb5_kt_list ktlist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while writing keytab \\\"%s\\\"\"",
            "argv[1]"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktutil_write_keytab",
          "args": [
            "kcontext",
            "ktlist",
            "argv[1]"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_write_keytab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "311-335",
          "snippet": "krb5_error_code ktutil_write_keytab(context, list, name)\n    krb5_context context;\n    krb5_kt_list list;\n    char *name;\n{\n    krb5_kt_list lp;\n    krb5_keytab kt;\n    char ktname[MAXPATHLEN+sizeof(\"WRFILE:\")+1];\n    krb5_error_code retval = 0;\n\n    strcpy(ktname, \"WRFILE:\");\n    if (strlen (name) >= MAXPATHLEN)\n\treturn ENAMETOOLONG;\n    strncat (ktname, name, MAXPATHLEN);\n    retval = krb5_kt_resolve(context, ktname, &kt);\n    if (retval)\n\treturn retval;\n    for (lp = list; lp; lp = lp->next) {\n\tretval = krb5_kt_add_entry(context, kt, lp->entry);\n\tif (retval)\n\t    break;\n    }\n    krb5_kt_close(context, kt);\n    return retval;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_write_keytab(context, list, name)\n    krb5_context context;\n    krb5_kt_list list;\n    char *name;\n{\n    krb5_kt_list lp;\n    krb5_keytab kt;\n    char ktname[MAXPATHLEN+sizeof(\"WRFILE:\")+1];\n    krb5_error_code retval = 0;\n\n    strcpy(ktname, \"WRFILE:\");\n    if (strlen (name) >= MAXPATHLEN)\n\treturn ENAMETOOLONG;\n    strncat (ktname, name, MAXPATHLEN);\n    retval = krb5_kt_resolve(context, ktname, &kt);\n    if (retval)\n\treturn retval;\n    for (lp = list; lp; lp = lp->next) {\n\tretval = krb5_kt_add_entry(context, kt, lp->entry);\n\tif (retval)\n\t    break;\n    }\n    krb5_kt_close(context, kt);\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: must specify keytab to write\\n\"",
            "argv[0]"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ss/ss.h>\n#include \"adm_proto.h\"\n#include <com_err.h>\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_context kcontext;\nkrb5_kt_list ktlist = NULL;\n\nvoid ktutil_write_v5(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify keytab to write\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_write_keytab(kcontext, ktlist, argv[1]);\n    if (retval)\n\tcom_err(argv[0], retval, \"while writing keytab \\\"%s\\\"\", argv[1]);\n}"
  },
  {
    "function_name": "ktutil_read_v4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
    "lines": "97-114",
    "snippet": "void ktutil_read_v4(argc, argv)\n    int argc;\n    char *argv[];\n{\n#ifdef KRB5_KRB4_COMPAT\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify the srvtab to read\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_read_srvtab(kcontext, argv[1], &ktlist);\n    if (retval)\n\tcom_err(argv[0], retval, \"while reading srvtab \\\"%s\\\"\", argv[1]);\n#else\n    fprintf(stderr, \"%s: krb4 support not configured\\n\", argv[0]);\n#endif\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ss/ss.h>",
      "#include \"adm_proto.h\"",
      "#include <com_err.h>",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "krb5_context kcontext;",
      "krb5_kt_list ktlist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: krb4 support not configured\\n\"",
            "argv[0]"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while reading srvtab \\\"%s\\\"\"",
            "argv[1]"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktutil_read_srvtab",
          "args": [
            "kcontext",
            "argv[1]",
            "&ktlist"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_read_srvtab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "365-455",
          "snippet": "krb5_error_code ktutil_read_srvtab(context, name, list)\n    krb5_context context;\n    char *name;\n    krb5_kt_list *list;\n{\n    krb5_kt_list lp = NULL, tail = NULL, back = NULL;\n    krb5_keytab_entry *entry;\n    krb5_error_code retval = 0;\n    char sname[SNAME_SZ];\t/* name of service */\n    char sinst[INST_SZ];\t/* instance of service */\n    char srealm[REALM_SZ];\t/* realm of service */\n    unsigned char kvno;\t\t/* key version number */\n    des_cblock key;\n    FILE *fp;\n\n    if (*list) {\n\t/* point lp at the tail of the list */\n\tfor (lp = *list; lp->next; lp = lp->next);\n\tback = lp;\n    }\n    fp = fopen(name, \"r\");\n    if (!fp)\n\treturn EIO;\n    for (;;) {\n\tentry = (krb5_keytab_entry *)malloc(sizeof (krb5_keytab_entry));\n\tif (!entry) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemset((char *)entry, 0, sizeof (*entry));\n\tmemset(sname, 0, sizeof (sname));\n\tmemset(sinst, 0, sizeof (sinst));\n\tmemset(srealm, 0, sizeof (srealm));\n\tif (!(getstr(fp, sname, SNAME_SZ) > 0 &&\n\t      getstr(fp, sinst, INST_SZ) > 0 &&\n\t      getstr(fp, srealm, REALM_SZ) > 0 &&\n\t      fread(&kvno, 1, 1, fp) > 0 &&\n\t      fread((char *)key, sizeof (key), 1, fp) > 0))\n\t    break;\n\tentry->magic = KV5M_KEYTAB_ENTRY;\n\tentry->timestamp = 0;\t/* XXX */\n\tentry->vno = kvno;\n\tretval = krb5_425_conv_principal(context,\n\t\t\t\t\t sname, sinst, srealm,\n\t\t\t\t\t &entry->principal);\n\tif (retval)\n\t    break;\n\tentry->key.magic = KV5M_KEYBLOCK;\n\tentry->key.enctype = ENCTYPE_DES_CBC_CRC;\n\tentry->key.length = sizeof (key);\n\tentry->key.contents = (krb5_octet *)malloc(sizeof (key));\n\tif (!entry->key.contents) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemcpy((char *)entry->key.contents, (char *)key, sizeof (key));\n\tif (!lp) {\t\t/* if list is empty, start one */\n\t    lp = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t} else {\n\t    lp->next = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp->next) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t    lp = lp->next;\n\t}\n\tlp->next = NULL;\n\tlp->entry = entry;\n\tif (!tail)\n\t    tail = lp;\n    }\n    if (entry) {\n\tif (entry->magic == KV5M_KEYTAB_ENTRY)\n\t    krb5_kt_free_entry(context, entry);\n\tfree((char *)entry);\n    }\n    if (retval) {\n\tktutil_free_kt_list(context, tail);\n\ttail = NULL;\n\tif (back)\n\t    back->next = NULL;\n    }\n    if (!*list)\n\t*list = tail;\n    fclose(fp);\n    return retval;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_read_srvtab(context, name, list)\n    krb5_context context;\n    char *name;\n    krb5_kt_list *list;\n{\n    krb5_kt_list lp = NULL, tail = NULL, back = NULL;\n    krb5_keytab_entry *entry;\n    krb5_error_code retval = 0;\n    char sname[SNAME_SZ];\t/* name of service */\n    char sinst[INST_SZ];\t/* instance of service */\n    char srealm[REALM_SZ];\t/* realm of service */\n    unsigned char kvno;\t\t/* key version number */\n    des_cblock key;\n    FILE *fp;\n\n    if (*list) {\n\t/* point lp at the tail of the list */\n\tfor (lp = *list; lp->next; lp = lp->next);\n\tback = lp;\n    }\n    fp = fopen(name, \"r\");\n    if (!fp)\n\treturn EIO;\n    for (;;) {\n\tentry = (krb5_keytab_entry *)malloc(sizeof (krb5_keytab_entry));\n\tif (!entry) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemset((char *)entry, 0, sizeof (*entry));\n\tmemset(sname, 0, sizeof (sname));\n\tmemset(sinst, 0, sizeof (sinst));\n\tmemset(srealm, 0, sizeof (srealm));\n\tif (!(getstr(fp, sname, SNAME_SZ) > 0 &&\n\t      getstr(fp, sinst, INST_SZ) > 0 &&\n\t      getstr(fp, srealm, REALM_SZ) > 0 &&\n\t      fread(&kvno, 1, 1, fp) > 0 &&\n\t      fread((char *)key, sizeof (key), 1, fp) > 0))\n\t    break;\n\tentry->magic = KV5M_KEYTAB_ENTRY;\n\tentry->timestamp = 0;\t/* XXX */\n\tentry->vno = kvno;\n\tretval = krb5_425_conv_principal(context,\n\t\t\t\t\t sname, sinst, srealm,\n\t\t\t\t\t &entry->principal);\n\tif (retval)\n\t    break;\n\tentry->key.magic = KV5M_KEYBLOCK;\n\tentry->key.enctype = ENCTYPE_DES_CBC_CRC;\n\tentry->key.length = sizeof (key);\n\tentry->key.contents = (krb5_octet *)malloc(sizeof (key));\n\tif (!entry->key.contents) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemcpy((char *)entry->key.contents, (char *)key, sizeof (key));\n\tif (!lp) {\t\t/* if list is empty, start one */\n\t    lp = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t} else {\n\t    lp->next = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp->next) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t    lp = lp->next;\n\t}\n\tlp->next = NULL;\n\tlp->entry = entry;\n\tif (!tail)\n\t    tail = lp;\n    }\n    if (entry) {\n\tif (entry->magic == KV5M_KEYTAB_ENTRY)\n\t    krb5_kt_free_entry(context, entry);\n\tfree((char *)entry);\n    }\n    if (retval) {\n\tktutil_free_kt_list(context, tail);\n\ttail = NULL;\n\tif (back)\n\t    back->next = NULL;\n    }\n    if (!*list)\n\t*list = tail;\n    fclose(fp);\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: must specify the srvtab to read\\n\"",
            "argv[0]"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ss/ss.h>\n#include \"adm_proto.h\"\n#include <com_err.h>\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_context kcontext;\nkrb5_kt_list ktlist = NULL;\n\nvoid ktutil_read_v4(argc, argv)\n    int argc;\n    char *argv[];\n{\n#ifdef KRB5_KRB4_COMPAT\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify the srvtab to read\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_read_srvtab(kcontext, argv[1], &ktlist);\n    if (retval)\n\tcom_err(argv[0], retval, \"while reading srvtab \\\"%s\\\"\", argv[1]);\n#else\n    fprintf(stderr, \"%s: krb4 support not configured\\n\", argv[0]);\n#endif\n}"
  },
  {
    "function_name": "ktutil_read_v5",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
    "lines": "82-95",
    "snippet": "void ktutil_read_v5(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify keytab to read\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_read_keytab(kcontext, argv[1], &ktlist);\n    if (retval)\n\tcom_err(argv[0], retval, \"while reading keytab \\\"%s\\\"\", argv[1]);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ss/ss.h>",
      "#include \"adm_proto.h\"",
      "#include <com_err.h>",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "krb5_context kcontext;",
      "krb5_kt_list ktlist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while reading keytab \\\"%s\\\"\"",
            "argv[1]"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktutil_read_keytab",
          "args": [
            "kcontext",
            "argv[1]",
            "&ktlist"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_read_keytab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "236-306",
          "snippet": "krb5_error_code ktutil_read_keytab(context, name, list)\n    krb5_context context;\n    char *name;\n    krb5_kt_list *list;\n{\n    krb5_kt_list lp = NULL, tail = NULL, back = NULL;\n    krb5_keytab kt;\n    krb5_keytab_entry *entry;\n    krb5_kt_cursor cursor;\n    krb5_error_code retval = 0;\n\n    if (*list) {\n\t/* point lp at the tail of the list */\n\tfor (lp = *list; lp->next; lp = lp->next);\n\tback = lp;\n    }\n    retval = krb5_kt_resolve(context, name, &kt);\n    if (retval)\n\treturn retval;\n    retval = krb5_kt_start_seq_get(context, kt, &cursor);\n    if (retval)\n\tgoto close_kt;\n    for (;;) {\n\tentry = (krb5_keytab_entry *)malloc(sizeof (krb5_keytab_entry));\n\tif (!entry) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemset((char *)entry, 0, sizeof (*entry));\n\tretval = krb5_kt_next_entry(context, kt, entry, &cursor);\n\tif (retval)\n\t    break;\n\n\tif (!lp) {\t\t/* if list is empty, start one */\n\t    lp = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t} else {\n\t    lp->next = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp->next) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t    lp = lp->next;\n\t}\n\tif (!tail)\n\t    tail = lp;\n\tlp->next = NULL;\n\tlp->entry = entry;\n    }\n    if (entry)\n\tfree((char *)entry);\n    if (retval) {\n\tif (retval == KRB5_KT_END)\n\t    retval = 0;\n\telse {\n\t    ktutil_free_kt_list(context, tail);\n\t    tail = NULL;\n\t    if (back)\n\t\tback->next = NULL;\n\t}\n    }\n    if (!*list)\n\t*list = tail;\n    krb5_kt_end_seq_get(context, kt, &cursor);\n close_kt:\n    krb5_kt_close(context, kt);\n    return retval;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_read_keytab(context, name, list)\n    krb5_context context;\n    char *name;\n    krb5_kt_list *list;\n{\n    krb5_kt_list lp = NULL, tail = NULL, back = NULL;\n    krb5_keytab kt;\n    krb5_keytab_entry *entry;\n    krb5_kt_cursor cursor;\n    krb5_error_code retval = 0;\n\n    if (*list) {\n\t/* point lp at the tail of the list */\n\tfor (lp = *list; lp->next; lp = lp->next);\n\tback = lp;\n    }\n    retval = krb5_kt_resolve(context, name, &kt);\n    if (retval)\n\treturn retval;\n    retval = krb5_kt_start_seq_get(context, kt, &cursor);\n    if (retval)\n\tgoto close_kt;\n    for (;;) {\n\tentry = (krb5_keytab_entry *)malloc(sizeof (krb5_keytab_entry));\n\tif (!entry) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemset((char *)entry, 0, sizeof (*entry));\n\tretval = krb5_kt_next_entry(context, kt, entry, &cursor);\n\tif (retval)\n\t    break;\n\n\tif (!lp) {\t\t/* if list is empty, start one */\n\t    lp = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t} else {\n\t    lp->next = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp->next) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t    lp = lp->next;\n\t}\n\tif (!tail)\n\t    tail = lp;\n\tlp->next = NULL;\n\tlp->entry = entry;\n    }\n    if (entry)\n\tfree((char *)entry);\n    if (retval) {\n\tif (retval == KRB5_KT_END)\n\t    retval = 0;\n\telse {\n\t    ktutil_free_kt_list(context, tail);\n\t    tail = NULL;\n\t    if (back)\n\t\tback->next = NULL;\n\t}\n    }\n    if (!*list)\n\t*list = tail;\n    krb5_kt_end_seq_get(context, kt, &cursor);\n close_kt:\n    krb5_kt_close(context, kt);\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: must specify keytab to read\\n\"",
            "argv[0]"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ss/ss.h>\n#include \"adm_proto.h\"\n#include <com_err.h>\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_context kcontext;\nkrb5_kt_list ktlist = NULL;\n\nvoid ktutil_read_v5(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n\n    if (argc != 2) {\n\tfprintf(stderr, \"%s: must specify keytab to read\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_read_keytab(kcontext, argv[1], &ktlist);\n    if (retval)\n\tcom_err(argv[0], retval, \"while reading keytab \\\"%s\\\"\", argv[1]);\n}"
  },
  {
    "function_name": "ktutil_clear_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
    "lines": "66-80",
    "snippet": "void ktutil_clear_list(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n\n    if (argc != 1) {\n\tfprintf(stderr, \"%s: invalid arguments\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_free_kt_list(kcontext, ktlist);\n    if (retval)\n\tcom_err(argv[0], retval, \"while freeing ktlist\");\n    ktlist = NULL;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ss/ss.h>",
      "#include \"adm_proto.h\"",
      "#include <com_err.h>",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "krb5_context kcontext;",
      "krb5_kt_list ktlist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while freeing ktlist\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktutil_free_kt_list",
          "args": [
            "kcontext",
            "ktlist"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_free_kt_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "41-58",
          "snippet": "krb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: invalid arguments\\n\"",
            "argv[0]"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ss/ss.h>\n#include \"adm_proto.h\"\n#include <com_err.h>\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_context kcontext;\nkrb5_kt_list ktlist = NULL;\n\nvoid ktutil_clear_list(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n\n    if (argc != 1) {\n\tfprintf(stderr, \"%s: invalid arguments\\n\", argv[0]);\n\treturn;\n    }\n    retval = ktutil_free_kt_list(kcontext, ktlist);\n    if (retval)\n\tcom_err(argv[0], retval, \"while freeing ktlist\");\n    ktlist = NULL;\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil.c",
    "lines": "43-64",
    "snippet": "int main(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n    int sci_idx;\n\n    retval = krb5_init_context(&kcontext);\n    if (retval) {\n        com_err(argv[0], retval, \"while initializing krb5\");\n\texit(1);\n    }\n    sci_idx = ss_create_invocation(\"ktutil\", \"5.0\", (char *)NULL,\n\t\t\t\t   &ktutil_cmds, &retval);\n    if (retval) {\n\tss_perror(sci_idx, retval, \"creating invocation\");\n\texit(1);\n    }\n    retval = ss_listen(sci_idx);\n    ktutil_free_kt_list(kcontext, ktlist);\n    exit(0);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <ss/ss.h>",
      "#include \"adm_proto.h\"",
      "#include <com_err.h>",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern ss_request_table ktutil_cmds;",
      "krb5_context kcontext;",
      "krb5_kt_list ktlist = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktutil_free_kt_list",
          "args": [
            "kcontext",
            "ktlist"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_free_kt_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "41-58",
          "snippet": "krb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ss_listen",
          "args": [
            "sci_idx"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss_perror",
          "args": [
            "sci_idx",
            "retval",
            "\"creating invocation\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ss_create_invocation",
          "args": [
            "\"ktutil\"",
            "\"5.0\"",
            "(char *)NULL",
            "&ktutil_cmds",
            "&retval"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "argv[0]",
            "retval",
            "\"while initializing krb5\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_init_context",
          "args": [
            "&kcontext"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n#include <ss/ss.h>\n#include \"adm_proto.h\"\n#include <com_err.h>\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nextern ss_request_table ktutil_cmds;\nkrb5_context kcontext;\nkrb5_kt_list ktlist = NULL;\n\nint main(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n    int sci_idx;\n\n    retval = krb5_init_context(&kcontext);\n    if (retval) {\n        com_err(argv[0], retval, \"while initializing krb5\");\n\texit(1);\n    }\n    sci_idx = ss_create_invocation(\"ktutil\", \"5.0\", (char *)NULL,\n\t\t\t\t   &ktutil_cmds, &retval);\n    if (retval) {\n\tss_perror(sci_idx, retval, \"creating invocation\");\n\texit(1);\n    }\n    retval = ss_listen(sci_idx);\n    ktutil_free_kt_list(kcontext, ktlist);\n    exit(0);\n}"
  }
]