[
  {
    "function_name": "check_for_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/util.c",
    "lines": "118-157",
    "snippet": "int\ncheck_for_match(search_field, must_be_first_character, chk_entry, \n\t\tnum_tokens, type)\nint must_be_first_character;\nchar *search_field;\nkrb5_db_entry *chk_entry;\nint num_tokens;\nint type;\n{\n    char token1[256];\n    char *found1;\n    char token2[256];\n    char *found2;\n    char token3[256];\n    char *found3;\n    char *local_entry;\n\n    local_entry = chk_entry->princ->data[type].data;\n\n    token1[0] = token2[0] = token3[0] = '\\0';\n\n    (void) sscanf(search_field, \"%s\\t%s\\t%s\", token1, token2, token3);\n\n    found1 = strstr(local_entry, token1);\n\n    if (must_be_first_character && (found1 != local_entry)) return(0);\n\n    if (found1 && (num_tokens == 1)) return(1);\n\n    if (found1 && (num_tokens > 1)) {\n\tfound2 = strstr(local_entry, token2);\n\tif (found2 && (found2 > found1) && (num_tokens == 2)) return(1);\n    }\n\n    if ((found2 > found1) && (num_tokens == 3)) {\n\tfound3 = strstr(local_entry, token3);\n       \tif (found3 && (found3 > found2) && (found2 > found1)) return(1);\n    }\n    return(0);\n}",
    "includes": [
      "#include \"./kdb5_edit.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "local_entry",
            "token3"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "local_entry",
            "token2"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "local_entry",
            "token1"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "search_field",
            "\"%s\\t%s\\t%s\"",
            "token1",
            "token2",
            "token3"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"./kdb5_edit.h\"\n#include \"k5-int.h\"\n\nint\ncheck_for_match(search_field, must_be_first_character, chk_entry, \n\t\tnum_tokens, type)\nint must_be_first_character;\nchar *search_field;\nkrb5_db_entry *chk_entry;\nint num_tokens;\nint type;\n{\n    char token1[256];\n    char *found1;\n    char token2[256];\n    char *found2;\n    char token3[256];\n    char *found3;\n    char *local_entry;\n\n    local_entry = chk_entry->princ->data[type].data;\n\n    token1[0] = token2[0] = token3[0] = '\\0';\n\n    (void) sscanf(search_field, \"%s\\t%s\\t%s\", token1, token2, token3);\n\n    found1 = strstr(local_entry, token1);\n\n    if (must_be_first_character && (found1 != local_entry)) return(0);\n\n    if (found1 && (num_tokens == 1)) return(1);\n\n    if (found1 && (num_tokens > 1)) {\n\tfound2 = strstr(local_entry, token2);\n\tif (found2 && (found2 > found1) && (num_tokens == 2)) return(1);\n    }\n\n    if ((found2 > found1) && (num_tokens == 3)) {\n\tfound3 = strstr(local_entry, token3);\n       \tif (found3 && (found3 > found2) && (found2 > found1)) return(1);\n    }\n    return(0);\n}"
  },
  {
    "function_name": "parse_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/util.c",
    "lines": "58-116",
    "snippet": "void\nparse_token(token_in, must_be_first_char, num_tokens, tokens_out)\nchar *token_in;\nint  *must_be_first_char;\nint  *num_tokens;\nchar *tokens_out;\n{\n    int i, j;\n    int token_count = 0;\n\n    i = 0;\n    j = 0;\n\n\t/* Eliminate Up Front Asterisks */\n    *must_be_first_char = 1;\n    for (i = 0; token_in[i] == '*'; i++) {\n\t*must_be_first_char = 0;\n    }\n\n    if (i == strlen(token_in)) {\n\t*num_tokens = 0;\n\treturn;\n    }\n\n\t/* Fill first token_out */\n    token_count++;\n    while ((token_in[i] != '*') && (token_in[i] != '\\0')) {\n\ttokens_out[j] = token_in[i];\n        j++;\n\ti++;\n    }\n\n    if (i == strlen(token_in)) {\n\ttokens_out[j] = '\\0';\n\t*num_tokens = token_count;\n\treturn;\n    }\n\n\t/* Then All Subsequent Tokens */\n    while (i < strlen(token_in)) {\n\tif (token_in[i] == '*') {\n\t   token_count++;\n\t   tokens_out[j] = '\\t';\n\t} else {\n\t   tokens_out[j] = token_in[i];\n\t}\n\ti++;\n\tj++;\n    }\n    tokens_out[j] = '\\0';\n\n    if (tokens_out[j - 1] == '\\t') {\n\ttoken_count--;\n\ttokens_out[j - 1] = '\\0';\n    }\n\n    *num_tokens = token_count;\n    return;\n}",
    "includes": [
      "#include \"./kdb5_edit.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "token_in"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "token_in"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "token_in"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"./kdb5_edit.h\"\n#include \"k5-int.h\"\n\nvoid\nparse_token(token_in, must_be_first_char, num_tokens, tokens_out)\nchar *token_in;\nint  *must_be_first_char;\nint  *num_tokens;\nchar *tokens_out;\n{\n    int i, j;\n    int token_count = 0;\n\n    i = 0;\n    j = 0;\n\n\t/* Eliminate Up Front Asterisks */\n    *must_be_first_char = 1;\n    for (i = 0; token_in[i] == '*'; i++) {\n\t*must_be_first_char = 0;\n    }\n\n    if (i == strlen(token_in)) {\n\t*num_tokens = 0;\n\treturn;\n    }\n\n\t/* Fill first token_out */\n    token_count++;\n    while ((token_in[i] != '*') && (token_in[i] != '\\0')) {\n\ttokens_out[j] = token_in[i];\n        j++;\n\ti++;\n    }\n\n    if (i == strlen(token_in)) {\n\ttokens_out[j] = '\\0';\n\t*num_tokens = token_count;\n\treturn;\n    }\n\n\t/* Then All Subsequent Tokens */\n    while (i < strlen(token_in)) {\n\tif (token_in[i] == '*') {\n\t   token_count++;\n\t   tokens_out[j] = '\\t';\n\t} else {\n\t   tokens_out[j] = token_in[i];\n\t}\n\ti++;\n\tj++;\n    }\n    tokens_out[j] = '\\0';\n\n    if (tokens_out[j - 1] == '\\t') {\n\ttoken_count--;\n\ttokens_out[j - 1] = '\\0';\n    }\n\n    *num_tokens = token_count;\n    return;\n}"
  }
]