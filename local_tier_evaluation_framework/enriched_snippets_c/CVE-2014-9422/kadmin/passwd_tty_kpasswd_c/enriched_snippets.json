[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/passwd/tty_kpasswd.c",
    "lines": "58-81",
    "snippet": "int\nmain(argc, argv)\n     int argc;\n     char *argv[];\n{\n  krb5_context context;\n  int retval;\n\n  whoami = (whoami = strrchr(argv[0], '/')) ? whoami + 1 : argv[0];\n\n  retval = krb5_init_context(&context);\n  if (retval) {\n       com_err(whoami, retval, \"initializing krb5 context\");\n       exit(retval);\n  }\n  initialize_kpws_error_table();\n\n  retval = kpasswd(context, argc, argv);\n\n  if (!retval)\n    printf(string_text(KPW_STR_PASSWORD_CHANGED));\n\n  exit(retval);\n}",
    "includes": [
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <stdio.h>",
      "#include \"kpasswd.h\"",
      "#include \"kpasswd_strings.h\"",
      "#include <krb5.h>",
      "#include <kadm5/admin.h>"
    ],
    "macros_used": [
      "#define string_text error_message"
    ],
    "globals_used": [
      "char *whoami;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "retval"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "string_text(KPW_STR_PASSWORD_CHANGED)"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_text",
          "args": [
            "KPW_STR_PASSWORD_CHANGED"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kpasswd",
          "args": [
            "context",
            "argc",
            "argv"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "kpasswd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/passwd/kpasswd.c",
          "lines": "73-280",
          "snippet": "int\nkpasswd(context, argc, argv)\n   krb5_context context;\n   int argc;\n   char *argv[];\n{\n  int code;\n  krb5_ccache ccache = NULL;\n  krb5_principal princ = 0;\n  char *princ_str;\n  struct passwd *pw = 0;\n  unsigned int pwsize;\n  char password[255];  /* I don't really like 255 but that's what kinit uses */\n  char msg_ret[1024], admin_realm[1024];\n  ovsec_kadm_principal_ent_t principal_entry = NULL;\n  ovsec_kadm_policy_ent_t policy_entry = NULL;\n  void *server_handle;\n\n  if (argc > 2) {\n      com_err(whoami, KPW_STR_USAGE, 0);\n      return(7);\n      /*NOTREACHED*/\n    }\n\n  /************************************\n   *  Get principal name to change    * \n   ************************************/\n\n  /* Look on the command line first, followed by the default credential\n     cache, followed by defaulting to the Unix user name */\n\n  if (argc == 2)\n    princ_str = strdup(argv[1]);\n  else {\n    code = krb5_cc_default(context, &ccache);\n    /* If we succeed, find who is in the credential cache */\n    if (code == 0) {\n      /* Get default principal from cache if one exists */\n      code = krb5_cc_get_principal(context, ccache, &princ);\n      /* if we got a principal, unparse it, otherwise get out of the if\n\t with an error code */\n      (void) krb5_cc_close(context, ccache);\n      if (code == 0) {\n\tcode = krb5_unparse_name(context, princ, &princ_str);\n\tif (code != 0) {\n\t  com_err(whoami,  code, string_text(KPW_STR_UNPARSE_NAME));\n\t  return(MISC_EXIT_STATUS);\n\t}\n      }\n    }\n\n    /* this is a crock.. we want to compare against */\n    /* \"KRB5_CC_DOESNOTEXIST\" but there is no such error code, and */\n    /* both the file and stdio types return FCC_NOFILE.  If there is */\n    /* ever another ccache type (or if the error codes are ever */\n    /* fixed), this code will have to be updated. */\n    if (code && code != KRB5_FCC_NOFILE) {\n      com_err(whoami, code, string_text(KPW_STR_WHILE_LOOKING_AT_CC));\n      return(MISC_EXIT_STATUS);\n    }\n\n    /* if either krb5_cc failed check the passwd file */\n    if (code != 0) {\n      pw = getpwuid( getuid());\n      if (pw == NULL) {\n\tcom_err(whoami, 0, string_text(KPW_STR_NOT_IN_PASSWD_FILE));\n\treturn(MISC_EXIT_STATUS);\n      }\n      princ_str = strdup(pw->pw_name);\n    }\n  }    \n  \n  display_intro_message(string_text(KPW_STR_CHANGING_PW_FOR), princ_str);\n\n  /* Need to get a krb5_principal, unless we started from with one from\n     the credential cache */\n\n  if (! princ) {\n      code = krb5_parse_name (context, princ_str, &princ);\n      if (code != 0) {\n\t  com_err(whoami, code, string_text(KPW_STR_PARSE_NAME), princ_str);\n\t  free(princ_str);\n\t  return(MISC_EXIT_STATUS);\n      }\n  }\n  \n  pwsize = sizeof(password);\n  code = read_old_password(context, password, &pwsize);\n\n  if (code != 0) {\n    memset(password, 0, sizeof(password));\n    com_err(whoami, code, string_text(KPW_STR_WHILE_READING_PASSWORD));\n    krb5_free_principal(context, princ);\n    free(princ_str);\n    return(MISC_EXIT_STATUS);\n  }\n  if (pwsize == 0) {\n    memset(password, 0, sizeof(password));\n    com_err(whoami, 0, string_text(KPW_STR_NO_PASSWORD_READ));\n    krb5_free_principal(context, princ);\n    free(princ_str);\n    return(5);\n  }\n\n  admin_realm[0] = '\\0';\n  strncat(admin_realm, krb5_princ_realm(context, princ)->data, \n\t  krb5_princ_realm(context, princ)->length);\n\n  code = ovsec_kadm_init(princ_str, password, KADM5_CHANGEPW_SERVICE,\n\t\t\t admin_realm /* we probably should take a -r */\n\t\t\t             /* someday */,\n\t\t\t OVSEC_KADM_STRUCT_VERSION,\n\t\t\t OVSEC_KADM_API_VERSION_1,\n\t\t\t &server_handle);\n  if (code != 0) {\n    if (code == OVSEC_KADM_BAD_PASSWORD)\n      com_err(whoami, 0, string_text(KPW_STR_OLD_PASSWORD_INCORRECT));\n    else \n      com_err(whoami, 0, string_text(KPW_STR_CANT_OPEN_ADMIN_SERVER), admin_realm,\n\t      error_message(code));\n    krb5_free_principal(context, princ);\n    free(princ_str);\n    return((code == OVSEC_KADM_BAD_PASSWORD)?2:3);\n  }\n\n  /* Explain policy restrictions on new password if any. */\n  /* Note: copy of this exists in login (kverify.c/get_verified_in_tkt). */\n\n  code = ovsec_kadm_get_principal(server_handle, princ, &principal_entry);\n  if (code != 0) {\n    com_err(whoami, 0,\n\t    string_text((code == OVSEC_KADM_UNK_PRINC)\n\t\t\t? KPW_STR_PRIN_UNKNOWN : KPW_STR_CANT_GET_POLICY_INFO),\n\t    princ_str);\n    krb5_free_principal(context, princ);\n    free(princ_str);\n    (void) ovsec_kadm_destroy(server_handle);\n    return((code == OVSEC_KADM_UNK_PRINC) ? 1 : MISC_EXIT_STATUS);\n  }\n  if ((principal_entry->aux_attributes & OVSEC_KADM_POLICY) != 0) {\n    code = ovsec_kadm_get_policy(server_handle,\n\t\t\t\t principal_entry->policy, &policy_entry);\n    if (code != 0) {\n      /* doesn't matter which error comes back, there's no nice recovery\n\t or need to differentiate to the user */\n      com_err(whoami, 0,\n\t      string_text(KPW_STR_CANT_GET_POLICY_INFO), princ_str);\n      (void) ovsec_kadm_free_principal_ent(server_handle, principal_entry);\n      krb5_free_principal(context, princ);\n      free(princ_str);\n      (void) ovsec_kadm_destroy(server_handle);\n      return(MISC_EXIT_STATUS);\n    }\n    com_err(whoami, 0, string_text(KPW_STR_POLICY_EXPLANATION),\n\t    princ_str, principal_entry->policy,\n\t    policy_entry->pw_min_length, policy_entry->pw_min_classes);\n\n    code = ovsec_kadm_free_principal_ent(server_handle, principal_entry);\n    if (code) {\n\t(void) ovsec_kadm_free_policy_ent(server_handle, policy_entry);\n\tkrb5_free_principal(context, princ);\n\tfree(princ_str);\n\tcom_err(whoami, code, string_text(KPW_STR_WHILE_FREEING_PRINCIPAL));\n\t(void) ovsec_kadm_destroy(server_handle);\n\treturn(MISC_EXIT_STATUS);\n    }\n\n    code = ovsec_kadm_free_policy_ent(server_handle, policy_entry);\n    if (code) {\n\tkrb5_free_principal(context, princ);\n\tfree(princ_str);\n\tcom_err(whoami, code, string_text(KPW_STR_WHILE_FREEING_POLICY));\n\t(void) ovsec_kadm_destroy(server_handle);\n\treturn(MISC_EXIT_STATUS);\n    }\n  }\n  else {\n    /* kpasswd *COULD* output something here to encourage the choice\n       of good passwords, in the absence of an enforced policy. */\n      code = ovsec_kadm_free_principal_ent(server_handle, principal_entry);\n      if (code) {\n\t  krb5_free_principal(context, princ);\n\t  free(princ_str);\n\t  com_err(whoami, code, string_text(KPW_STR_WHILE_FREEING_PRINCIPAL));\n\t  (void) ovsec_kadm_destroy(server_handle);\n\t  return(MISC_EXIT_STATUS);\n      }\n  }\n\n  pwsize = sizeof(password);\n  code = read_new_password(server_handle, password, &pwsize, msg_ret, princ);\n  memset(password, 0, sizeof(password));\n\n  if (code)\n    com_err(whoami, 0, msg_ret);\n\n  krb5_free_principal(context, princ);\n  free(princ_str);\n\n  (void) ovsec_kadm_destroy(server_handle);\n  \n  if (code == KRB5_LIBOS_CANTREADPWD)\n     return(5);\n  else if (code)\n     return(4);\n  else\n     return(0);\n}",
          "includes": [
            "#include <string.h>",
            "#include <pwd.h>",
            "#include <stdio.h>",
            "#include \"kpasswd.h\"",
            "#include \"kpasswd_strings.h\"",
            "#include <krb5.h>",
            "#include <kadm5/admin.h>"
          ],
          "macros_used": [
            "#define MISC_EXIT_STATUS 6",
            "#define string_text error_message"
          ],
          "globals_used": [
            "extern char *whoami;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <pwd.h>\n#include <stdio.h>\n#include \"kpasswd.h\"\n#include \"kpasswd_strings.h\"\n#include <krb5.h>\n#include <kadm5/admin.h>\n\n#define MISC_EXIT_STATUS 6\n#define string_text error_message\n\nextern char *whoami;\n\nint\nkpasswd(context, argc, argv)\n   krb5_context context;\n   int argc;\n   char *argv[];\n{\n  int code;\n  krb5_ccache ccache = NULL;\n  krb5_principal princ = 0;\n  char *princ_str;\n  struct passwd *pw = 0;\n  unsigned int pwsize;\n  char password[255];  /* I don't really like 255 but that's what kinit uses */\n  char msg_ret[1024], admin_realm[1024];\n  ovsec_kadm_principal_ent_t principal_entry = NULL;\n  ovsec_kadm_policy_ent_t policy_entry = NULL;\n  void *server_handle;\n\n  if (argc > 2) {\n      com_err(whoami, KPW_STR_USAGE, 0);\n      return(7);\n      /*NOTREACHED*/\n    }\n\n  /************************************\n   *  Get principal name to change    * \n   ************************************/\n\n  /* Look on the command line first, followed by the default credential\n     cache, followed by defaulting to the Unix user name */\n\n  if (argc == 2)\n    princ_str = strdup(argv[1]);\n  else {\n    code = krb5_cc_default(context, &ccache);\n    /* If we succeed, find who is in the credential cache */\n    if (code == 0) {\n      /* Get default principal from cache if one exists */\n      code = krb5_cc_get_principal(context, ccache, &princ);\n      /* if we got a principal, unparse it, otherwise get out of the if\n\t with an error code */\n      (void) krb5_cc_close(context, ccache);\n      if (code == 0) {\n\tcode = krb5_unparse_name(context, princ, &princ_str);\n\tif (code != 0) {\n\t  com_err(whoami,  code, string_text(KPW_STR_UNPARSE_NAME));\n\t  return(MISC_EXIT_STATUS);\n\t}\n      }\n    }\n\n    /* this is a crock.. we want to compare against */\n    /* \"KRB5_CC_DOESNOTEXIST\" but there is no such error code, and */\n    /* both the file and stdio types return FCC_NOFILE.  If there is */\n    /* ever another ccache type (or if the error codes are ever */\n    /* fixed), this code will have to be updated. */\n    if (code && code != KRB5_FCC_NOFILE) {\n      com_err(whoami, code, string_text(KPW_STR_WHILE_LOOKING_AT_CC));\n      return(MISC_EXIT_STATUS);\n    }\n\n    /* if either krb5_cc failed check the passwd file */\n    if (code != 0) {\n      pw = getpwuid( getuid());\n      if (pw == NULL) {\n\tcom_err(whoami, 0, string_text(KPW_STR_NOT_IN_PASSWD_FILE));\n\treturn(MISC_EXIT_STATUS);\n      }\n      princ_str = strdup(pw->pw_name);\n    }\n  }    \n  \n  display_intro_message(string_text(KPW_STR_CHANGING_PW_FOR), princ_str);\n\n  /* Need to get a krb5_principal, unless we started from with one from\n     the credential cache */\n\n  if (! princ) {\n      code = krb5_parse_name (context, princ_str, &princ);\n      if (code != 0) {\n\t  com_err(whoami, code, string_text(KPW_STR_PARSE_NAME), princ_str);\n\t  free(princ_str);\n\t  return(MISC_EXIT_STATUS);\n      }\n  }\n  \n  pwsize = sizeof(password);\n  code = read_old_password(context, password, &pwsize);\n\n  if (code != 0) {\n    memset(password, 0, sizeof(password));\n    com_err(whoami, code, string_text(KPW_STR_WHILE_READING_PASSWORD));\n    krb5_free_principal(context, princ);\n    free(princ_str);\n    return(MISC_EXIT_STATUS);\n  }\n  if (pwsize == 0) {\n    memset(password, 0, sizeof(password));\n    com_err(whoami, 0, string_text(KPW_STR_NO_PASSWORD_READ));\n    krb5_free_principal(context, princ);\n    free(princ_str);\n    return(5);\n  }\n\n  admin_realm[0] = '\\0';\n  strncat(admin_realm, krb5_princ_realm(context, princ)->data, \n\t  krb5_princ_realm(context, princ)->length);\n\n  code = ovsec_kadm_init(princ_str, password, KADM5_CHANGEPW_SERVICE,\n\t\t\t admin_realm /* we probably should take a -r */\n\t\t\t             /* someday */,\n\t\t\t OVSEC_KADM_STRUCT_VERSION,\n\t\t\t OVSEC_KADM_API_VERSION_1,\n\t\t\t &server_handle);\n  if (code != 0) {\n    if (code == OVSEC_KADM_BAD_PASSWORD)\n      com_err(whoami, 0, string_text(KPW_STR_OLD_PASSWORD_INCORRECT));\n    else \n      com_err(whoami, 0, string_text(KPW_STR_CANT_OPEN_ADMIN_SERVER), admin_realm,\n\t      error_message(code));\n    krb5_free_principal(context, princ);\n    free(princ_str);\n    return((code == OVSEC_KADM_BAD_PASSWORD)?2:3);\n  }\n\n  /* Explain policy restrictions on new password if any. */\n  /* Note: copy of this exists in login (kverify.c/get_verified_in_tkt). */\n\n  code = ovsec_kadm_get_principal(server_handle, princ, &principal_entry);\n  if (code != 0) {\n    com_err(whoami, 0,\n\t    string_text((code == OVSEC_KADM_UNK_PRINC)\n\t\t\t? KPW_STR_PRIN_UNKNOWN : KPW_STR_CANT_GET_POLICY_INFO),\n\t    princ_str);\n    krb5_free_principal(context, princ);\n    free(princ_str);\n    (void) ovsec_kadm_destroy(server_handle);\n    return((code == OVSEC_KADM_UNK_PRINC) ? 1 : MISC_EXIT_STATUS);\n  }\n  if ((principal_entry->aux_attributes & OVSEC_KADM_POLICY) != 0) {\n    code = ovsec_kadm_get_policy(server_handle,\n\t\t\t\t principal_entry->policy, &policy_entry);\n    if (code != 0) {\n      /* doesn't matter which error comes back, there's no nice recovery\n\t or need to differentiate to the user */\n      com_err(whoami, 0,\n\t      string_text(KPW_STR_CANT_GET_POLICY_INFO), princ_str);\n      (void) ovsec_kadm_free_principal_ent(server_handle, principal_entry);\n      krb5_free_principal(context, princ);\n      free(princ_str);\n      (void) ovsec_kadm_destroy(server_handle);\n      return(MISC_EXIT_STATUS);\n    }\n    com_err(whoami, 0, string_text(KPW_STR_POLICY_EXPLANATION),\n\t    princ_str, principal_entry->policy,\n\t    policy_entry->pw_min_length, policy_entry->pw_min_classes);\n\n    code = ovsec_kadm_free_principal_ent(server_handle, principal_entry);\n    if (code) {\n\t(void) ovsec_kadm_free_policy_ent(server_handle, policy_entry);\n\tkrb5_free_principal(context, princ);\n\tfree(princ_str);\n\tcom_err(whoami, code, string_text(KPW_STR_WHILE_FREEING_PRINCIPAL));\n\t(void) ovsec_kadm_destroy(server_handle);\n\treturn(MISC_EXIT_STATUS);\n    }\n\n    code = ovsec_kadm_free_policy_ent(server_handle, policy_entry);\n    if (code) {\n\tkrb5_free_principal(context, princ);\n\tfree(princ_str);\n\tcom_err(whoami, code, string_text(KPW_STR_WHILE_FREEING_POLICY));\n\t(void) ovsec_kadm_destroy(server_handle);\n\treturn(MISC_EXIT_STATUS);\n    }\n  }\n  else {\n    /* kpasswd *COULD* output something here to encourage the choice\n       of good passwords, in the absence of an enforced policy. */\n      code = ovsec_kadm_free_principal_ent(server_handle, principal_entry);\n      if (code) {\n\t  krb5_free_principal(context, princ);\n\t  free(princ_str);\n\t  com_err(whoami, code, string_text(KPW_STR_WHILE_FREEING_PRINCIPAL));\n\t  (void) ovsec_kadm_destroy(server_handle);\n\t  return(MISC_EXIT_STATUS);\n      }\n  }\n\n  pwsize = sizeof(password);\n  code = read_new_password(server_handle, password, &pwsize, msg_ret, princ);\n  memset(password, 0, sizeof(password));\n\n  if (code)\n    com_err(whoami, 0, msg_ret);\n\n  krb5_free_principal(context, princ);\n  free(princ_str);\n\n  (void) ovsec_kadm_destroy(server_handle);\n  \n  if (code == KRB5_LIBOS_CANTREADPWD)\n     return(5);\n  else if (code)\n     return(4);\n  else\n     return(0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "initialize_kpws_error_table",
          "args": [],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "retval",
            "\"initializing krb5 context\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_init_context",
          "args": [
            "&context"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <pwd.h>\n#include <stdio.h>\n#include \"kpasswd.h\"\n#include \"kpasswd_strings.h\"\n#include <krb5.h>\n#include <kadm5/admin.h>\n\n#define string_text error_message\n\nchar *whoami;\n\nint\nmain(argc, argv)\n     int argc;\n     char *argv[];\n{\n  krb5_context context;\n  int retval;\n\n  whoami = (whoami = strrchr(argv[0], '/')) ? whoami + 1 : argv[0];\n\n  retval = krb5_init_context(&context);\n  if (retval) {\n       com_err(whoami, retval, \"initializing krb5 context\");\n       exit(retval);\n  }\n  initialize_kpws_error_table();\n\n  retval = kpasswd(context, argc, argv);\n\n  if (!retval)\n    printf(string_text(KPW_STR_PASSWORD_CHANGED));\n\n  exit(retval);\n}"
  },
  {
    "function_name": "read_new_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/passwd/tty_kpasswd.c",
    "lines": "42-52",
    "snippet": "long read_new_password(server_handle, password, pwsize, msg_ret, princ)\n     void *server_handle;\n     char *password;\n     unsigned int *pwsize;\n     char *msg_ret;\n     krb5_principal princ;\n{\n  return (ovsec_kadm_chpass_principal_util(server_handle, princ, NULL, \n\t\t\t\t\t   NULL /* don't need new pw back */,\n\t\t\t\t\t   msg_ret));\n}",
    "includes": [
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <stdio.h>",
      "#include \"kpasswd.h\"",
      "#include \"kpasswd_strings.h\"",
      "#include <krb5.h>",
      "#include <kadm5/admin.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ovsec_kadm_chpass_principal_util",
          "args": [
            "server_handle",
            "princ",
            "NULL",
            "NULL/* don't need new pw back */",
            "msg_ret"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <pwd.h>\n#include <stdio.h>\n#include \"kpasswd.h\"\n#include \"kpasswd_strings.h\"\n#include <krb5.h>\n#include <kadm5/admin.h>\n\nlong read_new_password(server_handle, password, pwsize, msg_ret, princ)\n     void *server_handle;\n     char *password;\n     unsigned int *pwsize;\n     char *msg_ret;\n     krb5_principal princ;\n{\n  return (ovsec_kadm_chpass_principal_util(server_handle, princ, NULL, \n\t\t\t\t\t   NULL /* don't need new pw back */,\n\t\t\t\t\t   msg_ret));\n}"
  },
  {
    "function_name": "read_old_password",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/passwd/tty_kpasswd.c",
    "lines": "31-40",
    "snippet": "long read_old_password(context, password, pwsize)\n     krb5_context context;\n     char *password;\n     unsigned int *pwsize;\n{\n  long code = krb5_read_password(context,\n\t\t\t string_text(KPW_STR_OLD_PASSWORD_PROMPT),  \n\t\t\t 0, password, pwsize);\n  return code;\n}",
    "includes": [
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <stdio.h>",
      "#include \"kpasswd.h\"",
      "#include \"kpasswd_strings.h\"",
      "#include <krb5.h>",
      "#include <kadm5/admin.h>"
    ],
    "macros_used": [
      "#define string_text error_message"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_read_password",
          "args": [
            "context",
            "string_text(KPW_STR_OLD_PASSWORD_PROMPT)",
            "0",
            "password",
            "pwsize"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "string_text",
          "args": [
            "KPW_STR_OLD_PASSWORD_PROMPT"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <pwd.h>\n#include <stdio.h>\n#include \"kpasswd.h\"\n#include \"kpasswd_strings.h\"\n#include <krb5.h>\n#include <kadm5/admin.h>\n\n#define string_text error_message\n\nlong read_old_password(context, password, pwsize)\n     krb5_context context;\n     char *password;\n     unsigned int *pwsize;\n{\n  long code = krb5_read_password(context,\n\t\t\t string_text(KPW_STR_OLD_PASSWORD_PROMPT),  \n\t\t\t 0, password, pwsize);\n  return code;\n}"
  },
  {
    "function_name": "display_intro_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/passwd/tty_kpasswd.c",
    "lines": "24-29",
    "snippet": "void display_intro_message(fmt_string, arg_string)\n     const char *fmt_string;\n     const char *arg_string;\n{\n  com_err(whoami, 0, fmt_string, arg_string);\n}",
    "includes": [
      "#include <string.h>",
      "#include <pwd.h>",
      "#include <stdio.h>",
      "#include \"kpasswd.h\"",
      "#include \"kpasswd_strings.h\"",
      "#include <krb5.h>",
      "#include <kadm5/admin.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *whoami;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "whoami",
            "0",
            "fmt_string",
            "arg_string"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <string.h>\n#include <pwd.h>\n#include <stdio.h>\n#include \"kpasswd.h\"\n#include \"kpasswd_strings.h\"\n#include <krb5.h>\n#include <kadm5/admin.h>\n\nchar *whoami;\n\nvoid display_intro_message(fmt_string, arg_string)\n     const char *fmt_string;\n     const char *arg_string;\n{\n  com_err(whoami, 0, fmt_string, arg_string);\n}"
  }
]