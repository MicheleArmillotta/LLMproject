[
  {
    "function_name": "bcopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/cli/memmove.c",
    "lines": "71-144",
    "snippet": "void\nbcopy(src0, dst0, length)\n#endif\n#endif\n\tvoid *dst0;\n\tconst void *src0;\n\tregister size_t length;\n{\n\tregister char *dst = dst0;\n\tregister const char *src = src0;\n\tregister size_t t;\n\n\tif (length == 0 || dst == src)\t\t/* nothing to do */\n\t\tgoto done;\n\n\t/*\n\t * Macros: loop-t-times; and loop-t-times, t>0\n\t */\n#define\tTLOOP(s) if (t) TLOOP1(s)\n#define\tTLOOP1(s) do { s; } while (--t)\n\n\tif ((unsigned long)dst < (unsigned long)src) {\n\t\t/*\n\t\t * Copy forward.\n\t\t */\n\t\tt = (int)src;\t/* only need low bits */\n\t\tif ((t | (int)dst) & wmask) {\n\t\t\t/*\n\t\t\t * Try to align operands.  This cannot be done\n\t\t\t * unless the low bits match.\n\t\t\t */\n\t\t\tif ((t ^ (int)dst) & wmask || length < wsize)\n\t\t\t\tt = length;\n\t\t\telse\n\t\t\t\tt = wsize - (t & wmask);\n\t\t\tlength -= t;\n\t\t\tTLOOP1(*dst++ = *src++);\n\t\t}\n\t\t/*\n\t\t * Copy whole words, then mop up any trailing bytes.\n\t\t */\n\t\tt = length / wsize;\n\t\tTLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);\n\t\tt = length & wmask;\n\t\tTLOOP(*dst++ = *src++);\n\t} else {\n\t\t/*\n\t\t * Copy backwards.  Otherwise essentially the same.\n\t\t * Alignment works as before, except that it takes\n\t\t * (t&wmask) bytes to align, not wsize-(t&wmask).\n\t\t */\n\t\tsrc += length;\n\t\tdst += length;\n\t\tt = (int)src;\n\t\tif ((t | (int)dst) & wmask) {\n\t\t\tif ((t ^ (int)dst) & wmask || length <= wsize)\n\t\t\t\tt = length;\n\t\t\telse\n\t\t\t\tt &= wmask;\n\t\t\tlength -= t;\n\t\t\tTLOOP1(*--dst = *--src);\n\t\t}\n\t\tt = length / wsize;\n\t\tTLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);\n\t\tt = length & wmask;\n\t\tTLOOP(*--dst = *--src);\n\t}\ndone:\n#if defined(MEMCOPY) || defined(MEMMOVE)\n\treturn (dst0);\n#else\n\treturn;\n#endif\n}",
    "includes": [
      "#include <strings.h>",
      "#include <string.h>",
      "#include <krb5/config.h>",
      "#include <krb5/osconf.h>"
    ],
    "macros_used": [
      "#define\twmask\t(wsize - 1)",
      "#define\twsize\tsizeof(word)",
      "#define MEMMOVE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TLOOP",
          "args": [
            "*--dst = *--src"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLOOP",
          "args": [
            "src -= wsize"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLOOP1",
          "args": [
            "*--dst = *--src"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLOOP",
          "args": [
            "*dst++ = *src++"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLOOP",
          "args": [
            "*(word *)dst = *(word *)src"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TLOOP1",
          "args": [
            "*dst++ = *src++"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <strings.h>\n#include <string.h>\n#include <krb5/config.h>\n#include <krb5/osconf.h>\n\n#define\twmask\t(wsize - 1)\n#define\twsize\tsizeof(word)\n#define MEMMOVE\n\nvoid\nbcopy(src0, dst0, length)\n#endif\n#endif\n\tvoid *dst0;\n\tconst void *src0;\n\tregister size_t length;\n{\n\tregister char *dst = dst0;\n\tregister const char *src = src0;\n\tregister size_t t;\n\n\tif (length == 0 || dst == src)\t\t/* nothing to do */\n\t\tgoto done;\n\n\t/*\n\t * Macros: loop-t-times; and loop-t-times, t>0\n\t */\n#define\tTLOOP(s) if (t) TLOOP1(s)\n#define\tTLOOP1(s) do { s; } while (--t)\n\n\tif ((unsigned long)dst < (unsigned long)src) {\n\t\t/*\n\t\t * Copy forward.\n\t\t */\n\t\tt = (int)src;\t/* only need low bits */\n\t\tif ((t | (int)dst) & wmask) {\n\t\t\t/*\n\t\t\t * Try to align operands.  This cannot be done\n\t\t\t * unless the low bits match.\n\t\t\t */\n\t\t\tif ((t ^ (int)dst) & wmask || length < wsize)\n\t\t\t\tt = length;\n\t\t\telse\n\t\t\t\tt = wsize - (t & wmask);\n\t\t\tlength -= t;\n\t\t\tTLOOP1(*dst++ = *src++);\n\t\t}\n\t\t/*\n\t\t * Copy whole words, then mop up any trailing bytes.\n\t\t */\n\t\tt = length / wsize;\n\t\tTLOOP(*(word *)dst = *(word *)src; src += wsize; dst += wsize);\n\t\tt = length & wmask;\n\t\tTLOOP(*dst++ = *src++);\n\t} else {\n\t\t/*\n\t\t * Copy backwards.  Otherwise essentially the same.\n\t\t * Alignment works as before, except that it takes\n\t\t * (t&wmask) bytes to align, not wsize-(t&wmask).\n\t\t */\n\t\tsrc += length;\n\t\tdst += length;\n\t\tt = (int)src;\n\t\tif ((t | (int)dst) & wmask) {\n\t\t\tif ((t ^ (int)dst) & wmask || length <= wsize)\n\t\t\t\tt = length;\n\t\t\telse\n\t\t\t\tt &= wmask;\n\t\t\tlength -= t;\n\t\t\tTLOOP1(*--dst = *--src);\n\t\t}\n\t\tt = length / wsize;\n\t\tTLOOP(src -= wsize; dst -= wsize; *(word *)dst = *(word *)src);\n\t\tt = length & wmask;\n\t\tTLOOP(*--dst = *--src);\n\t}\ndone:\n#if defined(MEMCOPY) || defined(MEMMOVE)\n\treturn (dst0);\n#else\n\treturn;\n#endif\n}"
  }
]