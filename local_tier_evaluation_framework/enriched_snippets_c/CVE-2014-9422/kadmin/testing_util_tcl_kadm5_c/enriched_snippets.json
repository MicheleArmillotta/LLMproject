[
  {
    "function_name": "Tcl_kadm5_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "2494-2549",
    "snippet": "void Tcl_kadm5_init(Tcl_Interp *interp)\n{\n    char buf[20];\n\n     Tcl_SetVar(interp, \"KADM5_ADMIN_SERVICE\",\n\t\tKADM5_ADMIN_SERVICE, TCL_GLOBAL_ONLY);\n     Tcl_SetVar(interp, \"KADM5_CHANGEPW_SERVICE\",\n\t\tKADM5_CHANGEPW_SERVICE, TCL_GLOBAL_ONLY);\n    (void) sprintf(buf, \"%d\", KADM5_STRUCT_VERSION);\n     Tcl_SetVar(interp, \"KADM5_STRUCT_VERSION\", buf, TCL_GLOBAL_ONLY);\n    (void) sprintf(buf, \"%d\", KADM5_API_VERSION_1);\n     Tcl_SetVar(interp, \"KADM5_API_VERSION_1\", buf, TCL_GLOBAL_ONLY);\n    (void) sprintf(buf, \"%d\", KADM5_API_VERSION_2);\n     Tcl_SetVar(interp, \"KADM5_API_VERSION_2\", buf, TCL_GLOBAL_ONLY);\n    (void) sprintf(buf, \"%d\", KADM5_API_VERSION_MASK);\n     Tcl_SetVar(interp, \"KADM5_API_VERSION_MASK\", buf, TCL_GLOBAL_ONLY);\n    (void) sprintf(buf, \"%d\", KADM5_STRUCT_VERSION_MASK);\n     Tcl_SetVar(interp, \"KADM5_STRUCT_VERSION_MASK\", buf,\n\t\tTCL_GLOBAL_ONLY);\n\n     Tcl_CreateCommand(interp, \"kadm5_init\", tcl_kadm5_init, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_init_with_creds\",\n\t\t       tcl_kadm5_init_with_creds, 0, 0); \n     Tcl_CreateCommand(interp, \"kadm5_destroy\", tcl_kadm5_destroy, 0,\n\t\t       0);\n     Tcl_CreateCommand(interp, \"kadm5_create_principal\",\n\t\t       tcl_kadm5_create_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_delete_principal\",\n\t\t       tcl_kadm5_delete_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_modify_principal\",\n\t\t       tcl_kadm5_modify_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_rename_principal\",\n\t\t       tcl_kadm5_rename_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_chpass_principal\",\n\t\t       tcl_kadm5_chpass_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_chpass_principal_util\",\n\t\t       tcl_kadm5_chpass_principal_util, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_randkey_principal\",\n\t\t       tcl_kadm5_randkey_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_get_principal\",\n\t\t       tcl_kadm5_get_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_create_policy\",\n\t\t       tcl_kadm5_create_policy, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_delete_policy\",\n\t\t       tcl_kadm5_delete_policy, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_modify_policy\",\n\t\t       tcl_kadm5_modify_policy, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_get_policy\",\n\t\t       tcl_kadm5_get_policy, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_free_principal_ent\",\n\t\t       tcl_kadm5_free_principal_ent, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_free_policy_ent\",\n\t\t       tcl_kadm5_free_policy_ent, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_get_privs\",\n\t\t       tcl_kadm5_get_privs, 0, 0);\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_get_privs\"",
            "tcl_kadm5_get_privs",
            "0",
            "0"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_free_policy_ent\"",
            "tcl_kadm5_free_policy_ent",
            "0",
            "0"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_free_principal_ent\"",
            "tcl_kadm5_free_principal_ent",
            "0",
            "0"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_get_policy\"",
            "tcl_kadm5_get_policy",
            "0",
            "0"
          ],
          "line": 2541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_modify_policy\"",
            "tcl_kadm5_modify_policy",
            "0",
            "0"
          ],
          "line": 2539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_delete_policy\"",
            "tcl_kadm5_delete_policy",
            "0",
            "0"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_create_policy\"",
            "tcl_kadm5_create_policy",
            "0",
            "0"
          ],
          "line": 2535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_get_principal\"",
            "tcl_kadm5_get_principal",
            "0",
            "0"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_randkey_principal\"",
            "tcl_kadm5_randkey_principal",
            "0",
            "0"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_chpass_principal_util\"",
            "tcl_kadm5_chpass_principal_util",
            "0",
            "0"
          ],
          "line": 2529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_chpass_principal\"",
            "tcl_kadm5_chpass_principal",
            "0",
            "0"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_rename_principal\"",
            "tcl_kadm5_rename_principal",
            "0",
            "0"
          ],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_modify_principal\"",
            "tcl_kadm5_modify_principal",
            "0",
            "0"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_delete_principal\"",
            "tcl_kadm5_delete_principal",
            "0",
            "0"
          ],
          "line": 2521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_create_principal\"",
            "tcl_kadm5_create_principal",
            "0",
            "0"
          ],
          "line": 2519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_destroy\"",
            "tcl_kadm5_destroy",
            "0",
            "0"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_init_with_creds\"",
            "tcl_kadm5_init_with_creds",
            "0",
            "0"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateCommand",
          "args": [
            "interp",
            "\"kadm5_init\"",
            "tcl_kadm5_init",
            "0",
            "0"
          ],
          "line": 2514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "\"KADM5_STRUCT_VERSION_MASK\"",
            "buf",
            "TCL_GLOBAL_ONLY"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "KADM5_STRUCT_VERSION_MASK"
          ],
          "line": 2510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "\"KADM5_API_VERSION_MASK\"",
            "buf",
            "TCL_GLOBAL_ONLY"
          ],
          "line": 2509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "KADM5_API_VERSION_MASK"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "\"KADM5_API_VERSION_2\"",
            "buf",
            "TCL_GLOBAL_ONLY"
          ],
          "line": 2507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "KADM5_API_VERSION_2"
          ],
          "line": 2506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "\"KADM5_API_VERSION_1\"",
            "buf",
            "TCL_GLOBAL_ONLY"
          ],
          "line": 2505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "KADM5_API_VERSION_1"
          ],
          "line": 2504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "\"KADM5_STRUCT_VERSION\"",
            "buf",
            "TCL_GLOBAL_ONLY"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "KADM5_STRUCT_VERSION"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "\"KADM5_CHANGEPW_SERVICE\"",
            "KADM5_CHANGEPW_SERVICE",
            "TCL_GLOBAL_ONLY"
          ],
          "line": 2500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "\"KADM5_ADMIN_SERVICE\"",
            "KADM5_ADMIN_SERVICE",
            "TCL_GLOBAL_ONLY"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nvoid Tcl_kadm5_init(Tcl_Interp *interp)\n{\n    char buf[20];\n\n     Tcl_SetVar(interp, \"KADM5_ADMIN_SERVICE\",\n\t\tKADM5_ADMIN_SERVICE, TCL_GLOBAL_ONLY);\n     Tcl_SetVar(interp, \"KADM5_CHANGEPW_SERVICE\",\n\t\tKADM5_CHANGEPW_SERVICE, TCL_GLOBAL_ONLY);\n    (void) sprintf(buf, \"%d\", KADM5_STRUCT_VERSION);\n     Tcl_SetVar(interp, \"KADM5_STRUCT_VERSION\", buf, TCL_GLOBAL_ONLY);\n    (void) sprintf(buf, \"%d\", KADM5_API_VERSION_1);\n     Tcl_SetVar(interp, \"KADM5_API_VERSION_1\", buf, TCL_GLOBAL_ONLY);\n    (void) sprintf(buf, \"%d\", KADM5_API_VERSION_2);\n     Tcl_SetVar(interp, \"KADM5_API_VERSION_2\", buf, TCL_GLOBAL_ONLY);\n    (void) sprintf(buf, \"%d\", KADM5_API_VERSION_MASK);\n     Tcl_SetVar(interp, \"KADM5_API_VERSION_MASK\", buf, TCL_GLOBAL_ONLY);\n    (void) sprintf(buf, \"%d\", KADM5_STRUCT_VERSION_MASK);\n     Tcl_SetVar(interp, \"KADM5_STRUCT_VERSION_MASK\", buf,\n\t\tTCL_GLOBAL_ONLY);\n\n     Tcl_CreateCommand(interp, \"kadm5_init\", tcl_kadm5_init, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_init_with_creds\",\n\t\t       tcl_kadm5_init_with_creds, 0, 0); \n     Tcl_CreateCommand(interp, \"kadm5_destroy\", tcl_kadm5_destroy, 0,\n\t\t       0);\n     Tcl_CreateCommand(interp, \"kadm5_create_principal\",\n\t\t       tcl_kadm5_create_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_delete_principal\",\n\t\t       tcl_kadm5_delete_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_modify_principal\",\n\t\t       tcl_kadm5_modify_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_rename_principal\",\n\t\t       tcl_kadm5_rename_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_chpass_principal\",\n\t\t       tcl_kadm5_chpass_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_chpass_principal_util\",\n\t\t       tcl_kadm5_chpass_principal_util, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_randkey_principal\",\n\t\t       tcl_kadm5_randkey_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_get_principal\",\n\t\t       tcl_kadm5_get_principal, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_create_policy\",\n\t\t       tcl_kadm5_create_policy, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_delete_policy\",\n\t\t       tcl_kadm5_delete_policy, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_modify_policy\",\n\t\t       tcl_kadm5_modify_policy, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_get_policy\",\n\t\t       tcl_kadm5_get_policy, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_free_principal_ent\",\n\t\t       tcl_kadm5_free_principal_ent, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_free_policy_ent\",\n\t\t       tcl_kadm5_free_policy_ent, 0, 0);\n     Tcl_CreateCommand(interp, \"kadm5_get_privs\",\n\t\t       tcl_kadm5_get_privs, 0, 0);\n}"
  },
  {
    "function_name": "tcl_kadm5_get_privs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "2455-2491",
    "snippet": "static int tcl_kadm5_get_privs(ClientData clientData, Tcl_Interp *interp,\n\t\t\t       int argc, char *argv[])\n{\n     char *set_ret;\n     kadm5_ret_t ret;\n     char *priv_var;\n     long privs;\n\n     GET_HANDLE(1, 0);\n\n     if (parse_str(interp, argv[0], &priv_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing privs variable name\");\n\t  return TCL_ERROR;\n     }\n\n     ret = kadm5_get_privs(server_handle, priv_var ? &privs : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (priv_var) {\n\t       Tcl_DString *str = unparse_privs(privs);\n\t       set_ret = Tcl_SetVar(interp, priv_var, str->string,\n\t\t\t\t    TCL_LEAVE_ERR_MSG);\n\t       Tcl_DStringFree(str);\n\t       free(str);\n\t       if (! set_ret) {\n\t\t    Tcl_AppendElement(interp, \"while setting priv variable\");\n\t\t    return TCL_ERROR;\n\t       }\n\t  }\n\t  set_ok(interp, \"Privileges retrieved.\");\n\t  return TCL_OK;\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 2488
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Privileges retrieved.\""
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while setting priv variable\""
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 2478
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "str"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "priv_var",
            "str->string",
            "TCL_LEAVE_ERR_MSG"
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_privs",
          "args": [
            "privs"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_privs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "577-581",
          "snippet": "static Tcl_DString *unparse_privs(krb5_flags flags)\n{\n     return unparse_flags(priv_flags, sizeof(priv_flags) /\n\t\t\t  sizeof(struct flagval), flags);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval priv_flags[] = {\n     {\"KADM5_PRIV_GET\", KADM5_PRIV_GET},\n     {\"KADM5_PRIV_ADD\", KADM5_PRIV_ADD},\n     {\"KADM5_PRIV_MODIFY\", KADM5_PRIV_MODIFY},\n     {\"KADM5_PRIV_DELETE\", KADM5_PRIV_DELETE}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval priv_flags[] = {\n     {\"KADM5_PRIV_GET\", KADM5_PRIV_GET},\n     {\"KADM5_PRIV_ADD\", KADM5_PRIV_ADD},\n     {\"KADM5_PRIV_MODIFY\", KADM5_PRIV_MODIFY},\n     {\"KADM5_PRIV_DELETE\", KADM5_PRIV_DELETE}\n};\n\nstatic Tcl_DString *unparse_privs(krb5_flags flags)\n{\n     return unparse_flags(priv_flags, sizeof(priv_flags) /\n\t\t\t  sizeof(struct flagval), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_get_privs",
          "args": [
            "server_handle",
            "priv_var ? &privs : 0"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing privs variable name\""
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[0]",
            "&priv_var"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "1",
            "0"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int tcl_kadm5_get_privs(ClientData clientData, Tcl_Interp *interp,\n\t\t\t       int argc, char *argv[])\n{\n     char *set_ret;\n     kadm5_ret_t ret;\n     char *priv_var;\n     long privs;\n\n     GET_HANDLE(1, 0);\n\n     if (parse_str(interp, argv[0], &priv_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing privs variable name\");\n\t  return TCL_ERROR;\n     }\n\n     ret = kadm5_get_privs(server_handle, priv_var ? &privs : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (priv_var) {\n\t       Tcl_DString *str = unparse_privs(privs);\n\t       set_ret = Tcl_SetVar(interp, priv_var, str->string,\n\t\t\t\t    TCL_LEAVE_ERR_MSG);\n\t       Tcl_DStringFree(str);\n\t       free(str);\n\t       if (! set_ret) {\n\t\t    Tcl_AppendElement(interp, \"while setting priv variable\");\n\t\t    return TCL_ERROR;\n\t       }\n\t  }\n\t  set_ok(interp, \"Privileges retrieved.\");\n\t  return TCL_OK;\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n}"
  },
  {
    "function_name": "tcl_kadm5_free_policy_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "2400-2452",
    "snippet": "static int tcl_kadm5_free_policy_ent(ClientData clientData,\n\t\t\t\t     Tcl_Interp *interp,\n\t\t\t\t     int argc, char *argv[])\n{\n     char *ent_name;\n     kadm5_policy_ent_t ent;\n     kadm5_ret_t ret;\n\n     GET_HANDLE(1, 0);\n\n     if (parse_str(interp, argv[0], &ent_name) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing entry name\");\n\t  return TCL_ERROR;\n     }\n\n     if ((! ent_name) &&\n\t (ret = kadm5_free_policy_ent(server_handle, 0))) {\n\t stash_error(interp, ret);\n\t return TCL_ERROR;\n     }\n     else {\n\t  Tcl_HashEntry *entry;\n\n\t  if (strncmp(ent_name, \"policy\", sizeof(\"policy\")-1)) {\n\t       Tcl_AppendResult(interp, \"invalid principal handle \\\"\",\n\t\t\t\tent_name, \"\\\"\", 0);\n\t       return TCL_ERROR;\n\t  }\n\t  if (! struct_table) {\n\t       if (! (struct_table = malloc(sizeof(*struct_table)))) {\n\t\t    fprintf(stderr, \"Out of memory!\\n\");\n\t\t    exit(1); /* XXX */\n\t       }\n\t       Tcl_InitHashTable(struct_table, TCL_STRING_KEYS);\n\t  }\n\t  \n\t  if (! (entry = Tcl_FindHashEntry(struct_table, ent_name))) {\n\t       Tcl_AppendResult(interp, \"policy handle \\\"\", ent_name,\n\t\t\t\t\"\\\" not found\", 0);\n\t       return TCL_ERROR;\n\t  }\n\n\t  ent = (kadm5_policy_ent_t) Tcl_GetHashValue(entry);\n\n\t  if ((ret = kadm5_free_policy_ent(server_handle, ent)) != KADM5_OK) {\n\t      stash_error(interp, ret);\n\t      return TCL_ERROR;\n\t  }\n\t  Tcl_DeleteHashEntry(entry);\n     }\n     set_ok(interp, \"Policy freed.\");\n     return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static Tcl_HashTable *struct_table = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Policy freed.\""
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DeleteHashEntry",
          "args": [
            "entry"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_free_policy_ent",
          "args": [
            "server_handle",
            "ent"
          ],
          "line": 2444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetHashValue",
          "args": [
            "entry"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendResult",
          "args": [
            "interp",
            "\"policy handle \\\"\"",
            "ent_name",
            "\"\\\" not found\"",
            "0"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_FindHashEntry",
          "args": [
            "struct_table",
            "ent_name"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_InitHashTable",
          "args": [
            "struct_table",
            "TCL_STRING_KEYS"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 2430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*struct_table)"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendResult",
          "args": [
            "interp",
            "\"invalid principal handle \\\"\"",
            "ent_name",
            "\"\\\"\"",
            "0"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ent_name",
            "\"policy\"",
            "sizeof(\"policy\")-1"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_free_policy_ent",
          "args": [
            "server_handle",
            "0"
          ],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing entry name\""
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[0]",
            "&ent_name"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "1",
            "0"
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_HashTable *struct_table = 0;\n\nstatic int tcl_kadm5_free_policy_ent(ClientData clientData,\n\t\t\t\t     Tcl_Interp *interp,\n\t\t\t\t     int argc, char *argv[])\n{\n     char *ent_name;\n     kadm5_policy_ent_t ent;\n     kadm5_ret_t ret;\n\n     GET_HANDLE(1, 0);\n\n     if (parse_str(interp, argv[0], &ent_name) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing entry name\");\n\t  return TCL_ERROR;\n     }\n\n     if ((! ent_name) &&\n\t (ret = kadm5_free_policy_ent(server_handle, 0))) {\n\t stash_error(interp, ret);\n\t return TCL_ERROR;\n     }\n     else {\n\t  Tcl_HashEntry *entry;\n\n\t  if (strncmp(ent_name, \"policy\", sizeof(\"policy\")-1)) {\n\t       Tcl_AppendResult(interp, \"invalid principal handle \\\"\",\n\t\t\t\tent_name, \"\\\"\", 0);\n\t       return TCL_ERROR;\n\t  }\n\t  if (! struct_table) {\n\t       if (! (struct_table = malloc(sizeof(*struct_table)))) {\n\t\t    fprintf(stderr, \"Out of memory!\\n\");\n\t\t    exit(1); /* XXX */\n\t       }\n\t       Tcl_InitHashTable(struct_table, TCL_STRING_KEYS);\n\t  }\n\t  \n\t  if (! (entry = Tcl_FindHashEntry(struct_table, ent_name))) {\n\t       Tcl_AppendResult(interp, \"policy handle \\\"\", ent_name,\n\t\t\t\t\"\\\" not found\", 0);\n\t       return TCL_ERROR;\n\t  }\n\n\t  ent = (kadm5_policy_ent_t) Tcl_GetHashValue(entry);\n\n\t  if ((ret = kadm5_free_policy_ent(server_handle, ent)) != KADM5_OK) {\n\t      stash_error(interp, ret);\n\t      return TCL_ERROR;\n\t  }\n\t  Tcl_DeleteHashEntry(entry);\n     }\n     set_ok(interp, \"Policy freed.\");\n     return TCL_OK;\n}"
  },
  {
    "function_name": "tcl_kadm5_free_principal_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "2344-2397",
    "snippet": "static int tcl_kadm5_free_principal_ent(ClientData clientData,\n\t\t\t\t\tTcl_Interp *interp,\n\t\t\t\t\tint argc, char *argv[])\n{\n     char *ent_name;\n     kadm5_principal_ent_t ent;\n     kadm5_ret_t ret;\n\n     GET_HANDLE(1, 0);\n\n     if (parse_str(interp, argv[0], &ent_name) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing entry name\");\n\t  return TCL_ERROR;\n     }\n\n     if ((! ent_name) &&\n\t (ret = kadm5_free_principal_ent(server_handle, 0))) {\n\t stash_error(interp, ret);\n\t return TCL_ERROR;\n     }\n     else {\n\t  Tcl_HashEntry *entry;\n\n\t  if (strncmp(ent_name, \"principal\", sizeof(\"principal\")-1)) {\n\t       Tcl_AppendResult(interp, \"invalid principal handle \\\"\",\n\t\t\t\tent_name, \"\\\"\", 0);\n\t       return TCL_ERROR;\n\t  }\n\t  if (! struct_table) {\n\t       if (! (struct_table = malloc(sizeof(*struct_table)))) {\n\t\t    fprintf(stderr, \"Out of memory!\\n\");\n\t\t    exit(1); /* XXX */\n\t       }\n\t       Tcl_InitHashTable(struct_table, TCL_STRING_KEYS);\n\t  }\n\t  \n\t  if (! (entry = Tcl_FindHashEntry(struct_table, ent_name))) {\n\t       Tcl_AppendResult(interp, \"principal handle \\\"\", ent_name,\n\t\t\t\t\"\\\" not found\", 0);\n\t       return TCL_ERROR;\n\t  }\n\n\t  ent = (kadm5_principal_ent_t) Tcl_GetHashValue(entry);\n\n\t  ret = kadm5_free_principal_ent(server_handle, ent);\n\t  if (ret != KADM5_OK) {\n\t      stash_error(interp, ret);\n\t      return TCL_ERROR;\n\t  }\n\t  Tcl_DeleteHashEntry(entry);\n     }\n     set_ok(interp, \"Principal freed.\");\n     return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static Tcl_HashTable *struct_table = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Principal freed.\""
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DeleteHashEntry",
          "args": [
            "entry"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_free_principal_ent",
          "args": [
            "server_handle",
            "ent"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetHashValue",
          "args": [
            "entry"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendResult",
          "args": [
            "interp",
            "\"principal handle \\\"\"",
            "ent_name",
            "\"\\\" not found\"",
            "0"
          ],
          "line": 2381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_FindHashEntry",
          "args": [
            "struct_table",
            "ent_name"
          ],
          "line": 2380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_InitHashTable",
          "args": [
            "struct_table",
            "TCL_STRING_KEYS"
          ],
          "line": 2377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2375
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*struct_table)"
          ],
          "line": 2373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendResult",
          "args": [
            "interp",
            "\"invalid principal handle \\\"\"",
            "ent_name",
            "\"\\\"\"",
            "0"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "ent_name",
            "\"principal\"",
            "sizeof(\"principal\")-1"
          ],
          "line": 2367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_free_principal_ent",
          "args": [
            "server_handle",
            "0"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing entry name\""
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[0]",
            "&ent_name"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "1",
            "0"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_HashTable *struct_table = 0;\n\nstatic int tcl_kadm5_free_principal_ent(ClientData clientData,\n\t\t\t\t\tTcl_Interp *interp,\n\t\t\t\t\tint argc, char *argv[])\n{\n     char *ent_name;\n     kadm5_principal_ent_t ent;\n     kadm5_ret_t ret;\n\n     GET_HANDLE(1, 0);\n\n     if (parse_str(interp, argv[0], &ent_name) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing entry name\");\n\t  return TCL_ERROR;\n     }\n\n     if ((! ent_name) &&\n\t (ret = kadm5_free_principal_ent(server_handle, 0))) {\n\t stash_error(interp, ret);\n\t return TCL_ERROR;\n     }\n     else {\n\t  Tcl_HashEntry *entry;\n\n\t  if (strncmp(ent_name, \"principal\", sizeof(\"principal\")-1)) {\n\t       Tcl_AppendResult(interp, \"invalid principal handle \\\"\",\n\t\t\t\tent_name, \"\\\"\", 0);\n\t       return TCL_ERROR;\n\t  }\n\t  if (! struct_table) {\n\t       if (! (struct_table = malloc(sizeof(*struct_table)))) {\n\t\t    fprintf(stderr, \"Out of memory!\\n\");\n\t\t    exit(1); /* XXX */\n\t       }\n\t       Tcl_InitHashTable(struct_table, TCL_STRING_KEYS);\n\t  }\n\t  \n\t  if (! (entry = Tcl_FindHashEntry(struct_table, ent_name))) {\n\t       Tcl_AppendResult(interp, \"principal handle \\\"\", ent_name,\n\t\t\t\t\"\\\" not found\", 0);\n\t       return TCL_ERROR;\n\t  }\n\n\t  ent = (kadm5_principal_ent_t) Tcl_GetHashValue(entry);\n\n\t  ret = kadm5_free_principal_ent(server_handle, ent);\n\t  if (ret != KADM5_OK) {\n\t      stash_error(interp, ret);\n\t      return TCL_ERROR;\n\t  }\n\t  Tcl_DeleteHashEntry(entry);\n     }\n     set_ok(interp, \"Principal freed.\");\n     return TCL_OK;\n}"
  },
  {
    "function_name": "tcl_kadm5_get_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "2286-2340",
    "snippet": "static int tcl_kadm5_get_policy(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\tint argc, char *argv[])\n{\n     kadm5_policy_ent_rec ent;\n     Tcl_DString *ent_dstring = 0;\n     char *policy;\n     char *ent_var;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(2, 1);\n\n     if (parse_str(interp, argv[0], &policy) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy name\");\n\t  return TCL_ERROR;\n     }\n     \n     if (parse_str(interp, argv[1], &ent_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing entry variable name\");\n\t  return TCL_ERROR;\n     }\n     \n     ret = kadm5_get_policy(server_handle, policy, ent_var ? &ent : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (ent_var) {\n\t       ent_dstring = unparse_policy_ent(&ent);\n\t       if (! Tcl_SetVar(interp, ent_var, ent_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting entry variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t       set_ok(interp, \"Policy retrieved.\");\n\t  }\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     if (ent_dstring) {\n\t  Tcl_DStringFree(ent_dstring);\n\t  free(ent_dstring);\n     }\n     if (ent_var && ret == KADM5_OK &&\n\t (ret = kadm5_free_policy_ent(server_handle, &ent)) &&\n\t (retcode == TCL_OK)) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_free_policy_ent",
          "args": [
            "server_handle",
            "&ent"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ent_dstring"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "ent_dstring"
          ],
          "line": 2330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Policy retrieved.\""
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while setting entry variable\""
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "ent_var",
            "ent_dstring->string",
            "TCL_LEAVE_ERR_MSG"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_policy_ent",
          "args": [
            "&ent"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1343-1379",
          "snippet": "static Tcl_DString *unparse_policy_ent(kadm5_policy_ent_t policy)\n{\n     Tcl_DString *str, *tmp_dstring;\n     char buf[20];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     tmp_dstring = unparse_str(policy->policy);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n     \n     sprintf(buf, \"%ld\", policy->pw_min_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_max_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_min_length);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_min_classes);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_history_num);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->policy_refcnt);\n     Tcl_DStringAppendElement(str, buf);\n\n     return str;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_policy_ent(kadm5_policy_ent_t policy)\n{\n     Tcl_DString *str, *tmp_dstring;\n     char buf[20];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     tmp_dstring = unparse_str(policy->policy);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n     \n     sprintf(buf, \"%ld\", policy->pw_min_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_max_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_min_length);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_min_classes);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_history_num);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->policy_refcnt);\n     Tcl_DStringAppendElement(str, buf);\n\n     return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_get_policy",
          "args": [
            "server_handle",
            "policy",
            "ent_var ? &ent : 0"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "kadm5_get_policy_v1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/server_glue_v1.c",
          "lines": "28-32",
          "snippet": "kadm5_ret_t kadm5_get_policy_v1(void *server_handle, kadm5_policy_t name,\n\t\t\t\tkadm5_policy_ent_t *ent)\n{\n     return kadm5_get_policy(server_handle, name, ent);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include <kadm5/admin.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include <kadm5/admin.h>\n\nkadm5_ret_t kadm5_get_policy_v1(void *server_handle, kadm5_policy_t name,\n\t\t\t\tkadm5_policy_ent_t *ent)\n{\n     return kadm5_get_policy(server_handle, name, ent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing entry variable name\""
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[1]",
            "&ent_var"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing policy name\""
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "2",
            "1"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int tcl_kadm5_get_policy(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\tint argc, char *argv[])\n{\n     kadm5_policy_ent_rec ent;\n     Tcl_DString *ent_dstring = 0;\n     char *policy;\n     char *ent_var;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(2, 1);\n\n     if (parse_str(interp, argv[0], &policy) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy name\");\n\t  return TCL_ERROR;\n     }\n     \n     if (parse_str(interp, argv[1], &ent_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing entry variable name\");\n\t  return TCL_ERROR;\n     }\n     \n     ret = kadm5_get_policy(server_handle, policy, ent_var ? &ent : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (ent_var) {\n\t       ent_dstring = unparse_policy_ent(&ent);\n\t       if (! Tcl_SetVar(interp, ent_var, ent_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting entry variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t       set_ok(interp, \"Policy retrieved.\");\n\t  }\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     if (ent_dstring) {\n\t  Tcl_DStringFree(ent_dstring);\n\t  free(ent_dstring);\n     }\n     if (ent_var && ret == KADM5_OK &&\n\t (ret = kadm5_free_policy_ent(server_handle, &ent)) &&\n\t (retcode == TCL_OK)) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n     return retcode;\n}"
  },
  {
    "function_name": "tcl_kadm5_modify_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "2240-2283",
    "snippet": "static int tcl_kadm5_modify_policy(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t   int argc, char *argv[])\n{\n     char *policy_string;\n     kadm5_policy_ent_t policy = 0;\n     int tcl_ret;\n     krb5_int32 mask;\n     int retcode = TCL_OK;\n     kadm5_ret_t ret;\n\n     GET_HANDLE(2, 0);\n\n     if ((tcl_ret = parse_str(interp, argv[0], &policy_string)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy\");\n\t  return tcl_ret;\n     }\n\n     if (policy_string &&\n\t ((tcl_ret = parse_policy_ent(interp, policy_string, &policy))\n\t  != TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     if ((tcl_ret = parse_policy_mask(interp, argv[1], &mask)) != TCL_OK) {\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_modify_policy(server_handle, policy, mask);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n     else {\n\t  set_ok(interp, \"Policy modified.\");\n     }\n\nfinished:\n     if (policy) {\n\t  free_policy_ent(&policy);\n     }\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_policy_ent",
          "args": [
            "&policy"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Policy modified.\""
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_modify_policy",
          "args": [
            "server_handle",
            "policy",
            "mask"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_policy_mask",
          "args": [
            "interp",
            "argv[1]",
            "&mask"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "parse_policy_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "648-663",
          "snippet": "static int parse_policy_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, policy_mask_flags,\n\t\t\t\tsizeof(policy_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval policy_mask_flags[] = {\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_PW_MAX_LIFE\", KADM5_PW_MAX_LIFE},\n     {\"KADM5_PW_MIN_LIFE\", KADM5_PW_MIN_LIFE},\n     {\"KADM5_PW_MIN_LENGTH\", KADM5_PW_MIN_LENGTH},\n     {\"KADM5_PW_MIN_CLASSES\", KADM5_PW_MIN_CLASSES},\n     {\"KADM5_PW_HISTORY_NUM\", KADM5_PW_HISTORY_NUM},\n     {\"KADM5_REF_COUNT\", KADM5_REF_COUNT}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval policy_mask_flags[] = {\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_PW_MAX_LIFE\", KADM5_PW_MAX_LIFE},\n     {\"KADM5_PW_MIN_LIFE\", KADM5_PW_MIN_LIFE},\n     {\"KADM5_PW_MIN_LENGTH\", KADM5_PW_MIN_LENGTH},\n     {\"KADM5_PW_MIN_CLASSES\", KADM5_PW_MIN_CLASSES},\n     {\"KADM5_PW_HISTORY_NUM\", KADM5_PW_HISTORY_NUM},\n     {\"KADM5_REF_COUNT\", KADM5_REF_COUNT}\n};\n\nstatic int parse_policy_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, policy_mask_flags,\n\t\t\t\tsizeof(policy_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_policy_ent",
          "args": [
            "interp",
            "policy_string",
            "&policy"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "parse_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1383-1481",
          "snippet": "static int parse_policy_ent(Tcl_Interp *interp, char *list,\n\t\t\t    kadm5_policy_ent_t *out_policy)\n{\n     kadm5_policy_ent_t policy;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 7) {\n\t  sprintf(interp->result, \"wrong # args in policy structure (%d should be 7)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (policy = malloc(sizeof *policy))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n  \n     if ((tcl_ret = parse_str(interp, argv[0], &policy->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if(policy->policy != NULL) {\n\tif (! (policy->policy = strdup(policy->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1); /* XXX */\n\t}\n     }\n     \n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_life = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_max_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_length\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_length = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_classes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_classes = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[5], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_history_num\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_history_num = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy_refcnt\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->policy_refcnt = tmp;\n\nfinished:\n     free(argv);\n     *out_policy = policy;\n     return retcode;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_policy_ent(Tcl_Interp *interp, char *list,\n\t\t\t    kadm5_policy_ent_t *out_policy)\n{\n     kadm5_policy_ent_t policy;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 7) {\n\t  sprintf(interp->result, \"wrong # args in policy structure (%d should be 7)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (policy = malloc(sizeof *policy))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n  \n     if ((tcl_ret = parse_str(interp, argv[0], &policy->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if(policy->policy != NULL) {\n\tif (! (policy->policy = strdup(policy->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1); /* XXX */\n\t}\n     }\n     \n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_life = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_max_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_length\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_length = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_classes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_classes = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[5], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_history_num\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_history_num = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy_refcnt\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->policy_refcnt = tmp;\n\nfinished:\n     free(argv);\n     *out_policy = policy;\n     return retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing policy\""
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[0]",
            "&policy_string"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "2",
            "0"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int tcl_kadm5_modify_policy(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t   int argc, char *argv[])\n{\n     char *policy_string;\n     kadm5_policy_ent_t policy = 0;\n     int tcl_ret;\n     krb5_int32 mask;\n     int retcode = TCL_OK;\n     kadm5_ret_t ret;\n\n     GET_HANDLE(2, 0);\n\n     if ((tcl_ret = parse_str(interp, argv[0], &policy_string)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy\");\n\t  return tcl_ret;\n     }\n\n     if (policy_string &&\n\t ((tcl_ret = parse_policy_ent(interp, policy_string, &policy))\n\t  != TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     if ((tcl_ret = parse_policy_mask(interp, argv[1], &mask)) != TCL_OK) {\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_modify_policy(server_handle, policy, mask);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n     else {\n\t  set_ok(interp, \"Policy modified.\");\n     }\n\nfinished:\n     if (policy) {\n\t  free_policy_ent(&policy);\n     }\n     return retcode;\n}"
  },
  {
    "function_name": "tcl_kadm5_delete_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "2213-2236",
    "snippet": "static int tcl_kadm5_delete_policy(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t   int argc, char *argv[])\n{\n     kadm5_ret_t ret;\n     char *policy;\n\n     GET_HANDLE(1, 0);\n\n     if (parse_str(interp, argv[0], &policy) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy name\");\n\t  return TCL_ERROR;\n     }\n     \n     ret = kadm5_delete_policy(server_handle, policy);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n     else {\n\t  set_ok(interp, \"Policy deleted.\");\n\t  return TCL_OK;\n     }\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Policy deleted.\""
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_delete_policy",
          "args": [
            "server_handle",
            "policy"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing policy name\""
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[0]",
            "&policy"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "1",
            "0"
          ],
          "line": 2219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int tcl_kadm5_delete_policy(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t   int argc, char *argv[])\n{\n     kadm5_ret_t ret;\n     char *policy;\n\n     GET_HANDLE(1, 0);\n\n     if (parse_str(interp, argv[0], &policy) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy name\");\n\t  return TCL_ERROR;\n     }\n     \n     ret = kadm5_delete_policy(server_handle, policy);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n     else {\n\t  set_ok(interp, \"Policy deleted.\");\n\t  return TCL_OK;\n     }\n}"
  },
  {
    "function_name": "tcl_kadm5_create_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "2165-2209",
    "snippet": "static int tcl_kadm5_create_policy(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t   int argc, char *argv[])\n{\n     int tcl_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n     char *policy_string;\n     kadm5_policy_ent_t policy = 0;\n     krb5_int32 mask;\n\n     GET_HANDLE(2, 0);\n\n     if ((tcl_ret = parse_str(interp, argv[0], &policy_string)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy\");\n\t  return tcl_ret;\n     }\n\n     if (policy_string &&\n\t ((tcl_ret = parse_policy_ent(interp, policy_string, &policy))\n\t  != TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     if ((tcl_ret = parse_policy_mask(interp, argv[1], &mask)) != TCL_OK) {\n\t  retcode = tcl_ret;\n\t  goto finished;\n     }\n\n     ret = kadm5_create_policy(server_handle, policy, mask);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     else {\n\t  set_ok(interp, \"Policy created.\");\n     }\n\nfinished:\n     if (policy) {\n\t  free_policy_ent(&policy);\n     }\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_policy_ent",
          "args": [
            "&policy"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Policy created.\""
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_create_policy",
          "args": [
            "server_handle",
            "policy",
            "mask"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_policy_mask",
          "args": [
            "interp",
            "argv[1]",
            "&mask"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "parse_policy_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "648-663",
          "snippet": "static int parse_policy_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, policy_mask_flags,\n\t\t\t\tsizeof(policy_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval policy_mask_flags[] = {\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_PW_MAX_LIFE\", KADM5_PW_MAX_LIFE},\n     {\"KADM5_PW_MIN_LIFE\", KADM5_PW_MIN_LIFE},\n     {\"KADM5_PW_MIN_LENGTH\", KADM5_PW_MIN_LENGTH},\n     {\"KADM5_PW_MIN_CLASSES\", KADM5_PW_MIN_CLASSES},\n     {\"KADM5_PW_HISTORY_NUM\", KADM5_PW_HISTORY_NUM},\n     {\"KADM5_REF_COUNT\", KADM5_REF_COUNT}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval policy_mask_flags[] = {\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_PW_MAX_LIFE\", KADM5_PW_MAX_LIFE},\n     {\"KADM5_PW_MIN_LIFE\", KADM5_PW_MIN_LIFE},\n     {\"KADM5_PW_MIN_LENGTH\", KADM5_PW_MIN_LENGTH},\n     {\"KADM5_PW_MIN_CLASSES\", KADM5_PW_MIN_CLASSES},\n     {\"KADM5_PW_HISTORY_NUM\", KADM5_PW_HISTORY_NUM},\n     {\"KADM5_REF_COUNT\", KADM5_REF_COUNT}\n};\n\nstatic int parse_policy_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, policy_mask_flags,\n\t\t\t\tsizeof(policy_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_policy_ent",
          "args": [
            "interp",
            "policy_string",
            "&policy"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "parse_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1383-1481",
          "snippet": "static int parse_policy_ent(Tcl_Interp *interp, char *list,\n\t\t\t    kadm5_policy_ent_t *out_policy)\n{\n     kadm5_policy_ent_t policy;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 7) {\n\t  sprintf(interp->result, \"wrong # args in policy structure (%d should be 7)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (policy = malloc(sizeof *policy))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n  \n     if ((tcl_ret = parse_str(interp, argv[0], &policy->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if(policy->policy != NULL) {\n\tif (! (policy->policy = strdup(policy->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1); /* XXX */\n\t}\n     }\n     \n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_life = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_max_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_length\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_length = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_classes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_classes = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[5], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_history_num\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_history_num = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy_refcnt\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->policy_refcnt = tmp;\n\nfinished:\n     free(argv);\n     *out_policy = policy;\n     return retcode;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_policy_ent(Tcl_Interp *interp, char *list,\n\t\t\t    kadm5_policy_ent_t *out_policy)\n{\n     kadm5_policy_ent_t policy;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 7) {\n\t  sprintf(interp->result, \"wrong # args in policy structure (%d should be 7)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (policy = malloc(sizeof *policy))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n  \n     if ((tcl_ret = parse_str(interp, argv[0], &policy->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if(policy->policy != NULL) {\n\tif (! (policy->policy = strdup(policy->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1); /* XXX */\n\t}\n     }\n     \n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_life = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_max_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_length\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_length = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_classes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_classes = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[5], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_history_num\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_history_num = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy_refcnt\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->policy_refcnt = tmp;\n\nfinished:\n     free(argv);\n     *out_policy = policy;\n     return retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing policy\""
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[0]",
            "&policy_string"
          ],
          "line": 2177
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "2",
            "0"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int tcl_kadm5_create_policy(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t   int argc, char *argv[])\n{\n     int tcl_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n     char *policy_string;\n     kadm5_policy_ent_t policy = 0;\n     krb5_int32 mask;\n\n     GET_HANDLE(2, 0);\n\n     if ((tcl_ret = parse_str(interp, argv[0], &policy_string)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy\");\n\t  return tcl_ret;\n     }\n\n     if (policy_string &&\n\t ((tcl_ret = parse_policy_ent(interp, policy_string, &policy))\n\t  != TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     if ((tcl_ret = parse_policy_mask(interp, argv[1], &mask)) != TCL_OK) {\n\t  retcode = tcl_ret;\n\t  goto finished;\n     }\n\n     ret = kadm5_create_policy(server_handle, policy, mask);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     else {\n\t  set_ok(interp, \"Policy created.\");\n     }\n\nfinished:\n     if (policy) {\n\t  free_policy_ent(&policy);\n     }\n     return retcode;\n}"
  },
  {
    "function_name": "tcl_kadm5_get_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "2091-2163",
    "snippet": "static int tcl_kadm5_get_principal(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t   int argc, char *argv[])\n{\n     krb5_principal princ;\n     kadm5_principal_ent_rec ent;\n     Tcl_DString *ent_dstring = 0;\n     char *ent_var;\n     char *name;\n     krb5_error_code krb5_ret;\n     int tcl_ret;\n     kadm5_ret_t ret = -1;\n     krb5_int32 mask;\n     int retcode = TCL_OK;\n     \n     GET_HANDLE(3, 1);\n\n     if((tcl_ret = parse_str(interp, argv[0], &name)) != TCL_OK)\n\treturn tcl_ret;\n     if(name != NULL) {\n\tif ((krb5_ret = krb5_parse_name(context, name, &princ)) != 0) {\n\t    stash_error(interp, krb5_ret);\n\t    Tcl_AppendElement(interp, \"while parsing principal name\");\n\t    return TCL_ERROR;\n\t}\n     } else princ = NULL;\n\n     if ((tcl_ret = parse_str(interp, argv[1], &ent_var)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing entry variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((tcl_ret = parse_principal_mask(interp, argv[2], &mask)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing principal mask\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     \n     ret = kadm5_get_principal(server_handle, princ, ent_var ? &ent : 0,\n\t\t\t       mask);\n\n     if (ret == KADM5_OK) {\n\t  if (ent_var) {\n\t       ent_dstring = unparse_principal_ent(&ent, mask);\n\t       if (! Tcl_SetVar(interp, ent_var, ent_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting entry variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t       set_ok(interp, \"Principal retrieved.\");\n\t  }\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     if (ent_dstring) {\n\t  Tcl_DStringFree(ent_dstring);\n\t  free(ent_dstring);\n     }\n     if(princ != NULL)\n\tkrb5_free_principal(context, princ);\n     if (ret == KADM5_OK && ent_var &&\n\t (ret = kadm5_free_principal_ent(server_handle, &ent)) &&\n\t (retcode == TCL_OK)) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_context context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 2159
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_free_principal_ent",
          "args": [
            "server_handle",
            "&ent"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "princ"
          ],
          "line": 2155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "ent_dstring"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "ent_dstring"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Principal retrieved.\""
          ],
          "line": 2141
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while setting entry variable\""
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "ent_var",
            "ent_dstring->string",
            "TCL_LEAVE_ERR_MSG"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_principal_ent",
          "args": [
            "&ent",
            "mask"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_principal_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "666-785",
          "snippet": "static Tcl_DString *unparse_principal_ent(kadm5_principal_ent_t princ,\n\t\t\t\t\t  krb5_int32 mask)\n{\n     Tcl_DString *str, *tmp_dstring;\n     char *tmp;\n     char buf[20];\n     krb5_error_code krb5_ret;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     tmp = 0; /* It looks to me from looking at the library source */\n\t      /* code for krb5_parse_name that the pointer passed into */\n\t      /* it should be initialized to 0 if I want it do be */\n\t      /* allocated automatically. */\n     if (mask & KADM5_PRINCIPAL) {\n          krb5_ret = krb5_unparse_name(context, princ->principal, &tmp);\n\t  if (krb5_ret) {\n\t       /* XXX Do we want to return an error?  Not sure. */\n\t       Tcl_DStringAppendElement(str, \"[unparseable principal]\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, tmp);\n\t       free(tmp);\n\t  }\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->princ_expire_time);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_pwd_change);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->pw_expiration);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->max_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     tmp = 0;\n     if (mask & KADM5_MOD_NAME) {\n\t  if ((krb5_ret = krb5_unparse_name(context, princ->mod_name, &tmp))) {\n\t       /* XXX */\n\t       Tcl_DStringAppendElement(str, \"[unparseable principal]\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, tmp);\n\t       free(tmp);\n\t  }\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->mod_date);\n     Tcl_DStringAppendElement(str, buf);\n\n     if (mask & KADM5_ATTRIBUTES) {\n\t  tmp_dstring = unparse_krb5_flags(princ->attributes);\n\t  Tcl_DStringAppendElement(str, tmp_dstring->string);\n\t  Tcl_DStringFree(tmp_dstring);\n\t  free(tmp_dstring);\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->kvno);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->mkvno);\n     Tcl_DStringAppendElement(str, buf);\n\n     /* XXX This may be dangerous, because the contents of the policy */\n     /* field are undefined if the POLICY bit isn't set.  However, I */\n     /* think it's a bug for the field not to be null in that case */\n     /* anyway, so we should assume that it will be null so that we'll */\n     /* catch it if it isn't. */\n     \n     tmp_dstring = unparse_str(princ->policy);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     tmp_dstring = unparse_aux_attributes(princ->aux_attributes);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     sprintf(buf, \"%d\", princ->max_renewable_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_success);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_failed);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->fail_auth_count);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->n_key_data);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->n_tl_data);\n     Tcl_DStringAppendElement(str, buf);\n\n     tmp_dstring = unparse_key_data(princ->key_data, princ->n_key_data);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     tmp_dstring = unparse_tl_data(princ->tl_data, princ->n_tl_data);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n     \n     return str;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_context context;",
            "static struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\nstatic struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};\n\nstatic Tcl_DString *unparse_principal_ent(kadm5_principal_ent_t princ,\n\t\t\t\t\t  krb5_int32 mask)\n{\n     Tcl_DString *str, *tmp_dstring;\n     char *tmp;\n     char buf[20];\n     krb5_error_code krb5_ret;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     tmp = 0; /* It looks to me from looking at the library source */\n\t      /* code for krb5_parse_name that the pointer passed into */\n\t      /* it should be initialized to 0 if I want it do be */\n\t      /* allocated automatically. */\n     if (mask & KADM5_PRINCIPAL) {\n          krb5_ret = krb5_unparse_name(context, princ->principal, &tmp);\n\t  if (krb5_ret) {\n\t       /* XXX Do we want to return an error?  Not sure. */\n\t       Tcl_DStringAppendElement(str, \"[unparseable principal]\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, tmp);\n\t       free(tmp);\n\t  }\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->princ_expire_time);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_pwd_change);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->pw_expiration);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->max_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     tmp = 0;\n     if (mask & KADM5_MOD_NAME) {\n\t  if ((krb5_ret = krb5_unparse_name(context, princ->mod_name, &tmp))) {\n\t       /* XXX */\n\t       Tcl_DStringAppendElement(str, \"[unparseable principal]\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, tmp);\n\t       free(tmp);\n\t  }\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->mod_date);\n     Tcl_DStringAppendElement(str, buf);\n\n     if (mask & KADM5_ATTRIBUTES) {\n\t  tmp_dstring = unparse_krb5_flags(princ->attributes);\n\t  Tcl_DStringAppendElement(str, tmp_dstring->string);\n\t  Tcl_DStringFree(tmp_dstring);\n\t  free(tmp_dstring);\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->kvno);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->mkvno);\n     Tcl_DStringAppendElement(str, buf);\n\n     /* XXX This may be dangerous, because the contents of the policy */\n     /* field are undefined if the POLICY bit isn't set.  However, I */\n     /* think it's a bug for the field not to be null in that case */\n     /* anyway, so we should assume that it will be null so that we'll */\n     /* catch it if it isn't. */\n     \n     tmp_dstring = unparse_str(princ->policy);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     tmp_dstring = unparse_aux_attributes(princ->aux_attributes);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     sprintf(buf, \"%d\", princ->max_renewable_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_success);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_failed);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->fail_auth_count);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->n_key_data);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->n_tl_data);\n     Tcl_DStringAppendElement(str, buf);\n\n     tmp_dstring = unparse_key_data(princ->key_data, princ->n_key_data);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     tmp_dstring = unparse_tl_data(princ->tl_data, princ->n_tl_data);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n     \n     return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_get_principal",
          "args": [
            "server_handle",
            "princ",
            "ent_var ? &ent : 0",
            "mask"
          ],
          "line": 2128
        },
        "resolved": true,
        "details": {
          "function_name": "tcl_kadm5_get_principal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "2091-2163",
          "snippet": "static int tcl_kadm5_get_principal(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t   int argc, char *argv[])\n{\n     krb5_principal princ;\n     kadm5_principal_ent_rec ent;\n     Tcl_DString *ent_dstring = 0;\n     char *ent_var;\n     char *name;\n     krb5_error_code krb5_ret;\n     int tcl_ret;\n     kadm5_ret_t ret = -1;\n     krb5_int32 mask;\n     int retcode = TCL_OK;\n     \n     GET_HANDLE(3, 1);\n\n     if((tcl_ret = parse_str(interp, argv[0], &name)) != TCL_OK)\n\treturn tcl_ret;\n     if(name != NULL) {\n\tif ((krb5_ret = krb5_parse_name(context, name, &princ)) != 0) {\n\t    stash_error(interp, krb5_ret);\n\t    Tcl_AppendElement(interp, \"while parsing principal name\");\n\t    return TCL_ERROR;\n\t}\n     } else princ = NULL;\n\n     if ((tcl_ret = parse_str(interp, argv[1], &ent_var)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing entry variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((tcl_ret = parse_principal_mask(interp, argv[2], &mask)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing principal mask\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     \n     ret = kadm5_get_principal(server_handle, princ, ent_var ? &ent : 0,\n\t\t\t       mask);\n\n     if (ret == KADM5_OK) {\n\t  if (ent_var) {\n\t       ent_dstring = unparse_principal_ent(&ent, mask);\n\t       if (! Tcl_SetVar(interp, ent_var, ent_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting entry variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t       set_ok(interp, \"Principal retrieved.\");\n\t  }\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     if (ent_dstring) {\n\t  Tcl_DStringFree(ent_dstring);\n\t  free(ent_dstring);\n     }\n     if(princ != NULL)\n\tkrb5_free_principal(context, princ);\n     if (ret == KADM5_OK && ent_var &&\n\t (ret = kadm5_free_principal_ent(server_handle, &ent)) &&\n\t (retcode == TCL_OK)) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n     return retcode;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing principal mask\""
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_principal_mask",
          "args": [
            "interp",
            "argv[2]",
            "&mask"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "parse_principal_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "631-646",
          "snippet": "static int parse_principal_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, principal_mask_flags,\n\t\t\t\tsizeof(principal_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval principal_mask_flags[] = {\n     {\"KADM5_PRINCIPAL\", KADM5_PRINCIPAL},\n     {\"KADM5_PRINC_EXPIRE_TIME\", KADM5_PRINC_EXPIRE_TIME},\n     {\"KADM5_PW_EXPIRATION\", KADM5_PW_EXPIRATION},\n     {\"KADM5_LAST_PWD_CHANGE\", KADM5_LAST_PWD_CHANGE},\n     {\"KADM5_ATTRIBUTES\", KADM5_ATTRIBUTES},\n     {\"KADM5_MAX_LIFE\", KADM5_MAX_LIFE},\n     {\"KADM5_MOD_TIME\", KADM5_MOD_TIME},\n     {\"KADM5_MOD_NAME\", KADM5_MOD_NAME},\n     {\"KADM5_KVNO\", KADM5_KVNO},\n     {\"KADM5_MKVNO\", KADM5_MKVNO},\n     {\"KADM5_AUX_ATTRIBUTES\", KADM5_AUX_ATTRIBUTES},\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_POLICY_CLR\", KADM5_POLICY_CLR},\n     {\"KADM5_MAX_RLIFE\", KADM5_MAX_RLIFE},\n     {\"KADM5_LAST_SUCCESS\", KADM5_LAST_SUCCESS},\n     {\"KADM5_LAST_FAILED\", KADM5_LAST_FAILED},\n     {\"KADM5_FAIL_AUTH_COUNT\", KADM5_FAIL_AUTH_COUNT},\n     {\"KADM5_KEY_DATA\", KADM5_KEY_DATA},\n     {\"KADM5_TL_DATA\", KADM5_TL_DATA},\n     {\"KADM5_PRINCIPAL_NORMAL_MASK\", KADM5_PRINCIPAL_NORMAL_MASK}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval principal_mask_flags[] = {\n     {\"KADM5_PRINCIPAL\", KADM5_PRINCIPAL},\n     {\"KADM5_PRINC_EXPIRE_TIME\", KADM5_PRINC_EXPIRE_TIME},\n     {\"KADM5_PW_EXPIRATION\", KADM5_PW_EXPIRATION},\n     {\"KADM5_LAST_PWD_CHANGE\", KADM5_LAST_PWD_CHANGE},\n     {\"KADM5_ATTRIBUTES\", KADM5_ATTRIBUTES},\n     {\"KADM5_MAX_LIFE\", KADM5_MAX_LIFE},\n     {\"KADM5_MOD_TIME\", KADM5_MOD_TIME},\n     {\"KADM5_MOD_NAME\", KADM5_MOD_NAME},\n     {\"KADM5_KVNO\", KADM5_KVNO},\n     {\"KADM5_MKVNO\", KADM5_MKVNO},\n     {\"KADM5_AUX_ATTRIBUTES\", KADM5_AUX_ATTRIBUTES},\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_POLICY_CLR\", KADM5_POLICY_CLR},\n     {\"KADM5_MAX_RLIFE\", KADM5_MAX_RLIFE},\n     {\"KADM5_LAST_SUCCESS\", KADM5_LAST_SUCCESS},\n     {\"KADM5_LAST_FAILED\", KADM5_LAST_FAILED},\n     {\"KADM5_FAIL_AUTH_COUNT\", KADM5_FAIL_AUTH_COUNT},\n     {\"KADM5_KEY_DATA\", KADM5_KEY_DATA},\n     {\"KADM5_TL_DATA\", KADM5_TL_DATA},\n     {\"KADM5_PRINCIPAL_NORMAL_MASK\", KADM5_PRINCIPAL_NORMAL_MASK}\n};\n\nstatic int parse_principal_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, principal_mask_flags,\n\t\t\t\tsizeof(principal_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing entry variable name\""
          ],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[1]",
            "&ent_var"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing principal name\""
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "name",
            "&princ"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "3",
            "1"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic int tcl_kadm5_get_principal(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t   int argc, char *argv[])\n{\n     krb5_principal princ;\n     kadm5_principal_ent_rec ent;\n     Tcl_DString *ent_dstring = 0;\n     char *ent_var;\n     char *name;\n     krb5_error_code krb5_ret;\n     int tcl_ret;\n     kadm5_ret_t ret = -1;\n     krb5_int32 mask;\n     int retcode = TCL_OK;\n     \n     GET_HANDLE(3, 1);\n\n     if((tcl_ret = parse_str(interp, argv[0], &name)) != TCL_OK)\n\treturn tcl_ret;\n     if(name != NULL) {\n\tif ((krb5_ret = krb5_parse_name(context, name, &princ)) != 0) {\n\t    stash_error(interp, krb5_ret);\n\t    Tcl_AppendElement(interp, \"while parsing principal name\");\n\t    return TCL_ERROR;\n\t}\n     } else princ = NULL;\n\n     if ((tcl_ret = parse_str(interp, argv[1], &ent_var)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing entry variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((tcl_ret = parse_principal_mask(interp, argv[2], &mask)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing principal mask\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     \n     ret = kadm5_get_principal(server_handle, princ, ent_var ? &ent : 0,\n\t\t\t       mask);\n\n     if (ret == KADM5_OK) {\n\t  if (ent_var) {\n\t       ent_dstring = unparse_principal_ent(&ent, mask);\n\t       if (! Tcl_SetVar(interp, ent_var, ent_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting entry variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t       set_ok(interp, \"Principal retrieved.\");\n\t  }\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     if (ent_dstring) {\n\t  Tcl_DStringFree(ent_dstring);\n\t  free(ent_dstring);\n     }\n     if(princ != NULL)\n\tkrb5_free_principal(context, princ);\n     if (ret == KADM5_OK && ent_var &&\n\t (ret = kadm5_free_principal_ent(server_handle, &ent)) &&\n\t (retcode == TCL_OK)) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n     return retcode;\n}"
  },
  {
    "function_name": "tcl_kadm5_randkey_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "2017-2087",
    "snippet": "static int tcl_kadm5_randkey_principal(ClientData clientData, \n\t\t\t\t       Tcl_Interp *interp,\n\t\t\t\t       int argc, char *argv[])\n{\n     krb5_principal princ;\n     krb5_keyblock *keyblocks;\n     int num_keys;\n     char *keyblock_var, *num_var, buf[50];\n     Tcl_DString *keyblock_dstring = 0;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(3, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal name\");\n\t  return TCL_ERROR;\n     }\n\n     if (parse_str(interp, argv[1], &keyblock_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keyblock variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if (parse_str(interp, argv[2], &num_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keyblock variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_randkey_principal(server_handle,\n\t\t\t\t   princ, keyblock_var ? &keyblocks : 0,\n\t\t\t\t   num_var ? &num_keys : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (keyblock_var) {\n\t       keyblock_dstring = unparse_keyblocks(keyblocks, num_keys);\n\t       if (! Tcl_SetVar(interp, keyblock_var,\n\t\t\t\tkeyblock_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting keyblock variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t  }\n\t  if (num_var) {\n\t       sprintf(buf, \"%d\", num_keys);\n\t       if (! Tcl_SetVar(interp, num_var, buf,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting num_keys variable\");\n\t       }\n\t  }\n\t  set_ok(interp, \"Key randomized.\");\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     krb5_free_principal(context, princ);\n     if (keyblock_dstring) {\n\t  Tcl_DStringFree(keyblock_dstring);\n\t  free(keyblock_dstring);\n     }\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_context context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keyblock_dstring"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "keyblock_dstring"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "princ"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 2076
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Key randomized.\""
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while setting num_keys variable\""
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "num_var",
            "buf",
            "TCL_LEAVE_ERR_MSG"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "num_keys"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while setting keyblock variable\""
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "keyblock_var",
            "keyblock_dstring->string",
            "TCL_LEAVE_ERR_MSG"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_keyblocks",
          "args": [
            "keyblocks",
            "num_keys"
          ],
          "line": 2055
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_keyblocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1517-1556",
          "snippet": "static Tcl_DString *unparse_keyblocks(krb5_keyblock *keyblocks, int num_keys)\n{\n     Tcl_DString *str;\n     Tcl_DString *keytype;\n     int i, j;\n     \n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (j = 0; j < num_keys; j++) {\n\t  krb5_keyblock *keyblock = &keyblocks[j];\n\t  \n\t  Tcl_DStringStartSublist(str);\n\n\t  keytype = unparse_keytype(keyblock->enctype);\n\t  Tcl_DStringAppendElement(str, keytype->string);\n\t  Tcl_DStringFree(keytype);\n\t  free(keytype);\n\t  if (keyblock->length == 0) {\n\t       Tcl_DStringAppendElement(str, \"0x00\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, \"0x\");\n\t       for (i = 0; i < keyblock->length; i++) {\n\t\t    char buf[3];\n\t\t    sprintf(buf, \"%02x\", (int) keyblock->contents[i]);\n\t\t    Tcl_DStringAppend(str, buf, -1);\n\t       }\n\t  }\n\n\t  Tcl_DStringEndSublist(str);\n     }\n     \n\n     return str;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_keyblocks(krb5_keyblock *keyblocks, int num_keys)\n{\n     Tcl_DString *str;\n     Tcl_DString *keytype;\n     int i, j;\n     \n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (j = 0; j < num_keys; j++) {\n\t  krb5_keyblock *keyblock = &keyblocks[j];\n\t  \n\t  Tcl_DStringStartSublist(str);\n\n\t  keytype = unparse_keytype(keyblock->enctype);\n\t  Tcl_DStringAppendElement(str, keytype->string);\n\t  Tcl_DStringFree(keytype);\n\t  free(keytype);\n\t  if (keyblock->length == 0) {\n\t       Tcl_DStringAppendElement(str, \"0x00\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, \"0x\");\n\t       for (i = 0; i < keyblock->length; i++) {\n\t\t    char buf[3];\n\t\t    sprintf(buf, \"%02x\", (int) keyblock->contents[i]);\n\t\t    Tcl_DStringAppend(str, buf, -1);\n\t       }\n\t  }\n\n\t  Tcl_DStringEndSublist(str);\n     }\n     \n\n     return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_randkey_principal",
          "args": [
            "server_handle",
            "princ",
            "keyblock_var ? &keyblocks : 0",
            "num_var ? &num_keys : 0"
          ],
          "line": 2049
        },
        "resolved": true,
        "details": {
          "function_name": "tcl_kadm5_randkey_principal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "2017-2087",
          "snippet": "static int tcl_kadm5_randkey_principal(ClientData clientData, \n\t\t\t\t       Tcl_Interp *interp,\n\t\t\t\t       int argc, char *argv[])\n{\n     krb5_principal princ;\n     krb5_keyblock *keyblocks;\n     int num_keys;\n     char *keyblock_var, *num_var, buf[50];\n     Tcl_DString *keyblock_dstring = 0;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(3, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal name\");\n\t  return TCL_ERROR;\n     }\n\n     if (parse_str(interp, argv[1], &keyblock_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keyblock variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if (parse_str(interp, argv[2], &num_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keyblock variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_randkey_principal(server_handle,\n\t\t\t\t   princ, keyblock_var ? &keyblocks : 0,\n\t\t\t\t   num_var ? &num_keys : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (keyblock_var) {\n\t       keyblock_dstring = unparse_keyblocks(keyblocks, num_keys);\n\t       if (! Tcl_SetVar(interp, keyblock_var,\n\t\t\t\tkeyblock_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting keyblock variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t  }\n\t  if (num_var) {\n\t       sprintf(buf, \"%d\", num_keys);\n\t       if (! Tcl_SetVar(interp, num_var, buf,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting num_keys variable\");\n\t       }\n\t  }\n\t  set_ok(interp, \"Key randomized.\");\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     krb5_free_principal(context, princ);\n     if (keyblock_dstring) {\n\t  Tcl_DStringFree(keyblock_dstring);\n\t  free(keyblock_dstring);\n     }\n     return retcode;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing keyblock variable name\""
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[2]",
            "&num_var"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing keyblock variable name\""
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing principal name\""
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "argv[0]",
            "&princ"
          ],
          "line": 2032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "3",
            "0"
          ],
          "line": 2030
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic int tcl_kadm5_randkey_principal(ClientData clientData, \n\t\t\t\t       Tcl_Interp *interp,\n\t\t\t\t       int argc, char *argv[])\n{\n     krb5_principal princ;\n     krb5_keyblock *keyblocks;\n     int num_keys;\n     char *keyblock_var, *num_var, buf[50];\n     Tcl_DString *keyblock_dstring = 0;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(3, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal name\");\n\t  return TCL_ERROR;\n     }\n\n     if (parse_str(interp, argv[1], &keyblock_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keyblock variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if (parse_str(interp, argv[2], &num_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keyblock variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_randkey_principal(server_handle,\n\t\t\t\t   princ, keyblock_var ? &keyblocks : 0,\n\t\t\t\t   num_var ? &num_keys : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (keyblock_var) {\n\t       keyblock_dstring = unparse_keyblocks(keyblocks, num_keys);\n\t       if (! Tcl_SetVar(interp, keyblock_var,\n\t\t\t\tkeyblock_dstring->string,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting keyblock variable\");\n\t\t    retcode = TCL_ERROR;\n\t\t    goto finished;\n\t       }\n\t  }\n\t  if (num_var) {\n\t       sprintf(buf, \"%d\", num_keys);\n\t       if (! Tcl_SetVar(interp, num_var, buf,\n\t\t\t\tTCL_LEAVE_ERR_MSG)) {\n\t\t    Tcl_AppendElement(interp,\n\t\t\t\t      \"while setting num_keys variable\");\n\t       }\n\t  }\n\t  set_ok(interp, \"Key randomized.\");\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     krb5_free_principal(context, princ);\n     if (keyblock_dstring) {\n\t  Tcl_DStringFree(keyblock_dstring);\n\t  free(keyblock_dstring);\n     }\n     return retcode;\n}"
  },
  {
    "function_name": "tcl_kadm5_chpass_principal_util",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1932-2013",
    "snippet": "static int tcl_kadm5_chpass_principal_util(ClientData clientData,\n\t\t\t\t\t   Tcl_Interp *interp,\n\t\t\t\t\t   int argc, char *argv[])\n{\n     krb5_principal princ;\n     char *new_pw;\n#ifdef OVERRIDE     \n     int override_qual;\n#endif     \n     char *pw_ret, *pw_ret_var;\n     char msg_ret[1024], *msg_ret_var;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(4, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal name\");\n\t  return TCL_ERROR;\n     }\n\n     if (parse_str(interp, argv[1], &new_pw) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing new password\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n#ifdef OVERRIDE\n     if (Tcl_GetBoolean(interp, argv[2], &override_qual) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing override_qual\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n#endif\n     if (parse_str(interp, argv[3], &pw_ret_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_ret variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (parse_str(interp, argv[4], &msg_ret_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing msg_ret variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_chpass_principal_util(server_handle, princ, new_pw,\n#ifdef OVERRIDE     \n\t\t\t\t\t    override_qual,\n#endif\t\t\t\t\t    \n\t\t\t\t\t    pw_ret_var ? &pw_ret : 0,\n\t\t\t\t\t    msg_ret_var ? msg_ret : 0,\n\t\t\t\t            msg_ret_var ? sizeof(msg_ret) : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (pw_ret_var &&\n\t      (! Tcl_SetVar(interp, pw_ret_var, pw_ret,\n\t\t\t    TCL_LEAVE_ERR_MSG))) {\n\t       Tcl_AppendElement(interp, \"while setting pw_ret variable\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  if (msg_ret_var &&\n\t      (! Tcl_SetVar(interp, msg_ret_var, msg_ret,\n\t\t\t    TCL_LEAVE_ERR_MSG))) {\n\t       Tcl_AppendElement(interp,\n\t\t\t\t \"while setting msg_ret variable\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  set_ok(interp, \"Password changed.\");\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     krb5_free_principal(context, princ);\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_context context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "princ"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Password changed.\""
          ],
          "line": 2003
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while setting msg_ret variable\""
          ],
          "line": 1998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "msg_ret_var",
            "msg_ret",
            "TCL_LEAVE_ERR_MSG"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while setting pw_ret variable\""
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "pw_ret_var",
            "pw_ret",
            "TCL_LEAVE_ERR_MSG"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_chpass_principal_util",
          "args": [
            "server_handle",
            "princ",
            "new_pw",
            "#ifdef OVERRIDEoverride_qual",
            "#endifpw_ret_var ? &pw_ret : 0",
            "msg_ret_var ? msg_ret : 0",
            "msg_ret_var ? sizeof(msg_ret) : 0"
          ],
          "line": 1979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing msg_ret variable name\""
          ],
          "line": 1974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[4]",
            "&msg_ret_var"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing pw_ret variable name\""
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing override_qual\""
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetBoolean",
          "args": [
            "interp",
            "argv[2]",
            "&override_qual"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing new password\""
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing principal name\""
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "argv[0]",
            "&princ"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "4",
            "0"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic int tcl_kadm5_chpass_principal_util(ClientData clientData,\n\t\t\t\t\t   Tcl_Interp *interp,\n\t\t\t\t\t   int argc, char *argv[])\n{\n     krb5_principal princ;\n     char *new_pw;\n#ifdef OVERRIDE     \n     int override_qual;\n#endif     \n     char *pw_ret, *pw_ret_var;\n     char msg_ret[1024], *msg_ret_var;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(4, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal name\");\n\t  return TCL_ERROR;\n     }\n\n     if (parse_str(interp, argv[1], &new_pw) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing new password\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n#ifdef OVERRIDE\n     if (Tcl_GetBoolean(interp, argv[2], &override_qual) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing override_qual\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n#endif\n     if (parse_str(interp, argv[3], &pw_ret_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_ret variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (parse_str(interp, argv[4], &msg_ret_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing msg_ret variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_chpass_principal_util(server_handle, princ, new_pw,\n#ifdef OVERRIDE     \n\t\t\t\t\t    override_qual,\n#endif\t\t\t\t\t    \n\t\t\t\t\t    pw_ret_var ? &pw_ret : 0,\n\t\t\t\t\t    msg_ret_var ? msg_ret : 0,\n\t\t\t\t            msg_ret_var ? sizeof(msg_ret) : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (pw_ret_var &&\n\t      (! Tcl_SetVar(interp, pw_ret_var, pw_ret,\n\t\t\t    TCL_LEAVE_ERR_MSG))) {\n\t       Tcl_AppendElement(interp, \"while setting pw_ret variable\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  if (msg_ret_var &&\n\t      (! Tcl_SetVar(interp, msg_ret_var, msg_ret,\n\t\t\t    TCL_LEAVE_ERR_MSG))) {\n\t       Tcl_AppendElement(interp,\n\t\t\t\t \"while setting msg_ret variable\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  set_ok(interp, \"Password changed.\");\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     krb5_free_principal(context, princ);\n     return retcode;\n}"
  },
  {
    "function_name": "tcl_kadm5_chpass_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1876-1928",
    "snippet": "static int tcl_kadm5_chpass_principal(ClientData clientData, \n\t\t\t\t      Tcl_Interp *interp,\n\t\t\t\t      int argc, char *argv[])\n{\n     krb5_principal princ;\n     char *pw;\n#ifdef OVERRIDE     \n     int override_qual;\n#endif     \n     krb5_error_code krb5_ret;\n     int retcode = TCL_OK;\n     kadm5_ret_t ret;\n\n     GET_HANDLE(2, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal name\");\n\t  return TCL_ERROR;\n     }\n\n     if (parse_str(interp, argv[1], &pw) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing password\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n#ifdef OVERRIDE\n     if (Tcl_GetBoolean(interp, argv[2], &override_qual) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing override_qual\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     \n     ret = kadm5_chpass_principal(server_handle,\n\t\t\t\t       princ, pw, override_qual);\n#else\n     ret = kadm5_chpass_principal(server_handle, princ, pw);\n#endif     \n\n     if (ret == KADM5_OK) {\n\t  set_ok(interp, \"Password changed.\");\n\t  goto finished;\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     krb5_free_principal(context, princ);\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_context context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "princ"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Password changed.\""
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_chpass_principal",
          "args": [
            "server_handle",
            "princ",
            "pw"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_chpass_principal",
          "args": [
            "server_handle",
            "princ",
            "pw",
            "override_qual"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "tcl_kadm5_chpass_principal_util",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1932-2013",
          "snippet": "static int tcl_kadm5_chpass_principal_util(ClientData clientData,\n\t\t\t\t\t   Tcl_Interp *interp,\n\t\t\t\t\t   int argc, char *argv[])\n{\n     krb5_principal princ;\n     char *new_pw;\n#ifdef OVERRIDE     \n     int override_qual;\n#endif     \n     char *pw_ret, *pw_ret_var;\n     char msg_ret[1024], *msg_ret_var;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(4, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal name\");\n\t  return TCL_ERROR;\n     }\n\n     if (parse_str(interp, argv[1], &new_pw) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing new password\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n#ifdef OVERRIDE\n     if (Tcl_GetBoolean(interp, argv[2], &override_qual) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing override_qual\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n#endif\n     if (parse_str(interp, argv[3], &pw_ret_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_ret variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (parse_str(interp, argv[4], &msg_ret_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing msg_ret variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_chpass_principal_util(server_handle, princ, new_pw,\n#ifdef OVERRIDE     \n\t\t\t\t\t    override_qual,\n#endif\t\t\t\t\t    \n\t\t\t\t\t    pw_ret_var ? &pw_ret : 0,\n\t\t\t\t\t    msg_ret_var ? msg_ret : 0,\n\t\t\t\t            msg_ret_var ? sizeof(msg_ret) : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (pw_ret_var &&\n\t      (! Tcl_SetVar(interp, pw_ret_var, pw_ret,\n\t\t\t    TCL_LEAVE_ERR_MSG))) {\n\t       Tcl_AppendElement(interp, \"while setting pw_ret variable\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  if (msg_ret_var &&\n\t      (! Tcl_SetVar(interp, msg_ret_var, msg_ret,\n\t\t\t    TCL_LEAVE_ERR_MSG))) {\n\t       Tcl_AppendElement(interp,\n\t\t\t\t \"while setting msg_ret variable\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  set_ok(interp, \"Password changed.\");\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     krb5_free_principal(context, princ);\n     return retcode;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_context context;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic int tcl_kadm5_chpass_principal_util(ClientData clientData,\n\t\t\t\t\t   Tcl_Interp *interp,\n\t\t\t\t\t   int argc, char *argv[])\n{\n     krb5_principal princ;\n     char *new_pw;\n#ifdef OVERRIDE     \n     int override_qual;\n#endif     \n     char *pw_ret, *pw_ret_var;\n     char msg_ret[1024], *msg_ret_var;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(4, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal name\");\n\t  return TCL_ERROR;\n     }\n\n     if (parse_str(interp, argv[1], &new_pw) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing new password\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n#ifdef OVERRIDE\n     if (Tcl_GetBoolean(interp, argv[2], &override_qual) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing override_qual\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n#endif\n     if (parse_str(interp, argv[3], &pw_ret_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_ret variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (parse_str(interp, argv[4], &msg_ret_var) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing msg_ret variable name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_chpass_principal_util(server_handle, princ, new_pw,\n#ifdef OVERRIDE     \n\t\t\t\t\t    override_qual,\n#endif\t\t\t\t\t    \n\t\t\t\t\t    pw_ret_var ? &pw_ret : 0,\n\t\t\t\t\t    msg_ret_var ? msg_ret : 0,\n\t\t\t\t            msg_ret_var ? sizeof(msg_ret) : 0);\n\n     if (ret == KADM5_OK) {\n\t  if (pw_ret_var &&\n\t      (! Tcl_SetVar(interp, pw_ret_var, pw_ret,\n\t\t\t    TCL_LEAVE_ERR_MSG))) {\n\t       Tcl_AppendElement(interp, \"while setting pw_ret variable\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  if (msg_ret_var &&\n\t      (! Tcl_SetVar(interp, msg_ret_var, msg_ret,\n\t\t\t    TCL_LEAVE_ERR_MSG))) {\n\t       Tcl_AppendElement(interp,\n\t\t\t\t \"while setting msg_ret variable\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  set_ok(interp, \"Password changed.\");\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     krb5_free_principal(context, princ);\n     return retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing override_qual\""
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetBoolean",
          "args": [
            "interp",
            "argv[2]",
            "&override_qual"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing password\""
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[1]",
            "&pw"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing principal name\""
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "argv[0]",
            "&princ"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "2",
            "0"
          ],
          "line": 1889
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic int tcl_kadm5_chpass_principal(ClientData clientData, \n\t\t\t\t      Tcl_Interp *interp,\n\t\t\t\t      int argc, char *argv[])\n{\n     krb5_principal princ;\n     char *pw;\n#ifdef OVERRIDE     \n     int override_qual;\n#endif     \n     krb5_error_code krb5_ret;\n     int retcode = TCL_OK;\n     kadm5_ret_t ret;\n\n     GET_HANDLE(2, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal name\");\n\t  return TCL_ERROR;\n     }\n\n     if (parse_str(interp, argv[1], &pw) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing password\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n#ifdef OVERRIDE\n     if (Tcl_GetBoolean(interp, argv[2], &override_qual) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing override_qual\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     \n     ret = kadm5_chpass_principal(server_handle,\n\t\t\t\t       princ, pw, override_qual);\n#else\n     ret = kadm5_chpass_principal(server_handle, princ, pw);\n#endif     \n\n     if (ret == KADM5_OK) {\n\t  set_ok(interp, \"Password changed.\");\n\t  goto finished;\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\nfinished:\n     krb5_free_principal(context, princ);\n     return retcode;\n}"
  },
  {
    "function_name": "tcl_kadm5_rename_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1835-1872",
    "snippet": "static int tcl_kadm5_rename_principal(ClientData clientData, \n\t\t\t\t      Tcl_Interp *interp,\n\t\t\t\t      int argc, char *argv[])\n{\n     krb5_principal source, target;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(2, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &source)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing source\");\n\t  return TCL_ERROR;\n     }\n\n     if ((krb5_ret = krb5_parse_name(context, argv[1], &target)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing target\");\n\t  krb5_free_principal(context, source);\n\t  return TCL_ERROR;\n     }\n\n     ret = kadm5_rename_principal(server_handle, source, target);\n\n     if (ret == KADM5_OK) {\n\t  set_ok(interp, \"Principal renamed.\");\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\n     krb5_free_principal(context, source);\n     krb5_free_principal(context, target);\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_context context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "target"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "source"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Principal renamed.\""
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_rename_principal",
          "args": [
            "server_handle",
            "source",
            "target"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "source"
          ],
          "line": 1855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing target\""
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "argv[1]",
            "&target"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing source\""
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "argv[0]",
            "&source"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "2",
            "0"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic int tcl_kadm5_rename_principal(ClientData clientData, \n\t\t\t\t      Tcl_Interp *interp,\n\t\t\t\t      int argc, char *argv[])\n{\n     krb5_principal source, target;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n\n     GET_HANDLE(2, 0);\n\n     if ((krb5_ret = krb5_parse_name(context, argv[0], &source)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing source\");\n\t  return TCL_ERROR;\n     }\n\n     if ((krb5_ret = krb5_parse_name(context, argv[1], &target)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing target\");\n\t  krb5_free_principal(context, source);\n\t  return TCL_ERROR;\n     }\n\n     ret = kadm5_rename_principal(server_handle, source, target);\n\n     if (ret == KADM5_OK) {\n\t  set_ok(interp, \"Principal renamed.\");\n     }\n     else {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n\n     krb5_free_principal(context, source);\n     krb5_free_principal(context, target);\n     return retcode;\n}"
  },
  {
    "function_name": "tcl_kadm5_modify_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1788-1832",
    "snippet": "static int tcl_kadm5_modify_principal(ClientData clientData, \n\t\t\t\t      Tcl_Interp *interp,\n\t\t\t\t      int argc, char *argv[])\n{\n     char *princ_string;\n     kadm5_principal_ent_t princ = 0;\n     int tcl_ret;\n     krb5_int32 mask;\n     int retcode = TCL_OK;\n     kadm5_ret_t ret;\n\n     GET_HANDLE(2, 0);\n\n     if ((tcl_ret = parse_str(interp, argv[0], &princ_string)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing principal\");\n\t  return tcl_ret;\n     }\n\n     if (princ_string &&\n\t ((tcl_ret = parse_principal_ent(interp, princ_string, &princ))\n\t  != TCL_OK)) {\n\t  return tcl_ret;\n     }\n     \n     if ((tcl_ret = parse_principal_mask(interp, argv[1], &mask)) != TCL_OK) {\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_modify_principal(server_handle, princ, mask);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n     else {\n\t  set_ok(interp, \"Principal modified.\");\n     }\n\nfinished:\n     if (princ) {\n\t  free_principal_ent(&princ);\n     }\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_principal_ent",
          "args": [
            "&princ"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "free_principal_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1335-1341",
          "snippet": "static void free_principal_ent(kadm5_principal_ent_t *princ)\n{\n     krb5_free_principal(context, (*princ)->principal);\n     krb5_free_principal(context, (*princ)->mod_name);\n     free(*princ);\n     *princ = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_context context;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic void free_principal_ent(kadm5_principal_ent_t *princ)\n{\n     krb5_free_principal(context, (*princ)->principal);\n     krb5_free_principal(context, (*princ)->mod_name);\n     free(*princ);\n     *princ = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Principal modified.\""
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_modify_principal",
          "args": [
            "server_handle",
            "princ",
            "mask"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_principal_mask",
          "args": [
            "interp",
            "argv[1]",
            "&mask"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "parse_principal_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "631-646",
          "snippet": "static int parse_principal_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, principal_mask_flags,\n\t\t\t\tsizeof(principal_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval principal_mask_flags[] = {\n     {\"KADM5_PRINCIPAL\", KADM5_PRINCIPAL},\n     {\"KADM5_PRINC_EXPIRE_TIME\", KADM5_PRINC_EXPIRE_TIME},\n     {\"KADM5_PW_EXPIRATION\", KADM5_PW_EXPIRATION},\n     {\"KADM5_LAST_PWD_CHANGE\", KADM5_LAST_PWD_CHANGE},\n     {\"KADM5_ATTRIBUTES\", KADM5_ATTRIBUTES},\n     {\"KADM5_MAX_LIFE\", KADM5_MAX_LIFE},\n     {\"KADM5_MOD_TIME\", KADM5_MOD_TIME},\n     {\"KADM5_MOD_NAME\", KADM5_MOD_NAME},\n     {\"KADM5_KVNO\", KADM5_KVNO},\n     {\"KADM5_MKVNO\", KADM5_MKVNO},\n     {\"KADM5_AUX_ATTRIBUTES\", KADM5_AUX_ATTRIBUTES},\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_POLICY_CLR\", KADM5_POLICY_CLR},\n     {\"KADM5_MAX_RLIFE\", KADM5_MAX_RLIFE},\n     {\"KADM5_LAST_SUCCESS\", KADM5_LAST_SUCCESS},\n     {\"KADM5_LAST_FAILED\", KADM5_LAST_FAILED},\n     {\"KADM5_FAIL_AUTH_COUNT\", KADM5_FAIL_AUTH_COUNT},\n     {\"KADM5_KEY_DATA\", KADM5_KEY_DATA},\n     {\"KADM5_TL_DATA\", KADM5_TL_DATA},\n     {\"KADM5_PRINCIPAL_NORMAL_MASK\", KADM5_PRINCIPAL_NORMAL_MASK}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval principal_mask_flags[] = {\n     {\"KADM5_PRINCIPAL\", KADM5_PRINCIPAL},\n     {\"KADM5_PRINC_EXPIRE_TIME\", KADM5_PRINC_EXPIRE_TIME},\n     {\"KADM5_PW_EXPIRATION\", KADM5_PW_EXPIRATION},\n     {\"KADM5_LAST_PWD_CHANGE\", KADM5_LAST_PWD_CHANGE},\n     {\"KADM5_ATTRIBUTES\", KADM5_ATTRIBUTES},\n     {\"KADM5_MAX_LIFE\", KADM5_MAX_LIFE},\n     {\"KADM5_MOD_TIME\", KADM5_MOD_TIME},\n     {\"KADM5_MOD_NAME\", KADM5_MOD_NAME},\n     {\"KADM5_KVNO\", KADM5_KVNO},\n     {\"KADM5_MKVNO\", KADM5_MKVNO},\n     {\"KADM5_AUX_ATTRIBUTES\", KADM5_AUX_ATTRIBUTES},\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_POLICY_CLR\", KADM5_POLICY_CLR},\n     {\"KADM5_MAX_RLIFE\", KADM5_MAX_RLIFE},\n     {\"KADM5_LAST_SUCCESS\", KADM5_LAST_SUCCESS},\n     {\"KADM5_LAST_FAILED\", KADM5_LAST_FAILED},\n     {\"KADM5_FAIL_AUTH_COUNT\", KADM5_FAIL_AUTH_COUNT},\n     {\"KADM5_KEY_DATA\", KADM5_KEY_DATA},\n     {\"KADM5_TL_DATA\", KADM5_TL_DATA},\n     {\"KADM5_PRINCIPAL_NORMAL_MASK\", KADM5_PRINCIPAL_NORMAL_MASK}\n};\n\nstatic int parse_principal_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, principal_mask_flags,\n\t\t\t\tsizeof(principal_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_principal_ent",
          "args": [
            "interp",
            "princ_string",
            "&princ"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "parse_principal_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1130-1332",
          "snippet": "static int parse_principal_ent(Tcl_Interp *interp, char *list,\n\t\t\t       kadm5_principal_ent_t *out_princ)\n{\n     kadm5_principal_ent_t princ;\n     krb5_error_code krb5_ret;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 12 && argc != 20) {\n\t  sprintf(interp->result,\n             \"wrong # args in principal structure (%d should be 12 or 20)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (princ = malloc(sizeof *princ))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n     memset(princ, 0, sizeof(*princ));\n     \n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ->principal)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing princ_expire_time\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->princ_expire_time = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_pwd_change\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_pwd_change = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_expiration\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->pw_expiration = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_life = tmp;\n\n     if ((krb5_ret = krb5_parse_name(context, argv[5], &princ->mod_name)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing mod_name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\t  \n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mod_date\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mod_date = tmp;\n\n     if ((tcl_ret = parse_krb5_flags(interp, argv[7], &princ->attributes))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[8], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing kvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->kvno = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[9], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mkvno = tmp;\n\n     if ((tcl_ret = parse_str(interp, argv[10], &princ->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if(princ->policy != NULL) {\n\tif(!(princ->policy = strdup(princ->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1);\n\t}\n     }\n\n     if ((tcl_ret = parse_aux_attributes(interp, argv[11],\n\t\t\t\t\t &princ->aux_attributes)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing aux_attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (argc == 12) goto finished;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[12], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_renewable_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_renewable_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[13], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_success\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_success = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[14], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_failed\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_failed = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[15], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing fail_auth_count\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->fail_auth_count = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[16], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_key_data = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[17], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_tl_data = tmp;\n\n     if ((tcl_ret = parse_key_data(interp, argv[18],\n\t\t\t\t   &princ->key_data,\n\t\t\t\t   princ->n_key_data)) != TCL_OK) { \n\t  Tcl_AppendElement(interp, \"while parsing key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = parse_tl_data(interp, argv[19],\n\t\t\t\t  &princ->tl_data,\n\t\t\t\t  princ->n_tl_data)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     free(argv);\n     *out_princ = princ;\n     return retcode;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_context context;",
            "static struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\nstatic struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};\n\nstatic int parse_principal_ent(Tcl_Interp *interp, char *list,\n\t\t\t       kadm5_principal_ent_t *out_princ)\n{\n     kadm5_principal_ent_t princ;\n     krb5_error_code krb5_ret;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 12 && argc != 20) {\n\t  sprintf(interp->result,\n             \"wrong # args in principal structure (%d should be 12 or 20)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (princ = malloc(sizeof *princ))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n     memset(princ, 0, sizeof(*princ));\n     \n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ->principal)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing princ_expire_time\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->princ_expire_time = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_pwd_change\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_pwd_change = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_expiration\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->pw_expiration = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_life = tmp;\n\n     if ((krb5_ret = krb5_parse_name(context, argv[5], &princ->mod_name)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing mod_name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\t  \n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mod_date\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mod_date = tmp;\n\n     if ((tcl_ret = parse_krb5_flags(interp, argv[7], &princ->attributes))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[8], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing kvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->kvno = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[9], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mkvno = tmp;\n\n     if ((tcl_ret = parse_str(interp, argv[10], &princ->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if(princ->policy != NULL) {\n\tif(!(princ->policy = strdup(princ->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1);\n\t}\n     }\n\n     if ((tcl_ret = parse_aux_attributes(interp, argv[11],\n\t\t\t\t\t &princ->aux_attributes)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing aux_attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (argc == 12) goto finished;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[12], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_renewable_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_renewable_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[13], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_success\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_success = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[14], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_failed\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_failed = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[15], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing fail_auth_count\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->fail_auth_count = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[16], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_key_data = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[17], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_tl_data = tmp;\n\n     if ((tcl_ret = parse_key_data(interp, argv[18],\n\t\t\t\t   &princ->key_data,\n\t\t\t\t   princ->n_key_data)) != TCL_OK) { \n\t  Tcl_AppendElement(interp, \"while parsing key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = parse_tl_data(interp, argv[19],\n\t\t\t\t  &princ->tl_data,\n\t\t\t\t  princ->n_tl_data)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     free(argv);\n     *out_princ = princ;\n     return retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing principal\""
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[0]",
            "&princ_string"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "2",
            "0"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int tcl_kadm5_modify_principal(ClientData clientData, \n\t\t\t\t      Tcl_Interp *interp,\n\t\t\t\t      int argc, char *argv[])\n{\n     char *princ_string;\n     kadm5_principal_ent_t princ = 0;\n     int tcl_ret;\n     krb5_int32 mask;\n     int retcode = TCL_OK;\n     kadm5_ret_t ret;\n\n     GET_HANDLE(2, 0);\n\n     if ((tcl_ret = parse_str(interp, argv[0], &princ_string)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing principal\");\n\t  return tcl_ret;\n     }\n\n     if (princ_string &&\n\t ((tcl_ret = parse_principal_ent(interp, princ_string, &princ))\n\t  != TCL_OK)) {\n\t  return tcl_ret;\n     }\n     \n     if ((tcl_ret = parse_principal_mask(interp, argv[1], &mask)) != TCL_OK) {\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     ret = kadm5_modify_principal(server_handle, princ, mask);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n     }\n     else {\n\t  set_ok(interp, \"Principal modified.\");\n     }\n\nfinished:\n     if (princ) {\n\t  free_principal_ent(&princ);\n     }\n     return retcode;\n}"
  },
  {
    "function_name": "tcl_kadm5_delete_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1750-1784",
    "snippet": "static int tcl_kadm5_delete_principal(ClientData clientData, \n\t\t\t\t      Tcl_Interp *interp,\n\t\t\t\t      int argc, char *argv[])\n{\n     krb5_principal princ;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int tcl_ret;\n     char *name;\n     \n     GET_HANDLE(1, 0);\n\n     if((tcl_ret = parse_str(interp, argv[0], &name)) != TCL_OK)\n\treturn tcl_ret;\n     if(name != NULL) {\n\tif ((krb5_ret = krb5_parse_name(context, name, &princ))) {\n\t    stash_error(interp, krb5_ret);\n\t    Tcl_AppendElement(interp, \"while parsing principal\");\n\t    return TCL_ERROR;\n\t}\n     } else princ = NULL;\n     ret = kadm5_delete_principal(server_handle, princ);\n\n     if(princ != NULL) \n\tkrb5_free_principal(context, princ);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n     else {\n\t  set_ok(interp, \"Principal deleted.\");\n\t  return TCL_OK;\n     }\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_context context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Principal deleted.\""
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 1777
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "princ"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_delete_principal",
          "args": [
            "server_handle",
            "princ"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing principal\""
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "name",
            "&princ"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[0]",
            "&name"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "1",
            "0"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic int tcl_kadm5_delete_principal(ClientData clientData, \n\t\t\t\t      Tcl_Interp *interp,\n\t\t\t\t      int argc, char *argv[])\n{\n     krb5_principal princ;\n     krb5_error_code krb5_ret;\n     kadm5_ret_t ret;\n     int tcl_ret;\n     char *name;\n     \n     GET_HANDLE(1, 0);\n\n     if((tcl_ret = parse_str(interp, argv[0], &name)) != TCL_OK)\n\treturn tcl_ret;\n     if(name != NULL) {\n\tif ((krb5_ret = krb5_parse_name(context, name, &princ))) {\n\t    stash_error(interp, krb5_ret);\n\t    Tcl_AppendElement(interp, \"while parsing principal\");\n\t    return TCL_ERROR;\n\t}\n     } else princ = NULL;\n     ret = kadm5_delete_principal(server_handle, princ);\n\n     if(princ != NULL) \n\tkrb5_free_principal(context, princ);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n     else {\n\t  set_ok(interp, \"Principal deleted.\");\n\t  return TCL_OK;\n     }\n}"
  },
  {
    "function_name": "tcl_kadm5_create_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1680-1746",
    "snippet": "static int tcl_kadm5_create_principal(ClientData clientData, \n\t\t\t\t      Tcl_Interp *interp,\n\t\t\t\t      int argc, char *argv[])\n{\n     int tcl_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n     char *princ_string;\n     kadm5_principal_ent_t princ = 0;\n     krb5_int32 mask;\n     char *pw;\n#ifdef OVERRIDE     \n     int override_qual;\n#endif     \n\n     GET_HANDLE(3, 0);\n\n     if ((tcl_ret = parse_str(interp, argv[0], &princ_string)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing principal\");\n\t  return tcl_ret;\n     }\n\n     if (princ_string &&\n\t ((tcl_ret = parse_principal_ent(interp, princ_string, &princ))\n\t  != TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     if ((tcl_ret = parse_principal_mask(interp, argv[1], &mask)) != TCL_OK) {\n\t  retcode = tcl_ret;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = parse_str(interp, argv[2], &pw)) != TCL_OK) {\n\t  retcode = tcl_ret;\n\t  goto finished;\n     }\n#ifdef OVERRIDE\n     if ((tcl_ret = Tcl_GetBoolean(interp, argv[3], &override_qual)) !=\n\t TCL_OK) {\n\t  retcode = tcl_ret;\n\t  goto finished;\n     }\n#endif     \n\n#ifdef OVERRIDE\n     ret = kadm5_create_principal(server_handle, princ, mask, pw,\n\t\t\t\t       override_qual);\n#else\n     ret = kadm5_create_principal(server_handle, princ, mask, pw);\n#endif     \n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     else {\n\t  set_ok(interp, \"Principal created.\");\n     }\n\nfinished:\n     if (princ) {\n\t  free_principal_ent(&princ);\n     }\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_principal_ent",
          "args": [
            "&princ"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "free_principal_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1335-1341",
          "snippet": "static void free_principal_ent(kadm5_principal_ent_t *princ)\n{\n     krb5_free_principal(context, (*princ)->principal);\n     krb5_free_principal(context, (*princ)->mod_name);\n     free(*princ);\n     *princ = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_context context;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic void free_principal_ent(kadm5_principal_ent_t *princ)\n{\n     krb5_free_principal(context, (*princ)->principal);\n     krb5_free_principal(context, (*princ)->mod_name);\n     free(*princ);\n     *princ = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"Principal created.\""
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_create_principal",
          "args": [
            "server_handle",
            "princ",
            "mask",
            "pw"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "tcl_kadm5_create_principal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1680-1746",
          "snippet": "static int tcl_kadm5_create_principal(ClientData clientData, \n\t\t\t\t      Tcl_Interp *interp,\n\t\t\t\t      int argc, char *argv[])\n{\n     int tcl_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n     char *princ_string;\n     kadm5_principal_ent_t princ = 0;\n     krb5_int32 mask;\n     char *pw;\n#ifdef OVERRIDE     \n     int override_qual;\n#endif     \n\n     GET_HANDLE(3, 0);\n\n     if ((tcl_ret = parse_str(interp, argv[0], &princ_string)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing principal\");\n\t  return tcl_ret;\n     }\n\n     if (princ_string &&\n\t ((tcl_ret = parse_principal_ent(interp, princ_string, &princ))\n\t  != TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     if ((tcl_ret = parse_principal_mask(interp, argv[1], &mask)) != TCL_OK) {\n\t  retcode = tcl_ret;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = parse_str(interp, argv[2], &pw)) != TCL_OK) {\n\t  retcode = tcl_ret;\n\t  goto finished;\n     }\n#ifdef OVERRIDE\n     if ((tcl_ret = Tcl_GetBoolean(interp, argv[3], &override_qual)) !=\n\t TCL_OK) {\n\t  retcode = tcl_ret;\n\t  goto finished;\n     }\n#endif     \n\n#ifdef OVERRIDE\n     ret = kadm5_create_principal(server_handle, princ, mask, pw,\n\t\t\t\t       override_qual);\n#else\n     ret = kadm5_create_principal(server_handle, princ, mask, pw);\n#endif     \n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     else {\n\t  set_ok(interp, \"Principal created.\");\n     }\n\nfinished:\n     if (princ) {\n\t  free_principal_ent(&princ);\n     }\n     return retcode;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_create_principal",
          "args": [
            "server_handle",
            "princ",
            "mask",
            "pw",
            "override_qual"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetBoolean",
          "args": [
            "interp",
            "argv[3]",
            "&override_qual"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[2]",
            "&pw"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_principal_mask",
          "args": [
            "interp",
            "argv[1]",
            "&mask"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "parse_principal_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "631-646",
          "snippet": "static int parse_principal_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, principal_mask_flags,\n\t\t\t\tsizeof(principal_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval principal_mask_flags[] = {\n     {\"KADM5_PRINCIPAL\", KADM5_PRINCIPAL},\n     {\"KADM5_PRINC_EXPIRE_TIME\", KADM5_PRINC_EXPIRE_TIME},\n     {\"KADM5_PW_EXPIRATION\", KADM5_PW_EXPIRATION},\n     {\"KADM5_LAST_PWD_CHANGE\", KADM5_LAST_PWD_CHANGE},\n     {\"KADM5_ATTRIBUTES\", KADM5_ATTRIBUTES},\n     {\"KADM5_MAX_LIFE\", KADM5_MAX_LIFE},\n     {\"KADM5_MOD_TIME\", KADM5_MOD_TIME},\n     {\"KADM5_MOD_NAME\", KADM5_MOD_NAME},\n     {\"KADM5_KVNO\", KADM5_KVNO},\n     {\"KADM5_MKVNO\", KADM5_MKVNO},\n     {\"KADM5_AUX_ATTRIBUTES\", KADM5_AUX_ATTRIBUTES},\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_POLICY_CLR\", KADM5_POLICY_CLR},\n     {\"KADM5_MAX_RLIFE\", KADM5_MAX_RLIFE},\n     {\"KADM5_LAST_SUCCESS\", KADM5_LAST_SUCCESS},\n     {\"KADM5_LAST_FAILED\", KADM5_LAST_FAILED},\n     {\"KADM5_FAIL_AUTH_COUNT\", KADM5_FAIL_AUTH_COUNT},\n     {\"KADM5_KEY_DATA\", KADM5_KEY_DATA},\n     {\"KADM5_TL_DATA\", KADM5_TL_DATA},\n     {\"KADM5_PRINCIPAL_NORMAL_MASK\", KADM5_PRINCIPAL_NORMAL_MASK}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval principal_mask_flags[] = {\n     {\"KADM5_PRINCIPAL\", KADM5_PRINCIPAL},\n     {\"KADM5_PRINC_EXPIRE_TIME\", KADM5_PRINC_EXPIRE_TIME},\n     {\"KADM5_PW_EXPIRATION\", KADM5_PW_EXPIRATION},\n     {\"KADM5_LAST_PWD_CHANGE\", KADM5_LAST_PWD_CHANGE},\n     {\"KADM5_ATTRIBUTES\", KADM5_ATTRIBUTES},\n     {\"KADM5_MAX_LIFE\", KADM5_MAX_LIFE},\n     {\"KADM5_MOD_TIME\", KADM5_MOD_TIME},\n     {\"KADM5_MOD_NAME\", KADM5_MOD_NAME},\n     {\"KADM5_KVNO\", KADM5_KVNO},\n     {\"KADM5_MKVNO\", KADM5_MKVNO},\n     {\"KADM5_AUX_ATTRIBUTES\", KADM5_AUX_ATTRIBUTES},\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_POLICY_CLR\", KADM5_POLICY_CLR},\n     {\"KADM5_MAX_RLIFE\", KADM5_MAX_RLIFE},\n     {\"KADM5_LAST_SUCCESS\", KADM5_LAST_SUCCESS},\n     {\"KADM5_LAST_FAILED\", KADM5_LAST_FAILED},\n     {\"KADM5_FAIL_AUTH_COUNT\", KADM5_FAIL_AUTH_COUNT},\n     {\"KADM5_KEY_DATA\", KADM5_KEY_DATA},\n     {\"KADM5_TL_DATA\", KADM5_TL_DATA},\n     {\"KADM5_PRINCIPAL_NORMAL_MASK\", KADM5_PRINCIPAL_NORMAL_MASK}\n};\n\nstatic int parse_principal_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, principal_mask_flags,\n\t\t\t\tsizeof(principal_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_principal_ent",
          "args": [
            "interp",
            "princ_string",
            "&princ"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "parse_principal_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1130-1332",
          "snippet": "static int parse_principal_ent(Tcl_Interp *interp, char *list,\n\t\t\t       kadm5_principal_ent_t *out_princ)\n{\n     kadm5_principal_ent_t princ;\n     krb5_error_code krb5_ret;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 12 && argc != 20) {\n\t  sprintf(interp->result,\n             \"wrong # args in principal structure (%d should be 12 or 20)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (princ = malloc(sizeof *princ))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n     memset(princ, 0, sizeof(*princ));\n     \n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ->principal)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing princ_expire_time\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->princ_expire_time = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_pwd_change\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_pwd_change = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_expiration\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->pw_expiration = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_life = tmp;\n\n     if ((krb5_ret = krb5_parse_name(context, argv[5], &princ->mod_name)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing mod_name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\t  \n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mod_date\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mod_date = tmp;\n\n     if ((tcl_ret = parse_krb5_flags(interp, argv[7], &princ->attributes))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[8], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing kvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->kvno = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[9], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mkvno = tmp;\n\n     if ((tcl_ret = parse_str(interp, argv[10], &princ->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if(princ->policy != NULL) {\n\tif(!(princ->policy = strdup(princ->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1);\n\t}\n     }\n\n     if ((tcl_ret = parse_aux_attributes(interp, argv[11],\n\t\t\t\t\t &princ->aux_attributes)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing aux_attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (argc == 12) goto finished;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[12], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_renewable_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_renewable_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[13], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_success\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_success = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[14], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_failed\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_failed = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[15], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing fail_auth_count\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->fail_auth_count = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[16], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_key_data = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[17], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_tl_data = tmp;\n\n     if ((tcl_ret = parse_key_data(interp, argv[18],\n\t\t\t\t   &princ->key_data,\n\t\t\t\t   princ->n_key_data)) != TCL_OK) { \n\t  Tcl_AppendElement(interp, \"while parsing key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = parse_tl_data(interp, argv[19],\n\t\t\t\t  &princ->tl_data,\n\t\t\t\t  princ->n_tl_data)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     free(argv);\n     *out_princ = princ;\n     return retcode;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_context context;",
            "static struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\nstatic struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};\n\nstatic int parse_principal_ent(Tcl_Interp *interp, char *list,\n\t\t\t       kadm5_principal_ent_t *out_princ)\n{\n     kadm5_principal_ent_t princ;\n     krb5_error_code krb5_ret;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 12 && argc != 20) {\n\t  sprintf(interp->result,\n             \"wrong # args in principal structure (%d should be 12 or 20)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (princ = malloc(sizeof *princ))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n     memset(princ, 0, sizeof(*princ));\n     \n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ->principal)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing princ_expire_time\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->princ_expire_time = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_pwd_change\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_pwd_change = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_expiration\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->pw_expiration = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_life = tmp;\n\n     if ((krb5_ret = krb5_parse_name(context, argv[5], &princ->mod_name)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing mod_name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\t  \n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mod_date\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mod_date = tmp;\n\n     if ((tcl_ret = parse_krb5_flags(interp, argv[7], &princ->attributes))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[8], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing kvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->kvno = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[9], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mkvno = tmp;\n\n     if ((tcl_ret = parse_str(interp, argv[10], &princ->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if(princ->policy != NULL) {\n\tif(!(princ->policy = strdup(princ->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1);\n\t}\n     }\n\n     if ((tcl_ret = parse_aux_attributes(interp, argv[11],\n\t\t\t\t\t &princ->aux_attributes)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing aux_attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (argc == 12) goto finished;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[12], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_renewable_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_renewable_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[13], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_success\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_success = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[14], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_failed\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_failed = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[15], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing fail_auth_count\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->fail_auth_count = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[16], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_key_data = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[17], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_tl_data = tmp;\n\n     if ((tcl_ret = parse_key_data(interp, argv[18],\n\t\t\t\t   &princ->key_data,\n\t\t\t\t   princ->n_key_data)) != TCL_OK) { \n\t  Tcl_AppendElement(interp, \"while parsing key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = parse_tl_data(interp, argv[19],\n\t\t\t\t  &princ->tl_data,\n\t\t\t\t  princ->n_tl_data)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     free(argv);\n     *out_princ = princ;\n     return retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing principal\""
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "3",
            "0"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int tcl_kadm5_create_principal(ClientData clientData, \n\t\t\t\t      Tcl_Interp *interp,\n\t\t\t\t      int argc, char *argv[])\n{\n     int tcl_ret;\n     kadm5_ret_t ret;\n     int retcode = TCL_OK;\n     char *princ_string;\n     kadm5_principal_ent_t princ = 0;\n     krb5_int32 mask;\n     char *pw;\n#ifdef OVERRIDE     \n     int override_qual;\n#endif     \n\n     GET_HANDLE(3, 0);\n\n     if ((tcl_ret = parse_str(interp, argv[0], &princ_string)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing principal\");\n\t  return tcl_ret;\n     }\n\n     if (princ_string &&\n\t ((tcl_ret = parse_principal_ent(interp, princ_string, &princ))\n\t  != TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     if ((tcl_ret = parse_principal_mask(interp, argv[1], &mask)) != TCL_OK) {\n\t  retcode = tcl_ret;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = parse_str(interp, argv[2], &pw)) != TCL_OK) {\n\t  retcode = tcl_ret;\n\t  goto finished;\n     }\n#ifdef OVERRIDE\n     if ((tcl_ret = Tcl_GetBoolean(interp, argv[3], &override_qual)) !=\n\t TCL_OK) {\n\t  retcode = tcl_ret;\n\t  goto finished;\n     }\n#endif     \n\n#ifdef OVERRIDE\n     ret = kadm5_create_principal(server_handle, princ, mask, pw,\n\t\t\t\t       override_qual);\n#else\n     ret = kadm5_create_principal(server_handle, princ, mask, pw);\n#endif     \n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     else {\n\t  set_ok(interp, \"Principal created.\");\n     }\n\nfinished:\n     if (princ) {\n\t  free_principal_ent(&princ);\n     }\n     return retcode;\n}"
  },
  {
    "function_name": "tcl_kadm5_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1657-1678",
    "snippet": "static int tcl_kadm5_destroy(ClientData clientData, Tcl_Interp *interp,\n\t\t\t     int argc, char *argv[])\n{\n     kadm5_ret_t ret;\n     int tcl_ret;\n\n     GET_HANDLE(0, 0);\n\n     ret = kadm5_destroy(server_handle);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n\n     if ((tcl_ret = remove_server_handle(interp, argv[-1])) != TCL_OK) {\n\t return tcl_ret;\n     }\n     \n     set_ok(interp, \"KADM5 API deinitialized.\");\n     return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"KADM5 API deinitialized.\""
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_server_handle",
          "args": [
            "interp",
            "argv[-1]"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "remove_server_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "166-178",
          "snippet": "static int remove_server_handle(Tcl_Interp *interp, char *name) \n{\n    Tcl_HashEntry *entry;\n\n    if (! (struct_table &&\n\t   (entry = Tcl_FindHashEntry(struct_table, name)))) {\n\tTcl_AppendResult(interp, \"unknown server handle \", name, 0);\n\treturn TCL_ERROR;\n    }\n\n    Tcl_SetHashValue(entry, NULL);\n    return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static Tcl_HashTable *struct_table = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_HashTable *struct_table = 0;\n\nstatic int remove_server_handle(Tcl_Interp *interp, char *name) \n{\n    Tcl_HashEntry *entry;\n\n    if (! (struct_table &&\n\t   (entry = Tcl_FindHashEntry(struct_table, name)))) {\n\tTcl_AppendResult(interp, \"unknown server handle \", name, 0);\n\treturn TCL_ERROR;\n    }\n\n    Tcl_SetHashValue(entry, NULL);\n    return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_destroy",
          "args": [
            "server_handle"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_HANDLE",
          "args": [
            "0",
            "0"
          ],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int tcl_kadm5_destroy(ClientData clientData, Tcl_Interp *interp,\n\t\t\t     int argc, char *argv[])\n{\n     kadm5_ret_t ret;\n     int tcl_ret;\n\n     GET_HANDLE(0, 0);\n\n     ret = kadm5_destroy(server_handle);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n\n     if ((tcl_ret = remove_server_handle(interp, argv[-1])) != TCL_OK) {\n\t return tcl_ret;\n     }\n     \n     set_ok(interp, \"KADM5 API deinitialized.\");\n     return TCL_OK;\n}"
  },
  {
    "function_name": "tcl_kadm5_init_with_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1651-1655",
    "snippet": "static int tcl_kadm5_init_with_creds(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t     int argc, char *argv[])\n{\n     return _tcl_kadm5_init_any(INIT_CREDS, clientData, interp, argc, argv);\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_tcl_kadm5_init_any",
          "args": [
            "INIT_CREDS",
            "clientData",
            "interp",
            "argc",
            "argv"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "_tcl_kadm5_init_any",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1560-1643",
          "snippet": "static int _tcl_kadm5_init_any(enum init_type init_type, ClientData clientData,\n\t\t\tTcl_Interp *interp, int argc, char *argv[])\n{\n     kadm5_ret_t ret;\n     char *client_name, *pass, *service_name;\n     int tcl_ret;\n     krb5_ui_4 struct_version, api_version;\n     char *handle_var;\n     void *server_handle;\n     char *handle_name, *params_str;\n     char *whoami = argv[0];\n     kadm5_config_params params;\n\n     argv++, argc--;\n\n     krb5_init_context(&context);\n\n     if (argc != 7) {\n\t  Tcl_AppendResult(interp, whoami, \": \", arg_error, 0);\n\t  return TCL_ERROR;\n     }\n\n     if (((tcl_ret = parse_str(interp, argv[0], &client_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[1], &pass)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[2], &service_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[3], &params_str)) != TCL_OK) ||\n\t ((tcl_ret = parse_config_params(interp, params_str, &params))\n\t  != TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[4], (int *) &struct_version)) !=\n\t  TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[5], (int *) &api_version)) !=\n\t  TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     handle_var = argv[6];\n\n     if (! (handle_var && *handle_var)) {\n\t Tcl_SetResult(interp, \"must specify server handle variable name\",\n\t\t       TCL_STATIC);\n\t return TCL_ERROR;\n     }\n\n     if (init_type == INIT_CREDS) {\n\t  krb5_ccache cc;\n\t  \n\t  if (pass == NULL) {\n\t       if ((ret = krb5_cc_default(context, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  } else {\n\t       if ((ret = krb5_cc_resolve(context, pass, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  }\n\n\t  ret = kadm5_init_with_creds(client_name, cc, service_name,\n\t\t\t\t      &params, struct_version,\n\t\t\t\t      api_version, &server_handle); \n\t  \n\t  (void) krb5_cc_close(context, cc);\n     } else\n\t  ret = kadm5_init(client_name, pass, service_name, &params,\n\t\t\t   struct_version, api_version, &server_handle);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n\n     if ((tcl_ret = put_server_handle(interp, server_handle, &handle_name))\n\t != TCL_OK) {\n\t return tcl_ret;\n     }\n     \n     if (! Tcl_SetVar(interp, handle_var, handle_name, TCL_LEAVE_ERR_MSG)) {\n\t return TCL_ERROR;\n     }\n     \n     set_ok(interp, \"KADM5 API initialized.\");\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_context context;",
            "static char *arg_error = \"wrong # args\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\nstatic char *arg_error = \"wrong # args\";\n\nstatic int _tcl_kadm5_init_any(enum init_type init_type, ClientData clientData,\n\t\t\tTcl_Interp *interp, int argc, char *argv[])\n{\n     kadm5_ret_t ret;\n     char *client_name, *pass, *service_name;\n     int tcl_ret;\n     krb5_ui_4 struct_version, api_version;\n     char *handle_var;\n     void *server_handle;\n     char *handle_name, *params_str;\n     char *whoami = argv[0];\n     kadm5_config_params params;\n\n     argv++, argc--;\n\n     krb5_init_context(&context);\n\n     if (argc != 7) {\n\t  Tcl_AppendResult(interp, whoami, \": \", arg_error, 0);\n\t  return TCL_ERROR;\n     }\n\n     if (((tcl_ret = parse_str(interp, argv[0], &client_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[1], &pass)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[2], &service_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[3], &params_str)) != TCL_OK) ||\n\t ((tcl_ret = parse_config_params(interp, params_str, &params))\n\t  != TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[4], (int *) &struct_version)) !=\n\t  TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[5], (int *) &api_version)) !=\n\t  TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     handle_var = argv[6];\n\n     if (! (handle_var && *handle_var)) {\n\t Tcl_SetResult(interp, \"must specify server handle variable name\",\n\t\t       TCL_STATIC);\n\t return TCL_ERROR;\n     }\n\n     if (init_type == INIT_CREDS) {\n\t  krb5_ccache cc;\n\t  \n\t  if (pass == NULL) {\n\t       if ((ret = krb5_cc_default(context, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  } else {\n\t       if ((ret = krb5_cc_resolve(context, pass, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  }\n\n\t  ret = kadm5_init_with_creds(client_name, cc, service_name,\n\t\t\t\t      &params, struct_version,\n\t\t\t\t      api_version, &server_handle); \n\t  \n\t  (void) krb5_cc_close(context, cc);\n     } else\n\t  ret = kadm5_init(client_name, pass, service_name, &params,\n\t\t\t   struct_version, api_version, &server_handle);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n\n     if ((tcl_ret = put_server_handle(interp, server_handle, &handle_name))\n\t != TCL_OK) {\n\t return tcl_ret;\n     }\n     \n     if (! Tcl_SetVar(interp, handle_var, handle_name, TCL_LEAVE_ERR_MSG)) {\n\t return TCL_ERROR;\n     }\n     \n     set_ok(interp, \"KADM5 API initialized.\");\n     return TCL_OK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int tcl_kadm5_init_with_creds(ClientData clientData, Tcl_Interp *interp,\n\t\t\t\t     int argc, char *argv[])\n{\n     return _tcl_kadm5_init_any(INIT_CREDS, clientData, interp, argc, argv);\n}"
  },
  {
    "function_name": "tcl_kadm5_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1645-1649",
    "snippet": "static int tcl_kadm5_init(ClientData clientData, Tcl_Interp *interp,\n\t\t\t  int argc, char *argv[])\n{\n     return _tcl_kadm5_init_any(INIT_PASS, clientData, interp, argc, argv);\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_tcl_kadm5_init_any",
          "args": [
            "INIT_PASS",
            "clientData",
            "interp",
            "argc",
            "argv"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "_tcl_kadm5_init_any",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1560-1643",
          "snippet": "static int _tcl_kadm5_init_any(enum init_type init_type, ClientData clientData,\n\t\t\tTcl_Interp *interp, int argc, char *argv[])\n{\n     kadm5_ret_t ret;\n     char *client_name, *pass, *service_name;\n     int tcl_ret;\n     krb5_ui_4 struct_version, api_version;\n     char *handle_var;\n     void *server_handle;\n     char *handle_name, *params_str;\n     char *whoami = argv[0];\n     kadm5_config_params params;\n\n     argv++, argc--;\n\n     krb5_init_context(&context);\n\n     if (argc != 7) {\n\t  Tcl_AppendResult(interp, whoami, \": \", arg_error, 0);\n\t  return TCL_ERROR;\n     }\n\n     if (((tcl_ret = parse_str(interp, argv[0], &client_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[1], &pass)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[2], &service_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[3], &params_str)) != TCL_OK) ||\n\t ((tcl_ret = parse_config_params(interp, params_str, &params))\n\t  != TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[4], (int *) &struct_version)) !=\n\t  TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[5], (int *) &api_version)) !=\n\t  TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     handle_var = argv[6];\n\n     if (! (handle_var && *handle_var)) {\n\t Tcl_SetResult(interp, \"must specify server handle variable name\",\n\t\t       TCL_STATIC);\n\t return TCL_ERROR;\n     }\n\n     if (init_type == INIT_CREDS) {\n\t  krb5_ccache cc;\n\t  \n\t  if (pass == NULL) {\n\t       if ((ret = krb5_cc_default(context, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  } else {\n\t       if ((ret = krb5_cc_resolve(context, pass, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  }\n\n\t  ret = kadm5_init_with_creds(client_name, cc, service_name,\n\t\t\t\t      &params, struct_version,\n\t\t\t\t      api_version, &server_handle); \n\t  \n\t  (void) krb5_cc_close(context, cc);\n     } else\n\t  ret = kadm5_init(client_name, pass, service_name, &params,\n\t\t\t   struct_version, api_version, &server_handle);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n\n     if ((tcl_ret = put_server_handle(interp, server_handle, &handle_name))\n\t != TCL_OK) {\n\t return tcl_ret;\n     }\n     \n     if (! Tcl_SetVar(interp, handle_var, handle_name, TCL_LEAVE_ERR_MSG)) {\n\t return TCL_ERROR;\n     }\n     \n     set_ok(interp, \"KADM5 API initialized.\");\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static krb5_context context;",
            "static char *arg_error = \"wrong # args\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\nstatic char *arg_error = \"wrong # args\";\n\nstatic int _tcl_kadm5_init_any(enum init_type init_type, ClientData clientData,\n\t\t\tTcl_Interp *interp, int argc, char *argv[])\n{\n     kadm5_ret_t ret;\n     char *client_name, *pass, *service_name;\n     int tcl_ret;\n     krb5_ui_4 struct_version, api_version;\n     char *handle_var;\n     void *server_handle;\n     char *handle_name, *params_str;\n     char *whoami = argv[0];\n     kadm5_config_params params;\n\n     argv++, argc--;\n\n     krb5_init_context(&context);\n\n     if (argc != 7) {\n\t  Tcl_AppendResult(interp, whoami, \": \", arg_error, 0);\n\t  return TCL_ERROR;\n     }\n\n     if (((tcl_ret = parse_str(interp, argv[0], &client_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[1], &pass)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[2], &service_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[3], &params_str)) != TCL_OK) ||\n\t ((tcl_ret = parse_config_params(interp, params_str, &params))\n\t  != TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[4], (int *) &struct_version)) !=\n\t  TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[5], (int *) &api_version)) !=\n\t  TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     handle_var = argv[6];\n\n     if (! (handle_var && *handle_var)) {\n\t Tcl_SetResult(interp, \"must specify server handle variable name\",\n\t\t       TCL_STATIC);\n\t return TCL_ERROR;\n     }\n\n     if (init_type == INIT_CREDS) {\n\t  krb5_ccache cc;\n\t  \n\t  if (pass == NULL) {\n\t       if ((ret = krb5_cc_default(context, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  } else {\n\t       if ((ret = krb5_cc_resolve(context, pass, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  }\n\n\t  ret = kadm5_init_with_creds(client_name, cc, service_name,\n\t\t\t\t      &params, struct_version,\n\t\t\t\t      api_version, &server_handle); \n\t  \n\t  (void) krb5_cc_close(context, cc);\n     } else\n\t  ret = kadm5_init(client_name, pass, service_name, &params,\n\t\t\t   struct_version, api_version, &server_handle);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n\n     if ((tcl_ret = put_server_handle(interp, server_handle, &handle_name))\n\t != TCL_OK) {\n\t return tcl_ret;\n     }\n     \n     if (! Tcl_SetVar(interp, handle_var, handle_name, TCL_LEAVE_ERR_MSG)) {\n\t return TCL_ERROR;\n     }\n     \n     set_ok(interp, \"KADM5 API initialized.\");\n     return TCL_OK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int tcl_kadm5_init(ClientData clientData, Tcl_Interp *interp,\n\t\t\t  int argc, char *argv[])\n{\n     return _tcl_kadm5_init_any(INIT_PASS, clientData, interp, argc, argv);\n}"
  },
  {
    "function_name": "_tcl_kadm5_init_any",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1560-1643",
    "snippet": "static int _tcl_kadm5_init_any(enum init_type init_type, ClientData clientData,\n\t\t\tTcl_Interp *interp, int argc, char *argv[])\n{\n     kadm5_ret_t ret;\n     char *client_name, *pass, *service_name;\n     int tcl_ret;\n     krb5_ui_4 struct_version, api_version;\n     char *handle_var;\n     void *server_handle;\n     char *handle_name, *params_str;\n     char *whoami = argv[0];\n     kadm5_config_params params;\n\n     argv++, argc--;\n\n     krb5_init_context(&context);\n\n     if (argc != 7) {\n\t  Tcl_AppendResult(interp, whoami, \": \", arg_error, 0);\n\t  return TCL_ERROR;\n     }\n\n     if (((tcl_ret = parse_str(interp, argv[0], &client_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[1], &pass)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[2], &service_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[3], &params_str)) != TCL_OK) ||\n\t ((tcl_ret = parse_config_params(interp, params_str, &params))\n\t  != TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[4], (int *) &struct_version)) !=\n\t  TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[5], (int *) &api_version)) !=\n\t  TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     handle_var = argv[6];\n\n     if (! (handle_var && *handle_var)) {\n\t Tcl_SetResult(interp, \"must specify server handle variable name\",\n\t\t       TCL_STATIC);\n\t return TCL_ERROR;\n     }\n\n     if (init_type == INIT_CREDS) {\n\t  krb5_ccache cc;\n\t  \n\t  if (pass == NULL) {\n\t       if ((ret = krb5_cc_default(context, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  } else {\n\t       if ((ret = krb5_cc_resolve(context, pass, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  }\n\n\t  ret = kadm5_init_with_creds(client_name, cc, service_name,\n\t\t\t\t      &params, struct_version,\n\t\t\t\t      api_version, &server_handle); \n\t  \n\t  (void) krb5_cc_close(context, cc);\n     } else\n\t  ret = kadm5_init(client_name, pass, service_name, &params,\n\t\t\t   struct_version, api_version, &server_handle);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n\n     if ((tcl_ret = put_server_handle(interp, server_handle, &handle_name))\n\t != TCL_OK) {\n\t return tcl_ret;\n     }\n     \n     if (! Tcl_SetVar(interp, handle_var, handle_name, TCL_LEAVE_ERR_MSG)) {\n\t return TCL_ERROR;\n     }\n     \n     set_ok(interp, \"KADM5 API initialized.\");\n     return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_context context;",
      "static char *arg_error = \"wrong # args\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_ok",
          "args": [
            "interp",
            "\"KADM5 API initialized.\""
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "set_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "263-268",
          "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_SetVar",
          "args": [
            "interp",
            "handle_var",
            "handle_name",
            "TCL_LEAVE_ERR_MSG"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_server_handle",
          "args": [
            "interp",
            "server_handle",
            "&handle_name"
          ],
          "line": 1632
        },
        "resolved": true,
        "details": {
          "function_name": "put_server_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "110-143",
          "snippet": "static int put_server_handle(Tcl_Interp *interp, void *handle, char **name)\n{\n    int i = 1, newPtr = 0;\n    static char buf[20];\n    Tcl_HashEntry *entry;\n\n    if (! struct_table) {\n\tif (! (struct_table =\n\t       malloc(sizeof(*struct_table)))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1); /* XXX */\n\t}\n\tTcl_InitHashTable(struct_table, TCL_STRING_KEYS);\n    }\n\n    do {\n\t/*\n\t * Handles from ovsec_kadm_init() and kadm5_init() should not\n\t * be mixed during unit tests, but the API would happily\n\t * accept them.  Making the hash entry names different in\n\t * tcl_kadm.c and tcl_ovsec_kadm.c ensures that GET_HANDLE\n\t * will fail if presented a handle from the other API.\n\t */\n\tsprintf(buf, \"kadm5_handle%d\", i);\n\tentry = Tcl_CreateHashEntry(struct_table, buf, &newPtr);\n\ti++;\n    } while (! newPtr);\n\n    Tcl_SetHashValue(entry, handle);\n\n    *name = buf;\n\n    return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static Tcl_HashTable *struct_table = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_HashTable *struct_table = 0;\n\nstatic int put_server_handle(Tcl_Interp *interp, void *handle, char **name)\n{\n    int i = 1, newPtr = 0;\n    static char buf[20];\n    Tcl_HashEntry *entry;\n\n    if (! struct_table) {\n\tif (! (struct_table =\n\t       malloc(sizeof(*struct_table)))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1); /* XXX */\n\t}\n\tTcl_InitHashTable(struct_table, TCL_STRING_KEYS);\n    }\n\n    do {\n\t/*\n\t * Handles from ovsec_kadm_init() and kadm5_init() should not\n\t * be mixed during unit tests, but the API would happily\n\t * accept them.  Making the hash entry names different in\n\t * tcl_kadm.c and tcl_ovsec_kadm.c ensures that GET_HANDLE\n\t * will fail if presented a handle from the other API.\n\t */\n\tsprintf(buf, \"kadm5_handle%d\", i);\n\tentry = Tcl_CreateHashEntry(struct_table, buf, &newPtr);\n\ti++;\n    } while (! newPtr);\n\n    Tcl_SetHashValue(entry, handle);\n\n    *name = buf;\n\n    return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "ret"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kadm5_init",
          "args": [
            "client_name",
            "pass",
            "service_name",
            "&params",
            "struct_version",
            "api_version",
            "&server_handle"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_close",
          "args": [
            "context",
            "cc"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_init_with_creds",
          "args": [
            "client_name",
            "cc",
            "service_name",
            "&params",
            "struct_version",
            "api_version",
            "&server_handle"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_resolve",
          "args": [
            "context",
            "pass",
            "&cc"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_cc_default",
          "args": [
            "context",
            "&cc"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetResult",
          "args": [
            "interp",
            "\"must specify server handle variable name\"",
            "TCL_STATIC"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[5]",
            "(int *) &api_version"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[4]",
            "(int *) &struct_version"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_config_params",
          "args": [
            "interp",
            "params_str",
            "&params"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "parse_config_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "976-1128",
          "snippet": "static int parse_config_params(Tcl_Interp *interp, char *list,\n\t\t\t       kadm5_config_params *params)\n{\n     static Tcl_HashTable *table = 0;\n     char **argv = NULL;\n     int tmp, argc, retcode;\n\n     memset(params, 0, sizeof(kadm5_config_params));\n     if (list == NULL)\n\t  return TCL_OK;\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n\n     if (argc != 21) {\n\t  sprintf(interp->result,\n\t\t  \"wrong # args in config params structure (%d should be 21)\", \n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((retcode = parse_flags(interp, table, config_mask_flags,\n\t\t\t\tsizeof(config_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\targv[0], &tmp)) != TCL_OK) {\n\t  goto finished;\n     }\n     params->mask = tmp;\n\n     if ((retcode = parse_str(interp, argv[1], &params->realm)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing realm name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[2], &params->profile)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing kadmind_port\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->kadmind_port = tmp;\n     if ((retcode = parse_str(interp, argv[4], &params->admin_server))\n\t != TCL_OK) { \n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[5], &params->dbname)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[6], &params->admin_dbname)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_dbname name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[7], &params->admin_lockfile)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_lockfile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[8], &params->admin_keytab)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_keytab name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[9], &params->acl_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing acl_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[10], &params->dict_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing dict_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[11], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkey_from_kbd\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->mkey_from_kbd = tmp;\n     if ((retcode = parse_str(interp, argv[12], &params->stash_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing stash_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[13], &params->mkey_name)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkey_name name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[14], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing enctype\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->enctype = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[15], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->max_life = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[16], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_rlife\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->max_rlife = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[17], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing expiration\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->expiration = tmp;\n     if ((retcode = parse_krb5_flags(interp, argv[18], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing flags\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->flags = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[19], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing num_keysalts\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->num_keysalts = tmp;\n     if ((retcode = parse_keysalts(interp, argv[20], &params->keysalts,\n\t\t\t\t   params->num_keysalts)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keysalts\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     return retcode;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval config_mask_flags[] = {\n     {\"KADM5_CONFIG_REALM\", KADM5_CONFIG_REALM},\n     {\"KADM5_CONFIG_DBNAME\", KADM5_CONFIG_DBNAME},\n     {\"KADM5_CONFIG_MKEY_NAME\", KADM5_CONFIG_MKEY_NAME},\n     {\"KADM5_CONFIG_MAX_LIFE\", KADM5_CONFIG_MAX_LIFE},\n     {\"KADM5_CONFIG_MAX_RLIFE\", KADM5_CONFIG_MAX_RLIFE},\n     {\"KADM5_CONFIG_EXPIRATION\", KADM5_CONFIG_EXPIRATION},\n     {\"KADM5_CONFIG_FLAGS\", KADM5_CONFIG_FLAGS},\n     {\"KADM5_CONFIG_ADMIN_KEYTAB\", KADM5_CONFIG_ADMIN_KEYTAB},\n     {\"KADM5_CONFIG_STASH_FILE\", KADM5_CONFIG_STASH_FILE},\n     {\"KADM5_CONFIG_ENCTYPE\", KADM5_CONFIG_ENCTYPE},\n     {\"KADM5_CONFIG_ADBNAME\", KADM5_CONFIG_ADBNAME},\n     {\"KADM5_CONFIG_ADB_LOCKFILE\", KADM5_CONFIG_ADB_LOCKFILE},\n     {\"KADM5_CONFIG_PROFILE\", KADM5_CONFIG_PROFILE},\n     {\"KADM5_CONFIG_ACL_FILE\", KADM5_CONFIG_ACL_FILE},\n     {\"KADM5_CONFIG_KADMIND_PORT\", KADM5_CONFIG_KADMIND_PORT},\n     {\"KADM5_CONFIG_ENCTYPES\", KADM5_CONFIG_ENCTYPES},\n     {\"KADM5_CONFIG_ADMIN_SERVER\", KADM5_CONFIG_ADMIN_SERVER},\n     {\"KADM5_CONFIG_DICT_FILE\", KADM5_CONFIG_DICT_FILE},\n     {\"KADM5_CONFIG_MKEY_FROM_KBD\", KADM5_CONFIG_MKEY_FROM_KBD},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval config_mask_flags[] = {\n     {\"KADM5_CONFIG_REALM\", KADM5_CONFIG_REALM},\n     {\"KADM5_CONFIG_DBNAME\", KADM5_CONFIG_DBNAME},\n     {\"KADM5_CONFIG_MKEY_NAME\", KADM5_CONFIG_MKEY_NAME},\n     {\"KADM5_CONFIG_MAX_LIFE\", KADM5_CONFIG_MAX_LIFE},\n     {\"KADM5_CONFIG_MAX_RLIFE\", KADM5_CONFIG_MAX_RLIFE},\n     {\"KADM5_CONFIG_EXPIRATION\", KADM5_CONFIG_EXPIRATION},\n     {\"KADM5_CONFIG_FLAGS\", KADM5_CONFIG_FLAGS},\n     {\"KADM5_CONFIG_ADMIN_KEYTAB\", KADM5_CONFIG_ADMIN_KEYTAB},\n     {\"KADM5_CONFIG_STASH_FILE\", KADM5_CONFIG_STASH_FILE},\n     {\"KADM5_CONFIG_ENCTYPE\", KADM5_CONFIG_ENCTYPE},\n     {\"KADM5_CONFIG_ADBNAME\", KADM5_CONFIG_ADBNAME},\n     {\"KADM5_CONFIG_ADB_LOCKFILE\", KADM5_CONFIG_ADB_LOCKFILE},\n     {\"KADM5_CONFIG_PROFILE\", KADM5_CONFIG_PROFILE},\n     {\"KADM5_CONFIG_ACL_FILE\", KADM5_CONFIG_ACL_FILE},\n     {\"KADM5_CONFIG_KADMIND_PORT\", KADM5_CONFIG_KADMIND_PORT},\n     {\"KADM5_CONFIG_ENCTYPES\", KADM5_CONFIG_ENCTYPES},\n     {\"KADM5_CONFIG_ADMIN_SERVER\", KADM5_CONFIG_ADMIN_SERVER},\n     {\"KADM5_CONFIG_DICT_FILE\", KADM5_CONFIG_DICT_FILE},\n     {\"KADM5_CONFIG_MKEY_FROM_KBD\", KADM5_CONFIG_MKEY_FROM_KBD},\n};\n\nstatic int parse_config_params(Tcl_Interp *interp, char *list,\n\t\t\t       kadm5_config_params *params)\n{\n     static Tcl_HashTable *table = 0;\n     char **argv = NULL;\n     int tmp, argc, retcode;\n\n     memset(params, 0, sizeof(kadm5_config_params));\n     if (list == NULL)\n\t  return TCL_OK;\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n\n     if (argc != 21) {\n\t  sprintf(interp->result,\n\t\t  \"wrong # args in config params structure (%d should be 21)\", \n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((retcode = parse_flags(interp, table, config_mask_flags,\n\t\t\t\tsizeof(config_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\targv[0], &tmp)) != TCL_OK) {\n\t  goto finished;\n     }\n     params->mask = tmp;\n\n     if ((retcode = parse_str(interp, argv[1], &params->realm)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing realm name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[2], &params->profile)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing kadmind_port\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->kadmind_port = tmp;\n     if ((retcode = parse_str(interp, argv[4], &params->admin_server))\n\t != TCL_OK) { \n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[5], &params->dbname)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[6], &params->admin_dbname)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_dbname name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[7], &params->admin_lockfile)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_lockfile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[8], &params->admin_keytab)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_keytab name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[9], &params->acl_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing acl_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[10], &params->dict_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing dict_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[11], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkey_from_kbd\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->mkey_from_kbd = tmp;\n     if ((retcode = parse_str(interp, argv[12], &params->stash_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing stash_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[13], &params->mkey_name)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkey_name name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[14], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing enctype\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->enctype = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[15], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->max_life = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[16], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_rlife\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->max_rlife = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[17], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing expiration\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->expiration = tmp;\n     if ((retcode = parse_krb5_flags(interp, argv[18], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing flags\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->flags = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[19], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing num_keysalts\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->num_keysalts = tmp;\n     if ((retcode = parse_keysalts(interp, argv[20], &params->keysalts,\n\t\t\t\t   params->num_keysalts)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keysalts\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     return retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[3]",
            "&params_str"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendResult",
          "args": [
            "interp",
            "whoami",
            "\": \"",
            "arg_error",
            "0"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_init_context",
          "args": [
            "&context"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\nstatic char *arg_error = \"wrong # args\";\n\nstatic int _tcl_kadm5_init_any(enum init_type init_type, ClientData clientData,\n\t\t\tTcl_Interp *interp, int argc, char *argv[])\n{\n     kadm5_ret_t ret;\n     char *client_name, *pass, *service_name;\n     int tcl_ret;\n     krb5_ui_4 struct_version, api_version;\n     char *handle_var;\n     void *server_handle;\n     char *handle_name, *params_str;\n     char *whoami = argv[0];\n     kadm5_config_params params;\n\n     argv++, argc--;\n\n     krb5_init_context(&context);\n\n     if (argc != 7) {\n\t  Tcl_AppendResult(interp, whoami, \": \", arg_error, 0);\n\t  return TCL_ERROR;\n     }\n\n     if (((tcl_ret = parse_str(interp, argv[0], &client_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[1], &pass)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[2], &service_name)) != TCL_OK) ||\n\t ((tcl_ret = parse_str(interp, argv[3], &params_str)) != TCL_OK) ||\n\t ((tcl_ret = parse_config_params(interp, params_str, &params))\n\t  != TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[4], (int *) &struct_version)) !=\n\t  TCL_OK) ||\n\t ((tcl_ret = Tcl_GetInt(interp, argv[5], (int *) &api_version)) !=\n\t  TCL_OK)) {\n\t  return tcl_ret;\n     }\n\n     handle_var = argv[6];\n\n     if (! (handle_var && *handle_var)) {\n\t Tcl_SetResult(interp, \"must specify server handle variable name\",\n\t\t       TCL_STATIC);\n\t return TCL_ERROR;\n     }\n\n     if (init_type == INIT_CREDS) {\n\t  krb5_ccache cc;\n\t  \n\t  if (pass == NULL) {\n\t       if ((ret = krb5_cc_default(context, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  } else {\n\t       if ((ret = krb5_cc_resolve(context, pass, &cc))) {\n\t\t    stash_error(interp, ret);\n\t\t    return TCL_ERROR;\n\t       }\n\t  }\n\n\t  ret = kadm5_init_with_creds(client_name, cc, service_name,\n\t\t\t\t      &params, struct_version,\n\t\t\t\t      api_version, &server_handle); \n\t  \n\t  (void) krb5_cc_close(context, cc);\n     } else\n\t  ret = kadm5_init(client_name, pass, service_name, &params,\n\t\t\t   struct_version, api_version, &server_handle);\n\n     if (ret != KADM5_OK) {\n\t  stash_error(interp, ret);\n\t  return TCL_ERROR;\n     }\n\n     if ((tcl_ret = put_server_handle(interp, server_handle, &handle_name))\n\t != TCL_OK) {\n\t return tcl_ret;\n     }\n     \n     if (! Tcl_SetVar(interp, handle_var, handle_name, TCL_LEAVE_ERR_MSG)) {\n\t return TCL_ERROR;\n     }\n     \n     set_ok(interp, \"KADM5 API initialized.\");\n     return TCL_OK;\n}"
  },
  {
    "function_name": "unparse_keyblocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1517-1556",
    "snippet": "static Tcl_DString *unparse_keyblocks(krb5_keyblock *keyblocks, int num_keys)\n{\n     Tcl_DString *str;\n     Tcl_DString *keytype;\n     int i, j;\n     \n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (j = 0; j < num_keys; j++) {\n\t  krb5_keyblock *keyblock = &keyblocks[j];\n\t  \n\t  Tcl_DStringStartSublist(str);\n\n\t  keytype = unparse_keytype(keyblock->enctype);\n\t  Tcl_DStringAppendElement(str, keytype->string);\n\t  Tcl_DStringFree(keytype);\n\t  free(keytype);\n\t  if (keyblock->length == 0) {\n\t       Tcl_DStringAppendElement(str, \"0x00\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, \"0x\");\n\t       for (i = 0; i < keyblock->length; i++) {\n\t\t    char buf[3];\n\t\t    sprintf(buf, \"%02x\", (int) keyblock->contents[i]);\n\t\t    Tcl_DStringAppend(str, buf, -1);\n\t       }\n\t  }\n\n\t  Tcl_DStringEndSublist(str);\n     }\n     \n\n     return str;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_DStringEndSublist",
          "args": [
            "str"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppend",
          "args": [
            "str",
            "buf",
            "-1"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%02x\"",
            "(int) keyblock->contents[i]"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "\"0x\""
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "\"0x00\""
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "keytype"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "keytype"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "keytype->string"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_keytype",
          "args": [
            "keyblock->enctype"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_keytype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1490-1514",
          "snippet": "static Tcl_DString *unparse_keytype(krb5_enctype enctype)\n{\n     Tcl_DString *str;\n     char buf[50];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     switch (enctype) {\n\t  /* XXX is this right? */\n     case ENCTYPE_NULL: Tcl_DStringAppend(str, \"ENCTYPE_NULL\", -1); break;\n     case ENCTYPE_DES_CBC_CRC:\n\t  Tcl_DStringAppend(str, \"ENCTYPE_DES_CBC_CRC\", -1); break;\n     default:\n\t  sprintf(buf, \"UNKNOWN KEYTYPE (0x%x)\", enctype);\n\t  Tcl_DStringAppend(str, buf, -1);\n\t  break;\n     }\n\n     return str;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_keytype(krb5_enctype enctype)\n{\n     Tcl_DString *str;\n     char buf[50];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     switch (enctype) {\n\t  /* XXX is this right? */\n     case ENCTYPE_NULL: Tcl_DStringAppend(str, \"ENCTYPE_NULL\", -1); break;\n     case ENCTYPE_DES_CBC_CRC:\n\t  Tcl_DStringAppend(str, \"ENCTYPE_DES_CBC_CRC\", -1); break;\n     default:\n\t  sprintf(buf, \"UNKNOWN KEYTYPE (0x%x)\", enctype);\n\t  Tcl_DStringAppend(str, buf, -1);\n\t  break;\n     }\n\n     return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringStartSublist",
          "args": [
            "str"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringInit",
          "args": [
            "str"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*str)"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_keyblocks(krb5_keyblock *keyblocks, int num_keys)\n{\n     Tcl_DString *str;\n     Tcl_DString *keytype;\n     int i, j;\n     \n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (j = 0; j < num_keys; j++) {\n\t  krb5_keyblock *keyblock = &keyblocks[j];\n\t  \n\t  Tcl_DStringStartSublist(str);\n\n\t  keytype = unparse_keytype(keyblock->enctype);\n\t  Tcl_DStringAppendElement(str, keytype->string);\n\t  Tcl_DStringFree(keytype);\n\t  free(keytype);\n\t  if (keyblock->length == 0) {\n\t       Tcl_DStringAppendElement(str, \"0x00\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, \"0x\");\n\t       for (i = 0; i < keyblock->length; i++) {\n\t\t    char buf[3];\n\t\t    sprintf(buf, \"%02x\", (int) keyblock->contents[i]);\n\t\t    Tcl_DStringAppend(str, buf, -1);\n\t       }\n\t  }\n\n\t  Tcl_DStringEndSublist(str);\n     }\n     \n\n     return str;\n}"
  },
  {
    "function_name": "unparse_keytype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1490-1514",
    "snippet": "static Tcl_DString *unparse_keytype(krb5_enctype enctype)\n{\n     Tcl_DString *str;\n     char buf[50];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     switch (enctype) {\n\t  /* XXX is this right? */\n     case ENCTYPE_NULL: Tcl_DStringAppend(str, \"ENCTYPE_NULL\", -1); break;\n     case ENCTYPE_DES_CBC_CRC:\n\t  Tcl_DStringAppend(str, \"ENCTYPE_DES_CBC_CRC\", -1); break;\n     default:\n\t  sprintf(buf, \"UNKNOWN KEYTYPE (0x%x)\", enctype);\n\t  Tcl_DStringAppend(str, buf, -1);\n\t  break;\n     }\n\n     return str;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_DStringAppend",
          "args": [
            "str",
            "buf",
            "-1"
          ],
          "line": 1509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"UNKNOWN KEYTYPE (0x%x)\"",
            "enctype"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppend",
          "args": [
            "str",
            "\"ENCTYPE_DES_CBC_CRC\"",
            "-1"
          ],
          "line": 1506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppend",
          "args": [
            "str",
            "\"ENCTYPE_NULL\"",
            "-1"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringInit",
          "args": [
            "str"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*str)"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_keytype(krb5_enctype enctype)\n{\n     Tcl_DString *str;\n     char buf[50];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     switch (enctype) {\n\t  /* XXX is this right? */\n     case ENCTYPE_NULL: Tcl_DStringAppend(str, \"ENCTYPE_NULL\", -1); break;\n     case ENCTYPE_DES_CBC_CRC:\n\t  Tcl_DStringAppend(str, \"ENCTYPE_DES_CBC_CRC\", -1); break;\n     default:\n\t  sprintf(buf, \"UNKNOWN KEYTYPE (0x%x)\", enctype);\n\t  Tcl_DStringAppend(str, buf, -1);\n\t  break;\n     }\n\n     return str;\n}"
  },
  {
    "function_name": "free_policy_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1484-1488",
    "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*policy"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
  },
  {
    "function_name": "parse_policy_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1383-1481",
    "snippet": "static int parse_policy_ent(Tcl_Interp *interp, char *list,\n\t\t\t    kadm5_policy_ent_t *out_policy)\n{\n     kadm5_policy_ent_t policy;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 7) {\n\t  sprintf(interp->result, \"wrong # args in policy structure (%d should be 7)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (policy = malloc(sizeof *policy))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n  \n     if ((tcl_ret = parse_str(interp, argv[0], &policy->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if(policy->policy != NULL) {\n\tif (! (policy->policy = strdup(policy->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1); /* XXX */\n\t}\n     }\n     \n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_life = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_max_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_length\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_length = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_classes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_classes = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[5], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_history_num\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_history_num = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy_refcnt\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->policy_refcnt = tmp;\n\nfinished:\n     free(argv);\n     *out_policy = policy;\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing policy_refcnt\""
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[6]",
            "&tmp"
          ],
          "line": 1469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing pw_history_num\""
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[5]",
            "&tmp"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing pw_min_classes\""
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[4]",
            "&tmp"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing pw_min_length\""
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[3]",
            "&tmp"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing pw_max_life\""
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[2]",
            "&tmp"
          ],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing pw_min_life\""
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[1]",
            "&tmp"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "policy->policy"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing policy name\""
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[0]",
            "&policy->policy"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof *policy"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"wrong # args in policy structure (%d should be 7)\"",
            "argc"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SplitList",
          "args": [
            "interp",
            "list",
            "&argc",
            "&argv"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_policy_ent(Tcl_Interp *interp, char *list,\n\t\t\t    kadm5_policy_ent_t *out_policy)\n{\n     kadm5_policy_ent_t policy;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 7) {\n\t  sprintf(interp->result, \"wrong # args in policy structure (%d should be 7)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (policy = malloc(sizeof *policy))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n  \n     if ((tcl_ret = parse_str(interp, argv[0], &policy->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if(policy->policy != NULL) {\n\tif (! (policy->policy = strdup(policy->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1); /* XXX */\n\t}\n     }\n     \n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_life = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_max_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_length\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_length = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_min_classes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_min_classes = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[5], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_history_num\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->pw_history_num = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy_refcnt\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     policy->policy_refcnt = tmp;\n\nfinished:\n     free(argv);\n     *out_policy = policy;\n     return retcode;\n}"
  },
  {
    "function_name": "unparse_policy_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1343-1379",
    "snippet": "static Tcl_DString *unparse_policy_ent(kadm5_policy_ent_t policy)\n{\n     Tcl_DString *str, *tmp_dstring;\n     char buf[20];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     tmp_dstring = unparse_str(policy->policy);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n     \n     sprintf(buf, \"%ld\", policy->pw_min_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_max_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_min_length);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_min_classes);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_history_num);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->policy_refcnt);\n     Tcl_DStringAppendElement(str, buf);\n\n     return str;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%ld\"",
            "policy->policy_refcnt"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%ld\"",
            "policy->pw_history_num"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%ld\"",
            "policy->pw_min_classes"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%ld\"",
            "policy->pw_min_length"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%ld\"",
            "policy->pw_max_life"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%ld\"",
            "policy->pw_min_life"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp_dstring"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "tmp_dstring"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "tmp_dstring->string"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_str",
          "args": [
            "policy->policy"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "225-244",
          "snippet": "static Tcl_DString *unparse_str(char *in_str)\n{\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     if (! in_str) {\n\t  Tcl_DStringAppend(str, \"null\", -1);\n     }\n     else {\n\t  Tcl_DStringAppend(str, in_str, -1);\n     }\n\n     return str;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_str(char *in_str)\n{\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     if (! in_str) {\n\t  Tcl_DStringAppend(str, \"null\", -1);\n     }\n     else {\n\t  Tcl_DStringAppend(str, in_str, -1);\n     }\n\n     return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringInit",
          "args": [
            "str"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*str)"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_policy_ent(kadm5_policy_ent_t policy)\n{\n     Tcl_DString *str, *tmp_dstring;\n     char buf[20];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     tmp_dstring = unparse_str(policy->policy);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n     \n     sprintf(buf, \"%ld\", policy->pw_min_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_max_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_min_length);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_min_classes);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->pw_history_num);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%ld\", policy->policy_refcnt);\n     Tcl_DStringAppendElement(str, buf);\n\n     return str;\n}"
  },
  {
    "function_name": "free_principal_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1335-1341",
    "snippet": "static void free_principal_ent(kadm5_principal_ent_t *princ)\n{\n     krb5_free_principal(context, (*princ)->principal);\n     krb5_free_principal(context, (*princ)->mod_name);\n     free(*princ);\n     *princ = 0;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_context context;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "*princ"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "(*princ)->mod_name"
          ],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "(*princ)->principal"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\n\nstatic void free_principal_ent(kadm5_principal_ent_t *princ)\n{\n     krb5_free_principal(context, (*princ)->principal);\n     krb5_free_principal(context, (*princ)->mod_name);\n     free(*princ);\n     *princ = 0;\n}"
  },
  {
    "function_name": "parse_principal_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "1130-1332",
    "snippet": "static int parse_principal_ent(Tcl_Interp *interp, char *list,\n\t\t\t       kadm5_principal_ent_t *out_princ)\n{\n     kadm5_principal_ent_t princ;\n     krb5_error_code krb5_ret;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 12 && argc != 20) {\n\t  sprintf(interp->result,\n             \"wrong # args in principal structure (%d should be 12 or 20)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (princ = malloc(sizeof *princ))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n     memset(princ, 0, sizeof(*princ));\n     \n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ->principal)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing princ_expire_time\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->princ_expire_time = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_pwd_change\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_pwd_change = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_expiration\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->pw_expiration = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_life = tmp;\n\n     if ((krb5_ret = krb5_parse_name(context, argv[5], &princ->mod_name)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing mod_name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\t  \n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mod_date\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mod_date = tmp;\n\n     if ((tcl_ret = parse_krb5_flags(interp, argv[7], &princ->attributes))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[8], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing kvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->kvno = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[9], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mkvno = tmp;\n\n     if ((tcl_ret = parse_str(interp, argv[10], &princ->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if(princ->policy != NULL) {\n\tif(!(princ->policy = strdup(princ->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1);\n\t}\n     }\n\n     if ((tcl_ret = parse_aux_attributes(interp, argv[11],\n\t\t\t\t\t &princ->aux_attributes)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing aux_attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (argc == 12) goto finished;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[12], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_renewable_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_renewable_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[13], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_success\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_success = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[14], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_failed\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_failed = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[15], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing fail_auth_count\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->fail_auth_count = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[16], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_key_data = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[17], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_tl_data = tmp;\n\n     if ((tcl_ret = parse_key_data(interp, argv[18],\n\t\t\t\t   &princ->key_data,\n\t\t\t\t   princ->n_key_data)) != TCL_OK) { \n\t  Tcl_AppendElement(interp, \"while parsing key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = parse_tl_data(interp, argv[19],\n\t\t\t\t  &princ->tl_data,\n\t\t\t\t  princ->n_tl_data)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     free(argv);\n     *out_princ = princ;\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_context context;",
      "static struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing tl_data\""
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_tl_data",
          "args": [
            "interp",
            "argv[19]",
            "&princ->tl_data",
            "princ->n_tl_data"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "parse_tl_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "885-974",
          "snippet": "static int parse_tl_data(Tcl_Interp *interp, char *list,\n\t\t\t krb5_tl_data **tlp,\n\t\t\t int n_tl_data)\n{\n     krb5_tl_data *tl, *tl2;\n     char **argv, **argv1 = NULL;\n     int i, tmp, argc, argc1, retcode;\n\n     *tlp = NULL;\n     if (list == NULL) {\n\t  if (n_tl_data != 0) {\n\t       sprintf(interp->result, \"0 tl_datas specified, \"\n\t\t       \"but n_tl_data is %d\", n_tl_data);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  } else\n\t       return TCL_OK;\n     }\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != n_tl_data) {\n\t  sprintf(interp->result, \"%d tl_datas specified, \"\n\t\t  \"but n_tl_data is %d\", argc, n_tl_data);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     tl = tl2 = NULL;\n     for (i = 0; i < n_tl_data; i++) {\n\t  tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t  memset(tl2, 0, sizeof(krb5_tl_data));\n\t  tl2->tl_data_next = tl;\n\t  tl = tl2;\n     }\n     tl2 = tl;\n\t  \n     for (i = 0; i < n_tl_data; i++) {\n\t  if ((retcode = Tcl_SplitList(interp, argv[i], &argc1, &argv1)) !=\n\t      TCL_OK) { \n\t       goto finished;\n\t  }\n\t  if (argc1 != 3) {\n\t       sprintf(interp->result, \"wrong # fields in tl_data \"\n\t\t       \"(%d should be 3)\", argc1);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  if ((retcode = Tcl_GetInt(interp, argv1[0], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing tl_data_type\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_type = tmp;\n\t  if ((retcode = Tcl_GetInt(interp, argv1[1], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing tl_data_length\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_length = tmp;\n\t  if (tl->tl_data_length != strlen(argv1[2])) {\n\t       sprintf(interp->result, \"specified length %d does not \"\n\t\t       \"match length %d of string \\\"%s\\\"\", tmp,\n\t\t       strlen(argv1[2]), argv1[2]);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_contents = (krb5_octet *) malloc(tmp+1);\n\t  strcpy((char *) tl->tl_data_contents, argv1[2]);\n\n\t  free(argv1);\n\t  argv1 = NULL;\n\t  tl = tl->tl_data_next;\n     }\n     if (tl != NULL) {\n\t  sprintf(interp->result, \"tl is not NULL!\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     *tlp = tl2;\n\nfinished:\n     if (argv1)\n\t  free(argv1);\n     free(argv);\n     return retcode;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_tl_data(Tcl_Interp *interp, char *list,\n\t\t\t krb5_tl_data **tlp,\n\t\t\t int n_tl_data)\n{\n     krb5_tl_data *tl, *tl2;\n     char **argv, **argv1 = NULL;\n     int i, tmp, argc, argc1, retcode;\n\n     *tlp = NULL;\n     if (list == NULL) {\n\t  if (n_tl_data != 0) {\n\t       sprintf(interp->result, \"0 tl_datas specified, \"\n\t\t       \"but n_tl_data is %d\", n_tl_data);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  } else\n\t       return TCL_OK;\n     }\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != n_tl_data) {\n\t  sprintf(interp->result, \"%d tl_datas specified, \"\n\t\t  \"but n_tl_data is %d\", argc, n_tl_data);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     tl = tl2 = NULL;\n     for (i = 0; i < n_tl_data; i++) {\n\t  tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t  memset(tl2, 0, sizeof(krb5_tl_data));\n\t  tl2->tl_data_next = tl;\n\t  tl = tl2;\n     }\n     tl2 = tl;\n\t  \n     for (i = 0; i < n_tl_data; i++) {\n\t  if ((retcode = Tcl_SplitList(interp, argv[i], &argc1, &argv1)) !=\n\t      TCL_OK) { \n\t       goto finished;\n\t  }\n\t  if (argc1 != 3) {\n\t       sprintf(interp->result, \"wrong # fields in tl_data \"\n\t\t       \"(%d should be 3)\", argc1);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  if ((retcode = Tcl_GetInt(interp, argv1[0], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing tl_data_type\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_type = tmp;\n\t  if ((retcode = Tcl_GetInt(interp, argv1[1], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing tl_data_length\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_length = tmp;\n\t  if (tl->tl_data_length != strlen(argv1[2])) {\n\t       sprintf(interp->result, \"specified length %d does not \"\n\t\t       \"match length %d of string \\\"%s\\\"\", tmp,\n\t\t       strlen(argv1[2]), argv1[2]);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_contents = (krb5_octet *) malloc(tmp+1);\n\t  strcpy((char *) tl->tl_data_contents, argv1[2]);\n\n\t  free(argv1);\n\t  argv1 = NULL;\n\t  tl = tl->tl_data_next;\n     }\n     if (tl != NULL) {\n\t  sprintf(interp->result, \"tl is not NULL!\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     *tlp = tl2;\n\nfinished:\n     if (argv1)\n\t  free(argv1);\n     free(argv);\n     return retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing key_data\""
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_key_data",
          "args": [
            "interp",
            "argv[18]",
            "&princ->key_data",
            "princ->n_key_data"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "parse_key_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "846-883",
          "snippet": "static int parse_key_data(Tcl_Interp *interp, char *list,\n\t\t\t  krb5_key_data **key_data,\n\t\t\t  int n_key_data)\n{\n     char **argv;\n     int argc, retcode;\n\n     *key_data = NULL;\n     if (list == NULL) {\n\t  if (n_key_data != 0) {\n\t       sprintf(interp->result, \"0 key_datas specified, \"\n\t\t       \"but n_key_data is %d\", n_key_data);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  } else\n\t       return TCL_OK;\n     }\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != n_key_data) {\n\t  sprintf(interp->result, \"%d key_datas specified, \"\n\t\t  \"but n_key_data is %d\", argc, n_key_data);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (argc != 0) {\n\t  sprintf(interp->result, \"cannot parse key_data yet\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     free(argv);\n     return retcode;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_key_data(Tcl_Interp *interp, char *list,\n\t\t\t  krb5_key_data **key_data,\n\t\t\t  int n_key_data)\n{\n     char **argv;\n     int argc, retcode;\n\n     *key_data = NULL;\n     if (list == NULL) {\n\t  if (n_key_data != 0) {\n\t       sprintf(interp->result, \"0 key_datas specified, \"\n\t\t       \"but n_key_data is %d\", n_key_data);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  } else\n\t       return TCL_OK;\n     }\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != n_key_data) {\n\t  sprintf(interp->result, \"%d key_datas specified, \"\n\t\t  \"but n_key_data is %d\", argc, n_key_data);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (argc != 0) {\n\t  sprintf(interp->result, \"cannot parse key_data yet\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     free(argv);\n     return retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing n_tl_data\""
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[17]",
            "&tmp"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing n_key_data\""
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[16]",
            "&tmp"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing fail_auth_count\""
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[15]",
            "&tmp"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing last_failed\""
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[14]",
            "&tmp"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing last_success\""
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[13]",
            "&tmp"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing max_renewable_life\""
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[12]",
            "&tmp"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing aux_attributes\""
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_aux_attributes",
          "args": [
            "interp",
            "argv[11]",
            "&princ->aux_attributes"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "parse_aux_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "614-629",
          "snippet": "static int parse_aux_attributes(Tcl_Interp *interp, char *str, long *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, aux_attributes,\n\t\t\t\tsizeof(aux_attributes) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};\n\nstatic int parse_aux_attributes(Tcl_Interp *interp, char *str, long *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, aux_attributes,\n\t\t\t\tsizeof(aux_attributes) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "princ->policy"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing policy\""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[10]",
            "&princ->policy"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing mkvno\""
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[9]",
            "&tmp"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing kvno\""
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[8]",
            "&tmp"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing attributes\""
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_krb5_flags",
          "args": [
            "interp",
            "argv[7]",
            "&princ->attributes"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "parse_krb5_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "590-605",
          "snippet": "static int parse_krb5_flags(Tcl_Interp *interp, char *str, krb5_flags *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, krb5_flags_array,\n\t\t\t\tsizeof(krb5_flags_array) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval krb5_flags_array[] = {\n     {\"KRB5_KDB_DISALLOW_POSTDATED\", KRB5_KDB_DISALLOW_POSTDATED},\n     {\"KRB5_KDB_DISALLOW_FORWARDABLE\", KRB5_KDB_DISALLOW_FORWARDABLE},\n     {\"KRB5_KDB_DISALLOW_TGT_BASED\", KRB5_KDB_DISALLOW_TGT_BASED},\n     {\"KRB5_KDB_DISALLOW_RENEWABLE\", KRB5_KDB_DISALLOW_RENEWABLE},\n     {\"KRB5_KDB_DISALLOW_PROXIABLE\", KRB5_KDB_DISALLOW_PROXIABLE},\n     {\"KRB5_KDB_DISALLOW_DUP_SKEY\", KRB5_KDB_DISALLOW_DUP_SKEY},\n     {\"KRB5_KDB_DISALLOW_ALL_TIX\", KRB5_KDB_DISALLOW_ALL_TIX},\n     {\"KRB5_KDB_REQUIRES_PRE_AUTH\", KRB5_KDB_REQUIRES_PRE_AUTH},\n     {\"KRB5_KDB_REQUIRES_HW_AUTH\", KRB5_KDB_REQUIRES_HW_AUTH},\n     {\"KRB5_KDB_REQUIRES_PWCHANGE\", KRB5_KDB_REQUIRES_PWCHANGE},\n     {\"KRB5_KDB_DISALLOW_SVR\", KRB5_KDB_DISALLOW_SVR},\n     {\"KRB5_KDB_PWCHANGE_SERVICE\", KRB5_KDB_PWCHANGE_SERVICE}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval krb5_flags_array[] = {\n     {\"KRB5_KDB_DISALLOW_POSTDATED\", KRB5_KDB_DISALLOW_POSTDATED},\n     {\"KRB5_KDB_DISALLOW_FORWARDABLE\", KRB5_KDB_DISALLOW_FORWARDABLE},\n     {\"KRB5_KDB_DISALLOW_TGT_BASED\", KRB5_KDB_DISALLOW_TGT_BASED},\n     {\"KRB5_KDB_DISALLOW_RENEWABLE\", KRB5_KDB_DISALLOW_RENEWABLE},\n     {\"KRB5_KDB_DISALLOW_PROXIABLE\", KRB5_KDB_DISALLOW_PROXIABLE},\n     {\"KRB5_KDB_DISALLOW_DUP_SKEY\", KRB5_KDB_DISALLOW_DUP_SKEY},\n     {\"KRB5_KDB_DISALLOW_ALL_TIX\", KRB5_KDB_DISALLOW_ALL_TIX},\n     {\"KRB5_KDB_REQUIRES_PRE_AUTH\", KRB5_KDB_REQUIRES_PRE_AUTH},\n     {\"KRB5_KDB_REQUIRES_HW_AUTH\", KRB5_KDB_REQUIRES_HW_AUTH},\n     {\"KRB5_KDB_REQUIRES_PWCHANGE\", KRB5_KDB_REQUIRES_PWCHANGE},\n     {\"KRB5_KDB_DISALLOW_SVR\", KRB5_KDB_DISALLOW_SVR},\n     {\"KRB5_KDB_PWCHANGE_SERVICE\", KRB5_KDB_PWCHANGE_SERVICE}\n};\n\nstatic int parse_krb5_flags(Tcl_Interp *interp, char *str, krb5_flags *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, krb5_flags_array,\n\t\t\t\tsizeof(krb5_flags_array) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing mod_date\""
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[6]",
            "&tmp"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing mod_name\""
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stash_error",
          "args": [
            "interp",
            "krb5_ret"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "stash_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "446-452",
          "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "argv[5]",
            "&princ->mod_name"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing max_life\""
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[4]",
            "&tmp"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing pw_expiration\""
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[3]",
            "&tmp"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing last_pwd_change\""
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[2]",
            "&tmp"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing princ_expire_time\""
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[1]",
            "&tmp"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing principal\""
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "argv[0]",
            "&princ->principal"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "princ",
            "0",
            "sizeof(*princ)"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof *princ"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"wrong # args in principal structure (%d should be 12 or 20)\"",
            "argc"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SplitList",
          "args": [
            "interp",
            "list",
            "&argc",
            "&argv"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\nstatic struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};\n\nstatic int parse_principal_ent(Tcl_Interp *interp, char *list,\n\t\t\t       kadm5_principal_ent_t *out_princ)\n{\n     kadm5_principal_ent_t princ;\n     krb5_error_code krb5_ret;\n     int tcl_ret;\n     int argc;\n     char **argv;\n     int tmp;\n     int retcode = TCL_OK;\n\n     if ((tcl_ret = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     if (argc != 12 && argc != 20) {\n\t  sprintf(interp->result,\n             \"wrong # args in principal structure (%d should be 12 or 20)\",\n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (! (princ = malloc(sizeof *princ))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n     memset(princ, 0, sizeof(*princ));\n     \n     if ((krb5_ret = krb5_parse_name(context, argv[0], &princ->principal)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing principal\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     /*\n      * All of the numerical values parsed here are parsed into an\n      * \"int\" and then assigned into the structure in case the actual\n      * width of the field in the Kerberos structure is different from\n      * the width of an integer.\n      */\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[1], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing princ_expire_time\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->princ_expire_time = tmp;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[2], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_pwd_change\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_pwd_change = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing pw_expiration\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->pw_expiration = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[4], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_life = tmp;\n\n     if ((krb5_ret = krb5_parse_name(context, argv[5], &princ->mod_name)) != 0) {\n\t  stash_error(interp, krb5_ret);\n\t  Tcl_AppendElement(interp, \"while parsing mod_name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\t  \n     if ((tcl_ret = Tcl_GetInt(interp, argv[6], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mod_date\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mod_date = tmp;\n\n     if ((tcl_ret = parse_krb5_flags(interp, argv[7], &princ->attributes))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[8], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing kvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->kvno = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[9], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkvno\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->mkvno = tmp;\n\n     if ((tcl_ret = parse_str(interp, argv[10], &princ->policy)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing policy\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if(princ->policy != NULL) {\n\tif(!(princ->policy = strdup(princ->policy))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1);\n\t}\n     }\n\n     if ((tcl_ret = parse_aux_attributes(interp, argv[11],\n\t\t\t\t\t &princ->aux_attributes)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing aux_attributes\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (argc == 12) goto finished;\n     \n     if ((tcl_ret = Tcl_GetInt(interp, argv[12], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_renewable_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->max_renewable_life = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[13], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_success\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_success = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[14], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing last_failed\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->last_failed = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[15], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing fail_auth_count\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->fail_auth_count = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[16], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_key_data = tmp;\n\n     if ((tcl_ret = Tcl_GetInt(interp, argv[17], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing n_tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     princ->n_tl_data = tmp;\n\n     if ((tcl_ret = parse_key_data(interp, argv[18],\n\t\t\t\t   &princ->key_data,\n\t\t\t\t   princ->n_key_data)) != TCL_OK) { \n\t  Tcl_AppendElement(interp, \"while parsing key_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((tcl_ret = parse_tl_data(interp, argv[19],\n\t\t\t\t  &princ->tl_data,\n\t\t\t\t  princ->n_tl_data)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing tl_data\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     free(argv);\n     *out_princ = princ;\n     return retcode;\n}"
  },
  {
    "function_name": "parse_config_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "976-1128",
    "snippet": "static int parse_config_params(Tcl_Interp *interp, char *list,\n\t\t\t       kadm5_config_params *params)\n{\n     static Tcl_HashTable *table = 0;\n     char **argv = NULL;\n     int tmp, argc, retcode;\n\n     memset(params, 0, sizeof(kadm5_config_params));\n     if (list == NULL)\n\t  return TCL_OK;\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n\n     if (argc != 21) {\n\t  sprintf(interp->result,\n\t\t  \"wrong # args in config params structure (%d should be 21)\", \n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((retcode = parse_flags(interp, table, config_mask_flags,\n\t\t\t\tsizeof(config_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\targv[0], &tmp)) != TCL_OK) {\n\t  goto finished;\n     }\n     params->mask = tmp;\n\n     if ((retcode = parse_str(interp, argv[1], &params->realm)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing realm name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[2], &params->profile)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing kadmind_port\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->kadmind_port = tmp;\n     if ((retcode = parse_str(interp, argv[4], &params->admin_server))\n\t != TCL_OK) { \n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[5], &params->dbname)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[6], &params->admin_dbname)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_dbname name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[7], &params->admin_lockfile)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_lockfile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[8], &params->admin_keytab)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_keytab name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[9], &params->acl_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing acl_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[10], &params->dict_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing dict_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[11], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkey_from_kbd\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->mkey_from_kbd = tmp;\n     if ((retcode = parse_str(interp, argv[12], &params->stash_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing stash_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[13], &params->mkey_name)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkey_name name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[14], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing enctype\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->enctype = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[15], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->max_life = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[16], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_rlife\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->max_rlife = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[17], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing expiration\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->expiration = tmp;\n     if ((retcode = parse_krb5_flags(interp, argv[18], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing flags\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->flags = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[19], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing num_keysalts\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->num_keysalts = tmp;\n     if ((retcode = parse_keysalts(interp, argv[20], &params->keysalts,\n\t\t\t\t   params->num_keysalts)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keysalts\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct flagval config_mask_flags[] = {\n     {\"KADM5_CONFIG_REALM\", KADM5_CONFIG_REALM},\n     {\"KADM5_CONFIG_DBNAME\", KADM5_CONFIG_DBNAME},\n     {\"KADM5_CONFIG_MKEY_NAME\", KADM5_CONFIG_MKEY_NAME},\n     {\"KADM5_CONFIG_MAX_LIFE\", KADM5_CONFIG_MAX_LIFE},\n     {\"KADM5_CONFIG_MAX_RLIFE\", KADM5_CONFIG_MAX_RLIFE},\n     {\"KADM5_CONFIG_EXPIRATION\", KADM5_CONFIG_EXPIRATION},\n     {\"KADM5_CONFIG_FLAGS\", KADM5_CONFIG_FLAGS},\n     {\"KADM5_CONFIG_ADMIN_KEYTAB\", KADM5_CONFIG_ADMIN_KEYTAB},\n     {\"KADM5_CONFIG_STASH_FILE\", KADM5_CONFIG_STASH_FILE},\n     {\"KADM5_CONFIG_ENCTYPE\", KADM5_CONFIG_ENCTYPE},\n     {\"KADM5_CONFIG_ADBNAME\", KADM5_CONFIG_ADBNAME},\n     {\"KADM5_CONFIG_ADB_LOCKFILE\", KADM5_CONFIG_ADB_LOCKFILE},\n     {\"KADM5_CONFIG_PROFILE\", KADM5_CONFIG_PROFILE},\n     {\"KADM5_CONFIG_ACL_FILE\", KADM5_CONFIG_ACL_FILE},\n     {\"KADM5_CONFIG_KADMIND_PORT\", KADM5_CONFIG_KADMIND_PORT},\n     {\"KADM5_CONFIG_ENCTYPES\", KADM5_CONFIG_ENCTYPES},\n     {\"KADM5_CONFIG_ADMIN_SERVER\", KADM5_CONFIG_ADMIN_SERVER},\n     {\"KADM5_CONFIG_DICT_FILE\", KADM5_CONFIG_DICT_FILE},\n     {\"KADM5_CONFIG_MKEY_FROM_KBD\", KADM5_CONFIG_MKEY_FROM_KBD},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing keysalts\""
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_keysalts",
          "args": [
            "interp",
            "argv[20]",
            "&params->keysalts",
            "params->num_keysalts"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "parse_keysalts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "787-844",
          "snippet": "static int parse_keysalts(Tcl_Interp *interp, char *list,\n\t\t\t  krb5_key_salt_tuple **keysalts,\n\t\t\t  int num_keysalts)\n{\n     char **argv, **argv1 = NULL;\n     int i, tmp, argc, argc1, retcode;\n\n     *keysalts = NULL;\n     if (list == NULL)\n\t  return TCL_OK;\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != num_keysalts) {\n\t  sprintf(interp->result, \"%d keysalts specified, \"\n\t\t  \"but num_keysalts is %d\", argc, num_keysalts);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     *keysalts = (krb5_key_salt_tuple *)\n\t  malloc(sizeof(krb5_key_salt_tuple)*num_keysalts);\n     for (i = 0; i < num_keysalts; i++) {\n\t  if ((retcode = Tcl_SplitList(interp, argv[i], &argc1, &argv1)) !=\n\t      TCL_OK) { \n\t       goto finished;\n\t  }\n\t  if (argc1 != 2) {\n\t       sprintf(interp->result, \"wrong # fields in keysalt \"\n\t\t       \"(%d should be 2)\", argc1);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  /* XXX this used to be argv1[1] too! */\n\t  if ((retcode = Tcl_GetInt(interp, argv1[0], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing ks_enctype\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  (*keysalts)[i].ks_enctype = tmp;\n\t  if ((retcode = Tcl_GetInt(interp, argv1[1], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing ks_salttype\");\n\t       goto finished;\n\t  }\n\t  (*keysalts)[i].ks_salttype = tmp;\n\n\t  free(argv1);\n\t  argv1 = NULL;\n     }\n\nfinished:\n     if (argv1)\n\t  free(argv1);\n     free(argv);\n     return retcode;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_keysalts(Tcl_Interp *interp, char *list,\n\t\t\t  krb5_key_salt_tuple **keysalts,\n\t\t\t  int num_keysalts)\n{\n     char **argv, **argv1 = NULL;\n     int i, tmp, argc, argc1, retcode;\n\n     *keysalts = NULL;\n     if (list == NULL)\n\t  return TCL_OK;\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != num_keysalts) {\n\t  sprintf(interp->result, \"%d keysalts specified, \"\n\t\t  \"but num_keysalts is %d\", argc, num_keysalts);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     *keysalts = (krb5_key_salt_tuple *)\n\t  malloc(sizeof(krb5_key_salt_tuple)*num_keysalts);\n     for (i = 0; i < num_keysalts; i++) {\n\t  if ((retcode = Tcl_SplitList(interp, argv[i], &argc1, &argv1)) !=\n\t      TCL_OK) { \n\t       goto finished;\n\t  }\n\t  if (argc1 != 2) {\n\t       sprintf(interp->result, \"wrong # fields in keysalt \"\n\t\t       \"(%d should be 2)\", argc1);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  /* XXX this used to be argv1[1] too! */\n\t  if ((retcode = Tcl_GetInt(interp, argv1[0], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing ks_enctype\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  (*keysalts)[i].ks_enctype = tmp;\n\t  if ((retcode = Tcl_GetInt(interp, argv1[1], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing ks_salttype\");\n\t       goto finished;\n\t  }\n\t  (*keysalts)[i].ks_salttype = tmp;\n\n\t  free(argv1);\n\t  argv1 = NULL;\n     }\n\nfinished:\n     if (argv1)\n\t  free(argv1);\n     free(argv);\n     return retcode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing num_keysalts\""
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[19]",
            "&tmp"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing flags\""
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_krb5_flags",
          "args": [
            "interp",
            "argv[18]",
            "&tmp"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "parse_krb5_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "590-605",
          "snippet": "static int parse_krb5_flags(Tcl_Interp *interp, char *str, krb5_flags *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, krb5_flags_array,\n\t\t\t\tsizeof(krb5_flags_array) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval krb5_flags_array[] = {\n     {\"KRB5_KDB_DISALLOW_POSTDATED\", KRB5_KDB_DISALLOW_POSTDATED},\n     {\"KRB5_KDB_DISALLOW_FORWARDABLE\", KRB5_KDB_DISALLOW_FORWARDABLE},\n     {\"KRB5_KDB_DISALLOW_TGT_BASED\", KRB5_KDB_DISALLOW_TGT_BASED},\n     {\"KRB5_KDB_DISALLOW_RENEWABLE\", KRB5_KDB_DISALLOW_RENEWABLE},\n     {\"KRB5_KDB_DISALLOW_PROXIABLE\", KRB5_KDB_DISALLOW_PROXIABLE},\n     {\"KRB5_KDB_DISALLOW_DUP_SKEY\", KRB5_KDB_DISALLOW_DUP_SKEY},\n     {\"KRB5_KDB_DISALLOW_ALL_TIX\", KRB5_KDB_DISALLOW_ALL_TIX},\n     {\"KRB5_KDB_REQUIRES_PRE_AUTH\", KRB5_KDB_REQUIRES_PRE_AUTH},\n     {\"KRB5_KDB_REQUIRES_HW_AUTH\", KRB5_KDB_REQUIRES_HW_AUTH},\n     {\"KRB5_KDB_REQUIRES_PWCHANGE\", KRB5_KDB_REQUIRES_PWCHANGE},\n     {\"KRB5_KDB_DISALLOW_SVR\", KRB5_KDB_DISALLOW_SVR},\n     {\"KRB5_KDB_PWCHANGE_SERVICE\", KRB5_KDB_PWCHANGE_SERVICE}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval krb5_flags_array[] = {\n     {\"KRB5_KDB_DISALLOW_POSTDATED\", KRB5_KDB_DISALLOW_POSTDATED},\n     {\"KRB5_KDB_DISALLOW_FORWARDABLE\", KRB5_KDB_DISALLOW_FORWARDABLE},\n     {\"KRB5_KDB_DISALLOW_TGT_BASED\", KRB5_KDB_DISALLOW_TGT_BASED},\n     {\"KRB5_KDB_DISALLOW_RENEWABLE\", KRB5_KDB_DISALLOW_RENEWABLE},\n     {\"KRB5_KDB_DISALLOW_PROXIABLE\", KRB5_KDB_DISALLOW_PROXIABLE},\n     {\"KRB5_KDB_DISALLOW_DUP_SKEY\", KRB5_KDB_DISALLOW_DUP_SKEY},\n     {\"KRB5_KDB_DISALLOW_ALL_TIX\", KRB5_KDB_DISALLOW_ALL_TIX},\n     {\"KRB5_KDB_REQUIRES_PRE_AUTH\", KRB5_KDB_REQUIRES_PRE_AUTH},\n     {\"KRB5_KDB_REQUIRES_HW_AUTH\", KRB5_KDB_REQUIRES_HW_AUTH},\n     {\"KRB5_KDB_REQUIRES_PWCHANGE\", KRB5_KDB_REQUIRES_PWCHANGE},\n     {\"KRB5_KDB_DISALLOW_SVR\", KRB5_KDB_DISALLOW_SVR},\n     {\"KRB5_KDB_PWCHANGE_SERVICE\", KRB5_KDB_PWCHANGE_SERVICE}\n};\n\nstatic int parse_krb5_flags(Tcl_Interp *interp, char *str, krb5_flags *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, krb5_flags_array,\n\t\t\t\tsizeof(krb5_flags_array) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing expiration\""
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[17]",
            "&tmp"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing max_rlife\""
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[16]",
            "&tmp"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing max_life\""
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[15]",
            "&tmp"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing enctype\""
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[14]",
            "&tmp"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing mkey_name name\""
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_str",
          "args": [
            "interp",
            "argv[13]",
            "&params->mkey_name"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "parse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "248-260",
          "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing stash_file name\""
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing mkey_from_kbd\""
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[11]",
            "&tmp"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing dict_file name\""
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing acl_file name\""
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing admin_keytab name\""
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing admin_lockfile name\""
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing admin_dbname name\""
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing profile name\""
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing profile name\""
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing kadmind_port\""
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv[3]",
            "&tmp"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing profile name\""
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing realm name\""
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_flags",
          "args": [
            "interp",
            "table",
            "config_mask_flags",
            "sizeof(config_mask_flags) /\n\t\t\t\tsizeof(struct flagval)",
            "argv[0]",
            "&tmp"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "parse_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "540-575",
          "snippet": "static int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"wrong # args in config params structure (%d should be 21)\"",
            "argc"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SplitList",
          "args": [
            "interp",
            "list",
            "&argc",
            "&argv"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "params",
            "0",
            "sizeof(kadm5_config_params)"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval config_mask_flags[] = {\n     {\"KADM5_CONFIG_REALM\", KADM5_CONFIG_REALM},\n     {\"KADM5_CONFIG_DBNAME\", KADM5_CONFIG_DBNAME},\n     {\"KADM5_CONFIG_MKEY_NAME\", KADM5_CONFIG_MKEY_NAME},\n     {\"KADM5_CONFIG_MAX_LIFE\", KADM5_CONFIG_MAX_LIFE},\n     {\"KADM5_CONFIG_MAX_RLIFE\", KADM5_CONFIG_MAX_RLIFE},\n     {\"KADM5_CONFIG_EXPIRATION\", KADM5_CONFIG_EXPIRATION},\n     {\"KADM5_CONFIG_FLAGS\", KADM5_CONFIG_FLAGS},\n     {\"KADM5_CONFIG_ADMIN_KEYTAB\", KADM5_CONFIG_ADMIN_KEYTAB},\n     {\"KADM5_CONFIG_STASH_FILE\", KADM5_CONFIG_STASH_FILE},\n     {\"KADM5_CONFIG_ENCTYPE\", KADM5_CONFIG_ENCTYPE},\n     {\"KADM5_CONFIG_ADBNAME\", KADM5_CONFIG_ADBNAME},\n     {\"KADM5_CONFIG_ADB_LOCKFILE\", KADM5_CONFIG_ADB_LOCKFILE},\n     {\"KADM5_CONFIG_PROFILE\", KADM5_CONFIG_PROFILE},\n     {\"KADM5_CONFIG_ACL_FILE\", KADM5_CONFIG_ACL_FILE},\n     {\"KADM5_CONFIG_KADMIND_PORT\", KADM5_CONFIG_KADMIND_PORT},\n     {\"KADM5_CONFIG_ENCTYPES\", KADM5_CONFIG_ENCTYPES},\n     {\"KADM5_CONFIG_ADMIN_SERVER\", KADM5_CONFIG_ADMIN_SERVER},\n     {\"KADM5_CONFIG_DICT_FILE\", KADM5_CONFIG_DICT_FILE},\n     {\"KADM5_CONFIG_MKEY_FROM_KBD\", KADM5_CONFIG_MKEY_FROM_KBD},\n};\n\nstatic int parse_config_params(Tcl_Interp *interp, char *list,\n\t\t\t       kadm5_config_params *params)\n{\n     static Tcl_HashTable *table = 0;\n     char **argv = NULL;\n     int tmp, argc, retcode;\n\n     memset(params, 0, sizeof(kadm5_config_params));\n     if (list == NULL)\n\t  return TCL_OK;\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n\n     if (argc != 21) {\n\t  sprintf(interp->result,\n\t\t  \"wrong # args in config params structure (%d should be 21)\", \n\t\t  argc);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if ((retcode = parse_flags(interp, table, config_mask_flags,\n\t\t\t\tsizeof(config_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\targv[0], &tmp)) != TCL_OK) {\n\t  goto finished;\n     }\n     params->mask = tmp;\n\n     if ((retcode = parse_str(interp, argv[1], &params->realm)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing realm name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[2], &params->profile)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[3], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing kadmind_port\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->kadmind_port = tmp;\n     if ((retcode = parse_str(interp, argv[4], &params->admin_server))\n\t != TCL_OK) { \n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[5], &params->dbname)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing profile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[6], &params->admin_dbname)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_dbname name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[7], &params->admin_lockfile)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_lockfile name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[8], &params->admin_keytab)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing admin_keytab name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[9], &params->acl_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing acl_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[10], &params->dict_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing dict_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[11], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkey_from_kbd\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->mkey_from_kbd = tmp;\n     if ((retcode = parse_str(interp, argv[12], &params->stash_file)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing stash_file name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = parse_str(interp, argv[13], &params->mkey_name)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing mkey_name name\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     if ((retcode = Tcl_GetInt(interp, argv[14], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing enctype\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->enctype = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[15], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_life\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->max_life = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[16], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing max_rlife\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->max_rlife = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[17], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing expiration\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->expiration = tmp;\n     if ((retcode = parse_krb5_flags(interp, argv[18], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing flags\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->flags = tmp;\n     if ((retcode = Tcl_GetInt(interp, argv[19], &tmp))\n\t != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing num_keysalts\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     params->num_keysalts = tmp;\n     if ((retcode = parse_keysalts(interp, argv[20], &params->keysalts,\n\t\t\t\t   params->num_keysalts)) != TCL_OK) {\n\t  Tcl_AppendElement(interp, \"while parsing keysalts\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     return retcode;\n}"
  },
  {
    "function_name": "parse_tl_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "885-974",
    "snippet": "static int parse_tl_data(Tcl_Interp *interp, char *list,\n\t\t\t krb5_tl_data **tlp,\n\t\t\t int n_tl_data)\n{\n     krb5_tl_data *tl, *tl2;\n     char **argv, **argv1 = NULL;\n     int i, tmp, argc, argc1, retcode;\n\n     *tlp = NULL;\n     if (list == NULL) {\n\t  if (n_tl_data != 0) {\n\t       sprintf(interp->result, \"0 tl_datas specified, \"\n\t\t       \"but n_tl_data is %d\", n_tl_data);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  } else\n\t       return TCL_OK;\n     }\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != n_tl_data) {\n\t  sprintf(interp->result, \"%d tl_datas specified, \"\n\t\t  \"but n_tl_data is %d\", argc, n_tl_data);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     tl = tl2 = NULL;\n     for (i = 0; i < n_tl_data; i++) {\n\t  tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t  memset(tl2, 0, sizeof(krb5_tl_data));\n\t  tl2->tl_data_next = tl;\n\t  tl = tl2;\n     }\n     tl2 = tl;\n\t  \n     for (i = 0; i < n_tl_data; i++) {\n\t  if ((retcode = Tcl_SplitList(interp, argv[i], &argc1, &argv1)) !=\n\t      TCL_OK) { \n\t       goto finished;\n\t  }\n\t  if (argc1 != 3) {\n\t       sprintf(interp->result, \"wrong # fields in tl_data \"\n\t\t       \"(%d should be 3)\", argc1);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  if ((retcode = Tcl_GetInt(interp, argv1[0], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing tl_data_type\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_type = tmp;\n\t  if ((retcode = Tcl_GetInt(interp, argv1[1], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing tl_data_length\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_length = tmp;\n\t  if (tl->tl_data_length != strlen(argv1[2])) {\n\t       sprintf(interp->result, \"specified length %d does not \"\n\t\t       \"match length %d of string \\\"%s\\\"\", tmp,\n\t\t       strlen(argv1[2]), argv1[2]);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_contents = (krb5_octet *) malloc(tmp+1);\n\t  strcpy((char *) tl->tl_data_contents, argv1[2]);\n\n\t  free(argv1);\n\t  argv1 = NULL;\n\t  tl = tl->tl_data_next;\n     }\n     if (tl != NULL) {\n\t  sprintf(interp->result, \"tl is not NULL!\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     *tlp = tl2;\n\nfinished:\n     if (argv1)\n\t  free(argv1);\n     free(argv);\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"tl is not NULL!\""
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "(char *) tl->tl_data_contents",
            "argv1[2]"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "tmp+1"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"specified length %d does not \"\n\t\t       \"match length %d of string \\\"%s\\\"\"",
            "tmp",
            "strlen(argv1[2])",
            "argv1[2]"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv1[2]"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv1[2]"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing tl_data_length\""
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv1[1]",
            "&tmp"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing tl_data_type\""
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv1[0]",
            "&tmp"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"wrong # fields in tl_data \"\n\t\t       \"(%d should be 3)\"",
            "argc1"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SplitList",
          "args": [
            "interp",
            "argv[i]",
            "&argc1",
            "&argv1"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tl2",
            "0",
            "sizeof(krb5_tl_data)"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(krb5_tl_data)"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"%d tl_datas specified, \"\n\t\t  \"but n_tl_data is %d\"",
            "argc",
            "n_tl_data"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SplitList",
          "args": [
            "interp",
            "list",
            "&argc",
            "&argv"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"0 tl_datas specified, \"\n\t\t       \"but n_tl_data is %d\"",
            "n_tl_data"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_tl_data(Tcl_Interp *interp, char *list,\n\t\t\t krb5_tl_data **tlp,\n\t\t\t int n_tl_data)\n{\n     krb5_tl_data *tl, *tl2;\n     char **argv, **argv1 = NULL;\n     int i, tmp, argc, argc1, retcode;\n\n     *tlp = NULL;\n     if (list == NULL) {\n\t  if (n_tl_data != 0) {\n\t       sprintf(interp->result, \"0 tl_datas specified, \"\n\t\t       \"but n_tl_data is %d\", n_tl_data);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  } else\n\t       return TCL_OK;\n     }\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != n_tl_data) {\n\t  sprintf(interp->result, \"%d tl_datas specified, \"\n\t\t  \"but n_tl_data is %d\", argc, n_tl_data);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     tl = tl2 = NULL;\n     for (i = 0; i < n_tl_data; i++) {\n\t  tl2 = (krb5_tl_data *) malloc(sizeof(krb5_tl_data));\n\t  memset(tl2, 0, sizeof(krb5_tl_data));\n\t  tl2->tl_data_next = tl;\n\t  tl = tl2;\n     }\n     tl2 = tl;\n\t  \n     for (i = 0; i < n_tl_data; i++) {\n\t  if ((retcode = Tcl_SplitList(interp, argv[i], &argc1, &argv1)) !=\n\t      TCL_OK) { \n\t       goto finished;\n\t  }\n\t  if (argc1 != 3) {\n\t       sprintf(interp->result, \"wrong # fields in tl_data \"\n\t\t       \"(%d should be 3)\", argc1);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  if ((retcode = Tcl_GetInt(interp, argv1[0], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing tl_data_type\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_type = tmp;\n\t  if ((retcode = Tcl_GetInt(interp, argv1[1], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing tl_data_length\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_length = tmp;\n\t  if (tl->tl_data_length != strlen(argv1[2])) {\n\t       sprintf(interp->result, \"specified length %d does not \"\n\t\t       \"match length %d of string \\\"%s\\\"\", tmp,\n\t\t       strlen(argv1[2]), argv1[2]);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  tl->tl_data_contents = (krb5_octet *) malloc(tmp+1);\n\t  strcpy((char *) tl->tl_data_contents, argv1[2]);\n\n\t  free(argv1);\n\t  argv1 = NULL;\n\t  tl = tl->tl_data_next;\n     }\n     if (tl != NULL) {\n\t  sprintf(interp->result, \"tl is not NULL!\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     *tlp = tl2;\n\nfinished:\n     if (argv1)\n\t  free(argv1);\n     free(argv);\n     return retcode;\n}"
  },
  {
    "function_name": "parse_key_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "846-883",
    "snippet": "static int parse_key_data(Tcl_Interp *interp, char *list,\n\t\t\t  krb5_key_data **key_data,\n\t\t\t  int n_key_data)\n{\n     char **argv;\n     int argc, retcode;\n\n     *key_data = NULL;\n     if (list == NULL) {\n\t  if (n_key_data != 0) {\n\t       sprintf(interp->result, \"0 key_datas specified, \"\n\t\t       \"but n_key_data is %d\", n_key_data);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  } else\n\t       return TCL_OK;\n     }\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != n_key_data) {\n\t  sprintf(interp->result, \"%d key_datas specified, \"\n\t\t  \"but n_key_data is %d\", argc, n_key_data);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (argc != 0) {\n\t  sprintf(interp->result, \"cannot parse key_data yet\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     free(argv);\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"cannot parse key_data yet\""
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"%d key_datas specified, \"\n\t\t  \"but n_key_data is %d\"",
            "argc",
            "n_key_data"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SplitList",
          "args": [
            "interp",
            "list",
            "&argc",
            "&argv"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"0 key_datas specified, \"\n\t\t       \"but n_key_data is %d\"",
            "n_key_data"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_key_data(Tcl_Interp *interp, char *list,\n\t\t\t  krb5_key_data **key_data,\n\t\t\t  int n_key_data)\n{\n     char **argv;\n     int argc, retcode;\n\n     *key_data = NULL;\n     if (list == NULL) {\n\t  if (n_key_data != 0) {\n\t       sprintf(interp->result, \"0 key_datas specified, \"\n\t\t       \"but n_key_data is %d\", n_key_data);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  } else\n\t       return TCL_OK;\n     }\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != n_key_data) {\n\t  sprintf(interp->result, \"%d key_datas specified, \"\n\t\t  \"but n_key_data is %d\", argc, n_key_data);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\n     if (argc != 0) {\n\t  sprintf(interp->result, \"cannot parse key_data yet\");\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n\nfinished:\n     free(argv);\n     return retcode;\n}"
  },
  {
    "function_name": "parse_keysalts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "787-844",
    "snippet": "static int parse_keysalts(Tcl_Interp *interp, char *list,\n\t\t\t  krb5_key_salt_tuple **keysalts,\n\t\t\t  int num_keysalts)\n{\n     char **argv, **argv1 = NULL;\n     int i, tmp, argc, argc1, retcode;\n\n     *keysalts = NULL;\n     if (list == NULL)\n\t  return TCL_OK;\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != num_keysalts) {\n\t  sprintf(interp->result, \"%d keysalts specified, \"\n\t\t  \"but num_keysalts is %d\", argc, num_keysalts);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     *keysalts = (krb5_key_salt_tuple *)\n\t  malloc(sizeof(krb5_key_salt_tuple)*num_keysalts);\n     for (i = 0; i < num_keysalts; i++) {\n\t  if ((retcode = Tcl_SplitList(interp, argv[i], &argc1, &argv1)) !=\n\t      TCL_OK) { \n\t       goto finished;\n\t  }\n\t  if (argc1 != 2) {\n\t       sprintf(interp->result, \"wrong # fields in keysalt \"\n\t\t       \"(%d should be 2)\", argc1);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  /* XXX this used to be argv1[1] too! */\n\t  if ((retcode = Tcl_GetInt(interp, argv1[0], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing ks_enctype\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  (*keysalts)[i].ks_enctype = tmp;\n\t  if ((retcode = Tcl_GetInt(interp, argv1[1], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing ks_salttype\");\n\t       goto finished;\n\t  }\n\t  (*keysalts)[i].ks_salttype = tmp;\n\n\t  free(argv1);\n\t  argv1 = NULL;\n     }\n\nfinished:\n     if (argv1)\n\t  free(argv1);\n     free(argv);\n     return retcode;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing ks_salttype\""
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv1[1]",
            "&tmp"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"while parsing ks_enctype\""
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "argv1[0]",
            "&tmp"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"wrong # fields in keysalt \"\n\t\t       \"(%d should be 2)\"",
            "argc1"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SplitList",
          "args": [
            "interp",
            "argv[i]",
            "&argc1",
            "&argv1"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(krb5_key_salt_tuple)*num_keysalts"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "interp->result",
            "\"%d keysalts specified, \"\n\t\t  \"but num_keysalts is %d\"",
            "argc",
            "num_keysalts"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SplitList",
          "args": [
            "interp",
            "list",
            "&argc",
            "&argv"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_keysalts(Tcl_Interp *interp, char *list,\n\t\t\t  krb5_key_salt_tuple **keysalts,\n\t\t\t  int num_keysalts)\n{\n     char **argv, **argv1 = NULL;\n     int i, tmp, argc, argc1, retcode;\n\n     *keysalts = NULL;\n     if (list == NULL)\n\t  return TCL_OK;\n     \n     if ((retcode = Tcl_SplitList(interp, list, &argc, &argv)) != TCL_OK) {\n\t  return retcode;\n     }\n     if (argc != num_keysalts) {\n\t  sprintf(interp->result, \"%d keysalts specified, \"\n\t\t  \"but num_keysalts is %d\", argc, num_keysalts);\n\t  retcode = TCL_ERROR;\n\t  goto finished;\n     }\n     *keysalts = (krb5_key_salt_tuple *)\n\t  malloc(sizeof(krb5_key_salt_tuple)*num_keysalts);\n     for (i = 0; i < num_keysalts; i++) {\n\t  if ((retcode = Tcl_SplitList(interp, argv[i], &argc1, &argv1)) !=\n\t      TCL_OK) { \n\t       goto finished;\n\t  }\n\t  if (argc1 != 2) {\n\t       sprintf(interp->result, \"wrong # fields in keysalt \"\n\t\t       \"(%d should be 2)\", argc1);\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  /* XXX this used to be argv1[1] too! */\n\t  if ((retcode = Tcl_GetInt(interp, argv1[0], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing ks_enctype\");\n\t       retcode = TCL_ERROR;\n\t       goto finished;\n\t  }\n\t  (*keysalts)[i].ks_enctype = tmp;\n\t  if ((retcode = Tcl_GetInt(interp, argv1[1], &tmp))\n\t      != TCL_OK) {\n\t       Tcl_AppendElement(interp, \"while parsing ks_salttype\");\n\t       goto finished;\n\t  }\n\t  (*keysalts)[i].ks_salttype = tmp;\n\n\t  free(argv1);\n\t  argv1 = NULL;\n     }\n\nfinished:\n     if (argv1)\n\t  free(argv1);\n     free(argv);\n     return retcode;\n}"
  },
  {
    "function_name": "unparse_principal_ent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "666-785",
    "snippet": "static Tcl_DString *unparse_principal_ent(kadm5_principal_ent_t princ,\n\t\t\t\t\t  krb5_int32 mask)\n{\n     Tcl_DString *str, *tmp_dstring;\n     char *tmp;\n     char buf[20];\n     krb5_error_code krb5_ret;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     tmp = 0; /* It looks to me from looking at the library source */\n\t      /* code for krb5_parse_name that the pointer passed into */\n\t      /* it should be initialized to 0 if I want it do be */\n\t      /* allocated automatically. */\n     if (mask & KADM5_PRINCIPAL) {\n          krb5_ret = krb5_unparse_name(context, princ->principal, &tmp);\n\t  if (krb5_ret) {\n\t       /* XXX Do we want to return an error?  Not sure. */\n\t       Tcl_DStringAppendElement(str, \"[unparseable principal]\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, tmp);\n\t       free(tmp);\n\t  }\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->princ_expire_time);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_pwd_change);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->pw_expiration);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->max_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     tmp = 0;\n     if (mask & KADM5_MOD_NAME) {\n\t  if ((krb5_ret = krb5_unparse_name(context, princ->mod_name, &tmp))) {\n\t       /* XXX */\n\t       Tcl_DStringAppendElement(str, \"[unparseable principal]\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, tmp);\n\t       free(tmp);\n\t  }\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->mod_date);\n     Tcl_DStringAppendElement(str, buf);\n\n     if (mask & KADM5_ATTRIBUTES) {\n\t  tmp_dstring = unparse_krb5_flags(princ->attributes);\n\t  Tcl_DStringAppendElement(str, tmp_dstring->string);\n\t  Tcl_DStringFree(tmp_dstring);\n\t  free(tmp_dstring);\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->kvno);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->mkvno);\n     Tcl_DStringAppendElement(str, buf);\n\n     /* XXX This may be dangerous, because the contents of the policy */\n     /* field are undefined if the POLICY bit isn't set.  However, I */\n     /* think it's a bug for the field not to be null in that case */\n     /* anyway, so we should assume that it will be null so that we'll */\n     /* catch it if it isn't. */\n     \n     tmp_dstring = unparse_str(princ->policy);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     tmp_dstring = unparse_aux_attributes(princ->aux_attributes);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     sprintf(buf, \"%d\", princ->max_renewable_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_success);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_failed);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->fail_auth_count);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->n_key_data);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->n_tl_data);\n     Tcl_DStringAppendElement(str, buf);\n\n     tmp_dstring = unparse_key_data(princ->key_data, princ->n_key_data);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     tmp_dstring = unparse_tl_data(princ->tl_data, princ->n_tl_data);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n     \n     return str;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static krb5_context context;",
      "static struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "tmp_dstring"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "tmp_dstring"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "tmp_dstring->string"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_tl_data",
          "args": [
            "princ->tl_data",
            "princ->n_tl_data"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_tl_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "489-515",
          "snippet": "static Tcl_DString *unparse_tl_data(krb5_tl_data *tl_data, int n_tl_data)\n{\n     Tcl_DString *str;\n     char buf[2048];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n     Tcl_DStringStartSublist(str);\n     for (; tl_data; tl_data = tl_data->tl_data_next) {\n\t  Tcl_DStringStartSublist(str);\n\t  sprintf(buf, \"%d\", tl_data->tl_data_type);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  sprintf(buf, \"%d\", tl_data->tl_data_length);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  Tcl_DStringAppend(str, \" \", 1);\n\t  Tcl_DStringAppend(str, tl_data->tl_data_contents,\n\t\t\t    tl_data->tl_data_length);\n\t  Tcl_DStringEndSublist(str);\n     }\n     Tcl_DStringEndSublist(str);\n     \n     return str;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_tl_data(krb5_tl_data *tl_data, int n_tl_data)\n{\n     Tcl_DString *str;\n     char buf[2048];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n     Tcl_DStringStartSublist(str);\n     for (; tl_data; tl_data = tl_data->tl_data_next) {\n\t  Tcl_DStringStartSublist(str);\n\t  sprintf(buf, \"%d\", tl_data->tl_data_type);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  sprintf(buf, \"%d\", tl_data->tl_data_length);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  Tcl_DStringAppend(str, \" \", 1);\n\t  Tcl_DStringAppend(str, tl_data->tl_data_contents,\n\t\t\t    tl_data->tl_data_length);\n\t  Tcl_DStringEndSublist(str);\n     }\n     Tcl_DStringEndSublist(str);\n     \n     return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "tmp_dstring"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "tmp_dstring->string"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_key_data",
          "args": [
            "princ->key_data",
            "princ->n_key_data"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_key_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "454-487",
          "snippet": "static Tcl_DString *unparse_key_data(krb5_key_data *key_data, int n_key_data)\n{\n     Tcl_DString *str;\n     char buf[2048];\n     int i, j;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n     for (i = 0; i < n_key_data; i++) {\n\t  krb5_key_data *key = &key_data[i];\n\n\t  Tcl_DStringStartSublist(str);\n\t  sprintf(buf, \"%d\", key->key_data_type[0]);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  sprintf(buf, \"%d\", key->key_data_ver > 1 ?\n\t\t  key->key_data_type[1] : -1);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  if (key->key_data_contents[0]) {\n\t       sprintf(buf, \"0x\");\n\t       for (j = 0; j < key->key_data_length[0]; j++) {\n\t\t    sprintf(buf + 2*(j+1), \"%02x\",\n\t\t\t    key->key_data_contents[0][j]);\n\t       }\n\t  } else *buf = '\\0';\n\t  Tcl_DStringAppendElement(str, buf);\n\t  Tcl_DStringEndSublist(str);\n     }\n     \n     return str;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_key_data(krb5_key_data *key_data, int n_key_data)\n{\n     Tcl_DString *str;\n     char buf[2048];\n     int i, j;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n     for (i = 0; i < n_key_data; i++) {\n\t  krb5_key_data *key = &key_data[i];\n\n\t  Tcl_DStringStartSublist(str);\n\t  sprintf(buf, \"%d\", key->key_data_type[0]);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  sprintf(buf, \"%d\", key->key_data_ver > 1 ?\n\t\t  key->key_data_type[1] : -1);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  if (key->key_data_contents[0]) {\n\t       sprintf(buf, \"0x\");\n\t       for (j = 0; j < key->key_data_length[0]; j++) {\n\t\t    sprintf(buf + 2*(j+1), \"%02x\",\n\t\t\t    key->key_data_contents[0][j]);\n\t       }\n\t  } else *buf = '\\0';\n\t  Tcl_DStringAppendElement(str, buf);\n\t  Tcl_DStringEndSublist(str);\n     }\n     \n     return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->n_tl_data"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->n_key_data"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->fail_auth_count"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->last_failed"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->last_success"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->max_renewable_life"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "tmp_dstring"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "tmp_dstring->string"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_aux_attributes",
          "args": [
            "princ->aux_attributes"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_aux_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "607-611",
          "snippet": "static Tcl_DString *unparse_aux_attributes(krb5_int32 flags)\n{\n     return unparse_flags(aux_attributes, sizeof(aux_attributes) /\n\t\t\t  sizeof(struct flagval), flags);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};\n\nstatic Tcl_DString *unparse_aux_attributes(krb5_int32 flags)\n{\n     return unparse_flags(aux_attributes, sizeof(aux_attributes) /\n\t\t\t  sizeof(struct flagval), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "tmp_dstring"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "tmp_dstring->string"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_str",
          "args": [
            "princ->policy"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "225-244",
          "snippet": "static Tcl_DString *unparse_str(char *in_str)\n{\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     if (! in_str) {\n\t  Tcl_DStringAppend(str, \"null\", -1);\n     }\n     else {\n\t  Tcl_DStringAppend(str, in_str, -1);\n     }\n\n     return str;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_str(char *in_str)\n{\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     if (! in_str) {\n\t  Tcl_DStringAppend(str, \"null\", -1);\n     }\n     else {\n\t  Tcl_DStringAppend(str, in_str, -1);\n     }\n\n     return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->mkvno"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->kvno"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "\"null\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "tmp_dstring"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "tmp_dstring->string"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_krb5_flags",
          "args": [
            "princ->attributes"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_krb5_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "584-588",
          "snippet": "static Tcl_DString *unparse_krb5_flags(krb5_flags flags)\n{\n     return unparse_flags(krb5_flags_array, sizeof(krb5_flags_array) /\n\t\t\t  sizeof(struct flagval), flags);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct flagval krb5_flags_array[] = {\n     {\"KRB5_KDB_DISALLOW_POSTDATED\", KRB5_KDB_DISALLOW_POSTDATED},\n     {\"KRB5_KDB_DISALLOW_FORWARDABLE\", KRB5_KDB_DISALLOW_FORWARDABLE},\n     {\"KRB5_KDB_DISALLOW_TGT_BASED\", KRB5_KDB_DISALLOW_TGT_BASED},\n     {\"KRB5_KDB_DISALLOW_RENEWABLE\", KRB5_KDB_DISALLOW_RENEWABLE},\n     {\"KRB5_KDB_DISALLOW_PROXIABLE\", KRB5_KDB_DISALLOW_PROXIABLE},\n     {\"KRB5_KDB_DISALLOW_DUP_SKEY\", KRB5_KDB_DISALLOW_DUP_SKEY},\n     {\"KRB5_KDB_DISALLOW_ALL_TIX\", KRB5_KDB_DISALLOW_ALL_TIX},\n     {\"KRB5_KDB_REQUIRES_PRE_AUTH\", KRB5_KDB_REQUIRES_PRE_AUTH},\n     {\"KRB5_KDB_REQUIRES_HW_AUTH\", KRB5_KDB_REQUIRES_HW_AUTH},\n     {\"KRB5_KDB_REQUIRES_PWCHANGE\", KRB5_KDB_REQUIRES_PWCHANGE},\n     {\"KRB5_KDB_DISALLOW_SVR\", KRB5_KDB_DISALLOW_SVR},\n     {\"KRB5_KDB_PWCHANGE_SERVICE\", KRB5_KDB_PWCHANGE_SERVICE}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval krb5_flags_array[] = {\n     {\"KRB5_KDB_DISALLOW_POSTDATED\", KRB5_KDB_DISALLOW_POSTDATED},\n     {\"KRB5_KDB_DISALLOW_FORWARDABLE\", KRB5_KDB_DISALLOW_FORWARDABLE},\n     {\"KRB5_KDB_DISALLOW_TGT_BASED\", KRB5_KDB_DISALLOW_TGT_BASED},\n     {\"KRB5_KDB_DISALLOW_RENEWABLE\", KRB5_KDB_DISALLOW_RENEWABLE},\n     {\"KRB5_KDB_DISALLOW_PROXIABLE\", KRB5_KDB_DISALLOW_PROXIABLE},\n     {\"KRB5_KDB_DISALLOW_DUP_SKEY\", KRB5_KDB_DISALLOW_DUP_SKEY},\n     {\"KRB5_KDB_DISALLOW_ALL_TIX\", KRB5_KDB_DISALLOW_ALL_TIX},\n     {\"KRB5_KDB_REQUIRES_PRE_AUTH\", KRB5_KDB_REQUIRES_PRE_AUTH},\n     {\"KRB5_KDB_REQUIRES_HW_AUTH\", KRB5_KDB_REQUIRES_HW_AUTH},\n     {\"KRB5_KDB_REQUIRES_PWCHANGE\", KRB5_KDB_REQUIRES_PWCHANGE},\n     {\"KRB5_KDB_DISALLOW_SVR\", KRB5_KDB_DISALLOW_SVR},\n     {\"KRB5_KDB_PWCHANGE_SERVICE\", KRB5_KDB_PWCHANGE_SERVICE}\n};\n\nstatic Tcl_DString *unparse_krb5_flags(krb5_flags flags)\n{\n     return unparse_flags(krb5_flags_array, sizeof(krb5_flags_array) /\n\t\t\t  sizeof(struct flagval), flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->mod_date"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "\"null\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "tmp"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "\"[unparseable principal]\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "context",
            "princ->mod_name",
            "&tmp"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->max_life"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->pw_expiration"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->last_pwd_change"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "princ->princ_expire_time"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "\"null\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "tmp"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "\"[unparseable principal]\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "context",
            "princ->principal",
            "&tmp"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringInit",
          "args": [
            "str"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*str)"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic krb5_context context;\nstatic struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};\n\nstatic Tcl_DString *unparse_principal_ent(kadm5_principal_ent_t princ,\n\t\t\t\t\t  krb5_int32 mask)\n{\n     Tcl_DString *str, *tmp_dstring;\n     char *tmp;\n     char buf[20];\n     krb5_error_code krb5_ret;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     tmp = 0; /* It looks to me from looking at the library source */\n\t      /* code for krb5_parse_name that the pointer passed into */\n\t      /* it should be initialized to 0 if I want it do be */\n\t      /* allocated automatically. */\n     if (mask & KADM5_PRINCIPAL) {\n          krb5_ret = krb5_unparse_name(context, princ->principal, &tmp);\n\t  if (krb5_ret) {\n\t       /* XXX Do we want to return an error?  Not sure. */\n\t       Tcl_DStringAppendElement(str, \"[unparseable principal]\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, tmp);\n\t       free(tmp);\n\t  }\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->princ_expire_time);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_pwd_change);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->pw_expiration);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->max_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     tmp = 0;\n     if (mask & KADM5_MOD_NAME) {\n\t  if ((krb5_ret = krb5_unparse_name(context, princ->mod_name, &tmp))) {\n\t       /* XXX */\n\t       Tcl_DStringAppendElement(str, \"[unparseable principal]\");\n\t  }\n\t  else {\n\t       Tcl_DStringAppendElement(str, tmp);\n\t       free(tmp);\n\t  }\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->mod_date);\n     Tcl_DStringAppendElement(str, buf);\n\n     if (mask & KADM5_ATTRIBUTES) {\n\t  tmp_dstring = unparse_krb5_flags(princ->attributes);\n\t  Tcl_DStringAppendElement(str, tmp_dstring->string);\n\t  Tcl_DStringFree(tmp_dstring);\n\t  free(tmp_dstring);\n     } else\n\t  Tcl_DStringAppendElement(str, \"null\");\n\n     sprintf(buf, \"%d\", princ->kvno);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->mkvno);\n     Tcl_DStringAppendElement(str, buf);\n\n     /* XXX This may be dangerous, because the contents of the policy */\n     /* field are undefined if the POLICY bit isn't set.  However, I */\n     /* think it's a bug for the field not to be null in that case */\n     /* anyway, so we should assume that it will be null so that we'll */\n     /* catch it if it isn't. */\n     \n     tmp_dstring = unparse_str(princ->policy);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     tmp_dstring = unparse_aux_attributes(princ->aux_attributes);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     sprintf(buf, \"%d\", princ->max_renewable_life);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_success);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->last_failed);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->fail_auth_count);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->n_key_data);\n     Tcl_DStringAppendElement(str, buf);\n\n     sprintf(buf, \"%d\", princ->n_tl_data);\n     Tcl_DStringAppendElement(str, buf);\n\n     tmp_dstring = unparse_key_data(princ->key_data, princ->n_key_data);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n\n     tmp_dstring = unparse_tl_data(princ->tl_data, princ->n_tl_data);\n     Tcl_DStringAppendElement(str, tmp_dstring->string);\n     Tcl_DStringFree(tmp_dstring);\n     free(tmp_dstring);\n     \n     return str;\n}"
  },
  {
    "function_name": "parse_policy_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "648-663",
    "snippet": "static int parse_policy_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, policy_mask_flags,\n\t\t\t\tsizeof(policy_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct flagval policy_mask_flags[] = {\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_PW_MAX_LIFE\", KADM5_PW_MAX_LIFE},\n     {\"KADM5_PW_MIN_LIFE\", KADM5_PW_MIN_LIFE},\n     {\"KADM5_PW_MIN_LENGTH\", KADM5_PW_MIN_LENGTH},\n     {\"KADM5_PW_MIN_CLASSES\", KADM5_PW_MIN_CLASSES},\n     {\"KADM5_PW_HISTORY_NUM\", KADM5_PW_HISTORY_NUM},\n     {\"KADM5_REF_COUNT\", KADM5_REF_COUNT}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_flags",
          "args": [
            "interp",
            "table",
            "policy_mask_flags",
            "sizeof(policy_mask_flags) /\n\t\t\t\tsizeof(struct flagval)",
            "str",
            "&tmp"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "parse_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "540-575",
          "snippet": "static int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval policy_mask_flags[] = {\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_PW_MAX_LIFE\", KADM5_PW_MAX_LIFE},\n     {\"KADM5_PW_MIN_LIFE\", KADM5_PW_MIN_LIFE},\n     {\"KADM5_PW_MIN_LENGTH\", KADM5_PW_MIN_LENGTH},\n     {\"KADM5_PW_MIN_CLASSES\", KADM5_PW_MIN_CLASSES},\n     {\"KADM5_PW_HISTORY_NUM\", KADM5_PW_HISTORY_NUM},\n     {\"KADM5_REF_COUNT\", KADM5_REF_COUNT}\n};\n\nstatic int parse_policy_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, policy_mask_flags,\n\t\t\t\tsizeof(policy_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
  },
  {
    "function_name": "parse_principal_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "631-646",
    "snippet": "static int parse_principal_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, principal_mask_flags,\n\t\t\t\tsizeof(principal_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct flagval principal_mask_flags[] = {\n     {\"KADM5_PRINCIPAL\", KADM5_PRINCIPAL},\n     {\"KADM5_PRINC_EXPIRE_TIME\", KADM5_PRINC_EXPIRE_TIME},\n     {\"KADM5_PW_EXPIRATION\", KADM5_PW_EXPIRATION},\n     {\"KADM5_LAST_PWD_CHANGE\", KADM5_LAST_PWD_CHANGE},\n     {\"KADM5_ATTRIBUTES\", KADM5_ATTRIBUTES},\n     {\"KADM5_MAX_LIFE\", KADM5_MAX_LIFE},\n     {\"KADM5_MOD_TIME\", KADM5_MOD_TIME},\n     {\"KADM5_MOD_NAME\", KADM5_MOD_NAME},\n     {\"KADM5_KVNO\", KADM5_KVNO},\n     {\"KADM5_MKVNO\", KADM5_MKVNO},\n     {\"KADM5_AUX_ATTRIBUTES\", KADM5_AUX_ATTRIBUTES},\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_POLICY_CLR\", KADM5_POLICY_CLR},\n     {\"KADM5_MAX_RLIFE\", KADM5_MAX_RLIFE},\n     {\"KADM5_LAST_SUCCESS\", KADM5_LAST_SUCCESS},\n     {\"KADM5_LAST_FAILED\", KADM5_LAST_FAILED},\n     {\"KADM5_FAIL_AUTH_COUNT\", KADM5_FAIL_AUTH_COUNT},\n     {\"KADM5_KEY_DATA\", KADM5_KEY_DATA},\n     {\"KADM5_TL_DATA\", KADM5_TL_DATA},\n     {\"KADM5_PRINCIPAL_NORMAL_MASK\", KADM5_PRINCIPAL_NORMAL_MASK}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_flags",
          "args": [
            "interp",
            "table",
            "principal_mask_flags",
            "sizeof(principal_mask_flags) /\n\t\t\t\tsizeof(struct flagval)",
            "str",
            "&tmp"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "parse_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "540-575",
          "snippet": "static int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval principal_mask_flags[] = {\n     {\"KADM5_PRINCIPAL\", KADM5_PRINCIPAL},\n     {\"KADM5_PRINC_EXPIRE_TIME\", KADM5_PRINC_EXPIRE_TIME},\n     {\"KADM5_PW_EXPIRATION\", KADM5_PW_EXPIRATION},\n     {\"KADM5_LAST_PWD_CHANGE\", KADM5_LAST_PWD_CHANGE},\n     {\"KADM5_ATTRIBUTES\", KADM5_ATTRIBUTES},\n     {\"KADM5_MAX_LIFE\", KADM5_MAX_LIFE},\n     {\"KADM5_MOD_TIME\", KADM5_MOD_TIME},\n     {\"KADM5_MOD_NAME\", KADM5_MOD_NAME},\n     {\"KADM5_KVNO\", KADM5_KVNO},\n     {\"KADM5_MKVNO\", KADM5_MKVNO},\n     {\"KADM5_AUX_ATTRIBUTES\", KADM5_AUX_ATTRIBUTES},\n     {\"KADM5_POLICY\", KADM5_POLICY},\n     {\"KADM5_POLICY_CLR\", KADM5_POLICY_CLR},\n     {\"KADM5_MAX_RLIFE\", KADM5_MAX_RLIFE},\n     {\"KADM5_LAST_SUCCESS\", KADM5_LAST_SUCCESS},\n     {\"KADM5_LAST_FAILED\", KADM5_LAST_FAILED},\n     {\"KADM5_FAIL_AUTH_COUNT\", KADM5_FAIL_AUTH_COUNT},\n     {\"KADM5_KEY_DATA\", KADM5_KEY_DATA},\n     {\"KADM5_TL_DATA\", KADM5_TL_DATA},\n     {\"KADM5_PRINCIPAL_NORMAL_MASK\", KADM5_PRINCIPAL_NORMAL_MASK}\n};\n\nstatic int parse_principal_mask(Tcl_Interp *interp, char *str, krb5_int32 *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, principal_mask_flags,\n\t\t\t\tsizeof(principal_mask_flags) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
  },
  {
    "function_name": "parse_aux_attributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "614-629",
    "snippet": "static int parse_aux_attributes(Tcl_Interp *interp, char *str, long *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, aux_attributes,\n\t\t\t\tsizeof(aux_attributes) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_flags",
          "args": [
            "interp",
            "table",
            "aux_attributes",
            "sizeof(aux_attributes) /\n\t\t\t\tsizeof(struct flagval)",
            "str",
            "&tmp"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "parse_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "540-575",
          "snippet": "static int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};\n\nstatic int parse_aux_attributes(Tcl_Interp *interp, char *str, long *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, aux_attributes,\n\t\t\t\tsizeof(aux_attributes) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
  },
  {
    "function_name": "unparse_aux_attributes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "607-611",
    "snippet": "static Tcl_DString *unparse_aux_attributes(krb5_int32 flags)\n{\n     return unparse_flags(aux_attributes, sizeof(aux_attributes) /\n\t\t\t  sizeof(struct flagval), flags);\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unparse_flags",
          "args": [
            "aux_attributes",
            "sizeof(aux_attributes) /\n\t\t\t  sizeof(struct flagval)",
            "flags"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "517-537",
          "snippet": "static Tcl_DString *unparse_flags(struct flagval *array, int size,\n\t\t\t\t  krb5_int32 flags)\n{\n     int i;\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (i = 0; i < size; i++) {\n\t  if (flags & array[i].val) {\n\t       Tcl_DStringAppendElement(str, array[i].name);\n\t  }\n     }\n\n     return str;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_flags(struct flagval *array, int size,\n\t\t\t\t  krb5_int32 flags)\n{\n     int i;\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (i = 0; i < size; i++) {\n\t  if (flags & array[i].val) {\n\t       Tcl_DStringAppendElement(str, array[i].name);\n\t  }\n     }\n\n     return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval aux_attributes[] = {\n     {\"KADM5_POLICY\",   KADM5_POLICY}\n};\n\nstatic Tcl_DString *unparse_aux_attributes(krb5_int32 flags)\n{\n     return unparse_flags(aux_attributes, sizeof(aux_attributes) /\n\t\t\t  sizeof(struct flagval), flags);\n}"
  },
  {
    "function_name": "parse_krb5_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "590-605",
    "snippet": "static int parse_krb5_flags(Tcl_Interp *interp, char *str, krb5_flags *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, krb5_flags_array,\n\t\t\t\tsizeof(krb5_flags_array) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct flagval krb5_flags_array[] = {\n     {\"KRB5_KDB_DISALLOW_POSTDATED\", KRB5_KDB_DISALLOW_POSTDATED},\n     {\"KRB5_KDB_DISALLOW_FORWARDABLE\", KRB5_KDB_DISALLOW_FORWARDABLE},\n     {\"KRB5_KDB_DISALLOW_TGT_BASED\", KRB5_KDB_DISALLOW_TGT_BASED},\n     {\"KRB5_KDB_DISALLOW_RENEWABLE\", KRB5_KDB_DISALLOW_RENEWABLE},\n     {\"KRB5_KDB_DISALLOW_PROXIABLE\", KRB5_KDB_DISALLOW_PROXIABLE},\n     {\"KRB5_KDB_DISALLOW_DUP_SKEY\", KRB5_KDB_DISALLOW_DUP_SKEY},\n     {\"KRB5_KDB_DISALLOW_ALL_TIX\", KRB5_KDB_DISALLOW_ALL_TIX},\n     {\"KRB5_KDB_REQUIRES_PRE_AUTH\", KRB5_KDB_REQUIRES_PRE_AUTH},\n     {\"KRB5_KDB_REQUIRES_HW_AUTH\", KRB5_KDB_REQUIRES_HW_AUTH},\n     {\"KRB5_KDB_REQUIRES_PWCHANGE\", KRB5_KDB_REQUIRES_PWCHANGE},\n     {\"KRB5_KDB_DISALLOW_SVR\", KRB5_KDB_DISALLOW_SVR},\n     {\"KRB5_KDB_PWCHANGE_SERVICE\", KRB5_KDB_PWCHANGE_SERVICE}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_flags",
          "args": [
            "interp",
            "table",
            "krb5_flags_array",
            "sizeof(krb5_flags_array) /\n\t\t\t\tsizeof(struct flagval)",
            "str",
            "&tmp"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "parse_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "540-575",
          "snippet": "static int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval krb5_flags_array[] = {\n     {\"KRB5_KDB_DISALLOW_POSTDATED\", KRB5_KDB_DISALLOW_POSTDATED},\n     {\"KRB5_KDB_DISALLOW_FORWARDABLE\", KRB5_KDB_DISALLOW_FORWARDABLE},\n     {\"KRB5_KDB_DISALLOW_TGT_BASED\", KRB5_KDB_DISALLOW_TGT_BASED},\n     {\"KRB5_KDB_DISALLOW_RENEWABLE\", KRB5_KDB_DISALLOW_RENEWABLE},\n     {\"KRB5_KDB_DISALLOW_PROXIABLE\", KRB5_KDB_DISALLOW_PROXIABLE},\n     {\"KRB5_KDB_DISALLOW_DUP_SKEY\", KRB5_KDB_DISALLOW_DUP_SKEY},\n     {\"KRB5_KDB_DISALLOW_ALL_TIX\", KRB5_KDB_DISALLOW_ALL_TIX},\n     {\"KRB5_KDB_REQUIRES_PRE_AUTH\", KRB5_KDB_REQUIRES_PRE_AUTH},\n     {\"KRB5_KDB_REQUIRES_HW_AUTH\", KRB5_KDB_REQUIRES_HW_AUTH},\n     {\"KRB5_KDB_REQUIRES_PWCHANGE\", KRB5_KDB_REQUIRES_PWCHANGE},\n     {\"KRB5_KDB_DISALLOW_SVR\", KRB5_KDB_DISALLOW_SVR},\n     {\"KRB5_KDB_PWCHANGE_SERVICE\", KRB5_KDB_PWCHANGE_SERVICE}\n};\n\nstatic int parse_krb5_flags(Tcl_Interp *interp, char *str, krb5_flags *flags)\n{\n     krb5_flags tmp;\n     static Tcl_HashTable *table = 0;\n     int tcl_ret;\n     \n     if ((tcl_ret = parse_flags(interp, table, krb5_flags_array,\n\t\t\t\tsizeof(krb5_flags_array) /\n\t\t\t\tsizeof(struct flagval),\n\t\t\t\tstr, &tmp)) != TCL_OK) {\n\t  return tcl_ret;\n     }\n\n     *flags = tmp;\n     return TCL_OK;\n}"
  },
  {
    "function_name": "unparse_krb5_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "584-588",
    "snippet": "static Tcl_DString *unparse_krb5_flags(krb5_flags flags)\n{\n     return unparse_flags(krb5_flags_array, sizeof(krb5_flags_array) /\n\t\t\t  sizeof(struct flagval), flags);\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct flagval krb5_flags_array[] = {\n     {\"KRB5_KDB_DISALLOW_POSTDATED\", KRB5_KDB_DISALLOW_POSTDATED},\n     {\"KRB5_KDB_DISALLOW_FORWARDABLE\", KRB5_KDB_DISALLOW_FORWARDABLE},\n     {\"KRB5_KDB_DISALLOW_TGT_BASED\", KRB5_KDB_DISALLOW_TGT_BASED},\n     {\"KRB5_KDB_DISALLOW_RENEWABLE\", KRB5_KDB_DISALLOW_RENEWABLE},\n     {\"KRB5_KDB_DISALLOW_PROXIABLE\", KRB5_KDB_DISALLOW_PROXIABLE},\n     {\"KRB5_KDB_DISALLOW_DUP_SKEY\", KRB5_KDB_DISALLOW_DUP_SKEY},\n     {\"KRB5_KDB_DISALLOW_ALL_TIX\", KRB5_KDB_DISALLOW_ALL_TIX},\n     {\"KRB5_KDB_REQUIRES_PRE_AUTH\", KRB5_KDB_REQUIRES_PRE_AUTH},\n     {\"KRB5_KDB_REQUIRES_HW_AUTH\", KRB5_KDB_REQUIRES_HW_AUTH},\n     {\"KRB5_KDB_REQUIRES_PWCHANGE\", KRB5_KDB_REQUIRES_PWCHANGE},\n     {\"KRB5_KDB_DISALLOW_SVR\", KRB5_KDB_DISALLOW_SVR},\n     {\"KRB5_KDB_PWCHANGE_SERVICE\", KRB5_KDB_PWCHANGE_SERVICE}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unparse_flags",
          "args": [
            "krb5_flags_array",
            "sizeof(krb5_flags_array) /\n\t\t\t  sizeof(struct flagval)",
            "flags"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "517-537",
          "snippet": "static Tcl_DString *unparse_flags(struct flagval *array, int size,\n\t\t\t\t  krb5_int32 flags)\n{\n     int i;\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (i = 0; i < size; i++) {\n\t  if (flags & array[i].val) {\n\t       Tcl_DStringAppendElement(str, array[i].name);\n\t  }\n     }\n\n     return str;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_flags(struct flagval *array, int size,\n\t\t\t\t  krb5_int32 flags)\n{\n     int i;\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (i = 0; i < size; i++) {\n\t  if (flags & array[i].val) {\n\t       Tcl_DStringAppendElement(str, array[i].name);\n\t  }\n     }\n\n     return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval krb5_flags_array[] = {\n     {\"KRB5_KDB_DISALLOW_POSTDATED\", KRB5_KDB_DISALLOW_POSTDATED},\n     {\"KRB5_KDB_DISALLOW_FORWARDABLE\", KRB5_KDB_DISALLOW_FORWARDABLE},\n     {\"KRB5_KDB_DISALLOW_TGT_BASED\", KRB5_KDB_DISALLOW_TGT_BASED},\n     {\"KRB5_KDB_DISALLOW_RENEWABLE\", KRB5_KDB_DISALLOW_RENEWABLE},\n     {\"KRB5_KDB_DISALLOW_PROXIABLE\", KRB5_KDB_DISALLOW_PROXIABLE},\n     {\"KRB5_KDB_DISALLOW_DUP_SKEY\", KRB5_KDB_DISALLOW_DUP_SKEY},\n     {\"KRB5_KDB_DISALLOW_ALL_TIX\", KRB5_KDB_DISALLOW_ALL_TIX},\n     {\"KRB5_KDB_REQUIRES_PRE_AUTH\", KRB5_KDB_REQUIRES_PRE_AUTH},\n     {\"KRB5_KDB_REQUIRES_HW_AUTH\", KRB5_KDB_REQUIRES_HW_AUTH},\n     {\"KRB5_KDB_REQUIRES_PWCHANGE\", KRB5_KDB_REQUIRES_PWCHANGE},\n     {\"KRB5_KDB_DISALLOW_SVR\", KRB5_KDB_DISALLOW_SVR},\n     {\"KRB5_KDB_PWCHANGE_SERVICE\", KRB5_KDB_PWCHANGE_SERVICE}\n};\n\nstatic Tcl_DString *unparse_krb5_flags(krb5_flags flags)\n{\n     return unparse_flags(krb5_flags_array, sizeof(krb5_flags_array) /\n\t\t\t  sizeof(struct flagval), flags);\n}"
  },
  {
    "function_name": "unparse_privs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "577-581",
    "snippet": "static Tcl_DString *unparse_privs(krb5_flags flags)\n{\n     return unparse_flags(priv_flags, sizeof(priv_flags) /\n\t\t\t  sizeof(struct flagval), flags);\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct flagval priv_flags[] = {\n     {\"KADM5_PRIV_GET\", KADM5_PRIV_GET},\n     {\"KADM5_PRIV_ADD\", KADM5_PRIV_ADD},\n     {\"KADM5_PRIV_MODIFY\", KADM5_PRIV_MODIFY},\n     {\"KADM5_PRIV_DELETE\", KADM5_PRIV_DELETE}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unparse_flags",
          "args": [
            "priv_flags",
            "sizeof(priv_flags) /\n\t\t\t  sizeof(struct flagval)",
            "flags"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "517-537",
          "snippet": "static Tcl_DString *unparse_flags(struct flagval *array, int size,\n\t\t\t\t  krb5_int32 flags)\n{\n     int i;\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (i = 0; i < size; i++) {\n\t  if (flags & array[i].val) {\n\t       Tcl_DStringAppendElement(str, array[i].name);\n\t  }\n     }\n\n     return str;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_flags(struct flagval *array, int size,\n\t\t\t\t  krb5_int32 flags)\n{\n     int i;\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (i = 0; i < size; i++) {\n\t  if (flags & array[i].val) {\n\t       Tcl_DStringAppendElement(str, array[i].name);\n\t  }\n     }\n\n     return str;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic struct flagval priv_flags[] = {\n     {\"KADM5_PRIV_GET\", KADM5_PRIV_GET},\n     {\"KADM5_PRIV_ADD\", KADM5_PRIV_ADD},\n     {\"KADM5_PRIV_MODIFY\", KADM5_PRIV_MODIFY},\n     {\"KADM5_PRIV_DELETE\", KADM5_PRIV_DELETE}\n};\n\nstatic Tcl_DString *unparse_privs(krb5_flags flags)\n{\n     return unparse_flags(priv_flags, sizeof(priv_flags) /\n\t\t\t  sizeof(struct flagval), flags);\n}"
  },
  {
    "function_name": "parse_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "540-575",
    "snippet": "static int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "argv"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_GetHashValue",
          "args": [
            "entry"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendResult",
          "args": [
            "interp",
            "\"unknown krb5 flag \"",
            "argv[i]",
            "0"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_FindHashEntry",
          "args": [
            "table",
            "argv[i]"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_flag_table",
          "args": [
            "array",
            "size"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "create_flag_table",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "197-222",
          "snippet": "static Tcl_HashTable *create_flag_table(struct flagval *flags, int size)\n{\n     Tcl_HashTable *table;\n     Tcl_HashEntry *entry;\n     int i;\n\n     if (! (table = (Tcl_HashTable *) malloc(sizeof(Tcl_HashTable)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_InitHashTable(table, TCL_STRING_KEYS);\n\n     for (i = 0; i < size; i++) {\n\t  int newPtr;\n\t       \n\t  if (! (entry = Tcl_CreateHashEntry(table, flags[i].name, &newPtr))) {\n\t       fprintf(stderr, \"Out of memory!\\n\");\n\t       exit(1); /* XXX */\n\t  }\n\n\t  Tcl_SetHashValue(entry, &flags[i].val);\n     }\n\n     return table;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_HashTable *create_flag_table(struct flagval *flags, int size)\n{\n     Tcl_HashTable *table;\n     Tcl_HashEntry *entry;\n     int i;\n\n     if (! (table = (Tcl_HashTable *) malloc(sizeof(Tcl_HashTable)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_InitHashTable(table, TCL_STRING_KEYS);\n\n     for (i = 0; i < size; i++) {\n\t  int newPtr;\n\t       \n\t  if (! (entry = Tcl_CreateHashEntry(table, flags[i].name, &newPtr))) {\n\t       fprintf(stderr, \"Out of memory!\\n\");\n\t       exit(1); /* XXX */\n\t  }\n\n\t  Tcl_SetHashValue(entry, &flags[i].val);\n     }\n\n     return table;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_SplitList",
          "args": [
            "interp",
            "str",
            "&argc",
            "&argv"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_ResetResult",
          "args": [
            "interp"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_GetInt",
          "args": [
            "interp",
            "str",
            "&tmp"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_flags(Tcl_Interp *interp, Tcl_HashTable *table,\n\t\t       struct flagval *array, int size, char *str,\n\t\t       krb5_flags *flags)\n{\n     int tmp, argc, i, retcode = TCL_OK;\n     char **argv;\n     Tcl_HashEntry *entry;\n\n     if (Tcl_GetInt(interp, str, &tmp) == TCL_OK) {\n\t  *flags = tmp;\n\t  return TCL_OK;\n     }\n     Tcl_ResetResult(interp);\n\n     if (Tcl_SplitList(interp, str, &argc, &argv) != TCL_OK) {\n\t  return TCL_ERROR;\n     }\n\n     if (! table) {\n\t  table = create_flag_table(array, size);\n     }\n\n     *flags = 0;\n\n     for (i = 0; i < argc; i++) {\n\t  if (! (entry = Tcl_FindHashEntry(table, argv[i]))) {\n\t       Tcl_AppendResult(interp, \"unknown krb5 flag \", argv[i], 0);\n\t       retcode = TCL_ERROR;\n\t       break;\n\t  }\n\t  *flags |= *(krb5_flags *) Tcl_GetHashValue(entry);\n     }\n  \n     free(argv);\n     return(retcode);\n}"
  },
  {
    "function_name": "unparse_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "517-537",
    "snippet": "static Tcl_DString *unparse_flags(struct flagval *array, int size,\n\t\t\t\t  krb5_int32 flags)\n{\n     int i;\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (i = 0; i < size; i++) {\n\t  if (flags & array[i].val) {\n\t       Tcl_DStringAppendElement(str, array[i].name);\n\t  }\n     }\n\n     return str;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "array[i].name"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringInit",
          "args": [
            "str"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*str)"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_flags(struct flagval *array, int size,\n\t\t\t\t  krb5_int32 flags)\n{\n     int i;\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     for (i = 0; i < size; i++) {\n\t  if (flags & array[i].val) {\n\t       Tcl_DStringAppendElement(str, array[i].name);\n\t  }\n     }\n\n     return str;\n}"
  },
  {
    "function_name": "unparse_tl_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "489-515",
    "snippet": "static Tcl_DString *unparse_tl_data(krb5_tl_data *tl_data, int n_tl_data)\n{\n     Tcl_DString *str;\n     char buf[2048];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n     Tcl_DStringStartSublist(str);\n     for (; tl_data; tl_data = tl_data->tl_data_next) {\n\t  Tcl_DStringStartSublist(str);\n\t  sprintf(buf, \"%d\", tl_data->tl_data_type);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  sprintf(buf, \"%d\", tl_data->tl_data_length);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  Tcl_DStringAppend(str, \" \", 1);\n\t  Tcl_DStringAppend(str, tl_data->tl_data_contents,\n\t\t\t    tl_data->tl_data_length);\n\t  Tcl_DStringEndSublist(str);\n     }\n     Tcl_DStringEndSublist(str);\n     \n     return str;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_DStringEndSublist",
          "args": [
            "str"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringEndSublist",
          "args": [
            "str"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppend",
          "args": [
            "str",
            "tl_data->tl_data_contents",
            "tl_data->tl_data_length"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppend",
          "args": [
            "str",
            "\" \"",
            "1"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "tl_data->tl_data_length"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "tl_data->tl_data_type"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringStartSublist",
          "args": [
            "str"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringStartSublist",
          "args": [
            "str"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringInit",
          "args": [
            "str"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*str)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_tl_data(krb5_tl_data *tl_data, int n_tl_data)\n{\n     Tcl_DString *str;\n     char buf[2048];\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n     Tcl_DStringStartSublist(str);\n     for (; tl_data; tl_data = tl_data->tl_data_next) {\n\t  Tcl_DStringStartSublist(str);\n\t  sprintf(buf, \"%d\", tl_data->tl_data_type);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  sprintf(buf, \"%d\", tl_data->tl_data_length);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  Tcl_DStringAppend(str, \" \", 1);\n\t  Tcl_DStringAppend(str, tl_data->tl_data_contents,\n\t\t\t    tl_data->tl_data_length);\n\t  Tcl_DStringEndSublist(str);\n     }\n     Tcl_DStringEndSublist(str);\n     \n     return str;\n}"
  },
  {
    "function_name": "unparse_key_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "454-487",
    "snippet": "static Tcl_DString *unparse_key_data(krb5_key_data *key_data, int n_key_data)\n{\n     Tcl_DString *str;\n     char buf[2048];\n     int i, j;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n     for (i = 0; i < n_key_data; i++) {\n\t  krb5_key_data *key = &key_data[i];\n\n\t  Tcl_DStringStartSublist(str);\n\t  sprintf(buf, \"%d\", key->key_data_type[0]);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  sprintf(buf, \"%d\", key->key_data_ver > 1 ?\n\t\t  key->key_data_type[1] : -1);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  if (key->key_data_contents[0]) {\n\t       sprintf(buf, \"0x\");\n\t       for (j = 0; j < key->key_data_length[0]; j++) {\n\t\t    sprintf(buf + 2*(j+1), \"%02x\",\n\t\t\t    key->key_data_contents[0][j]);\n\t       }\n\t  } else *buf = '\\0';\n\t  Tcl_DStringAppendElement(str, buf);\n\t  Tcl_DStringEndSublist(str);\n     }\n     \n     return str;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_DStringEndSublist",
          "args": [
            "str"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf + 2*(j+1)",
            "\"%02x\"",
            "key->key_data_contents[0][j]"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"0x\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "key->key_data_ver > 1 ?\n\t\t  key->key_data_type[1] : -1"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "str",
            "buf"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\"",
            "key->key_data_type[0]"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringStartSublist",
          "args": [
            "str"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringInit",
          "args": [
            "str"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*str)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_key_data(krb5_key_data *key_data, int n_key_data)\n{\n     Tcl_DString *str;\n     char buf[2048];\n     int i, j;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n     for (i = 0; i < n_key_data; i++) {\n\t  krb5_key_data *key = &key_data[i];\n\n\t  Tcl_DStringStartSublist(str);\n\t  sprintf(buf, \"%d\", key->key_data_type[0]);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  sprintf(buf, \"%d\", key->key_data_ver > 1 ?\n\t\t  key->key_data_type[1] : -1);\n\t  Tcl_DStringAppendElement(str, buf);\n\t  if (key->key_data_contents[0]) {\n\t       sprintf(buf, \"0x\");\n\t       for (j = 0; j < key->key_data_length[0]; j++) {\n\t\t    sprintf(buf + 2*(j+1), \"%02x\",\n\t\t\t    key->key_data_contents[0][j]);\n\t       }\n\t  } else *buf = '\\0';\n\t  Tcl_DStringAppendElement(str, buf);\n\t  Tcl_DStringEndSublist(str);\n     }\n     \n     return str;\n}"
  },
  {
    "function_name": "stash_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "446-452",
    "snippet": "static void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "dstring"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "1484-1488",
          "snippet": "static void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(kadm5_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "Tcl_DStringFree",
          "args": [
            "dstring"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringResult",
          "args": [
            "interp",
            "dstring"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unparse_err",
          "args": [
            "code"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "unparse_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
          "lines": "272-442",
          "snippet": "static Tcl_DString *unparse_err(kadm5_ret_t code)\n{\n     char *code_string;\n     const char *error_string;\n     Tcl_DString *dstring;\n\n     switch (code) {\n     case KADM5_FAILURE: code_string = \"KADM5_FAILURE\"; break;\n     case KADM5_AUTH_GET: code_string = \"KADM5_AUTH_GET\"; break;\n     case KADM5_AUTH_ADD: code_string = \"KADM5_AUTH_ADD\"; break;\n     case KADM5_AUTH_MODIFY:\n\t  code_string = \"KADM5_AUTH_MODIFY\"; break;\n     case KADM5_AUTH_DELETE:\n\t  code_string = \"KADM5_AUTH_DELETE\"; break;\n     case KADM5_AUTH_INSUFFICIENT:\n\t  code_string = \"KADM5_AUTH_INSUFFICIENT\"; break;\n     case KADM5_BAD_DB: code_string = \"KADM5_BAD_DB\"; break;\n     case KADM5_DUP: code_string = \"KADM5_DUP\"; break;\n     case KADM5_RPC_ERROR: code_string = \"KADM5_RPC_ERROR\"; break;\n     case KADM5_NO_SRV: code_string = \"KADM5_NO_SRV\"; break;\n     case KADM5_BAD_HIST_KEY:\n\t  code_string = \"KADM5_BAD_HIST_KEY\"; break;\n     case KADM5_NOT_INIT: code_string = \"KADM5_NOT_INIT\"; break;\n     case KADM5_INIT: code_string = \"KADM5_INIT\"; break;\n     case KADM5_BAD_PASSWORD:\n\t  code_string = \"KADM5_BAD_PASSWORD\"; break;\n     case KADM5_UNK_PRINC: code_string = \"KADM5_UNK_PRINC\"; break;\n     case KADM5_UNK_POLICY: code_string = \"KADM5_UNK_POLICY\"; break;\n     case KADM5_BAD_MASK: code_string = \"KADM5_BAD_MASK\"; break;\n     case KADM5_BAD_CLASS: code_string = \"KADM5_BAD_CLASS\"; break;\n     case KADM5_BAD_LENGTH: code_string = \"KADM5_BAD_LENGTH\"; break;\n     case KADM5_BAD_POLICY: code_string = \"KADM5_BAD_POLICY\"; break;\n     case KADM5_BAD_HISTORY: code_string = \"KADM5_BAD_HISTORY\"; break;\n     case KADM5_BAD_PRINCIPAL:\n\t  code_string = \"KADM5_BAD_PRINCIPAL\"; break;\n     case KADM5_BAD_AUX_ATTR:\n\t  code_string = \"KADM5_BAD_AUX_ATTR\"; break;\n     case KADM5_PASS_Q_TOOSHORT:\n\t  code_string = \"KADM5_PASS_Q_TOOSHORT\"; break;\n     case KADM5_PASS_Q_CLASS:\n\t  code_string = \"KADM5_PASS_Q_CLASS\"; break;\n     case KADM5_PASS_Q_DICT:\n\t  code_string = \"KADM5_PASS_Q_DICT\"; break;\n     case KADM5_PASS_REUSE: code_string = \"KADM5_PASS_REUSE\"; break;\n     case KADM5_PASS_TOOSOON:\n\t  code_string = \"KADM5_PASS_TOOSOON\"; break;\n     case KADM5_POLICY_REF:\n\t  code_string = \"KADM5_POLICY_REF\"; break;\n     case KADM5_PROTECT_PRINCIPAL:\n\t  code_string = \"KADM5_PROTECT_PRINCIPAL\"; break;\n     case KADM5_BAD_SERVER_HANDLE:\n\t  code_string = \"KADM5_BAD_SERVER_HANDLE\"; break;\n     case KADM5_BAD_STRUCT_VERSION:\n     \t  code_string = \"KADM5_BAD_STRUCT_VERSION\"; break;\n     case KADM5_OLD_STRUCT_VERSION:\n\t  code_string = \"KADM5_OLD_STRUCT_VERSION\"; break;\n     case KADM5_NEW_STRUCT_VERSION:\n\t  code_string = \"KADM5_NEW_STRUCT_VERSION\"; break;\n     case KADM5_BAD_API_VERSION:\n\t  code_string = \"KADM5_BAD_API_VERSION\"; break;\n     case KADM5_OLD_LIB_API_VERSION:\n     \t  code_string = \"KADM5_OLD_LIB_API_VERSION\"; break;\n     case KADM5_OLD_SERVER_API_VERSION:\n     \t  code_string = \"KADM5_OLD_SERVER_API_VERSION\"; break;\n     case KADM5_NEW_LIB_API_VERSION:\n     \t  code_string = \"KADM5_NEW_LIB_API_VERSION\"; break;\n     case KADM5_NEW_SERVER_API_VERSION:\n\t  code_string = \"KADM5_NEW_SERVER_API_VERSION\"; break;\n     case KADM5_SECURE_PRINC_MISSING:\n\t  code_string = \"KADM5_SECURE_PRINC_MISSING\"; break;\n     case KADM5_NO_RENAME_SALT:\n\t  code_string = \"KADM5_NO_RENAME_SALT\"; break;\n     case KADM5_BAD_CLIENT_PARAMS:\n\t  code_string = \"KADM5_BAD_CLIENT_PARAMS\"; break;\n     case KADM5_BAD_SERVER_PARAMS:\n\t  code_string = \"KADM5_BAD_SERVER_PARAMS\"; break;\n     case KADM5_AUTH_LIST:\n\t  code_string = \"KADM5_AUTH_LIST\"; break;\n     case KADM5_AUTH_CHANGEPW:\n\t  code_string = \"KADM5_AUTH_CHANGEPW\"; break;\n     case KADM5_GSS_ERROR: code_string = \"KADM5_GSS_ERROR\"; break;\n     case KADM5_BAD_TL_TYPE: code_string = \"KADM5_BAD_TL_TYPE\"; break; \n     case KADM5_MISSING_CONF_PARAMS:\n\t  code_string = \"KADM5_MISSING_CONF_PARAMS\"; break;\n     case KADM5_BAD_SERVER_NAME:\n\t  code_string = \"KADM5_BAD_SERVER_NAME\"; break;\n     case KADM5_MISSING_KRB5_CONF_PARAMS:\n\t  code_string = \"KADM5_MISSING_KRB5_CONF_PARAMS\"; break;\n\n\n     case OSA_ADB_DUP: code_string = \"OSA_ADB_DUP\"; break;\n     case OSA_ADB_NOENT: code_string = \"ENOENT\"; break;\n     case OSA_ADB_DBINIT: code_string = \"OSA_ADB_DBINIT\"; break;\n     case OSA_ADB_BAD_POLICY: code_string = \"Bad policy name\"; break;\n     case OSA_ADB_BAD_PRINC: code_string = \"Bad principal name\"; break;\n     case OSA_ADB_BAD_DB: code_string = \"Invalid database.\"; break;\n     case OSA_ADB_XDR_FAILURE: code_string = \"OSA_ADB_XDR_FAILURE\"; break;\n     case OSA_ADB_BADLOCKMODE: code_string = \"OSA_ADB_BADLOCKMODE\"; break;\n     case OSA_ADB_CANTLOCK_DB: code_string = \"OSA_ADB_CANTLOCK_DB\"; break;\n     case OSA_ADB_NOTLOCKED: code_string = \"OSA_ADB_NOTLOCKED\"; break;\n     case OSA_ADB_NOLOCKFILE: code_string = \"OSA_ADB_NOLOCKFILE\"; break;\n     case OSA_ADB_NOEXCL_PERM: code_string = \"OSA_ADB_NOEXCL_PERM\"; break;\n\n     case KRB5_KDB_INUSE: code_string = \"KRB5_KDB_INUSE\"; break;\n     case KRB5_KDB_UK_SERROR: code_string = \"KRB5_KDB_UK_SERROR\"; break;\n     case KRB5_KDB_UK_RERROR: code_string = \"KRB5_KDB_UK_RERROR\"; break;\n     case KRB5_KDB_UNAUTH: code_string = \"KRB5_KDB_UNAUTH\"; break;\n     case KRB5_KDB_NOENTRY: code_string = \"KRB5_KDB_NOENTRY\"; break;\n     case KRB5_KDB_ILL_WILDCARD: code_string = \"KRB5_KDB_ILL_WILDCARD\"; break;\n     case KRB5_KDB_DB_INUSE: code_string = \"KRB5_KDB_DB_INUSE\"; break;\n     case KRB5_KDB_DB_CHANGED: code_string = \"KRB5_KDB_DB_CHANGED\"; break;\n     case KRB5_KDB_TRUNCATED_RECORD:\n\t  code_string = \"KRB5_KDB_TRUNCATED_RECORD\"; break;\n     case KRB5_KDB_RECURSIVELOCK:\n\t  code_string = \"KRB5_KDB_RECURSIVELOCK\"; break;\n     case KRB5_KDB_NOTLOCKED: code_string = \"KRB5_KDB_NOTLOCKED\"; break;\n     case KRB5_KDB_BADLOCKMODE: code_string = \"KRB5_KDB_BADLOCKMODE\"; break;\n     case KRB5_KDB_DBNOTINITED: code_string = \"KRB5_KDB_DBNOTINITED\"; break;\n     case KRB5_KDB_DBINITED: code_string = \"KRB5_KDB_DBINITED\"; break;\n     case KRB5_KDB_ILLDIRECTION: code_string = \"KRB5_KDB_ILLDIRECTION\"; break;\n     case KRB5_KDB_NOMASTERKEY: code_string = \"KRB5_KDB_NOMASTERKEY\"; break;\n     case KRB5_KDB_BADMASTERKEY: code_string = \"KRB5_KDB_BADMASTERKEY\"; break;\n     case KRB5_KDB_INVALIDKEYSIZE:\n\t  code_string = \"KRB5_KDB_INVALIDKEYSIZE\"; break;\n     case KRB5_KDB_CANTREAD_STORED:\n\t  code_string = \"KRB5_KDB_CANTREAD_STORED\"; break;\n     case KRB5_KDB_BADSTORED_MKEY:\n\t  code_string = \"KRB5_KDB_BADSTORED_MKEY\"; break;\n     case KRB5_KDB_CANTLOCK_DB: code_string = \"KRB5_KDB_CANTLOCK_DB\"; break;\n     case KRB5_KDB_DB_CORRUPT: code_string = \"KRB5_KDB_DB_CORRUPT\"; break;\n\n     case KRB5_PARSE_ILLCHAR: code_string = \"KRB5_PARSE_ILLCHAR\"; break;\n     case KRB5_PARSE_MALFORMED: code_string = \"KRB5_PARSE_MALFORMED\"; break;\n     case KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN: code_string = \"KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN\"; break;\n     case KRB5_REALM_UNKNOWN: code_string = \"KRB5_REALM_UNKNOWN\"; break;\n     case KRB5_KDC_UNREACH: code_string = \"KRB5_KDC_UNREACH\"; break;\n     case KRB5_KDCREP_MODIFIED: code_string = \"KRB5_KDCREP_MODIFIED\"; break;\n     case KRB5KRB_AP_ERR_BAD_INTEGRITY: code_string  = \"KRB5KRB_AP_ERR_BAD_INTEGRITY\"; break;\n     case KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN: code_string = \"KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN\"; break;\n     case KRB5_CONFIG_BADFORMAT: code_string = \"KRB5_CONFIG_BADFORMAT\"; break;\n\n     case EINVAL: code_string = \"EINVAL\"; break;\n     case ENOENT: code_string = \"ENOENT\"; break;\n\n     default:\n\t fprintf(stderr, \"**** CODE %d (%s) ***\\n\", code,\n\t\t error_message (code));\n\t code_string = \"UNKNOWN\";\n\t break;\n     }\n\n     error_string = error_message(code);\n\n     if (! (dstring = (Tcl_DString *) malloc(sizeof(Tcl_DString)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX Do we really want to exit?  Ok if this is */\n\t\t   /* just a test program, but what about if it gets */\n\t\t   /* used for other things later? */\n     }\n\n     Tcl_DStringInit(dstring);\n\n     if (! (Tcl_DStringAppendElement(dstring, \"ERROR\") &&\n\t    Tcl_DStringAppendElement(dstring, code_string) &&\n\t    Tcl_DStringAppendElement(dstring, error_string))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n     \n     return dstring;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_err(kadm5_ret_t code)\n{\n     char *code_string;\n     const char *error_string;\n     Tcl_DString *dstring;\n\n     switch (code) {\n     case KADM5_FAILURE: code_string = \"KADM5_FAILURE\"; break;\n     case KADM5_AUTH_GET: code_string = \"KADM5_AUTH_GET\"; break;\n     case KADM5_AUTH_ADD: code_string = \"KADM5_AUTH_ADD\"; break;\n     case KADM5_AUTH_MODIFY:\n\t  code_string = \"KADM5_AUTH_MODIFY\"; break;\n     case KADM5_AUTH_DELETE:\n\t  code_string = \"KADM5_AUTH_DELETE\"; break;\n     case KADM5_AUTH_INSUFFICIENT:\n\t  code_string = \"KADM5_AUTH_INSUFFICIENT\"; break;\n     case KADM5_BAD_DB: code_string = \"KADM5_BAD_DB\"; break;\n     case KADM5_DUP: code_string = \"KADM5_DUP\"; break;\n     case KADM5_RPC_ERROR: code_string = \"KADM5_RPC_ERROR\"; break;\n     case KADM5_NO_SRV: code_string = \"KADM5_NO_SRV\"; break;\n     case KADM5_BAD_HIST_KEY:\n\t  code_string = \"KADM5_BAD_HIST_KEY\"; break;\n     case KADM5_NOT_INIT: code_string = \"KADM5_NOT_INIT\"; break;\n     case KADM5_INIT: code_string = \"KADM5_INIT\"; break;\n     case KADM5_BAD_PASSWORD:\n\t  code_string = \"KADM5_BAD_PASSWORD\"; break;\n     case KADM5_UNK_PRINC: code_string = \"KADM5_UNK_PRINC\"; break;\n     case KADM5_UNK_POLICY: code_string = \"KADM5_UNK_POLICY\"; break;\n     case KADM5_BAD_MASK: code_string = \"KADM5_BAD_MASK\"; break;\n     case KADM5_BAD_CLASS: code_string = \"KADM5_BAD_CLASS\"; break;\n     case KADM5_BAD_LENGTH: code_string = \"KADM5_BAD_LENGTH\"; break;\n     case KADM5_BAD_POLICY: code_string = \"KADM5_BAD_POLICY\"; break;\n     case KADM5_BAD_HISTORY: code_string = \"KADM5_BAD_HISTORY\"; break;\n     case KADM5_BAD_PRINCIPAL:\n\t  code_string = \"KADM5_BAD_PRINCIPAL\"; break;\n     case KADM5_BAD_AUX_ATTR:\n\t  code_string = \"KADM5_BAD_AUX_ATTR\"; break;\n     case KADM5_PASS_Q_TOOSHORT:\n\t  code_string = \"KADM5_PASS_Q_TOOSHORT\"; break;\n     case KADM5_PASS_Q_CLASS:\n\t  code_string = \"KADM5_PASS_Q_CLASS\"; break;\n     case KADM5_PASS_Q_DICT:\n\t  code_string = \"KADM5_PASS_Q_DICT\"; break;\n     case KADM5_PASS_REUSE: code_string = \"KADM5_PASS_REUSE\"; break;\n     case KADM5_PASS_TOOSOON:\n\t  code_string = \"KADM5_PASS_TOOSOON\"; break;\n     case KADM5_POLICY_REF:\n\t  code_string = \"KADM5_POLICY_REF\"; break;\n     case KADM5_PROTECT_PRINCIPAL:\n\t  code_string = \"KADM5_PROTECT_PRINCIPAL\"; break;\n     case KADM5_BAD_SERVER_HANDLE:\n\t  code_string = \"KADM5_BAD_SERVER_HANDLE\"; break;\n     case KADM5_BAD_STRUCT_VERSION:\n     \t  code_string = \"KADM5_BAD_STRUCT_VERSION\"; break;\n     case KADM5_OLD_STRUCT_VERSION:\n\t  code_string = \"KADM5_OLD_STRUCT_VERSION\"; break;\n     case KADM5_NEW_STRUCT_VERSION:\n\t  code_string = \"KADM5_NEW_STRUCT_VERSION\"; break;\n     case KADM5_BAD_API_VERSION:\n\t  code_string = \"KADM5_BAD_API_VERSION\"; break;\n     case KADM5_OLD_LIB_API_VERSION:\n     \t  code_string = \"KADM5_OLD_LIB_API_VERSION\"; break;\n     case KADM5_OLD_SERVER_API_VERSION:\n     \t  code_string = \"KADM5_OLD_SERVER_API_VERSION\"; break;\n     case KADM5_NEW_LIB_API_VERSION:\n     \t  code_string = \"KADM5_NEW_LIB_API_VERSION\"; break;\n     case KADM5_NEW_SERVER_API_VERSION:\n\t  code_string = \"KADM5_NEW_SERVER_API_VERSION\"; break;\n     case KADM5_SECURE_PRINC_MISSING:\n\t  code_string = \"KADM5_SECURE_PRINC_MISSING\"; break;\n     case KADM5_NO_RENAME_SALT:\n\t  code_string = \"KADM5_NO_RENAME_SALT\"; break;\n     case KADM5_BAD_CLIENT_PARAMS:\n\t  code_string = \"KADM5_BAD_CLIENT_PARAMS\"; break;\n     case KADM5_BAD_SERVER_PARAMS:\n\t  code_string = \"KADM5_BAD_SERVER_PARAMS\"; break;\n     case KADM5_AUTH_LIST:\n\t  code_string = \"KADM5_AUTH_LIST\"; break;\n     case KADM5_AUTH_CHANGEPW:\n\t  code_string = \"KADM5_AUTH_CHANGEPW\"; break;\n     case KADM5_GSS_ERROR: code_string = \"KADM5_GSS_ERROR\"; break;\n     case KADM5_BAD_TL_TYPE: code_string = \"KADM5_BAD_TL_TYPE\"; break; \n     case KADM5_MISSING_CONF_PARAMS:\n\t  code_string = \"KADM5_MISSING_CONF_PARAMS\"; break;\n     case KADM5_BAD_SERVER_NAME:\n\t  code_string = \"KADM5_BAD_SERVER_NAME\"; break;\n     case KADM5_MISSING_KRB5_CONF_PARAMS:\n\t  code_string = \"KADM5_MISSING_KRB5_CONF_PARAMS\"; break;\n\n\n     case OSA_ADB_DUP: code_string = \"OSA_ADB_DUP\"; break;\n     case OSA_ADB_NOENT: code_string = \"ENOENT\"; break;\n     case OSA_ADB_DBINIT: code_string = \"OSA_ADB_DBINIT\"; break;\n     case OSA_ADB_BAD_POLICY: code_string = \"Bad policy name\"; break;\n     case OSA_ADB_BAD_PRINC: code_string = \"Bad principal name\"; break;\n     case OSA_ADB_BAD_DB: code_string = \"Invalid database.\"; break;\n     case OSA_ADB_XDR_FAILURE: code_string = \"OSA_ADB_XDR_FAILURE\"; break;\n     case OSA_ADB_BADLOCKMODE: code_string = \"OSA_ADB_BADLOCKMODE\"; break;\n     case OSA_ADB_CANTLOCK_DB: code_string = \"OSA_ADB_CANTLOCK_DB\"; break;\n     case OSA_ADB_NOTLOCKED: code_string = \"OSA_ADB_NOTLOCKED\"; break;\n     case OSA_ADB_NOLOCKFILE: code_string = \"OSA_ADB_NOLOCKFILE\"; break;\n     case OSA_ADB_NOEXCL_PERM: code_string = \"OSA_ADB_NOEXCL_PERM\"; break;\n\n     case KRB5_KDB_INUSE: code_string = \"KRB5_KDB_INUSE\"; break;\n     case KRB5_KDB_UK_SERROR: code_string = \"KRB5_KDB_UK_SERROR\"; break;\n     case KRB5_KDB_UK_RERROR: code_string = \"KRB5_KDB_UK_RERROR\"; break;\n     case KRB5_KDB_UNAUTH: code_string = \"KRB5_KDB_UNAUTH\"; break;\n     case KRB5_KDB_NOENTRY: code_string = \"KRB5_KDB_NOENTRY\"; break;\n     case KRB5_KDB_ILL_WILDCARD: code_string = \"KRB5_KDB_ILL_WILDCARD\"; break;\n     case KRB5_KDB_DB_INUSE: code_string = \"KRB5_KDB_DB_INUSE\"; break;\n     case KRB5_KDB_DB_CHANGED: code_string = \"KRB5_KDB_DB_CHANGED\"; break;\n     case KRB5_KDB_TRUNCATED_RECORD:\n\t  code_string = \"KRB5_KDB_TRUNCATED_RECORD\"; break;\n     case KRB5_KDB_RECURSIVELOCK:\n\t  code_string = \"KRB5_KDB_RECURSIVELOCK\"; break;\n     case KRB5_KDB_NOTLOCKED: code_string = \"KRB5_KDB_NOTLOCKED\"; break;\n     case KRB5_KDB_BADLOCKMODE: code_string = \"KRB5_KDB_BADLOCKMODE\"; break;\n     case KRB5_KDB_DBNOTINITED: code_string = \"KRB5_KDB_DBNOTINITED\"; break;\n     case KRB5_KDB_DBINITED: code_string = \"KRB5_KDB_DBINITED\"; break;\n     case KRB5_KDB_ILLDIRECTION: code_string = \"KRB5_KDB_ILLDIRECTION\"; break;\n     case KRB5_KDB_NOMASTERKEY: code_string = \"KRB5_KDB_NOMASTERKEY\"; break;\n     case KRB5_KDB_BADMASTERKEY: code_string = \"KRB5_KDB_BADMASTERKEY\"; break;\n     case KRB5_KDB_INVALIDKEYSIZE:\n\t  code_string = \"KRB5_KDB_INVALIDKEYSIZE\"; break;\n     case KRB5_KDB_CANTREAD_STORED:\n\t  code_string = \"KRB5_KDB_CANTREAD_STORED\"; break;\n     case KRB5_KDB_BADSTORED_MKEY:\n\t  code_string = \"KRB5_KDB_BADSTORED_MKEY\"; break;\n     case KRB5_KDB_CANTLOCK_DB: code_string = \"KRB5_KDB_CANTLOCK_DB\"; break;\n     case KRB5_KDB_DB_CORRUPT: code_string = \"KRB5_KDB_DB_CORRUPT\"; break;\n\n     case KRB5_PARSE_ILLCHAR: code_string = \"KRB5_PARSE_ILLCHAR\"; break;\n     case KRB5_PARSE_MALFORMED: code_string = \"KRB5_PARSE_MALFORMED\"; break;\n     case KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN: code_string = \"KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN\"; break;\n     case KRB5_REALM_UNKNOWN: code_string = \"KRB5_REALM_UNKNOWN\"; break;\n     case KRB5_KDC_UNREACH: code_string = \"KRB5_KDC_UNREACH\"; break;\n     case KRB5_KDCREP_MODIFIED: code_string = \"KRB5_KDCREP_MODIFIED\"; break;\n     case KRB5KRB_AP_ERR_BAD_INTEGRITY: code_string  = \"KRB5KRB_AP_ERR_BAD_INTEGRITY\"; break;\n     case KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN: code_string = \"KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN\"; break;\n     case KRB5_CONFIG_BADFORMAT: code_string = \"KRB5_CONFIG_BADFORMAT\"; break;\n\n     case EINVAL: code_string = \"EINVAL\"; break;\n     case ENOENT: code_string = \"ENOENT\"; break;\n\n     default:\n\t fprintf(stderr, \"**** CODE %d (%s) ***\\n\", code,\n\t\t error_message (code));\n\t code_string = \"UNKNOWN\";\n\t break;\n     }\n\n     error_string = error_message(code);\n\n     if (! (dstring = (Tcl_DString *) malloc(sizeof(Tcl_DString)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX Do we really want to exit?  Ok if this is */\n\t\t   /* just a test program, but what about if it gets */\n\t\t   /* used for other things later? */\n     }\n\n     Tcl_DStringInit(dstring);\n\n     if (! (Tcl_DStringAppendElement(dstring, \"ERROR\") &&\n\t    Tcl_DStringAppendElement(dstring, code_string) &&\n\t    Tcl_DStringAppendElement(dstring, error_string))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n     \n     return dstring;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void stash_error(Tcl_Interp *interp, krb5_error_code code)\n{\n     Tcl_DString *dstring = unparse_err(code);\n     Tcl_DStringResult(interp, dstring);\n     Tcl_DStringFree(dstring);\n     free(dstring);\n}"
  },
  {
    "function_name": "unparse_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "272-442",
    "snippet": "static Tcl_DString *unparse_err(kadm5_ret_t code)\n{\n     char *code_string;\n     const char *error_string;\n     Tcl_DString *dstring;\n\n     switch (code) {\n     case KADM5_FAILURE: code_string = \"KADM5_FAILURE\"; break;\n     case KADM5_AUTH_GET: code_string = \"KADM5_AUTH_GET\"; break;\n     case KADM5_AUTH_ADD: code_string = \"KADM5_AUTH_ADD\"; break;\n     case KADM5_AUTH_MODIFY:\n\t  code_string = \"KADM5_AUTH_MODIFY\"; break;\n     case KADM5_AUTH_DELETE:\n\t  code_string = \"KADM5_AUTH_DELETE\"; break;\n     case KADM5_AUTH_INSUFFICIENT:\n\t  code_string = \"KADM5_AUTH_INSUFFICIENT\"; break;\n     case KADM5_BAD_DB: code_string = \"KADM5_BAD_DB\"; break;\n     case KADM5_DUP: code_string = \"KADM5_DUP\"; break;\n     case KADM5_RPC_ERROR: code_string = \"KADM5_RPC_ERROR\"; break;\n     case KADM5_NO_SRV: code_string = \"KADM5_NO_SRV\"; break;\n     case KADM5_BAD_HIST_KEY:\n\t  code_string = \"KADM5_BAD_HIST_KEY\"; break;\n     case KADM5_NOT_INIT: code_string = \"KADM5_NOT_INIT\"; break;\n     case KADM5_INIT: code_string = \"KADM5_INIT\"; break;\n     case KADM5_BAD_PASSWORD:\n\t  code_string = \"KADM5_BAD_PASSWORD\"; break;\n     case KADM5_UNK_PRINC: code_string = \"KADM5_UNK_PRINC\"; break;\n     case KADM5_UNK_POLICY: code_string = \"KADM5_UNK_POLICY\"; break;\n     case KADM5_BAD_MASK: code_string = \"KADM5_BAD_MASK\"; break;\n     case KADM5_BAD_CLASS: code_string = \"KADM5_BAD_CLASS\"; break;\n     case KADM5_BAD_LENGTH: code_string = \"KADM5_BAD_LENGTH\"; break;\n     case KADM5_BAD_POLICY: code_string = \"KADM5_BAD_POLICY\"; break;\n     case KADM5_BAD_HISTORY: code_string = \"KADM5_BAD_HISTORY\"; break;\n     case KADM5_BAD_PRINCIPAL:\n\t  code_string = \"KADM5_BAD_PRINCIPAL\"; break;\n     case KADM5_BAD_AUX_ATTR:\n\t  code_string = \"KADM5_BAD_AUX_ATTR\"; break;\n     case KADM5_PASS_Q_TOOSHORT:\n\t  code_string = \"KADM5_PASS_Q_TOOSHORT\"; break;\n     case KADM5_PASS_Q_CLASS:\n\t  code_string = \"KADM5_PASS_Q_CLASS\"; break;\n     case KADM5_PASS_Q_DICT:\n\t  code_string = \"KADM5_PASS_Q_DICT\"; break;\n     case KADM5_PASS_REUSE: code_string = \"KADM5_PASS_REUSE\"; break;\n     case KADM5_PASS_TOOSOON:\n\t  code_string = \"KADM5_PASS_TOOSOON\"; break;\n     case KADM5_POLICY_REF:\n\t  code_string = \"KADM5_POLICY_REF\"; break;\n     case KADM5_PROTECT_PRINCIPAL:\n\t  code_string = \"KADM5_PROTECT_PRINCIPAL\"; break;\n     case KADM5_BAD_SERVER_HANDLE:\n\t  code_string = \"KADM5_BAD_SERVER_HANDLE\"; break;\n     case KADM5_BAD_STRUCT_VERSION:\n     \t  code_string = \"KADM5_BAD_STRUCT_VERSION\"; break;\n     case KADM5_OLD_STRUCT_VERSION:\n\t  code_string = \"KADM5_OLD_STRUCT_VERSION\"; break;\n     case KADM5_NEW_STRUCT_VERSION:\n\t  code_string = \"KADM5_NEW_STRUCT_VERSION\"; break;\n     case KADM5_BAD_API_VERSION:\n\t  code_string = \"KADM5_BAD_API_VERSION\"; break;\n     case KADM5_OLD_LIB_API_VERSION:\n     \t  code_string = \"KADM5_OLD_LIB_API_VERSION\"; break;\n     case KADM5_OLD_SERVER_API_VERSION:\n     \t  code_string = \"KADM5_OLD_SERVER_API_VERSION\"; break;\n     case KADM5_NEW_LIB_API_VERSION:\n     \t  code_string = \"KADM5_NEW_LIB_API_VERSION\"; break;\n     case KADM5_NEW_SERVER_API_VERSION:\n\t  code_string = \"KADM5_NEW_SERVER_API_VERSION\"; break;\n     case KADM5_SECURE_PRINC_MISSING:\n\t  code_string = \"KADM5_SECURE_PRINC_MISSING\"; break;\n     case KADM5_NO_RENAME_SALT:\n\t  code_string = \"KADM5_NO_RENAME_SALT\"; break;\n     case KADM5_BAD_CLIENT_PARAMS:\n\t  code_string = \"KADM5_BAD_CLIENT_PARAMS\"; break;\n     case KADM5_BAD_SERVER_PARAMS:\n\t  code_string = \"KADM5_BAD_SERVER_PARAMS\"; break;\n     case KADM5_AUTH_LIST:\n\t  code_string = \"KADM5_AUTH_LIST\"; break;\n     case KADM5_AUTH_CHANGEPW:\n\t  code_string = \"KADM5_AUTH_CHANGEPW\"; break;\n     case KADM5_GSS_ERROR: code_string = \"KADM5_GSS_ERROR\"; break;\n     case KADM5_BAD_TL_TYPE: code_string = \"KADM5_BAD_TL_TYPE\"; break; \n     case KADM5_MISSING_CONF_PARAMS:\n\t  code_string = \"KADM5_MISSING_CONF_PARAMS\"; break;\n     case KADM5_BAD_SERVER_NAME:\n\t  code_string = \"KADM5_BAD_SERVER_NAME\"; break;\n     case KADM5_MISSING_KRB5_CONF_PARAMS:\n\t  code_string = \"KADM5_MISSING_KRB5_CONF_PARAMS\"; break;\n\n\n     case OSA_ADB_DUP: code_string = \"OSA_ADB_DUP\"; break;\n     case OSA_ADB_NOENT: code_string = \"ENOENT\"; break;\n     case OSA_ADB_DBINIT: code_string = \"OSA_ADB_DBINIT\"; break;\n     case OSA_ADB_BAD_POLICY: code_string = \"Bad policy name\"; break;\n     case OSA_ADB_BAD_PRINC: code_string = \"Bad principal name\"; break;\n     case OSA_ADB_BAD_DB: code_string = \"Invalid database.\"; break;\n     case OSA_ADB_XDR_FAILURE: code_string = \"OSA_ADB_XDR_FAILURE\"; break;\n     case OSA_ADB_BADLOCKMODE: code_string = \"OSA_ADB_BADLOCKMODE\"; break;\n     case OSA_ADB_CANTLOCK_DB: code_string = \"OSA_ADB_CANTLOCK_DB\"; break;\n     case OSA_ADB_NOTLOCKED: code_string = \"OSA_ADB_NOTLOCKED\"; break;\n     case OSA_ADB_NOLOCKFILE: code_string = \"OSA_ADB_NOLOCKFILE\"; break;\n     case OSA_ADB_NOEXCL_PERM: code_string = \"OSA_ADB_NOEXCL_PERM\"; break;\n\n     case KRB5_KDB_INUSE: code_string = \"KRB5_KDB_INUSE\"; break;\n     case KRB5_KDB_UK_SERROR: code_string = \"KRB5_KDB_UK_SERROR\"; break;\n     case KRB5_KDB_UK_RERROR: code_string = \"KRB5_KDB_UK_RERROR\"; break;\n     case KRB5_KDB_UNAUTH: code_string = \"KRB5_KDB_UNAUTH\"; break;\n     case KRB5_KDB_NOENTRY: code_string = \"KRB5_KDB_NOENTRY\"; break;\n     case KRB5_KDB_ILL_WILDCARD: code_string = \"KRB5_KDB_ILL_WILDCARD\"; break;\n     case KRB5_KDB_DB_INUSE: code_string = \"KRB5_KDB_DB_INUSE\"; break;\n     case KRB5_KDB_DB_CHANGED: code_string = \"KRB5_KDB_DB_CHANGED\"; break;\n     case KRB5_KDB_TRUNCATED_RECORD:\n\t  code_string = \"KRB5_KDB_TRUNCATED_RECORD\"; break;\n     case KRB5_KDB_RECURSIVELOCK:\n\t  code_string = \"KRB5_KDB_RECURSIVELOCK\"; break;\n     case KRB5_KDB_NOTLOCKED: code_string = \"KRB5_KDB_NOTLOCKED\"; break;\n     case KRB5_KDB_BADLOCKMODE: code_string = \"KRB5_KDB_BADLOCKMODE\"; break;\n     case KRB5_KDB_DBNOTINITED: code_string = \"KRB5_KDB_DBNOTINITED\"; break;\n     case KRB5_KDB_DBINITED: code_string = \"KRB5_KDB_DBINITED\"; break;\n     case KRB5_KDB_ILLDIRECTION: code_string = \"KRB5_KDB_ILLDIRECTION\"; break;\n     case KRB5_KDB_NOMASTERKEY: code_string = \"KRB5_KDB_NOMASTERKEY\"; break;\n     case KRB5_KDB_BADMASTERKEY: code_string = \"KRB5_KDB_BADMASTERKEY\"; break;\n     case KRB5_KDB_INVALIDKEYSIZE:\n\t  code_string = \"KRB5_KDB_INVALIDKEYSIZE\"; break;\n     case KRB5_KDB_CANTREAD_STORED:\n\t  code_string = \"KRB5_KDB_CANTREAD_STORED\"; break;\n     case KRB5_KDB_BADSTORED_MKEY:\n\t  code_string = \"KRB5_KDB_BADSTORED_MKEY\"; break;\n     case KRB5_KDB_CANTLOCK_DB: code_string = \"KRB5_KDB_CANTLOCK_DB\"; break;\n     case KRB5_KDB_DB_CORRUPT: code_string = \"KRB5_KDB_DB_CORRUPT\"; break;\n\n     case KRB5_PARSE_ILLCHAR: code_string = \"KRB5_PARSE_ILLCHAR\"; break;\n     case KRB5_PARSE_MALFORMED: code_string = \"KRB5_PARSE_MALFORMED\"; break;\n     case KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN: code_string = \"KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN\"; break;\n     case KRB5_REALM_UNKNOWN: code_string = \"KRB5_REALM_UNKNOWN\"; break;\n     case KRB5_KDC_UNREACH: code_string = \"KRB5_KDC_UNREACH\"; break;\n     case KRB5_KDCREP_MODIFIED: code_string = \"KRB5_KDCREP_MODIFIED\"; break;\n     case KRB5KRB_AP_ERR_BAD_INTEGRITY: code_string  = \"KRB5KRB_AP_ERR_BAD_INTEGRITY\"; break;\n     case KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN: code_string = \"KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN\"; break;\n     case KRB5_CONFIG_BADFORMAT: code_string = \"KRB5_CONFIG_BADFORMAT\"; break;\n\n     case EINVAL: code_string = \"EINVAL\"; break;\n     case ENOENT: code_string = \"ENOENT\"; break;\n\n     default:\n\t fprintf(stderr, \"**** CODE %d (%s) ***\\n\", code,\n\t\t error_message (code));\n\t code_string = \"UNKNOWN\";\n\t break;\n     }\n\n     error_string = error_message(code);\n\n     if (! (dstring = (Tcl_DString *) malloc(sizeof(Tcl_DString)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX Do we really want to exit?  Ok if this is */\n\t\t   /* just a test program, but what about if it gets */\n\t\t   /* used for other things later? */\n     }\n\n     Tcl_DStringInit(dstring);\n\n     if (! (Tcl_DStringAppendElement(dstring, \"ERROR\") &&\n\t    Tcl_DStringAppendElement(dstring, code_string) &&\n\t    Tcl_DStringAppendElement(dstring, error_string))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n     \n     return dstring;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "dstring",
            "error_string"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "dstring",
            "code_string"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppendElement",
          "args": [
            "dstring",
            "\"ERROR\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringInit",
          "args": [
            "dstring"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(Tcl_DString)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "code"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"**** CODE %d (%s) ***\\n\"",
            "code",
            "error_message (code)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error_message",
          "args": [
            "code"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_err(kadm5_ret_t code)\n{\n     char *code_string;\n     const char *error_string;\n     Tcl_DString *dstring;\n\n     switch (code) {\n     case KADM5_FAILURE: code_string = \"KADM5_FAILURE\"; break;\n     case KADM5_AUTH_GET: code_string = \"KADM5_AUTH_GET\"; break;\n     case KADM5_AUTH_ADD: code_string = \"KADM5_AUTH_ADD\"; break;\n     case KADM5_AUTH_MODIFY:\n\t  code_string = \"KADM5_AUTH_MODIFY\"; break;\n     case KADM5_AUTH_DELETE:\n\t  code_string = \"KADM5_AUTH_DELETE\"; break;\n     case KADM5_AUTH_INSUFFICIENT:\n\t  code_string = \"KADM5_AUTH_INSUFFICIENT\"; break;\n     case KADM5_BAD_DB: code_string = \"KADM5_BAD_DB\"; break;\n     case KADM5_DUP: code_string = \"KADM5_DUP\"; break;\n     case KADM5_RPC_ERROR: code_string = \"KADM5_RPC_ERROR\"; break;\n     case KADM5_NO_SRV: code_string = \"KADM5_NO_SRV\"; break;\n     case KADM5_BAD_HIST_KEY:\n\t  code_string = \"KADM5_BAD_HIST_KEY\"; break;\n     case KADM5_NOT_INIT: code_string = \"KADM5_NOT_INIT\"; break;\n     case KADM5_INIT: code_string = \"KADM5_INIT\"; break;\n     case KADM5_BAD_PASSWORD:\n\t  code_string = \"KADM5_BAD_PASSWORD\"; break;\n     case KADM5_UNK_PRINC: code_string = \"KADM5_UNK_PRINC\"; break;\n     case KADM5_UNK_POLICY: code_string = \"KADM5_UNK_POLICY\"; break;\n     case KADM5_BAD_MASK: code_string = \"KADM5_BAD_MASK\"; break;\n     case KADM5_BAD_CLASS: code_string = \"KADM5_BAD_CLASS\"; break;\n     case KADM5_BAD_LENGTH: code_string = \"KADM5_BAD_LENGTH\"; break;\n     case KADM5_BAD_POLICY: code_string = \"KADM5_BAD_POLICY\"; break;\n     case KADM5_BAD_HISTORY: code_string = \"KADM5_BAD_HISTORY\"; break;\n     case KADM5_BAD_PRINCIPAL:\n\t  code_string = \"KADM5_BAD_PRINCIPAL\"; break;\n     case KADM5_BAD_AUX_ATTR:\n\t  code_string = \"KADM5_BAD_AUX_ATTR\"; break;\n     case KADM5_PASS_Q_TOOSHORT:\n\t  code_string = \"KADM5_PASS_Q_TOOSHORT\"; break;\n     case KADM5_PASS_Q_CLASS:\n\t  code_string = \"KADM5_PASS_Q_CLASS\"; break;\n     case KADM5_PASS_Q_DICT:\n\t  code_string = \"KADM5_PASS_Q_DICT\"; break;\n     case KADM5_PASS_REUSE: code_string = \"KADM5_PASS_REUSE\"; break;\n     case KADM5_PASS_TOOSOON:\n\t  code_string = \"KADM5_PASS_TOOSOON\"; break;\n     case KADM5_POLICY_REF:\n\t  code_string = \"KADM5_POLICY_REF\"; break;\n     case KADM5_PROTECT_PRINCIPAL:\n\t  code_string = \"KADM5_PROTECT_PRINCIPAL\"; break;\n     case KADM5_BAD_SERVER_HANDLE:\n\t  code_string = \"KADM5_BAD_SERVER_HANDLE\"; break;\n     case KADM5_BAD_STRUCT_VERSION:\n     \t  code_string = \"KADM5_BAD_STRUCT_VERSION\"; break;\n     case KADM5_OLD_STRUCT_VERSION:\n\t  code_string = \"KADM5_OLD_STRUCT_VERSION\"; break;\n     case KADM5_NEW_STRUCT_VERSION:\n\t  code_string = \"KADM5_NEW_STRUCT_VERSION\"; break;\n     case KADM5_BAD_API_VERSION:\n\t  code_string = \"KADM5_BAD_API_VERSION\"; break;\n     case KADM5_OLD_LIB_API_VERSION:\n     \t  code_string = \"KADM5_OLD_LIB_API_VERSION\"; break;\n     case KADM5_OLD_SERVER_API_VERSION:\n     \t  code_string = \"KADM5_OLD_SERVER_API_VERSION\"; break;\n     case KADM5_NEW_LIB_API_VERSION:\n     \t  code_string = \"KADM5_NEW_LIB_API_VERSION\"; break;\n     case KADM5_NEW_SERVER_API_VERSION:\n\t  code_string = \"KADM5_NEW_SERVER_API_VERSION\"; break;\n     case KADM5_SECURE_PRINC_MISSING:\n\t  code_string = \"KADM5_SECURE_PRINC_MISSING\"; break;\n     case KADM5_NO_RENAME_SALT:\n\t  code_string = \"KADM5_NO_RENAME_SALT\"; break;\n     case KADM5_BAD_CLIENT_PARAMS:\n\t  code_string = \"KADM5_BAD_CLIENT_PARAMS\"; break;\n     case KADM5_BAD_SERVER_PARAMS:\n\t  code_string = \"KADM5_BAD_SERVER_PARAMS\"; break;\n     case KADM5_AUTH_LIST:\n\t  code_string = \"KADM5_AUTH_LIST\"; break;\n     case KADM5_AUTH_CHANGEPW:\n\t  code_string = \"KADM5_AUTH_CHANGEPW\"; break;\n     case KADM5_GSS_ERROR: code_string = \"KADM5_GSS_ERROR\"; break;\n     case KADM5_BAD_TL_TYPE: code_string = \"KADM5_BAD_TL_TYPE\"; break; \n     case KADM5_MISSING_CONF_PARAMS:\n\t  code_string = \"KADM5_MISSING_CONF_PARAMS\"; break;\n     case KADM5_BAD_SERVER_NAME:\n\t  code_string = \"KADM5_BAD_SERVER_NAME\"; break;\n     case KADM5_MISSING_KRB5_CONF_PARAMS:\n\t  code_string = \"KADM5_MISSING_KRB5_CONF_PARAMS\"; break;\n\n\n     case OSA_ADB_DUP: code_string = \"OSA_ADB_DUP\"; break;\n     case OSA_ADB_NOENT: code_string = \"ENOENT\"; break;\n     case OSA_ADB_DBINIT: code_string = \"OSA_ADB_DBINIT\"; break;\n     case OSA_ADB_BAD_POLICY: code_string = \"Bad policy name\"; break;\n     case OSA_ADB_BAD_PRINC: code_string = \"Bad principal name\"; break;\n     case OSA_ADB_BAD_DB: code_string = \"Invalid database.\"; break;\n     case OSA_ADB_XDR_FAILURE: code_string = \"OSA_ADB_XDR_FAILURE\"; break;\n     case OSA_ADB_BADLOCKMODE: code_string = \"OSA_ADB_BADLOCKMODE\"; break;\n     case OSA_ADB_CANTLOCK_DB: code_string = \"OSA_ADB_CANTLOCK_DB\"; break;\n     case OSA_ADB_NOTLOCKED: code_string = \"OSA_ADB_NOTLOCKED\"; break;\n     case OSA_ADB_NOLOCKFILE: code_string = \"OSA_ADB_NOLOCKFILE\"; break;\n     case OSA_ADB_NOEXCL_PERM: code_string = \"OSA_ADB_NOEXCL_PERM\"; break;\n\n     case KRB5_KDB_INUSE: code_string = \"KRB5_KDB_INUSE\"; break;\n     case KRB5_KDB_UK_SERROR: code_string = \"KRB5_KDB_UK_SERROR\"; break;\n     case KRB5_KDB_UK_RERROR: code_string = \"KRB5_KDB_UK_RERROR\"; break;\n     case KRB5_KDB_UNAUTH: code_string = \"KRB5_KDB_UNAUTH\"; break;\n     case KRB5_KDB_NOENTRY: code_string = \"KRB5_KDB_NOENTRY\"; break;\n     case KRB5_KDB_ILL_WILDCARD: code_string = \"KRB5_KDB_ILL_WILDCARD\"; break;\n     case KRB5_KDB_DB_INUSE: code_string = \"KRB5_KDB_DB_INUSE\"; break;\n     case KRB5_KDB_DB_CHANGED: code_string = \"KRB5_KDB_DB_CHANGED\"; break;\n     case KRB5_KDB_TRUNCATED_RECORD:\n\t  code_string = \"KRB5_KDB_TRUNCATED_RECORD\"; break;\n     case KRB5_KDB_RECURSIVELOCK:\n\t  code_string = \"KRB5_KDB_RECURSIVELOCK\"; break;\n     case KRB5_KDB_NOTLOCKED: code_string = \"KRB5_KDB_NOTLOCKED\"; break;\n     case KRB5_KDB_BADLOCKMODE: code_string = \"KRB5_KDB_BADLOCKMODE\"; break;\n     case KRB5_KDB_DBNOTINITED: code_string = \"KRB5_KDB_DBNOTINITED\"; break;\n     case KRB5_KDB_DBINITED: code_string = \"KRB5_KDB_DBINITED\"; break;\n     case KRB5_KDB_ILLDIRECTION: code_string = \"KRB5_KDB_ILLDIRECTION\"; break;\n     case KRB5_KDB_NOMASTERKEY: code_string = \"KRB5_KDB_NOMASTERKEY\"; break;\n     case KRB5_KDB_BADMASTERKEY: code_string = \"KRB5_KDB_BADMASTERKEY\"; break;\n     case KRB5_KDB_INVALIDKEYSIZE:\n\t  code_string = \"KRB5_KDB_INVALIDKEYSIZE\"; break;\n     case KRB5_KDB_CANTREAD_STORED:\n\t  code_string = \"KRB5_KDB_CANTREAD_STORED\"; break;\n     case KRB5_KDB_BADSTORED_MKEY:\n\t  code_string = \"KRB5_KDB_BADSTORED_MKEY\"; break;\n     case KRB5_KDB_CANTLOCK_DB: code_string = \"KRB5_KDB_CANTLOCK_DB\"; break;\n     case KRB5_KDB_DB_CORRUPT: code_string = \"KRB5_KDB_DB_CORRUPT\"; break;\n\n     case KRB5_PARSE_ILLCHAR: code_string = \"KRB5_PARSE_ILLCHAR\"; break;\n     case KRB5_PARSE_MALFORMED: code_string = \"KRB5_PARSE_MALFORMED\"; break;\n     case KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN: code_string = \"KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN\"; break;\n     case KRB5_REALM_UNKNOWN: code_string = \"KRB5_REALM_UNKNOWN\"; break;\n     case KRB5_KDC_UNREACH: code_string = \"KRB5_KDC_UNREACH\"; break;\n     case KRB5_KDCREP_MODIFIED: code_string = \"KRB5_KDCREP_MODIFIED\"; break;\n     case KRB5KRB_AP_ERR_BAD_INTEGRITY: code_string  = \"KRB5KRB_AP_ERR_BAD_INTEGRITY\"; break;\n     case KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN: code_string = \"KRB5KDC_ERR_C_PRINCIPAL_UNKNOWN\"; break;\n     case KRB5_CONFIG_BADFORMAT: code_string = \"KRB5_CONFIG_BADFORMAT\"; break;\n\n     case EINVAL: code_string = \"EINVAL\"; break;\n     case ENOENT: code_string = \"ENOENT\"; break;\n\n     default:\n\t fprintf(stderr, \"**** CODE %d (%s) ***\\n\", code,\n\t\t error_message (code));\n\t code_string = \"UNKNOWN\";\n\t break;\n     }\n\n     error_string = error_message(code);\n\n     if (! (dstring = (Tcl_DString *) malloc(sizeof(Tcl_DString)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX Do we really want to exit?  Ok if this is */\n\t\t   /* just a test program, but what about if it gets */\n\t\t   /* used for other things later? */\n     }\n\n     Tcl_DStringInit(dstring);\n\n     if (! (Tcl_DStringAppendElement(dstring, \"ERROR\") &&\n\t    Tcl_DStringAppendElement(dstring, code_string) &&\n\t    Tcl_DStringAppendElement(dstring, error_string))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n     \n     return dstring;\n}"
  },
  {
    "function_name": "set_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "263-268",
    "snippet": "static void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "string"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendElement",
          "args": [
            "interp",
            "\"KADM5_OK\""
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_SetResult",
          "args": [
            "interp",
            "\"OK\"",
            "TCL_STATIC"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void set_ok(Tcl_Interp *interp, char *string)\n{\n     Tcl_SetResult(interp, \"OK\", TCL_STATIC);\n     Tcl_AppendElement(interp, \"KADM5_OK\");\n     Tcl_AppendElement(interp, string);\n}"
  },
  {
    "function_name": "parse_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "248-260",
    "snippet": "static int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "in_str",
            "\"null\""
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic int parse_str(Tcl_Interp *interp, char *in_str, char **out_str)\n{\n     if (! in_str) {\n\t  *out_str = 0;\n     }\n     else if (! strcasecmp(in_str, \"null\")) {\n\t  *out_str = 0;\n     }\n     else {\n\t  *out_str = in_str;\n     }\n     return TCL_OK;\n}"
  },
  {
    "function_name": "unparse_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "225-244",
    "snippet": "static Tcl_DString *unparse_str(char *in_str)\n{\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     if (! in_str) {\n\t  Tcl_DStringAppend(str, \"null\", -1);\n     }\n     else {\n\t  Tcl_DStringAppend(str, in_str, -1);\n     }\n\n     return str;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_DStringAppend",
          "args": [
            "str",
            "in_str",
            "-1"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringAppend",
          "args": [
            "str",
            "\"null\"",
            "-1"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_DStringInit",
          "args": [
            "str"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*str)"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_DString *unparse_str(char *in_str)\n{\n     Tcl_DString *str;\n\n     if (! (str = malloc(sizeof(*str)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_DStringInit(str);\n\n     if (! in_str) {\n\t  Tcl_DStringAppend(str, \"null\", -1);\n     }\n     else {\n\t  Tcl_DStringAppend(str, in_str, -1);\n     }\n\n     return str;\n}"
  },
  {
    "function_name": "create_flag_table",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "197-222",
    "snippet": "static Tcl_HashTable *create_flag_table(struct flagval *flags, int size)\n{\n     Tcl_HashTable *table;\n     Tcl_HashEntry *entry;\n     int i;\n\n     if (! (table = (Tcl_HashTable *) malloc(sizeof(Tcl_HashTable)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_InitHashTable(table, TCL_STRING_KEYS);\n\n     for (i = 0; i < size; i++) {\n\t  int newPtr;\n\t       \n\t  if (! (entry = Tcl_CreateHashEntry(table, flags[i].name, &newPtr))) {\n\t       fprintf(stderr, \"Out of memory!\\n\");\n\t       exit(1); /* XXX */\n\t  }\n\n\t  Tcl_SetHashValue(entry, &flags[i].val);\n     }\n\n     return table;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_SetHashValue",
          "args": [
            "entry",
            "&flags[i].val"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateHashEntry",
          "args": [
            "table",
            "flags[i].name",
            "&newPtr"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_InitHashTable",
          "args": [
            "table",
            "TCL_STRING_KEYS"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(Tcl_HashTable)"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_HashTable *create_flag_table(struct flagval *flags, int size)\n{\n     Tcl_HashTable *table;\n     Tcl_HashEntry *entry;\n     int i;\n\n     if (! (table = (Tcl_HashTable *) malloc(sizeof(Tcl_HashTable)))) {\n\t  fprintf(stderr, \"Out of memory!\\n\");\n\t  exit(1); /* XXX */\n     }\n\n     Tcl_InitHashTable(table, TCL_STRING_KEYS);\n\n     for (i = 0; i < size; i++) {\n\t  int newPtr;\n\t       \n\t  if (! (entry = Tcl_CreateHashEntry(table, flags[i].name, &newPtr))) {\n\t       fprintf(stderr, \"Out of memory!\\n\");\n\t       exit(1); /* XXX */\n\t  }\n\n\t  Tcl_SetHashValue(entry, &flags[i].val);\n     }\n\n     return table;\n}"
  },
  {
    "function_name": "remove_server_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "166-178",
    "snippet": "static int remove_server_handle(Tcl_Interp *interp, char *name) \n{\n    Tcl_HashEntry *entry;\n\n    if (! (struct_table &&\n\t   (entry = Tcl_FindHashEntry(struct_table, name)))) {\n\tTcl_AppendResult(interp, \"unknown server handle \", name, 0);\n\treturn TCL_ERROR;\n    }\n\n    Tcl_SetHashValue(entry, NULL);\n    return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static Tcl_HashTable *struct_table = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_SetHashValue",
          "args": [
            "entry",
            "NULL"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendResult",
          "args": [
            "interp",
            "\"unknown server handle \"",
            "name",
            "0"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_FindHashEntry",
          "args": [
            "struct_table",
            "name"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_HashTable *struct_table = 0;\n\nstatic int remove_server_handle(Tcl_Interp *interp, char *name) \n{\n    Tcl_HashEntry *entry;\n\n    if (! (struct_table &&\n\t   (entry = Tcl_FindHashEntry(struct_table, name)))) {\n\tTcl_AppendResult(interp, \"unknown server handle \", name, 0);\n\treturn TCL_ERROR;\n    }\n\n    Tcl_SetHashValue(entry, NULL);\n    return TCL_OK;\n}"
  },
  {
    "function_name": "get_server_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "145-164",
    "snippet": "static int get_server_handle(Tcl_Interp *interp, char *name, void **handle) \n{\n    Tcl_HashEntry *entry;\n\n    if(!strcasecmp(name, \"null\"))\n\t*handle = 0;\n    else {\n\tif (! (struct_table &&\n\t       (entry = Tcl_FindHashEntry(struct_table, name)))) {\n\t     if (strncmp(name, \"ovsec_kadm_handle\", 17) == 0)\n\t\t  Tcl_AppendResult(interp, \"ovsec_kadm handle \"\n\t\t\t\t   \"specified for kadm5 api: \", name, 0);\n\t     else \n\t\t  Tcl_AppendResult(interp, \"unknown server handle \", name, 0);\n\t    return TCL_ERROR;\n\t}\n\t*handle = (void *) Tcl_GetHashValue(entry);\n    }\n    return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static Tcl_HashTable *struct_table = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_GetHashValue",
          "args": [
            "entry"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendResult",
          "args": [
            "interp",
            "\"unknown server handle \"",
            "name",
            "0"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_AppendResult",
          "args": [
            "interp",
            "\"ovsec_kadm handle \"\n\t\t\t\t   \"specified for kadm5 api: \"",
            "name",
            "0"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "\"ovsec_kadm_handle\"",
            "17"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_FindHashEntry",
          "args": [
            "struct_table",
            "name"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "name",
            "\"null\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_HashTable *struct_table = 0;\n\nstatic int get_server_handle(Tcl_Interp *interp, char *name, void **handle) \n{\n    Tcl_HashEntry *entry;\n\n    if(!strcasecmp(name, \"null\"))\n\t*handle = 0;\n    else {\n\tif (! (struct_table &&\n\t       (entry = Tcl_FindHashEntry(struct_table, name)))) {\n\t     if (strncmp(name, \"ovsec_kadm_handle\", 17) == 0)\n\t\t  Tcl_AppendResult(interp, \"ovsec_kadm handle \"\n\t\t\t\t   \"specified for kadm5 api: \", name, 0);\n\t     else \n\t\t  Tcl_AppendResult(interp, \"unknown server handle \", name, 0);\n\t    return TCL_ERROR;\n\t}\n\t*handle = (void *) Tcl_GetHashValue(entry);\n    }\n    return TCL_OK;\n}"
  },
  {
    "function_name": "put_server_handle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_kadm5.c",
    "lines": "110-143",
    "snippet": "static int put_server_handle(Tcl_Interp *interp, void *handle, char **name)\n{\n    int i = 1, newPtr = 0;\n    static char buf[20];\n    Tcl_HashEntry *entry;\n\n    if (! struct_table) {\n\tif (! (struct_table =\n\t       malloc(sizeof(*struct_table)))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1); /* XXX */\n\t}\n\tTcl_InitHashTable(struct_table, TCL_STRING_KEYS);\n    }\n\n    do {\n\t/*\n\t * Handles from ovsec_kadm_init() and kadm5_init() should not\n\t * be mixed during unit tests, but the API would happily\n\t * accept them.  Making the hash entry names different in\n\t * tcl_kadm.c and tcl_ovsec_kadm.c ensures that GET_HANDLE\n\t * will fail if presented a handle from the other API.\n\t */\n\tsprintf(buf, \"kadm5_handle%d\", i);\n\tentry = Tcl_CreateHashEntry(struct_table, buf, &newPtr);\n\ti++;\n    } while (! newPtr);\n\n    Tcl_SetHashValue(entry, handle);\n\n    *name = buf;\n\n    return TCL_OK;\n}",
    "includes": [
      "#include \"tcl_kadm5.h\"",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <k5-int.h>",
      "#include <com_err.h>",
      "#include <kadm5/admin.h>",
      "#include <tcl/tcl.h>",
      "#include <tcl.h>",
      "#include <string.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static Tcl_HashTable *struct_table = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "Tcl_SetHashValue",
          "args": [
            "entry",
            "handle"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_CreateHashEntry",
          "args": [
            "struct_table",
            "buf",
            "&newPtr"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"kadm5_handle%d\"",
            "i"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "Tcl_InitHashTable",
          "args": [
            "struct_table",
            "TCL_STRING_KEYS"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "request_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "841-846",
          "snippet": "void request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "volatile int\tsignal_request_exit = 0;",
            "void\trequest_exit(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvolatile int\tsignal_request_exit = 0;\nvoid\trequest_exit(int);\n\nvoid request_exit(int signum)\n{\n     krb5_klog_syslog(LOG_DEBUG, \"Got signal to request exit\");\n     signal_request_exit = 1;\n     return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"Out of memory!\\n\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(*struct_table)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic Tcl_HashTable *struct_table = 0;\n\nstatic int put_server_handle(Tcl_Interp *interp, void *handle, char **name)\n{\n    int i = 1, newPtr = 0;\n    static char buf[20];\n    Tcl_HashEntry *entry;\n\n    if (! struct_table) {\n\tif (! (struct_table =\n\t       malloc(sizeof(*struct_table)))) {\n\t    fprintf(stderr, \"Out of memory!\\n\");\n\t    exit(1); /* XXX */\n\t}\n\tTcl_InitHashTable(struct_table, TCL_STRING_KEYS);\n    }\n\n    do {\n\t/*\n\t * Handles from ovsec_kadm_init() and kadm5_init() should not\n\t * be mixed during unit tests, but the API would happily\n\t * accept them.  Making the hash entry names different in\n\t * tcl_kadm.c and tcl_ovsec_kadm.c ensures that GET_HANDLE\n\t * will fail if presented a handle from the other API.\n\t */\n\tsprintf(buf, \"kadm5_handle%d\", i);\n\tentry = Tcl_CreateHashEntry(struct_table, buf, &newPtr);\n\ti++;\n    } while (! newPtr);\n\n    Tcl_SetHashValue(entry, handle);\n\n    *name = buf;\n\n    return TCL_OK;\n}"
  }
]