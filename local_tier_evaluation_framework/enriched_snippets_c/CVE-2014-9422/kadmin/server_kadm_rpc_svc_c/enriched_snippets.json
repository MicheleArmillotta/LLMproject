[
  {
    "function_name": "gss_to_krb5_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/kadm_rpc_svc.c",
    "lines": "308-335",
    "snippet": "static int\ngss_to_krb5_name(struct svc_req *rqstp, krb5_context ctx, gss_name_t gss_name,\n\t\t krb5_principal *princ, gss_buffer_t gss_str)\n{\n     OM_uint32 status, minor_stat;\n     gss_OID gss_type;\n     char *str;\n     int success;\n\n     status = gss_display_name(&minor_stat, gss_name, gss_str, &gss_type);\n     if ((status != GSS_S_COMPLETE) || (gss_type != gss_nt_krb5_name)) {\n\t  krb5_klog_syslog(LOG_ERR,\n\t\t\t   \"gss_to_krb5_name: \"\n\t\t\t   \"failed display_name status %d\", status);\n\t  log_badauth(status, minor_stat,\n\t\t      &rqstp->rq_xprt->xp_raddr, NULL);\n\t  return 0;\n     }\n     str = malloc(gss_str->length +1);\n     if (str == NULL)\n\t  return 0;\n     *str = '\\0';\n\n     strncat(str, gss_str->value, gss_str->length);\n     success = (krb5_parse_name(ctx, str, princ) == 0);\n     free(str);\n     return success;\n}",
    "includes": [
      "#include \"kadm5/server_internal.h\"",
      "#include \"misc.h\"",
      "#include <arpa/inet.h>",
      "#include <adm_proto.h>",
      "#include <kadm5/admin.h>",
      "#include <krb5.h>",
      "#include <kadm5/kadm_rpc.h>",
      "#include <memory.h>",
      "#include <syslog.h>",
      "#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */",
      "#include <gssrpc/rpc.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int check_rpcsec_auth(struct svc_req *);",
      "static int gss_to_krb5_name(struct svc_req *, krb5_context, gss_name_t, krb5_principal *, gss_buffer_t);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "str"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "free_server_handle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/server_stubs.c",
          "lines": "137-141",
          "snippet": "static void free_server_handle(kadm5_server_handle_t handle)\n{\n     krb5_free_principal(handle->context, handle->current_caller);\n     free(handle);\n}",
          "includes": [
            "#include \"misc.h\"",
            "#include <krb5/adm_proto.h>  /* krb5_klog_syslog */",
            "#include <arpa/inet.h>  /* inet_ntoa */",
            "#include <syslog.h>",
            "#include <kadm5/server_acl.h>",
            "#include <kadm5/server_internal.h>",
            "#include <kadm5/kadm_rpc.h>",
            "#include <kadm5/admin.h>",
            "#include <krb5.h>",
            "#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */",
            "#include <gssapi/gssapi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static gss_name_t acceptor_name(gss_ctx_id_t context);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"misc.h\"\n#include <krb5/adm_proto.h>  /* krb5_klog_syslog */\n#include <arpa/inet.h>  /* inet_ntoa */\n#include <syslog.h>\n#include <kadm5/server_acl.h>\n#include <kadm5/server_internal.h>\n#include <kadm5/kadm_rpc.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */\n#include <gssapi/gssapi.h>\n\nstatic gss_name_t acceptor_name(gss_ctx_id_t context);\n\nstatic void free_server_handle(kadm5_server_handle_t handle)\n{\n     krb5_free_principal(handle->context, handle->current_caller);\n     free(handle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "ctx",
            "str",
            "princ"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "str",
            "gss_str->value",
            "gss_str->length"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "gss_str->length +1"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_badauth",
          "args": [
            "status",
            "minor_stat",
            "&rqstp->rq_xprt->xp_raddr",
            "NULL"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "log_badauth_display_status_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "1052-1081",
          "snippet": "void log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec)\n{\n     OM_uint32 gssstat, minor_stat;\n     gss_buffer_desc msg;\n     OM_uint32 msg_ctx;\n\n     msg_ctx = 0;\n     while (1) {\n\t  gssstat = gss_display_status(&minor_stat, code,\n\t\t\t\t       type, GSS_C_NULL_OID,\n\t\t\t\t       &msg_ctx, &msg);\n\t  if (gssstat != GSS_S_COMPLETE) {\n \t       if (!rec) {\n\t\t    log_badauth_display_status_1(m,gssstat,GSS_C_GSS_CODE,1); \n\t\t    log_badauth_display_status_1(m, minor_stat,\n\t\t\t\t\t\t GSS_C_MECH_CODE, 1);\n\t       } else\n\t\t    krb5_klog_syslog(LOG_ERR, \"GSS-API authentication error %s: \"\n\t\t\t   \"recursive failure!\", msg);\n\t       return;\n\t  }\n\n\t  krb5_klog_syslog(LOG_NOTICE, \"%s %s\", m, (char *)msg.value); \n\t  (void) gss_release_buffer(&minor_stat, &msg);\n\t  \n\t  if (!msg_ctx)\n\t       break;\n     }\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec);",
            "static void display_status_1(char *, OM_uint32, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec);\nstatic void display_status_1(char *, OM_uint32, int);\n\nvoid log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec)\n{\n     OM_uint32 gssstat, minor_stat;\n     gss_buffer_desc msg;\n     OM_uint32 msg_ctx;\n\n     msg_ctx = 0;\n     while (1) {\n\t  gssstat = gss_display_status(&minor_stat, code,\n\t\t\t\t       type, GSS_C_NULL_OID,\n\t\t\t\t       &msg_ctx, &msg);\n\t  if (gssstat != GSS_S_COMPLETE) {\n \t       if (!rec) {\n\t\t    log_badauth_display_status_1(m,gssstat,GSS_C_GSS_CODE,1); \n\t\t    log_badauth_display_status_1(m, minor_stat,\n\t\t\t\t\t\t GSS_C_MECH_CODE, 1);\n\t       } else\n\t\t    krb5_klog_syslog(LOG_ERR, \"GSS-API authentication error %s: \"\n\t\t\t   \"recursive failure!\", msg);\n\t       return;\n\t  }\n\n\t  krb5_klog_syslog(LOG_NOTICE, \"%s %s\", m, (char *)msg.value); \n\t  (void) gss_release_buffer(&minor_stat, &msg);\n\t  \n\t  if (!msg_ctx)\n\t       break;\n     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"gss_to_krb5_name: \"\n\t\t\t   \"failed display_name status %d\"",
            "status"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_display_name",
          "args": [
            "&minor_stat",
            "gss_name",
            "gss_str",
            "&gss_type"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kadm5/server_internal.h\"\n#include \"misc.h\"\n#include <arpa/inet.h>\n#include <adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <kadm5/kadm_rpc.h>\n#include <memory.h>\n#include <syslog.h>\n#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */\n#include <gssrpc/rpc.h>\n#include <stdio.h>\n\nstatic int check_rpcsec_auth(struct svc_req *);\nstatic int gss_to_krb5_name(struct svc_req *, krb5_context, gss_name_t, krb5_principal *, gss_buffer_t);\n\nstatic int\ngss_to_krb5_name(struct svc_req *rqstp, krb5_context ctx, gss_name_t gss_name,\n\t\t krb5_principal *princ, gss_buffer_t gss_str)\n{\n     OM_uint32 status, minor_stat;\n     gss_OID gss_type;\n     char *str;\n     int success;\n\n     status = gss_display_name(&minor_stat, gss_name, gss_str, &gss_type);\n     if ((status != GSS_S_COMPLETE) || (gss_type != gss_nt_krb5_name)) {\n\t  krb5_klog_syslog(LOG_ERR,\n\t\t\t   \"gss_to_krb5_name: \"\n\t\t\t   \"failed display_name status %d\", status);\n\t  log_badauth(status, minor_stat,\n\t\t      &rqstp->rq_xprt->xp_raddr, NULL);\n\t  return 0;\n     }\n     str = malloc(gss_str->length +1);\n     if (str == NULL)\n\t  return 0;\n     *str = '\\0';\n\n     strncat(str, gss_str->value, gss_str->length);\n     success = (krb5_parse_name(ctx, str, princ) == 0);\n     free(str);\n     return success;\n}"
  },
  {
    "function_name": "check_rpcsec_auth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/kadm_rpc_svc.c",
    "lines": "240-306",
    "snippet": "static int\ncheck_rpcsec_auth(struct svc_req *rqstp)\n{\n     gss_ctx_id_t ctx;\n     krb5_context kctx;\n     OM_uint32 maj_stat, min_stat;\n     gss_name_t name;\n     krb5_principal princ;\n     int ret, success;\n     krb5_data *c1, *c2, *realm;\n     gss_buffer_desc gss_str;\n     kadm5_server_handle_t handle;\n\n     success = 0;\n     handle = (kadm5_server_handle_t)global_server_handle;\n\n     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)\n\t  return 0;\n\n     ctx = rqstp->rq_svccred;\n\n     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,\n\t\t\t\t    NULL, NULL, NULL, NULL, NULL);\n     if (maj_stat != GSS_S_COMPLETE) {\n\t  krb5_klog_syslog(LOG_ERR, \"check_rpcsec_auth: \"\n\t\t\t   \"failed inquire_context, stat=%u\", maj_stat);\n\t  log_badauth(maj_stat, min_stat,\n\t\t      &rqstp->rq_xprt->xp_raddr, NULL);\n\t  goto fail_name;\n     }\n\n     kctx = handle->context;\n     ret = gss_to_krb5_name(rqstp, kctx, name, &princ, &gss_str);\n     if (ret == 0)\n\t  goto fail_name;\n\n     /*\n      * Since we accept with GSS_C_NO_NAME, the client can authenticate\n      * against the entire kdb.  Therefore, ensure that the service\n      * name is something reasonable.\n      */\n     if (krb5_princ_size(kctx, princ) != 2)\n\t  goto fail_princ;\n\n     c1 = krb5_princ_component(kctx, princ, 0);\n     c2 = krb5_princ_component(kctx, princ, 1);\n     realm = krb5_princ_realm(kctx, princ);\n     if (strncmp(handle->params.realm, realm->data, realm->length) == 0\n\t && strncmp(\"kadmin\", c1->data, c1->length) == 0) {\n\n\t  if (strncmp(\"history\", c2->data, c2->length) == 0)\n\t       goto fail_princ;\n\t  else\n\t       success = 1;\n     }\n\nfail_princ:\n     if (!success) {\n\t krb5_klog_syslog(LOG_ERR, \"bad service principal %.*s\",\n\t\t\t  gss_str.length, gss_str.value);\n     }\n     gss_release_buffer(&min_stat, &gss_str);\n     krb5_free_principal(kctx, princ);\nfail_name:\n     gss_release_name(&min_stat, &name);\n     return success;\n}",
    "includes": [
      "#include \"kadm5/server_internal.h\"",
      "#include \"misc.h\"",
      "#include <arpa/inet.h>",
      "#include <adm_proto.h>",
      "#include <kadm5/admin.h>",
      "#include <krb5.h>",
      "#include <kadm5/kadm_rpc.h>",
      "#include <memory.h>",
      "#include <syslog.h>",
      "#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */",
      "#include <gssrpc/rpc.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern void *global_server_handle;",
      "static int check_rpcsec_auth(struct svc_req *);",
      "void log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gss_release_name",
          "args": [
            "&min_stat",
            "&name"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "kctx",
            "princ"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_release_buffer",
          "args": [
            "&min_stat",
            "&gss_str"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"bad service principal %.*s\"",
            "gss_str.length",
            "gss_str.value"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"history\"",
            "c2->data",
            "c2->length"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "\"kadmin\"",
            "c1->data",
            "c1->length"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "handle->params.realm",
            "realm->data",
            "realm->length"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_princ_realm",
          "args": [
            "kctx",
            "princ"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_princ_component",
          "args": [
            "kctx",
            "princ",
            "1"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_princ_component",
          "args": [
            "kctx",
            "princ",
            "0"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_princ_size",
          "args": [
            "kctx",
            "princ"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_to_krb5_name",
          "args": [
            "rqstp",
            "kctx",
            "name",
            "&princ",
            "&gss_str"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "gss_to_krb5_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/kadm_rpc_svc.c",
          "lines": "308-335",
          "snippet": "static int\ngss_to_krb5_name(struct svc_req *rqstp, krb5_context ctx, gss_name_t gss_name,\n\t\t krb5_principal *princ, gss_buffer_t gss_str)\n{\n     OM_uint32 status, minor_stat;\n     gss_OID gss_type;\n     char *str;\n     int success;\n\n     status = gss_display_name(&minor_stat, gss_name, gss_str, &gss_type);\n     if ((status != GSS_S_COMPLETE) || (gss_type != gss_nt_krb5_name)) {\n\t  krb5_klog_syslog(LOG_ERR,\n\t\t\t   \"gss_to_krb5_name: \"\n\t\t\t   \"failed display_name status %d\", status);\n\t  log_badauth(status, minor_stat,\n\t\t      &rqstp->rq_xprt->xp_raddr, NULL);\n\t  return 0;\n     }\n     str = malloc(gss_str->length +1);\n     if (str == NULL)\n\t  return 0;\n     *str = '\\0';\n\n     strncat(str, gss_str->value, gss_str->length);\n     success = (krb5_parse_name(ctx, str, princ) == 0);\n     free(str);\n     return success;\n}",
          "includes": [
            "#include \"kadm5/server_internal.h\"",
            "#include \"misc.h\"",
            "#include <arpa/inet.h>",
            "#include <adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <krb5.h>",
            "#include <kadm5/kadm_rpc.h>",
            "#include <memory.h>",
            "#include <syslog.h>",
            "#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */",
            "#include <gssrpc/rpc.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int check_rpcsec_auth(struct svc_req *);",
            "static int gss_to_krb5_name(struct svc_req *, krb5_context, gss_name_t, krb5_principal *, gss_buffer_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kadm5/server_internal.h\"\n#include \"misc.h\"\n#include <arpa/inet.h>\n#include <adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <kadm5/kadm_rpc.h>\n#include <memory.h>\n#include <syslog.h>\n#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */\n#include <gssrpc/rpc.h>\n#include <stdio.h>\n\nstatic int check_rpcsec_auth(struct svc_req *);\nstatic int gss_to_krb5_name(struct svc_req *, krb5_context, gss_name_t, krb5_principal *, gss_buffer_t);\n\nstatic int\ngss_to_krb5_name(struct svc_req *rqstp, krb5_context ctx, gss_name_t gss_name,\n\t\t krb5_principal *princ, gss_buffer_t gss_str)\n{\n     OM_uint32 status, minor_stat;\n     gss_OID gss_type;\n     char *str;\n     int success;\n\n     status = gss_display_name(&minor_stat, gss_name, gss_str, &gss_type);\n     if ((status != GSS_S_COMPLETE) || (gss_type != gss_nt_krb5_name)) {\n\t  krb5_klog_syslog(LOG_ERR,\n\t\t\t   \"gss_to_krb5_name: \"\n\t\t\t   \"failed display_name status %d\", status);\n\t  log_badauth(status, minor_stat,\n\t\t      &rqstp->rq_xprt->xp_raddr, NULL);\n\t  return 0;\n     }\n     str = malloc(gss_str->length +1);\n     if (str == NULL)\n\t  return 0;\n     *str = '\\0';\n\n     strncat(str, gss_str->value, gss_str->length);\n     success = (krb5_parse_name(ctx, str, princ) == 0);\n     free(str);\n     return success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_badauth",
          "args": [
            "maj_stat",
            "min_stat",
            "&rqstp->rq_xprt->xp_raddr",
            "NULL"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "log_badauth_display_status_1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/ovsec_kadmd.c",
          "lines": "1052-1081",
          "snippet": "void log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec)\n{\n     OM_uint32 gssstat, minor_stat;\n     gss_buffer_desc msg;\n     OM_uint32 msg_ctx;\n\n     msg_ctx = 0;\n     while (1) {\n\t  gssstat = gss_display_status(&minor_stat, code,\n\t\t\t\t       type, GSS_C_NULL_OID,\n\t\t\t\t       &msg_ctx, &msg);\n\t  if (gssstat != GSS_S_COMPLETE) {\n \t       if (!rec) {\n\t\t    log_badauth_display_status_1(m,gssstat,GSS_C_GSS_CODE,1); \n\t\t    log_badauth_display_status_1(m, minor_stat,\n\t\t\t\t\t\t GSS_C_MECH_CODE, 1);\n\t       } else\n\t\t    krb5_klog_syslog(LOG_ERR, \"GSS-API authentication error %s: \"\n\t\t\t   \"recursive failure!\", msg);\n\t       return;\n\t  }\n\n\t  krb5_klog_syslog(LOG_NOTICE, \"%s %s\", m, (char *)msg.value); \n\t  (void) gss_release_buffer(&minor_stat, &msg);\n\t  \n\t  if (!msg_ctx)\n\t       break;\n     }\n}",
          "includes": [
            "#include    \"purify.h\"",
            "#include    \"misc.h\"",
            "#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */",
            "#include    <string.h>",
            "#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */",
            "#include    <krb5/adm_proto.h>",
            "#include    <kadm5/server_acl.h>",
            "#include    <kadm5/kadm_rpc.h>",
            "#include    <kadm5/admin.h>",
            "#include    <gssrpc/auth_gssapi.h>",
            "#include    \"gssapiP_krb5.h\" /* for kg_get_context */",
            "#include    <gssapi/gssapi.h>",
            "#include    <gssrpc/rpc.h>",
            "#include    <arpa/inet.h>  /* inet_ntoa */",
            "#include    <netinet/in.h>",
            "#include    <unistd.h>",
            "#include    <sys/socket.h>",
            "#include    <sys/time.h>",
            "#include    <sys/select.h>",
            "#include    <sys/types.h>",
            "#include    <syslog.h>",
            "#include    <signal.h>",
            "#include    <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec);",
            "static void display_status_1(char *, OM_uint32, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include    \"purify.h\"\n#include    \"misc.h\"\n#include    \"kadm5/server_internal.h\" /* XXX for kadm5_server_handle_t */\n#include    <string.h>\n#include    \"krb5/kdb_kt.h\"\t/* for krb5_ktkdb_set_context */\n#include    <krb5/adm_proto.h>\n#include    <kadm5/server_acl.h>\n#include    <kadm5/kadm_rpc.h>\n#include    <kadm5/admin.h>\n#include    <gssrpc/auth_gssapi.h>\n#include    \"gssapiP_krb5.h\" /* for kg_get_context */\n#include    <gssapi/gssapi.h>\n#include    <gssrpc/rpc.h>\n#include    <arpa/inet.h>  /* inet_ntoa */\n#include    <netinet/in.h>\n#include    <unistd.h>\n#include    <sys/socket.h>\n#include    <sys/time.h>\n#include    <sys/select.h>\n#include    <sys/types.h>\n#include    <syslog.h>\n#include    <signal.h>\n#include    <stdio.h>\n\nvoid log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec);\nstatic void display_status_1(char *, OM_uint32, int);\n\nvoid log_badauth_display_status_1(char *m, OM_uint32 code, int type,\n\t\t\t\t  int rec)\n{\n     OM_uint32 gssstat, minor_stat;\n     gss_buffer_desc msg;\n     OM_uint32 msg_ctx;\n\n     msg_ctx = 0;\n     while (1) {\n\t  gssstat = gss_display_status(&minor_stat, code,\n\t\t\t\t       type, GSS_C_NULL_OID,\n\t\t\t\t       &msg_ctx, &msg);\n\t  if (gssstat != GSS_S_COMPLETE) {\n \t       if (!rec) {\n\t\t    log_badauth_display_status_1(m,gssstat,GSS_C_GSS_CODE,1); \n\t\t    log_badauth_display_status_1(m, minor_stat,\n\t\t\t\t\t\t GSS_C_MECH_CODE, 1);\n\t       } else\n\t\t    krb5_klog_syslog(LOG_ERR, \"GSS-API authentication error %s: \"\n\t\t\t   \"recursive failure!\", msg);\n\t       return;\n\t  }\n\n\t  krb5_klog_syslog(LOG_NOTICE, \"%s %s\", m, (char *)msg.value); \n\t  (void) gss_release_buffer(&minor_stat, &msg);\n\t  \n\t  if (!msg_ctx)\n\t       break;\n     }\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"check_rpcsec_auth: \"\n\t\t\t   \"failed inquire_context, stat=%u\"",
            "maj_stat"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gss_inquire_context",
          "args": [
            "&min_stat",
            "ctx",
            "NULL",
            "&name",
            "NULL",
            "NULL",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kadm5/server_internal.h\"\n#include \"misc.h\"\n#include <arpa/inet.h>\n#include <adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <kadm5/kadm_rpc.h>\n#include <memory.h>\n#include <syslog.h>\n#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */\n#include <gssrpc/rpc.h>\n#include <stdio.h>\n\nextern void *global_server_handle;\nstatic int check_rpcsec_auth(struct svc_req *);\nvoid log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);\n\nstatic int\ncheck_rpcsec_auth(struct svc_req *rqstp)\n{\n     gss_ctx_id_t ctx;\n     krb5_context kctx;\n     OM_uint32 maj_stat, min_stat;\n     gss_name_t name;\n     krb5_principal princ;\n     int ret, success;\n     krb5_data *c1, *c2, *realm;\n     gss_buffer_desc gss_str;\n     kadm5_server_handle_t handle;\n\n     success = 0;\n     handle = (kadm5_server_handle_t)global_server_handle;\n\n     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)\n\t  return 0;\n\n     ctx = rqstp->rq_svccred;\n\n     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,\n\t\t\t\t    NULL, NULL, NULL, NULL, NULL);\n     if (maj_stat != GSS_S_COMPLETE) {\n\t  krb5_klog_syslog(LOG_ERR, \"check_rpcsec_auth: \"\n\t\t\t   \"failed inquire_context, stat=%u\", maj_stat);\n\t  log_badauth(maj_stat, min_stat,\n\t\t      &rqstp->rq_xprt->xp_raddr, NULL);\n\t  goto fail_name;\n     }\n\n     kctx = handle->context;\n     ret = gss_to_krb5_name(rqstp, kctx, name, &princ, &gss_str);\n     if (ret == 0)\n\t  goto fail_name;\n\n     /*\n      * Since we accept with GSS_C_NO_NAME, the client can authenticate\n      * against the entire kdb.  Therefore, ensure that the service\n      * name is something reasonable.\n      */\n     if (krb5_princ_size(kctx, princ) != 2)\n\t  goto fail_princ;\n\n     c1 = krb5_princ_component(kctx, princ, 0);\n     c2 = krb5_princ_component(kctx, princ, 1);\n     realm = krb5_princ_realm(kctx, princ);\n     if (strncmp(handle->params.realm, realm->data, realm->length) == 0\n\t && strncmp(\"kadmin\", c1->data, c1->length) == 0) {\n\n\t  if (strncmp(\"history\", c2->data, c2->length) == 0)\n\t       goto fail_princ;\n\t  else\n\t       success = 1;\n     }\n\nfail_princ:\n     if (!success) {\n\t krb5_klog_syslog(LOG_ERR, \"bad service principal %.*s\",\n\t\t\t  gss_str.length, gss_str.value);\n     }\n     gss_release_buffer(&min_stat, &gss_str);\n     krb5_free_principal(kctx, princ);\nfail_name:\n     gss_release_name(&min_stat, &name);\n     return success;\n}"
  },
  {
    "function_name": "kadm_1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/kadm_rpc_svc.c",
    "lines": "47-238",
    "snippet": "void kadm_1(rqstp, transp)\n   struct svc_req *rqstp;\n   register SVCXPRT *transp;\n{\n     union {\n\t  cprinc_arg create_principal_1_arg;\n\t  dprinc_arg delete_principal_1_arg;\n\t  mprinc_arg modify_principal_1_arg;\n\t  rprinc_arg rename_principal_1_arg;\n\t  gprinc_arg get_principal_1_arg;\n\t  chpass_arg chpass_principal_1_arg;\n\t  chrand_arg chrand_principal_1_arg;\n\t  cpol_arg create_policy_1_arg;\n\t  dpol_arg delete_policy_1_arg;\n\t  mpol_arg modify_policy_1_arg;\n\t  gpol_arg get_policy_1_arg;\n\t  setkey_arg setkey_principal_1_arg;\n\t  setv4key_arg setv4key_principal_1_arg;\n\t  cprinc3_arg create_principal3_1_arg;\n\t  chpass3_arg chpass_principal3_1_arg;\n\t  chrand3_arg chrand_principal3_1_arg;\n\t  setkey3_arg setkey_principal3_1_arg;\n     } argument;\n     char *result;\n     bool_t (*xdr_argument)(), (*xdr_result)();\n     char *(*local)();\n\n     if (rqstp->rq_cred.oa_flavor != AUTH_GSSAPI &&\n\t !check_rpcsec_auth(rqstp)) {\n\t  krb5_klog_syslog(LOG_ERR, \"Authentication attempt failed: %s, \"\n\t\t \"RPC authentication flavor %d\",\n\t\t inet_ntoa(rqstp->rq_xprt->xp_raddr.sin_addr),\n\t\t rqstp->rq_cred.oa_flavor);\n\t  svcerr_weakauth(transp);\n\t  return;\n     }\n     \n     switch (rqstp->rq_proc) {\n     case NULLPROC:\n\t  (void) svc_sendreply(transp, xdr_void, (char *)NULL);\n\t  return;\n\t  \n     case CREATE_PRINCIPAL:\n\t  xdr_argument = xdr_cprinc_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) create_principal_1_svc;\n\t  break;\n\t  \n     case DELETE_PRINCIPAL:\n\t  xdr_argument = xdr_dprinc_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) delete_principal_1_svc;\n\t  break;\n\t  \n     case MODIFY_PRINCIPAL:\n\t  xdr_argument = xdr_mprinc_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) modify_principal_1_svc;\n\t  break;\n\t  \n     case RENAME_PRINCIPAL:\n\t  xdr_argument = xdr_rprinc_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) rename_principal_1_svc;\n\t  break;\n\t  \n     case GET_PRINCIPAL:\n\t  xdr_argument = xdr_gprinc_arg;\n\t  xdr_result = xdr_gprinc_ret;\n\t  local = (char *(*)()) get_principal_1_svc;\n\t  break;\n\n     case GET_PRINCS:\n\t  xdr_argument = xdr_gprincs_arg;\n\t  xdr_result = xdr_gprincs_ret;\n\t  local = (char *(*)()) get_princs_1_svc;\n\t  break;\n\t  \n     case CHPASS_PRINCIPAL:\n\t  xdr_argument = xdr_chpass_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) chpass_principal_1_svc;\n\t  break;\n\n     case SETV4KEY_PRINCIPAL:\n\t  xdr_argument = xdr_setv4key_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) setv4key_principal_1_svc;\n\t  break;\n\n     case SETKEY_PRINCIPAL:\n\t  xdr_argument = xdr_setkey_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) setkey_principal_1_svc;\n\t  break;\n\t  \n     case CHRAND_PRINCIPAL:\n\t  xdr_argument = xdr_chrand_arg;\n\t  xdr_result = xdr_chrand_ret;\n\t  local = (char *(*)()) chrand_principal_1_svc;\n\t  break;\n\t  \n     case CREATE_POLICY:\n\t  xdr_argument = xdr_cpol_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) create_policy_1_svc;\n\t  break;\n\t  \n     case DELETE_POLICY:\n\t  xdr_argument = xdr_dpol_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) delete_policy_1_svc;\n\t  break;\n\t  \n     case MODIFY_POLICY:\n\t  xdr_argument = xdr_mpol_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) modify_policy_1_svc;\n\t  break;\n\t  \n     case GET_POLICY:\n\t  xdr_argument = xdr_gpol_arg;\n\t  xdr_result = xdr_gpol_ret;\n\t  local = (char *(*)()) get_policy_1_svc;\n\t  break;\n\n     case GET_POLS:\n\t  xdr_argument = xdr_gpols_arg;\n\t  xdr_result = xdr_gpols_ret;\n\t  local = (char *(*)()) get_pols_1_svc;\n\t  break;\n\t  \n     case GET_PRIVS:\n\t  xdr_argument = xdr_u_int32;\n\t  xdr_result = xdr_getprivs_ret;\n\t  local = (char *(*)()) get_privs_1_svc;\n\t  break;\n\n     case INIT:\n\t  xdr_argument = xdr_u_int32;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) init_1_svc;\n\t  break;\n\n     case CREATE_PRINCIPAL3:\n\t  xdr_argument = xdr_cprinc3_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) create_principal3_1_svc;\n\t  break;\n\n     case CHPASS_PRINCIPAL3:\n\t  xdr_argument = xdr_chpass3_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) chpass_principal3_1_svc;\n\t  break;\n\n     case CHRAND_PRINCIPAL3:\n\t  xdr_argument = xdr_chrand3_arg;\n\t  xdr_result = xdr_chrand_ret;\n\t  local = (char *(*)()) chrand_principal3_1_svc;\n\t  break;\n\n     case SETKEY_PRINCIPAL3:\n\t  xdr_argument = xdr_setkey3_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) setkey_principal3_1_svc;\n\t  break;\n\n     default:\n\t  krb5_klog_syslog(LOG_ERR, \"Invalid KADM5 procedure number: %s, %d\",\n\t\t inet_ntoa(rqstp->rq_xprt->xp_raddr.sin_addr),\n\t\t rqstp->rq_proc);\n\t  svcerr_noproc(transp);\n\t  return;\n     }\n     memset((char *)&argument, 0, sizeof(argument));\n     if (!svc_getargs(transp, xdr_argument, &argument)) {\n\t  svcerr_decode(transp);\n\t  return;\n     }\n     result = (*local)(&argument, rqstp);\n     if (result != NULL && !svc_sendreply(transp, xdr_result, result)) {\n\t  krb5_klog_syslog(LOG_ERR, \"WARNING! Unable to send function results, \"\n\t\t \"continuing.\");\n\t  svcerr_systemerr(transp);\n     }\n     if (!svc_freeargs(transp, xdr_argument, &argument)) {\n\t  krb5_klog_syslog(LOG_ERR, \"WARNING! Unable to free arguments, \"\n\t\t \"continuing.\");\n     }\n     return;\n}",
    "includes": [
      "#include \"kadm5/server_internal.h\"",
      "#include \"misc.h\"",
      "#include <arpa/inet.h>",
      "#include <adm_proto.h>",
      "#include <kadm5/admin.h>",
      "#include <krb5.h>",
      "#include <kadm5/kadm_rpc.h>",
      "#include <memory.h>",
      "#include <syslog.h>",
      "#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */",
      "#include <gssrpc/rpc.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int check_rpcsec_auth(struct svc_req *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"WARNING! Unable to free arguments, \"\n\t\t \"continuing.\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_freeargs",
          "args": [
            "transp",
            "xdr_argument",
            "&argument"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcerr_systemerr",
          "args": [
            "transp"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"WARNING! Unable to send function results, \"\n\t\t \"continuing.\""
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_sendreply",
          "args": [
            "transp",
            "xdr_result",
            "result"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&argument",
            "rqstp"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcerr_decode",
          "args": [
            "transp"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_getargs",
          "args": [
            "transp",
            "xdr_argument",
            "&argument"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&argument",
            "0",
            "sizeof(argument)"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcerr_noproc",
          "args": [
            "transp"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Invalid KADM5 procedure number: %s, %d\"",
            "inet_ntoa(rqstp->rq_xprt->xp_raddr.sin_addr)",
            "rqstp->rq_proc"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "rqstp->rq_xprt->xp_raddr.sin_addr"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svc_sendreply",
          "args": [
            "transp",
            "xdr_void",
            "(char *)NULL"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svcerr_weakauth",
          "args": [
            "transp"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_klog_syslog",
          "args": [
            "LOG_ERR",
            "\"Authentication attempt failed: %s, \"\n\t\t \"RPC authentication flavor %d\"",
            "inet_ntoa(rqstp->rq_xprt->xp_raddr.sin_addr)",
            "rqstp->rq_cred.oa_flavor"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inet_ntoa",
          "args": [
            "rqstp->rq_xprt->xp_raddr.sin_addr"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_rpcsec_auth",
          "args": [
            "rqstp"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "check_rpcsec_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/server/kadm_rpc_svc.c",
          "lines": "240-306",
          "snippet": "static int\ncheck_rpcsec_auth(struct svc_req *rqstp)\n{\n     gss_ctx_id_t ctx;\n     krb5_context kctx;\n     OM_uint32 maj_stat, min_stat;\n     gss_name_t name;\n     krb5_principal princ;\n     int ret, success;\n     krb5_data *c1, *c2, *realm;\n     gss_buffer_desc gss_str;\n     kadm5_server_handle_t handle;\n\n     success = 0;\n     handle = (kadm5_server_handle_t)global_server_handle;\n\n     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)\n\t  return 0;\n\n     ctx = rqstp->rq_svccred;\n\n     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,\n\t\t\t\t    NULL, NULL, NULL, NULL, NULL);\n     if (maj_stat != GSS_S_COMPLETE) {\n\t  krb5_klog_syslog(LOG_ERR, \"check_rpcsec_auth: \"\n\t\t\t   \"failed inquire_context, stat=%u\", maj_stat);\n\t  log_badauth(maj_stat, min_stat,\n\t\t      &rqstp->rq_xprt->xp_raddr, NULL);\n\t  goto fail_name;\n     }\n\n     kctx = handle->context;\n     ret = gss_to_krb5_name(rqstp, kctx, name, &princ, &gss_str);\n     if (ret == 0)\n\t  goto fail_name;\n\n     /*\n      * Since we accept with GSS_C_NO_NAME, the client can authenticate\n      * against the entire kdb.  Therefore, ensure that the service\n      * name is something reasonable.\n      */\n     if (krb5_princ_size(kctx, princ) != 2)\n\t  goto fail_princ;\n\n     c1 = krb5_princ_component(kctx, princ, 0);\n     c2 = krb5_princ_component(kctx, princ, 1);\n     realm = krb5_princ_realm(kctx, princ);\n     if (strncmp(handle->params.realm, realm->data, realm->length) == 0\n\t && strncmp(\"kadmin\", c1->data, c1->length) == 0) {\n\n\t  if (strncmp(\"history\", c2->data, c2->length) == 0)\n\t       goto fail_princ;\n\t  else\n\t       success = 1;\n     }\n\nfail_princ:\n     if (!success) {\n\t krb5_klog_syslog(LOG_ERR, \"bad service principal %.*s\",\n\t\t\t  gss_str.length, gss_str.value);\n     }\n     gss_release_buffer(&min_stat, &gss_str);\n     krb5_free_principal(kctx, princ);\nfail_name:\n     gss_release_name(&min_stat, &name);\n     return success;\n}",
          "includes": [
            "#include \"kadm5/server_internal.h\"",
            "#include \"misc.h\"",
            "#include <arpa/inet.h>",
            "#include <adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <krb5.h>",
            "#include <kadm5/kadm_rpc.h>",
            "#include <memory.h>",
            "#include <syslog.h>",
            "#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */",
            "#include <gssrpc/rpc.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void *global_server_handle;",
            "static int check_rpcsec_auth(struct svc_req *);",
            "void log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kadm5/server_internal.h\"\n#include \"misc.h\"\n#include <arpa/inet.h>\n#include <adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <kadm5/kadm_rpc.h>\n#include <memory.h>\n#include <syslog.h>\n#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */\n#include <gssrpc/rpc.h>\n#include <stdio.h>\n\nextern void *global_server_handle;\nstatic int check_rpcsec_auth(struct svc_req *);\nvoid log_badauth(OM_uint32 major, OM_uint32 minor,\n\t\t struct sockaddr_in *addr, char *data);\n\nstatic int\ncheck_rpcsec_auth(struct svc_req *rqstp)\n{\n     gss_ctx_id_t ctx;\n     krb5_context kctx;\n     OM_uint32 maj_stat, min_stat;\n     gss_name_t name;\n     krb5_principal princ;\n     int ret, success;\n     krb5_data *c1, *c2, *realm;\n     gss_buffer_desc gss_str;\n     kadm5_server_handle_t handle;\n\n     success = 0;\n     handle = (kadm5_server_handle_t)global_server_handle;\n\n     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)\n\t  return 0;\n\n     ctx = rqstp->rq_svccred;\n\n     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,\n\t\t\t\t    NULL, NULL, NULL, NULL, NULL);\n     if (maj_stat != GSS_S_COMPLETE) {\n\t  krb5_klog_syslog(LOG_ERR, \"check_rpcsec_auth: \"\n\t\t\t   \"failed inquire_context, stat=%u\", maj_stat);\n\t  log_badauth(maj_stat, min_stat,\n\t\t      &rqstp->rq_xprt->xp_raddr, NULL);\n\t  goto fail_name;\n     }\n\n     kctx = handle->context;\n     ret = gss_to_krb5_name(rqstp, kctx, name, &princ, &gss_str);\n     if (ret == 0)\n\t  goto fail_name;\n\n     /*\n      * Since we accept with GSS_C_NO_NAME, the client can authenticate\n      * against the entire kdb.  Therefore, ensure that the service\n      * name is something reasonable.\n      */\n     if (krb5_princ_size(kctx, princ) != 2)\n\t  goto fail_princ;\n\n     c1 = krb5_princ_component(kctx, princ, 0);\n     c2 = krb5_princ_component(kctx, princ, 1);\n     realm = krb5_princ_realm(kctx, princ);\n     if (strncmp(handle->params.realm, realm->data, realm->length) == 0\n\t && strncmp(\"kadmin\", c1->data, c1->length) == 0) {\n\n\t  if (strncmp(\"history\", c2->data, c2->length) == 0)\n\t       goto fail_princ;\n\t  else\n\t       success = 1;\n     }\n\nfail_princ:\n     if (!success) {\n\t krb5_klog_syslog(LOG_ERR, \"bad service principal %.*s\",\n\t\t\t  gss_str.length, gss_str.value);\n     }\n     gss_release_buffer(&min_stat, &gss_str);\n     krb5_free_principal(kctx, princ);\nfail_name:\n     gss_release_name(&min_stat, &name);\n     return success;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool_t",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bool_t",
          "args": [
            "*xdr_argument"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kadm5/server_internal.h\"\n#include \"misc.h\"\n#include <arpa/inet.h>\n#include <adm_proto.h>\n#include <kadm5/admin.h>\n#include <krb5.h>\n#include <kadm5/kadm_rpc.h>\n#include <memory.h>\n#include <syslog.h>\n#include <gssapi/gssapi_krb5.h> /* for gss_nt_krb5_name */\n#include <gssrpc/rpc.h>\n#include <stdio.h>\n\nstatic int check_rpcsec_auth(struct svc_req *);\n\nvoid kadm_1(rqstp, transp)\n   struct svc_req *rqstp;\n   register SVCXPRT *transp;\n{\n     union {\n\t  cprinc_arg create_principal_1_arg;\n\t  dprinc_arg delete_principal_1_arg;\n\t  mprinc_arg modify_principal_1_arg;\n\t  rprinc_arg rename_principal_1_arg;\n\t  gprinc_arg get_principal_1_arg;\n\t  chpass_arg chpass_principal_1_arg;\n\t  chrand_arg chrand_principal_1_arg;\n\t  cpol_arg create_policy_1_arg;\n\t  dpol_arg delete_policy_1_arg;\n\t  mpol_arg modify_policy_1_arg;\n\t  gpol_arg get_policy_1_arg;\n\t  setkey_arg setkey_principal_1_arg;\n\t  setv4key_arg setv4key_principal_1_arg;\n\t  cprinc3_arg create_principal3_1_arg;\n\t  chpass3_arg chpass_principal3_1_arg;\n\t  chrand3_arg chrand_principal3_1_arg;\n\t  setkey3_arg setkey_principal3_1_arg;\n     } argument;\n     char *result;\n     bool_t (*xdr_argument)(), (*xdr_result)();\n     char *(*local)();\n\n     if (rqstp->rq_cred.oa_flavor != AUTH_GSSAPI &&\n\t !check_rpcsec_auth(rqstp)) {\n\t  krb5_klog_syslog(LOG_ERR, \"Authentication attempt failed: %s, \"\n\t\t \"RPC authentication flavor %d\",\n\t\t inet_ntoa(rqstp->rq_xprt->xp_raddr.sin_addr),\n\t\t rqstp->rq_cred.oa_flavor);\n\t  svcerr_weakauth(transp);\n\t  return;\n     }\n     \n     switch (rqstp->rq_proc) {\n     case NULLPROC:\n\t  (void) svc_sendreply(transp, xdr_void, (char *)NULL);\n\t  return;\n\t  \n     case CREATE_PRINCIPAL:\n\t  xdr_argument = xdr_cprinc_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) create_principal_1_svc;\n\t  break;\n\t  \n     case DELETE_PRINCIPAL:\n\t  xdr_argument = xdr_dprinc_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) delete_principal_1_svc;\n\t  break;\n\t  \n     case MODIFY_PRINCIPAL:\n\t  xdr_argument = xdr_mprinc_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) modify_principal_1_svc;\n\t  break;\n\t  \n     case RENAME_PRINCIPAL:\n\t  xdr_argument = xdr_rprinc_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) rename_principal_1_svc;\n\t  break;\n\t  \n     case GET_PRINCIPAL:\n\t  xdr_argument = xdr_gprinc_arg;\n\t  xdr_result = xdr_gprinc_ret;\n\t  local = (char *(*)()) get_principal_1_svc;\n\t  break;\n\n     case GET_PRINCS:\n\t  xdr_argument = xdr_gprincs_arg;\n\t  xdr_result = xdr_gprincs_ret;\n\t  local = (char *(*)()) get_princs_1_svc;\n\t  break;\n\t  \n     case CHPASS_PRINCIPAL:\n\t  xdr_argument = xdr_chpass_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) chpass_principal_1_svc;\n\t  break;\n\n     case SETV4KEY_PRINCIPAL:\n\t  xdr_argument = xdr_setv4key_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) setv4key_principal_1_svc;\n\t  break;\n\n     case SETKEY_PRINCIPAL:\n\t  xdr_argument = xdr_setkey_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) setkey_principal_1_svc;\n\t  break;\n\t  \n     case CHRAND_PRINCIPAL:\n\t  xdr_argument = xdr_chrand_arg;\n\t  xdr_result = xdr_chrand_ret;\n\t  local = (char *(*)()) chrand_principal_1_svc;\n\t  break;\n\t  \n     case CREATE_POLICY:\n\t  xdr_argument = xdr_cpol_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) create_policy_1_svc;\n\t  break;\n\t  \n     case DELETE_POLICY:\n\t  xdr_argument = xdr_dpol_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) delete_policy_1_svc;\n\t  break;\n\t  \n     case MODIFY_POLICY:\n\t  xdr_argument = xdr_mpol_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) modify_policy_1_svc;\n\t  break;\n\t  \n     case GET_POLICY:\n\t  xdr_argument = xdr_gpol_arg;\n\t  xdr_result = xdr_gpol_ret;\n\t  local = (char *(*)()) get_policy_1_svc;\n\t  break;\n\n     case GET_POLS:\n\t  xdr_argument = xdr_gpols_arg;\n\t  xdr_result = xdr_gpols_ret;\n\t  local = (char *(*)()) get_pols_1_svc;\n\t  break;\n\t  \n     case GET_PRIVS:\n\t  xdr_argument = xdr_u_int32;\n\t  xdr_result = xdr_getprivs_ret;\n\t  local = (char *(*)()) get_privs_1_svc;\n\t  break;\n\n     case INIT:\n\t  xdr_argument = xdr_u_int32;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) init_1_svc;\n\t  break;\n\n     case CREATE_PRINCIPAL3:\n\t  xdr_argument = xdr_cprinc3_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) create_principal3_1_svc;\n\t  break;\n\n     case CHPASS_PRINCIPAL3:\n\t  xdr_argument = xdr_chpass3_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) chpass_principal3_1_svc;\n\t  break;\n\n     case CHRAND_PRINCIPAL3:\n\t  xdr_argument = xdr_chrand3_arg;\n\t  xdr_result = xdr_chrand_ret;\n\t  local = (char *(*)()) chrand_principal3_1_svc;\n\t  break;\n\n     case SETKEY_PRINCIPAL3:\n\t  xdr_argument = xdr_setkey3_arg;\n\t  xdr_result = xdr_generic_ret;\n\t  local = (char *(*)()) setkey_principal3_1_svc;\n\t  break;\n\n     default:\n\t  krb5_klog_syslog(LOG_ERR, \"Invalid KADM5 procedure number: %s, %d\",\n\t\t inet_ntoa(rqstp->rq_xprt->xp_raddr.sin_addr),\n\t\t rqstp->rq_proc);\n\t  svcerr_noproc(transp);\n\t  return;\n     }\n     memset((char *)&argument, 0, sizeof(argument));\n     if (!svc_getargs(transp, xdr_argument, &argument)) {\n\t  svcerr_decode(transp);\n\t  return;\n     }\n     result = (*local)(&argument, rqstp);\n     if (result != NULL && !svc_sendreply(transp, xdr_result, result)) {\n\t  krb5_klog_syslog(LOG_ERR, \"WARNING! Unable to send function results, \"\n\t\t \"continuing.\");\n\t  svcerr_systemerr(transp);\n     }\n     if (!svc_freeargs(transp, xdr_argument, &argument)) {\n\t  krb5_klog_syslog(LOG_ERR, \"WARNING! Unable to free arguments, \"\n\t\t \"continuing.\");\n     }\n     return;\n}"
  }
]