[
  {
    "function_name": "kvm_arch_irq_routing_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "429-432",
    "snippet": "void kvm_arch_irq_routing_update(struct kvm *kvm)\n{\n\tkvm_hv_irq_routing_update(kvm);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_irq_routing_update",
          "args": [
            "kvm"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_irq_routing_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "367-383",
          "snippet": "void kvm_hv_irq_routing_update(struct kvm *kvm)\n{\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tu32 gsi;\n\n\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));\n\n\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {\n\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {\n\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)\n\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,\n\t\t\t\t\t\t    e->hv_sint.sint, gsi);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_irq_routing_update(struct kvm *kvm)\n{\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tu32 gsi;\n\n\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));\n\n\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {\n\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {\n\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)\n\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,\n\t\t\t\t\t\t    e->hv_sint.sint, gsi);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_irq_routing_update(struct kvm *kvm)\n{\n\tkvm_hv_irq_routing_update(kvm);\n}"
  },
  {
    "function_name": "kvm_scan_ioapic_routes",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "398-427",
    "snippet": "void kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,\n\t\t\t    ulong *ioapic_handled_vectors)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_kernel_irq_routing_entry *entry;\n\tstruct kvm_irq_routing_table *table;\n\tu32 i, nr_ioapic_pins;\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\ttable = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tnr_ioapic_pins = min_t(u32, table->nr_rt_entries,\n\t\t\t       kvm->arch.nr_reserved_ioapic_pins);\n\tfor (i = 0; i < nr_ioapic_pins; ++i) {\n\t\thlist_for_each_entry(entry, &table->map[i], link) {\n\t\t\tstruct kvm_lapic_irq irq;\n\n\t\t\tif (entry->type != KVM_IRQ_ROUTING_MSI)\n\t\t\t\tcontinue;\n\n\t\t\tkvm_set_msi_irq(vcpu->kvm, entry, &irq);\n\n\t\t\tif (irq.trig_mode &&\n\t\t\t    kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t\tirq.dest_id, irq.dest_mode))\n\t\t\t\t__set_bit(irq.vector, ioapic_handled_vectors);\n\t\t}\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->irq_srcu",
            "idx"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "irq.vector",
            "ioapic_handled_vectors"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "NULL",
            "APIC_DEST_NOSHORT",
            "irq.dest_id",
            "irq.dest_mode"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "808-830",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_msi_irq",
          "args": [
            "vcpu->kvm",
            "entry",
            "&irq"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msi_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "104-125",
          "snippet": "void kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "entry",
            "&table->map[i]",
            "link"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "table->nr_rt_entries",
            "kvm->arch.nr_reserved_ioapic_pins"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference",
          "args": [
            "kvm->irq_routing",
            "&kvm->irq_srcu"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->irq_srcu"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_scan_ioapic_routes(struct kvm_vcpu *vcpu,\n\t\t\t    ulong *ioapic_handled_vectors)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_kernel_irq_routing_entry *entry;\n\tstruct kvm_irq_routing_table *table;\n\tu32 i, nr_ioapic_pins;\n\tint idx;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\ttable = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tnr_ioapic_pins = min_t(u32, table->nr_rt_entries,\n\t\t\t       kvm->arch.nr_reserved_ioapic_pins);\n\tfor (i = 0; i < nr_ioapic_pins; ++i) {\n\t\thlist_for_each_entry(entry, &table->map[i], link) {\n\t\t\tstruct kvm_lapic_irq irq;\n\n\t\t\tif (entry->type != KVM_IRQ_ROUTING_MSI)\n\t\t\t\tcontinue;\n\n\t\t\tkvm_set_msi_irq(vcpu->kvm, entry, &irq);\n\n\t\t\tif (irq.trig_mode &&\n\t\t\t    kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t\tirq.dest_id, irq.dest_mode))\n\t\t\t\t__set_bit(irq.vector, ioapic_handled_vectors);\n\t\t}\n\t}\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
  },
  {
    "function_name": "kvm_arch_post_irq_routing_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "391-396",
    "snippet": "void kvm_arch_post_irq_routing_update(struct kvm *kvm)\n{\n\tif (!irqchip_split(kvm))\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_scan_ioapic_request",
          "args": [
            "kvm"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_make_scan_ioapic_request",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8034-8037",
          "snippet": "void kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_split",
          "args": [
            "kvm"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_split",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.h",
          "lines": "78-85",
          "snippet": "static inline int irqchip_split(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_SPLIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_split(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_SPLIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_post_irq_routing_update(struct kvm *kvm)\n{\n\tif (!irqchip_split(kvm))\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}"
  },
  {
    "function_name": "kvm_setup_empty_irq_routing",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "386-389",
    "snippet": "int kvm_setup_empty_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, empty_routing, 0, 0);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_irq_routing_entry empty_routing[] = {};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_irq_routing",
          "args": [
            "kvm",
            "empty_routing",
            "0",
            "0"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic const struct kvm_irq_routing_entry empty_routing[] = {};\n\nint kvm_setup_empty_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, empty_routing, 0, 0);\n}"
  },
  {
    "function_name": "kvm_setup_default_irq_routing",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "378-382",
    "snippet": "int kvm_setup_default_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, default_routing,\n\t\t\t\t   ARRAY_SIZE(default_routing), 0);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_irq_routing_entry default_routing[] = {\n\tROUTING_ENTRY2(0), ROUTING_ENTRY2(1),\n\tROUTING_ENTRY2(2), ROUTING_ENTRY2(3),\n\tROUTING_ENTRY2(4), ROUTING_ENTRY2(5),\n\tROUTING_ENTRY2(6), ROUTING_ENTRY2(7),\n\tROUTING_ENTRY2(8), ROUTING_ENTRY2(9),\n\tROUTING_ENTRY2(10), ROUTING_ENTRY2(11),\n\tROUTING_ENTRY2(12), ROUTING_ENTRY2(13),\n\tROUTING_ENTRY2(14), ROUTING_ENTRY2(15),\n\tROUTING_ENTRY1(16), ROUTING_ENTRY1(17),\n\tROUTING_ENTRY1(18), ROUTING_ENTRY1(19),\n\tROUTING_ENTRY1(20), ROUTING_ENTRY1(21),\n\tROUTING_ENTRY1(22), ROUTING_ENTRY1(23),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_irq_routing",
          "args": [
            "kvm",
            "default_routing",
            "ARRAY_SIZE(default_routing)",
            "0"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "default_routing"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic const struct kvm_irq_routing_entry default_routing[] = {\n\tROUTING_ENTRY2(0), ROUTING_ENTRY2(1),\n\tROUTING_ENTRY2(2), ROUTING_ENTRY2(3),\n\tROUTING_ENTRY2(4), ROUTING_ENTRY2(5),\n\tROUTING_ENTRY2(6), ROUTING_ENTRY2(7),\n\tROUTING_ENTRY2(8), ROUTING_ENTRY2(9),\n\tROUTING_ENTRY2(10), ROUTING_ENTRY2(11),\n\tROUTING_ENTRY2(12), ROUTING_ENTRY2(13),\n\tROUTING_ENTRY2(14), ROUTING_ENTRY2(15),\n\tROUTING_ENTRY1(16), ROUTING_ENTRY1(17),\n\tROUTING_ENTRY1(18), ROUTING_ENTRY1(19),\n\tROUTING_ENTRY1(20), ROUTING_ENTRY1(21),\n\tROUTING_ENTRY1(22), ROUTING_ENTRY1(23),\n};\n\nint kvm_setup_default_irq_routing(struct kvm *kvm)\n{\n\treturn kvm_set_irq_routing(kvm, default_routing,\n\t\t\t\t   ARRAY_SIZE(default_routing), 0);\n}"
  },
  {
    "function_name": "kvm_intr_is_single_vcpu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "325-349",
    "snippet": "bool kvm_intr_is_single_vcpu(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\t     struct kvm_vcpu **dest_vcpu)\n{\n\tint i, r = 0;\n\tstruct kvm_vcpu *vcpu;\n\n\tif (kvm_intr_is_single_vcpu_fast(kvm, irq, dest_vcpu))\n\t\treturn true;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, NULL, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (++r == 2)\n\t\t\treturn false;\n\n\t\t*dest_vcpu = vcpu;\n\t}\n\n\treturn r == 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "NULL",
            "irq->shorthand",
            "irq->dest_id",
            "irq->dest_mode"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "808-830",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_present",
          "args": [
            "vcpu"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_present",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "193-196",
          "snippet": "static inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_intr_is_single_vcpu_fast",
          "args": [
            "kvm",
            "irq",
            "dest_vcpu"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_intr_is_single_vcpu_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "997-1023",
          "snippet": "bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tbool ret = false;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (kvm_apic_map_get_dest_lapic(kvm, NULL, irq, map, &dst, &bitmap) &&\n\t\t\thweight16(bitmap) == 1) {\n\t\tunsigned long i = find_first_bit(&bitmap, 16);\n\n\t\tif (dst[i]) {\n\t\t\t*dest_vcpu = dst[i]->vcpu;\n\t\t\tret = true;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tbool ret = false;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (kvm_apic_map_get_dest_lapic(kvm, NULL, irq, map, &dst, &bitmap) &&\n\t\t\thweight16(bitmap) == 1) {\n\t\tunsigned long i = find_first_bit(&bitmap, 16);\n\n\t\tif (dst[i]) {\n\t\t\t*dest_vcpu = dst[i]->vcpu;\n\t\t\tret = true;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nbool kvm_intr_is_single_vcpu(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\t     struct kvm_vcpu **dest_vcpu)\n{\n\tint i, r = 0;\n\tstruct kvm_vcpu *vcpu;\n\n\tif (kvm_intr_is_single_vcpu_fast(kvm, irq, dest_vcpu))\n\t\treturn true;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, NULL, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (++r == 2)\n\t\t\treturn false;\n\n\t\t*dest_vcpu = vcpu;\n\t}\n\n\treturn r == 1;\n}"
  },
  {
    "function_name": "kvm_set_routing_entry",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "272-323",
    "snippet": "int kvm_set_routing_entry(struct kvm *kvm,\n\t\t\t  struct kvm_kernel_irq_routing_entry *e,\n\t\t\t  const struct kvm_irq_routing_entry *ue)\n{\n\t/* We can't check irqchip_in_kernel() here as some callers are\n\t * currently inititalizing the irqchip. Other callers should therefore\n\t * check kvm_arch_can_set_irq_routing() before calling this function.\n\t */\n\tswitch (ue->type) {\n\tcase KVM_IRQ_ROUTING_IRQCHIP:\n\t\tif (irqchip_split(kvm))\n\t\t\treturn -EINVAL;\n\t\te->irqchip.pin = ue->u.irqchip.pin;\n\t\tswitch (ue->u.irqchip.irqchip) {\n\t\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\t\te->irqchip.pin += PIC_NUM_PINS / 2;\n\t\t\t/* fall through */\n\t\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\t\tif (ue->u.irqchip.pin >= PIC_NUM_PINS / 2)\n\t\t\t\treturn -EINVAL;\n\t\t\te->set = kvm_set_pic_irq;\n\t\t\tbreak;\n\t\tcase KVM_IRQCHIP_IOAPIC:\n\t\t\tif (ue->u.irqchip.pin >= KVM_IOAPIC_NUM_PINS)\n\t\t\t\treturn -EINVAL;\n\t\t\te->set = kvm_set_ioapic_irq;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\te->irqchip.irqchip = ue->u.irqchip.irqchip;\n\t\tbreak;\n\tcase KVM_IRQ_ROUTING_MSI:\n\t\te->set = kvm_set_msi;\n\t\te->msi.address_lo = ue->u.msi.address_lo;\n\t\te->msi.address_hi = ue->u.msi.address_hi;\n\t\te->msi.data = ue->u.msi.data;\n\n\t\tif (kvm_msi_route_invalid(kvm, e))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase KVM_IRQ_ROUTING_HV_SINT:\n\t\te->set = kvm_hv_set_sint;\n\t\te->hv_sint.vcpu = ue->u.hv_sint.vcpu;\n\t\te->hv_sint.sint = ue->u.hv_sint.sint;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_msi_route_invalid",
          "args": [
            "kvm",
            "e"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_msi_route_invalid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "128-132",
          "snippet": "static inline bool kvm_msi_route_invalid(struct kvm *kvm,\n\t\tstruct kvm_kernel_irq_routing_entry *e)\n{\n\treturn kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_msi_route_invalid(struct kvm *kvm,\n\t\tstruct kvm_kernel_irq_routing_entry *e)\n{\n\treturn kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_split",
          "args": [
            "kvm"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_split",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.h",
          "lines": "78-85",
          "snippet": "static inline int irqchip_split(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_SPLIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_split(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_SPLIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_set_routing_entry(struct kvm *kvm,\n\t\t\t  struct kvm_kernel_irq_routing_entry *e,\n\t\t\t  const struct kvm_irq_routing_entry *ue)\n{\n\t/* We can't check irqchip_in_kernel() here as some callers are\n\t * currently inititalizing the irqchip. Other callers should therefore\n\t * check kvm_arch_can_set_irq_routing() before calling this function.\n\t */\n\tswitch (ue->type) {\n\tcase KVM_IRQ_ROUTING_IRQCHIP:\n\t\tif (irqchip_split(kvm))\n\t\t\treturn -EINVAL;\n\t\te->irqchip.pin = ue->u.irqchip.pin;\n\t\tswitch (ue->u.irqchip.irqchip) {\n\t\tcase KVM_IRQCHIP_PIC_SLAVE:\n\t\t\te->irqchip.pin += PIC_NUM_PINS / 2;\n\t\t\t/* fall through */\n\t\tcase KVM_IRQCHIP_PIC_MASTER:\n\t\t\tif (ue->u.irqchip.pin >= PIC_NUM_PINS / 2)\n\t\t\t\treturn -EINVAL;\n\t\t\te->set = kvm_set_pic_irq;\n\t\t\tbreak;\n\t\tcase KVM_IRQCHIP_IOAPIC:\n\t\t\tif (ue->u.irqchip.pin >= KVM_IOAPIC_NUM_PINS)\n\t\t\t\treturn -EINVAL;\n\t\t\te->set = kvm_set_ioapic_irq;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\te->irqchip.irqchip = ue->u.irqchip.irqchip;\n\t\tbreak;\n\tcase KVM_IRQ_ROUTING_MSI:\n\t\te->set = kvm_set_msi;\n\t\te->msi.address_lo = ue->u.msi.address_lo;\n\t\te->msi.address_hi = ue->u.msi.address_hi;\n\t\te->msi.data = ue->u.msi.data;\n\n\t\tif (kvm_msi_route_invalid(kvm, e))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase KVM_IRQ_ROUTING_HV_SINT:\n\t\te->set = kvm_hv_set_sint;\n\t\te->hv_sint.vcpu = ue->u.hv_sint.vcpu;\n\t\te->hv_sint.sint = ue->u.hv_sint.sint;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_can_set_irq_routing",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "267-270",
    "snippet": "bool kvm_arch_can_set_irq_routing(struct kvm *kvm)\n{\n\treturn irqchip_in_kernel(kvm);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.h",
          "lines": "96-103",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode != KVM_IRQCHIP_NONE;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode != KVM_IRQCHIP_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nbool kvm_arch_can_set_irq_routing(struct kvm *kvm)\n{\n\treturn irqchip_in_kernel(kvm);\n}"
  },
  {
    "function_name": "kvm_fire_mask_notifiers",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "252-265",
    "snippet": "void kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->irq_srcu",
            "idx"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kimn->func",
          "args": [
            "kimn",
            "mask"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "kimn",
            "&kvm->arch.mask_notifier_list",
            "link"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_irq_map_chip_pin",
          "args": [
            "kvm",
            "irqchip",
            "pin"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->irq_srcu"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
  },
  {
    "function_name": "kvm_unregister_irq_mask_notifier",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "243-250",
    "snippet": "void kvm_unregister_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t      struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\thlist_del_rcu(&kimn->link);\n\tmutex_unlock(&kvm->irq_lock);\n\tsynchronize_srcu(&kvm->irq_srcu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "&kvm->irq_srcu"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&kimn->link"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_unregister_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t      struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\thlist_del_rcu(&kimn->link);\n\tmutex_unlock(&kvm->irq_lock);\n\tsynchronize_srcu(&kvm->irq_srcu);\n}"
  },
  {
    "function_name": "kvm_register_irq_mask_notifier",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "234-241",
    "snippet": "void kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t    struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\tkimn->irq = irq;\n\thlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);\n\tmutex_unlock(&kvm->irq_lock);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&kimn->link",
            "&kvm->arch.mask_notifier_list"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t    struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\tkimn->irq = irq;\n\thlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);\n\tmutex_unlock(&kvm->irq_lock);\n}"
  },
  {
    "function_name": "kvm_free_irq_source_id",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "213-232",
    "snippet": "void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!irqchip_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(kvm->arch.vpic, irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pic_clear_all",
          "args": [
            "kvm->arch.vpic",
            "irq_source_id"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_clear_all",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "204-212",
          "snippet": "void kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)\n{\n\tint i;\n\n\tpic_lock(s);\n\tfor (i = 0; i < PIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &s->irq_states[i]);\n\tpic_unlock(s);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)\n{\n\tint i;\n\n\tpic_lock(s);\n\tfor (i = 0; i < PIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &s->irq_states[i]);\n\tpic_unlock(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_clear_all",
          "args": [
            "kvm->arch.vioapic",
            "irq_source_id"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_clear_all",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "476-484",
          "snippet": "void kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)\n{\n\tint i;\n\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &ioapic->irq_states[i]);\n\tspin_unlock(&ioapic->lock);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)\n{\n\tint i;\n\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &ioapic->irq_states[i]);\n\tspin_unlock(&ioapic->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_kernel",
          "args": [
            "kvm"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.h",
          "lines": "87-94",
          "snippet": "static inline int irqchip_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "irq_source_id",
            "&kvm->arch.irq_sources_bitmap"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "214-222",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kvm: IRQ source ID out of range!\\n\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!irqchip_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(kvm->arch.vpic, irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}"
  },
  {
    "function_name": "kvm_request_irq_source_id",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "190-211",
    "snippet": "int kvm_request_irq_source_id(struct kvm *kvm)\n{\n\tunsigned long *bitmap = &kvm->arch.irq_sources_bitmap;\n\tint irq_source_id;\n\n\tmutex_lock(&kvm->irq_lock);\n\tirq_source_id = find_first_zero_bit(bitmap, BITS_PER_LONG);\n\n\tif (irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_WARNING \"kvm: exhaust allocatable IRQ sources!\\n\");\n\t\tirq_source_id = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\tset_bit(irq_source_id, bitmap);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n\n\treturn irq_source_id;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "irq_source_id",
            "bitmap"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "224-232",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"kvm: exhaust allocatable IRQ sources!\\n\""
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "bitmap",
            "BITS_PER_LONG"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_request_irq_source_id(struct kvm *kvm)\n{\n\tunsigned long *bitmap = &kvm->arch.irq_sources_bitmap;\n\tint irq_source_id;\n\n\tmutex_lock(&kvm->irq_lock);\n\tirq_source_id = find_first_zero_bit(bitmap, BITS_PER_LONG);\n\n\tif (irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_WARNING \"kvm: exhaust allocatable IRQ sources!\\n\");\n\t\tirq_source_id = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\tset_bit(irq_source_id, bitmap);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n\n\treturn irq_source_id;\n}"
  },
  {
    "function_name": "kvm_arch_set_irq_inatomic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "161-188",
    "snippet": "int kvm_arch_set_irq_inatomic(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t      struct kvm *kvm, int irq_source_id, int level,\n\t\t\t      bool line_status)\n{\n\tstruct kvm_lapic_irq irq;\n\tint r;\n\n\tswitch (e->type) {\n\tcase KVM_IRQ_ROUTING_HV_SINT:\n\t\treturn kvm_hv_set_sint(e, kvm, irq_source_id, level,\n\t\t\t\t       line_status);\n\n\tcase KVM_IRQ_ROUTING_MSI:\n\t\tif (kvm_msi_route_invalid(kvm, e))\n\t\t\treturn -EINVAL;\n\n\t\tkvm_set_msi_irq(kvm, e, &irq);\n\n\t\tif (kvm_irq_delivery_to_apic_fast(kvm, NULL, &irq, &r, NULL))\n\t\t\treturn r;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EWOULDBLOCK;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic_fast",
          "args": [
            "kvm",
            "NULL",
            "&irq",
            "&r",
            "NULL"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "950-981",
          "snippet": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_msi_irq",
          "args": [
            "kvm",
            "e",
            "&irq"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msi_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "104-125",
          "snippet": "void kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_msi_route_invalid",
          "args": [
            "kvm",
            "e"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_msi_route_invalid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "128-132",
          "snippet": "static inline bool kvm_msi_route_invalid(struct kvm *kvm,\n\t\tstruct kvm_kernel_irq_routing_entry *e)\n{\n\treturn kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_msi_route_invalid(struct kvm *kvm,\n\t\tstruct kvm_kernel_irq_routing_entry *e)\n{\n\treturn kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_set_sint",
          "args": [
            "e",
            "kvm",
            "irq_source_id",
            "level",
            "line_status"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_set_sint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "151-159",
          "snippet": "static int kvm_hv_set_sint(struct kvm_kernel_irq_routing_entry *e,\n\t\t    struct kvm *kvm, int irq_source_id, int level,\n\t\t    bool line_status)\n{\n\tif (!level)\n\t\treturn -1;\n\n\treturn kvm_hv_synic_set_irq(kvm, e->hv_sint.vcpu, e->hv_sint.sint);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_hv_set_sint(struct kvm_kernel_irq_routing_entry *e,\n\t\t    struct kvm *kvm, int irq_source_id, int level,\n\t\t    bool line_status)\n{\n\tif (!level)\n\t\treturn -1;\n\n\treturn kvm_hv_synic_set_irq(kvm, e->hv_sint.vcpu, e->hv_sint.sint);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_arch_set_irq_inatomic(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t      struct kvm *kvm, int irq_source_id, int level,\n\t\t\t      bool line_status)\n{\n\tstruct kvm_lapic_irq irq;\n\tint r;\n\n\tswitch (e->type) {\n\tcase KVM_IRQ_ROUTING_HV_SINT:\n\t\treturn kvm_hv_set_sint(e, kvm, irq_source_id, level,\n\t\t\t\t       line_status);\n\n\tcase KVM_IRQ_ROUTING_MSI:\n\t\tif (kvm_msi_route_invalid(kvm, e))\n\t\t\treturn -EINVAL;\n\n\t\tkvm_set_msi_irq(kvm, e, &irq);\n\n\t\tif (kvm_irq_delivery_to_apic_fast(kvm, NULL, &irq, &r, NULL))\n\t\t\treturn r;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -EWOULDBLOCK;\n}"
  },
  {
    "function_name": "kvm_hv_set_sint",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "151-159",
    "snippet": "static int kvm_hv_set_sint(struct kvm_kernel_irq_routing_entry *e,\n\t\t    struct kvm *kvm, int irq_source_id, int level,\n\t\t    bool line_status)\n{\n\tif (!level)\n\t\treturn -1;\n\n\treturn kvm_hv_synic_set_irq(kvm, e->hv_sint.vcpu, e->hv_sint.sint);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_synic_set_irq",
          "args": [
            "kvm",
            "e->hv_sint.vcpu",
            "e->hv_sint.sint"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_synic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "329-338",
          "snippet": "int kvm_hv_synic_set_irq(struct kvm *kvm, u32 vpidx, u32 sint)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vpidx);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\treturn synic_set_irq(synic, sint);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_synic_set_irq(struct kvm *kvm, u32 vpidx, u32 sint)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vpidx);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\treturn synic_set_irq(synic, sint);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_hv_set_sint(struct kvm_kernel_irq_routing_entry *e,\n\t\t    struct kvm *kvm, int irq_source_id, int level,\n\t\t    bool line_status)\n{\n\tif (!level)\n\t\treturn -1;\n\n\treturn kvm_hv_synic_set_irq(kvm, e->hv_sint.vcpu, e->hv_sint.sint);\n}"
  },
  {
    "function_name": "kvm_set_msi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "134-148",
    "snippet": "int kvm_set_msi(struct kvm_kernel_irq_routing_entry *e,\n\t\tstruct kvm *kvm, int irq_source_id, int level, bool line_status)\n{\n\tstruct kvm_lapic_irq irq;\n\n\tif (kvm_msi_route_invalid(kvm, e))\n\t\treturn -EINVAL;\n\n\tif (!level)\n\t\treturn -1;\n\n\tkvm_set_msi_irq(kvm, e, &irq);\n\n\treturn kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic",
          "args": [
            "kvm",
            "NULL",
            "&irq",
            "NULL"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "47-102",
          "snippet": "int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL &&\n\t    irq->dest_id == 0xff && kvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL &&\n\t    irq->dest_id == 0xff && kvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_msi_irq",
          "args": [
            "kvm",
            "e",
            "&irq"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msi_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "104-125",
          "snippet": "void kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_msi_route_invalid",
          "args": [
            "kvm",
            "e"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_msi_route_invalid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "128-132",
          "snippet": "static inline bool kvm_msi_route_invalid(struct kvm *kvm,\n\t\tstruct kvm_kernel_irq_routing_entry *e)\n{\n\treturn kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_msi_route_invalid(struct kvm *kvm,\n\t\tstruct kvm_kernel_irq_routing_entry *e)\n{\n\treturn kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_set_msi(struct kvm_kernel_irq_routing_entry *e,\n\t\tstruct kvm *kvm, int irq_source_id, int level, bool line_status)\n{\n\tstruct kvm_lapic_irq irq;\n\n\tif (kvm_msi_route_invalid(kvm, e))\n\t\treturn -EINVAL;\n\n\tif (!level)\n\t\treturn -1;\n\n\tkvm_set_msi_irq(kvm, e, &irq);\n\n\treturn kvm_irq_delivery_to_apic(kvm, NULL, &irq, NULL);\n}"
  },
  {
    "function_name": "kvm_msi_route_invalid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "128-132",
    "snippet": "static inline bool kvm_msi_route_invalid(struct kvm *kvm,\n\t\tstruct kvm_kernel_irq_routing_entry *e)\n{\n\treturn kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_msi_route_invalid(struct kvm *kvm,\n\t\tstruct kvm_kernel_irq_routing_entry *e)\n{\n\treturn kvm->arch.x2apic_format && (e->msi.address_hi & 0xff);\n}"
  },
  {
    "function_name": "kvm_set_msi_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "104-125",
    "snippet": "void kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_irq_dest_mode",
          "args": [
            "!!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSI_ADDR_EXT_DEST_ID",
          "args": [
            "e->msi.address_hi"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_msi_set_irq",
          "args": [
            "e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0)",
            "e->msi.data"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}"
  },
  {
    "function_name": "kvm_irq_delivery_to_apic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "47-102",
    "snippet": "int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL &&\n\t    irq->dest_id == 0xff && kvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_set_irq",
          "args": [
            "lowest",
            "irq",
            "dest_map"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "563-570",
          "snippet": "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_vcpu",
          "args": [
            "kvm",
            "idx"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vector_to_index",
          "args": [
            "irq->vector",
            "dest_vcpus",
            "dest_vcpu_bitmap",
            "KVM_MAX_VCPUS"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vector_to_index",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "833-847",
          "snippet": "int kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "i",
            "dest_vcpu_bitmap"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_compare_prio",
          "args": [
            "vcpu",
            "lowest"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_compare_prio",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1172-1175",
          "snippet": "int kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vector_hashing_enabled",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vector_hashing_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10529-10532",
          "snippet": "bool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_sw_enabled",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_sw_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "186-191",
          "snippet": "static inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lowest_prio_delivery",
          "args": [
            "irq"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lowest_prio_delivery",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "218-222",
          "snippet": "static inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)\n{\n\treturn (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\tirq->msi_redir_hint);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)\n{\n\treturn (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\tirq->msi_redir_hint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "src",
            "irq->shorthand",
            "irq->dest_id",
            "irq->dest_mode"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "808-830",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_present",
          "args": [
            "vcpu"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_present",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "193-196",
          "snippet": "static inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dest_vcpu_bitmap",
            "0",
            "sizeof(dest_vcpu_bitmap)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic_fast",
          "args": [
            "kvm",
            "src",
            "irq",
            "&r",
            "dest_map"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "950-981",
          "snippet": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BITS_TO_LONGS",
          "args": [
            "KVM_MAX_VCPUS"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL &&\n\t    irq->dest_id == 0xff && kvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_set_ioapic_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "38-45",
    "snippet": "static int kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t      struct kvm *kvm, int irq_source_id, int level,\n\t\t\t      bool line_status)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\treturn kvm_ioapic_set_irq(ioapic, e->irqchip.pin, irq_source_id, level,\n\t\t\t\tline_status);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_ioapic_set_irq",
          "args": [
            "ioapic",
            "e->irqchip.pin",
            "irq_source_id",
            "level",
            "line_status"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "459-474",
          "snippet": "int kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level, bool line_status)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);\n\n\tspin_lock(&ioapic->lock);\n\tirq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = ioapic_set_irq(ioapic, irq, irq_level, line_status);\n\n\tspin_unlock(&ioapic->lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nint kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level, bool line_status)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);\n\n\tspin_lock(&ioapic->lock);\n\tirq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = ioapic_set_irq(ioapic, irq, irq_level, line_status);\n\n\tspin_unlock(&ioapic->lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_set_ioapic_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t      struct kvm *kvm, int irq_source_id, int level,\n\t\t\t      bool line_status)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\treturn kvm_ioapic_set_irq(ioapic, e->irqchip.pin, irq_source_id, level,\n\t\t\t\tline_status);\n}"
  },
  {
    "function_name": "kvm_set_pic_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
    "lines": "30-36",
    "snippet": "static int kvm_set_pic_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t   struct kvm *kvm, int irq_source_id, int level,\n\t\t\t   bool line_status)\n{\n\tstruct kvm_pic *pic = kvm->arch.vpic;\n\treturn kvm_pic_set_irq(pic, e->irqchip.pin, irq_source_id, level);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"hyperv.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include \"irq.h\"",
      "#include <asm/msidef.h>",
      "#include <trace/events/kvm.h>",
      "#include <linux/rculist.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pic_set_irq",
          "args": [
            "pic",
            "e->irqchip.pin",
            "irq_source_id",
            "level"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "186-202",
          "snippet": "int kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= PIC_NUM_PINS);\n\n\tpic_lock(s);\n\tirq_level = __kvm_irq_line_state(&s->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);\n\tpic_update_irq(s);\n\ttrace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,\n\t\t\t      s->pics[irq >> 3].imr, ret == 0);\n\tpic_unlock(s);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nint kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= PIC_NUM_PINS);\n\n\tpic_lock(s);\n\tirq_level = __kvm_irq_line_state(&s->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);\n\tpic_update_irq(s);\n\ttrace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,\n\t\t\t      s->pics[irq >> 3].imr, ret == 0);\n\tpic_unlock(s);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int kvm_set_pic_irq(struct kvm_kernel_irq_routing_entry *e,\n\t\t\t   struct kvm *kvm, int irq_source_id, int level,\n\t\t\t   bool line_status)\n{\n\tstruct kvm_pic *pic = kvm->arch.vpic;\n\treturn kvm_pic_set_irq(pic, e->irqchip.pin, irq_source_id, level);\n}"
  }
]