[
  {
    "function_name": "amd_pmu_reset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "300-311",
    "snippet": "static void amd_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < AMD64_NUM_COUNTERS_CORE; i++) {\n\t\tstruct kvm_pmc *pmc = &pmu->gp_counters[i];\n\n\t\tpmc_stop_counter(pmc);\n\t\tpmc->counter = pmc->eventsel = 0;\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmc_stop_counter",
          "args": [
            "pmc"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_stop_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "71-77",
          "snippet": "static inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tpmc_release_perf_event(pmc);\n\t}\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tpmc_release_perf_event(pmc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void amd_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < AMD64_NUM_COUNTERS_CORE; i++) {\n\t\tstruct kvm_pmc *pmc = &pmu->gp_counters[i];\n\n\t\tpmc_stop_counter(pmc);\n\t\tpmc->counter = pmc->eventsel = 0;\n\t}\n}"
  },
  {
    "function_name": "amd_pmu_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "285-298",
    "snippet": "static void amd_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint i;\n\n\tBUILD_BUG_ON(AMD64_NUM_COUNTERS_CORE > INTEL_PMC_MAX_GENERIC);\n\n\tfor (i = 0; i < AMD64_NUM_COUNTERS_CORE ; i++) {\n\t\tpmu->gp_counters[i].type = KVM_PMC_GP;\n\t\tpmu->gp_counters[i].vcpu = vcpu;\n\t\tpmu->gp_counters[i].idx = i;\n\t\tpmu->gp_counters[i].current_config = 0;\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "AMD64_NUM_COUNTERS_CORE > INTEL_PMC_MAX_GENERIC"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void amd_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint i;\n\n\tBUILD_BUG_ON(AMD64_NUM_COUNTERS_CORE > INTEL_PMC_MAX_GENERIC);\n\n\tfor (i = 0; i < AMD64_NUM_COUNTERS_CORE ; i++) {\n\t\tpmu->gp_counters[i].type = KVM_PMC_GP;\n\t\tpmu->gp_counters[i].vcpu = vcpu;\n\t\tpmu->gp_counters[i].idx = i;\n\t\tpmu->gp_counters[i].current_config = 0;\n\t}\n}"
  },
  {
    "function_name": "amd_pmu_refresh",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "266-283",
    "snippet": "static void amd_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_PERFCTR_CORE))\n\t\tpmu->nr_arch_gp_counters = AMD64_NUM_COUNTERS_CORE;\n\telse\n\t\tpmu->nr_arch_gp_counters = AMD64_NUM_COUNTERS;\n\n\tpmu->counter_bitmask[KVM_PMC_GP] = ((u64)1 << 48) - 1;\n\tpmu->reserved_bits = 0xffffffff00200000ull;\n\tpmu->version = 1;\n\t/* not applicable to AMD; but clean them to prevent any fall out */\n\tpmu->counter_bitmask[KVM_PMC_FIXED] = 0;\n\tpmu->nr_arch_fixed_counters = 0;\n\tpmu->global_status = 0;\n\tbitmap_set(pmu->all_valid_pmc_idx, 0, pmu->nr_arch_gp_counters);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "pmu->all_valid_pmc_idx",
            "0",
            "pmu->nr_arch_gp_counters"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_PERFCTR_CORE"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void amd_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_PERFCTR_CORE))\n\t\tpmu->nr_arch_gp_counters = AMD64_NUM_COUNTERS_CORE;\n\telse\n\t\tpmu->nr_arch_gp_counters = AMD64_NUM_COUNTERS;\n\n\tpmu->counter_bitmask[KVM_PMC_GP] = ((u64)1 << 48) - 1;\n\tpmu->reserved_bits = 0xffffffff00200000ull;\n\tpmu->version = 1;\n\t/* not applicable to AMD; but clean them to prevent any fall out */\n\tpmu->counter_bitmask[KVM_PMC_FIXED] = 0;\n\tpmu->nr_arch_fixed_counters = 0;\n\tpmu->global_status = 0;\n\tbitmap_set(pmu->all_valid_pmc_idx, 0, pmu->nr_arch_gp_counters);\n}"
  },
  {
    "function_name": "amd_pmu_set_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "239-264",
    "snippet": "static int amd_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\t/* MSR_PERFCTRn */\n\tpmc = get_gp_pmc_amd(pmu, msr, PMU_TYPE_COUNTER);\n\tif (pmc) {\n\t\tpmc->counter += data - pmc_read_counter(pmc);\n\t\treturn 0;\n\t}\n\t/* MSR_EVNTSELn */\n\tpmc = get_gp_pmc_amd(pmu, msr, PMU_TYPE_EVNTSEL);\n\tif (pmc) {\n\t\tif (data == pmc->eventsel)\n\t\t\treturn 0;\n\t\tif (!(data & pmu->reserved_bits)) {\n\t\t\treprogram_gp_counter(pmc, data);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reprogram_gp_counter",
          "args": [
            "pmc",
            "data"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_gp_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.c",
          "lines": "171-236",
          "snippet": "void reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\tstruct kvm *kvm = pmc->vcpu->kvm;\n\tstruct kvm_pmu_event_filter *filter;\n\tint i;\n\tbool allow_event = true;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_pause_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tfilter = srcu_dereference(kvm->arch.pmu_event_filter, &kvm->srcu);\n\tif (filter) {\n\t\tfor (i = 0; i < filter->nevents; i++)\n\t\t\tif (filter->events[i] ==\n\t\t\t    (eventsel & AMD64_RAW_EVENT_MASK_NB))\n\t\t\t\tbreak;\n\t\tif (filter->action == KVM_PMU_EVENT_ALLOW &&\n\t\t    i == filter->nevents)\n\t\t\tallow_event = false;\n\t\tif (filter->action == KVM_PMU_EVENT_DENY &&\n\t\t    i < filter->nevents)\n\t\t\tallow_event = false;\n\t}\n\tif (!allow_event)\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops.pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tif (pmc->current_config == eventsel && pmc_resume_counter(pmc))\n\t\treturn;\n\n\tpmc_release_perf_event(pmc);\n\n\tpmc->current_config = eventsel;\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\tstruct kvm *kvm = pmc->vcpu->kvm;\n\tstruct kvm_pmu_event_filter *filter;\n\tint i;\n\tbool allow_event = true;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_pause_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tfilter = srcu_dereference(kvm->arch.pmu_event_filter, &kvm->srcu);\n\tif (filter) {\n\t\tfor (i = 0; i < filter->nevents; i++)\n\t\t\tif (filter->events[i] ==\n\t\t\t    (eventsel & AMD64_RAW_EVENT_MASK_NB))\n\t\t\t\tbreak;\n\t\tif (filter->action == KVM_PMU_EVENT_ALLOW &&\n\t\t    i == filter->nevents)\n\t\t\tallow_event = false;\n\t\tif (filter->action == KVM_PMU_EVENT_DENY &&\n\t\t    i < filter->nevents)\n\t\t\tallow_event = false;\n\t}\n\tif (!allow_event)\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops.pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tif (pmc->current_config == eventsel && pmc_resume_counter(pmc))\n\t\treturn;\n\n\tpmc_release_perf_event(pmc);\n\n\tpmc->current_config = eventsel;\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gp_pmc_amd",
          "args": [
            "pmu",
            "msr",
            "PMU_TYPE_EVNTSEL"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc_amd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
          "lines": "98-127",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc_amd(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t     enum pmu_type type)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\t\tif (type != PMU_TYPE_EVNTSEL)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_F15H_PERF_CTR4:\n\tcase MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\t\tif (type != PMU_TYPE_COUNTER)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &pmu->gp_counters[msr_to_index(msr)];\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic inline struct kvm_pmc *get_gp_pmc_amd(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t     enum pmu_type type)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\t\tif (type != PMU_TYPE_EVNTSEL)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_F15H_PERF_CTR4:\n\tcase MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\t\tif (type != PMU_TYPE_COUNTER)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &pmu->gp_counters[msr_to_index(msr)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_read_counter",
          "args": [
            "pmc"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_read_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "49-59",
          "snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int amd_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\t/* MSR_PERFCTRn */\n\tpmc = get_gp_pmc_amd(pmu, msr, PMU_TYPE_COUNTER);\n\tif (pmc) {\n\t\tpmc->counter += data - pmc_read_counter(pmc);\n\t\treturn 0;\n\t}\n\t/* MSR_EVNTSELn */\n\tpmc = get_gp_pmc_amd(pmu, msr, PMU_TYPE_EVNTSEL);\n\tif (pmc) {\n\t\tif (data == pmc->eventsel)\n\t\t\treturn 0;\n\t\tif (!(data & pmu->reserved_bits)) {\n\t\t\treprogram_gp_counter(pmc, data);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "amd_pmu_get_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "218-237",
    "snippet": "static int amd_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\t/* MSR_PERFCTRn */\n\tpmc = get_gp_pmc_amd(pmu, msr, PMU_TYPE_COUNTER);\n\tif (pmc) {\n\t\t*data = pmc_read_counter(pmc);\n\t\treturn 0;\n\t}\n\t/* MSR_EVNTSELn */\n\tpmc = get_gp_pmc_amd(pmu, msr, PMU_TYPE_EVNTSEL);\n\tif (pmc) {\n\t\t*data = pmc->eventsel;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_gp_pmc_amd",
          "args": [
            "pmu",
            "msr",
            "PMU_TYPE_EVNTSEL"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc_amd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
          "lines": "98-127",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc_amd(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t     enum pmu_type type)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\t\tif (type != PMU_TYPE_EVNTSEL)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_F15H_PERF_CTR4:\n\tcase MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\t\tif (type != PMU_TYPE_COUNTER)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &pmu->gp_counters[msr_to_index(msr)];\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic inline struct kvm_pmc *get_gp_pmc_amd(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t     enum pmu_type type)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\t\tif (type != PMU_TYPE_EVNTSEL)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_F15H_PERF_CTR4:\n\tcase MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\t\tif (type != PMU_TYPE_COUNTER)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &pmu->gp_counters[msr_to_index(msr)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_read_counter",
          "args": [
            "pmc"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_read_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "49-59",
          "snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int amd_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\t/* MSR_PERFCTRn */\n\tpmc = get_gp_pmc_amd(pmu, msr, PMU_TYPE_COUNTER);\n\tif (pmc) {\n\t\t*data = pmc_read_counter(pmc);\n\t\treturn 0;\n\t}\n\t/* MSR_EVNTSELn */\n\tpmc = get_gp_pmc_amd(pmu, msr, PMU_TYPE_EVNTSEL);\n\tif (pmc) {\n\t\t*data = pmc->eventsel;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "amd_msr_idx_to_pmc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "207-216",
    "snippet": "static struct kvm_pmc *amd_msr_idx_to_pmc(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\tpmc = get_gp_pmc_amd(pmu, msr, PMU_TYPE_COUNTER);\n\tpmc = pmc ? pmc : get_gp_pmc_amd(pmu, msr, PMU_TYPE_EVNTSEL);\n\n\treturn pmc;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_gp_pmc_amd",
          "args": [
            "pmu",
            "msr",
            "PMU_TYPE_EVNTSEL"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc_amd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
          "lines": "98-127",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc_amd(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t     enum pmu_type type)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\t\tif (type != PMU_TYPE_EVNTSEL)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_F15H_PERF_CTR4:\n\tcase MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\t\tif (type != PMU_TYPE_COUNTER)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &pmu->gp_counters[msr_to_index(msr)];\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic inline struct kvm_pmc *get_gp_pmc_amd(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t     enum pmu_type type)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\t\tif (type != PMU_TYPE_EVNTSEL)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_F15H_PERF_CTR4:\n\tcase MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\t\tif (type != PMU_TYPE_COUNTER)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &pmu->gp_counters[msr_to_index(msr)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_pmc *amd_msr_idx_to_pmc(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\tpmc = get_gp_pmc_amd(pmu, msr, PMU_TYPE_COUNTER);\n\tpmc = pmc ? pmc : get_gp_pmc_amd(pmu, msr, PMU_TYPE_EVNTSEL);\n\n\treturn pmc;\n}"
  },
  {
    "function_name": "amd_is_valid_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "201-205",
    "snippet": "static bool amd_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\t/* All MSRs refer to exactly one PMC, so msr_idx_to_pmc is enough.  */\n\treturn false;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic bool amd_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\t/* All MSRs refer to exactly one PMC, so msr_idx_to_pmc is enough.  */\n\treturn false;\n}"
  },
  {
    "function_name": "amd_rdpmc_ecx_to_pmc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "187-199",
    "snippet": "static struct kvm_pmc *amd_rdpmc_ecx_to_pmc(struct kvm_vcpu *vcpu,\n\tunsigned int idx, u64 *mask)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *counters;\n\n\tidx &= ~(3u << 30);\n\tif (idx >= pmu->nr_arch_gp_counters)\n\t\treturn NULL;\n\tcounters = pmu->gp_counters;\n\n\treturn &counters[idx];\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_pmc *amd_rdpmc_ecx_to_pmc(struct kvm_vcpu *vcpu,\n\tunsigned int idx, u64 *mask)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *counters;\n\n\tidx &= ~(3u << 30);\n\tif (idx >= pmu->nr_arch_gp_counters)\n\t\treturn NULL;\n\tcounters = pmu->gp_counters;\n\n\treturn &counters[idx];\n}"
  },
  {
    "function_name": "amd_is_valid_rdpmc_ecx",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "177-184",
    "snippet": "static int amd_is_valid_rdpmc_ecx(struct kvm_vcpu *vcpu, unsigned int idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tidx &= ~(3u << 30);\n\n\treturn (idx >= pmu->nr_arch_gp_counters);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int amd_is_valid_rdpmc_ecx(struct kvm_vcpu *vcpu, unsigned int idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tidx &= ~(3u << 30);\n\n\treturn (idx >= pmu->nr_arch_gp_counters);\n}"
  },
  {
    "function_name": "amd_pmc_idx_to_pmc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "160-174",
    "snippet": "static struct kvm_pmc *amd_pmc_idx_to_pmc(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tunsigned int base = get_msr_base(pmu, PMU_TYPE_COUNTER);\n\tstruct kvm_vcpu *vcpu = pmu_to_vcpu(pmu);\n\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_PERFCTR_CORE)) {\n\t\t/*\n\t\t * The idx is contiguous. The MSRs are not. The counter MSRs\n\t\t * are interleaved with the event select MSRs.\n\t\t */\n\t\tpmc_idx *= 2;\n\t}\n\n\treturn get_gp_pmc_amd(pmu, base + pmc_idx, PMU_TYPE_COUNTER);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_gp_pmc_amd",
          "args": [
            "pmu",
            "base + pmc_idx",
            "PMU_TYPE_COUNTER"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc_amd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
          "lines": "98-127",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc_amd(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t     enum pmu_type type)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\t\tif (type != PMU_TYPE_EVNTSEL)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_F15H_PERF_CTR4:\n\tcase MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\t\tif (type != PMU_TYPE_COUNTER)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &pmu->gp_counters[msr_to_index(msr)];\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic inline struct kvm_pmc *get_gp_pmc_amd(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t     enum pmu_type type)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\t\tif (type != PMU_TYPE_EVNTSEL)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_F15H_PERF_CTR4:\n\tcase MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\t\tif (type != PMU_TYPE_COUNTER)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &pmu->gp_counters[msr_to_index(msr)];\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_PERFCTR_CORE"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmu_to_vcpu",
          "args": [
            "pmu"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_msr_base",
          "args": [
            "pmu",
            "PMU_TYPE_COUNTER"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "get_msr_base",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
          "lines": "47-62",
          "snippet": "static unsigned int get_msr_base(struct kvm_pmu *pmu, enum pmu_type type)\n{\n\tstruct kvm_vcpu *vcpu = pmu_to_vcpu(pmu);\n\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_PERFCTR_CORE)) {\n\t\tif (type == PMU_TYPE_COUNTER)\n\t\t\treturn MSR_F15H_PERF_CTR;\n\t\telse\n\t\t\treturn MSR_F15H_PERF_CTL;\n\t} else {\n\t\tif (type == PMU_TYPE_COUNTER)\n\t\t\treturn MSR_K7_PERFCTR0;\n\t\telse\n\t\t\treturn MSR_K7_EVNTSEL0;\n\t}\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic unsigned int get_msr_base(struct kvm_pmu *pmu, enum pmu_type type)\n{\n\tstruct kvm_vcpu *vcpu = pmu_to_vcpu(pmu);\n\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_PERFCTR_CORE)) {\n\t\tif (type == PMU_TYPE_COUNTER)\n\t\t\treturn MSR_F15H_PERF_CTR;\n\t\telse\n\t\t\treturn MSR_F15H_PERF_CTL;\n\t} else {\n\t\tif (type == PMU_TYPE_COUNTER)\n\t\t\treturn MSR_K7_PERFCTR0;\n\t\telse\n\t\t\treturn MSR_K7_EVNTSEL0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_pmc *amd_pmc_idx_to_pmc(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tunsigned int base = get_msr_base(pmu, PMU_TYPE_COUNTER);\n\tstruct kvm_vcpu *vcpu = pmu_to_vcpu(pmu);\n\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_PERFCTR_CORE)) {\n\t\t/*\n\t\t * The idx is contiguous. The MSRs are not. The counter MSRs\n\t\t * are interleaved with the event select MSRs.\n\t\t */\n\t\tpmc_idx *= 2;\n\t}\n\n\treturn get_gp_pmc_amd(pmu, base + pmc_idx, PMU_TYPE_COUNTER);\n}"
  },
  {
    "function_name": "amd_pmc_is_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "155-158",
    "snippet": "static bool amd_pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\treturn true;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic bool amd_pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "amd_find_fixed_event",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "147-150",
    "snippet": "static unsigned amd_find_fixed_event(int idx)\n{\n\treturn PERF_COUNT_HW_MAX;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic unsigned amd_find_fixed_event(int idx)\n{\n\treturn PERF_COUNT_HW_MAX;\n}"
  },
  {
    "function_name": "amd_find_arch_event",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "129-144",
    "snippet": "static unsigned amd_find_arch_event(struct kvm_pmu *pmu,\n\t\t\t\t    u8 event_select,\n\t\t\t\t    u8 unit_mask)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(amd_event_mapping); i++)\n\t\tif (amd_event_mapping[i].eventsel == event_select\n\t\t    && amd_event_mapping[i].unit_mask == unit_mask)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(amd_event_mapping))\n\t\treturn PERF_COUNT_HW_MAX;\n\n\treturn amd_event_mapping[i].event_type;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kvm_event_hw_type_mapping amd_event_mapping[] = {\n\t[0] = { 0x76, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x7d, 0x07, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[3] = { 0x7e, 0x07, PERF_COUNT_HW_CACHE_MISSES },\n\t[4] = { 0xc2, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[5] = { 0xc3, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[6] = { 0xd0, 0x00, PERF_COUNT_HW_STALLED_CYCLES_FRONTEND },\n\t[7] = { 0xd1, 0x00, PERF_COUNT_HW_STALLED_CYCLES_BACKEND },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "amd_event_mapping"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "amd_event_mapping"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_event_hw_type_mapping amd_event_mapping[] = {\n\t[0] = { 0x76, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x7d, 0x07, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[3] = { 0x7e, 0x07, PERF_COUNT_HW_CACHE_MISSES },\n\t[4] = { 0xc2, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[5] = { 0xc3, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[6] = { 0xd0, 0x00, PERF_COUNT_HW_STALLED_CYCLES_FRONTEND },\n\t[7] = { 0xd1, 0x00, PERF_COUNT_HW_STALLED_CYCLES_BACKEND },\n};\n\nstatic unsigned amd_find_arch_event(struct kvm_pmu *pmu,\n\t\t\t\t    u8 event_select,\n\t\t\t\t    u8 unit_mask)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(amd_event_mapping); i++)\n\t\tif (amd_event_mapping[i].eventsel == event_select\n\t\t    && amd_event_mapping[i].unit_mask == unit_mask)\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(amd_event_mapping))\n\t\treturn PERF_COUNT_HW_MAX;\n\n\treturn amd_event_mapping[i].event_type;\n}"
  },
  {
    "function_name": "get_gp_pmc_amd",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "98-127",
    "snippet": "static inline struct kvm_pmc *get_gp_pmc_amd(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t     enum pmu_type type)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\t\tif (type != PMU_TYPE_EVNTSEL)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_F15H_PERF_CTR4:\n\tcase MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\t\tif (type != PMU_TYPE_COUNTER)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &pmu->gp_counters[msr_to_index(msr)];\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "msr_to_index",
          "args": [
            "msr"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "msr_to_index",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
          "lines": "64-96",
          "snippet": "static enum index msr_to_index(u32 msr)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_PERFCTR0:\n\t\treturn INDEX_ZERO;\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_PERFCTR1:\n\t\treturn INDEX_ONE;\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_PERFCTR2:\n\t\treturn INDEX_TWO;\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR3:\n\t\treturn INDEX_THREE;\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTR4:\n\t\treturn INDEX_FOUR;\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_F15H_PERF_CTR5:\n\t\treturn INDEX_FIVE;\n\tdefault:\n\t\treturn INDEX_ERROR;\n\t}\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic enum index msr_to_index(u32 msr)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_PERFCTR0:\n\t\treturn INDEX_ZERO;\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_PERFCTR1:\n\t\treturn INDEX_ONE;\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_PERFCTR2:\n\t\treturn INDEX_TWO;\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR3:\n\t\treturn INDEX_THREE;\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTR4:\n\t\treturn INDEX_FOUR;\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_F15H_PERF_CTR5:\n\t\treturn INDEX_FIVE;\n\tdefault:\n\t\treturn INDEX_ERROR;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic inline struct kvm_pmc *get_gp_pmc_amd(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t     enum pmu_type type)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\t\tif (type != PMU_TYPE_EVNTSEL)\n\t\t\treturn NULL;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_F15H_PERF_CTR4:\n\tcase MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\t\tif (type != PMU_TYPE_COUNTER)\n\t\t\treturn NULL;\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\treturn &pmu->gp_counters[msr_to_index(msr)];\n}"
  },
  {
    "function_name": "msr_to_index",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "64-96",
    "snippet": "static enum index msr_to_index(u32 msr)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_PERFCTR0:\n\t\treturn INDEX_ZERO;\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_PERFCTR1:\n\t\treturn INDEX_ONE;\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_PERFCTR2:\n\t\treturn INDEX_TWO;\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR3:\n\t\treturn INDEX_THREE;\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTR4:\n\t\treturn INDEX_FOUR;\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_F15H_PERF_CTR5:\n\t\treturn INDEX_FIVE;\n\tdefault:\n\t\treturn INDEX_ERROR;\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic enum index msr_to_index(u32 msr)\n{\n\tswitch (msr) {\n\tcase MSR_F15H_PERF_CTL0:\n\tcase MSR_F15H_PERF_CTR0:\n\tcase MSR_K7_EVNTSEL0:\n\tcase MSR_K7_PERFCTR0:\n\t\treturn INDEX_ZERO;\n\tcase MSR_F15H_PERF_CTL1:\n\tcase MSR_F15H_PERF_CTR1:\n\tcase MSR_K7_EVNTSEL1:\n\tcase MSR_K7_PERFCTR1:\n\t\treturn INDEX_ONE;\n\tcase MSR_F15H_PERF_CTL2:\n\tcase MSR_F15H_PERF_CTR2:\n\tcase MSR_K7_EVNTSEL2:\n\tcase MSR_K7_PERFCTR2:\n\t\treturn INDEX_TWO;\n\tcase MSR_F15H_PERF_CTL3:\n\tcase MSR_F15H_PERF_CTR3:\n\tcase MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR3:\n\t\treturn INDEX_THREE;\n\tcase MSR_F15H_PERF_CTL4:\n\tcase MSR_F15H_PERF_CTR4:\n\t\treturn INDEX_FOUR;\n\tcase MSR_F15H_PERF_CTL5:\n\tcase MSR_F15H_PERF_CTR5:\n\t\treturn INDEX_FIVE;\n\tdefault:\n\t\treturn INDEX_ERROR;\n\t}\n}"
  },
  {
    "function_name": "get_msr_base",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/pmu.c",
    "lines": "47-62",
    "snippet": "static unsigned int get_msr_base(struct kvm_pmu *pmu, enum pmu_type type)\n{\n\tstruct kvm_vcpu *vcpu = pmu_to_vcpu(pmu);\n\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_PERFCTR_CORE)) {\n\t\tif (type == PMU_TYPE_COUNTER)\n\t\t\treturn MSR_F15H_PERF_CTR;\n\t\telse\n\t\t\treturn MSR_F15H_PERF_CTL;\n\t} else {\n\t\tif (type == PMU_TYPE_COUNTER)\n\t\t\treturn MSR_K7_PERFCTR0;\n\t\telse\n\t\t\treturn MSR_K7_EVNTSEL0;\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_PERFCTR_CORE"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmu_to_vcpu",
          "args": [
            "pmu"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic unsigned int get_msr_base(struct kvm_pmu *pmu, enum pmu_type type)\n{\n\tstruct kvm_vcpu *vcpu = pmu_to_vcpu(pmu);\n\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_PERFCTR_CORE)) {\n\t\tif (type == PMU_TYPE_COUNTER)\n\t\t\treturn MSR_F15H_PERF_CTR;\n\t\telse\n\t\t\treturn MSR_F15H_PERF_CTL;\n\t} else {\n\t\tif (type == PMU_TYPE_COUNTER)\n\t\t\treturn MSR_K7_PERFCTR0;\n\t\telse\n\t\t\treturn MSR_K7_EVNTSEL0;\n\t}\n}"
  }
]