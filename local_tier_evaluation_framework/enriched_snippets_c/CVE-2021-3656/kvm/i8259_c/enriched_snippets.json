[
  {
    "function_name": "kvm_pic_destroy",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "640-655",
    "snippet": "void kvm_pic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = kvm->arch.vpic;\n\n\tif (!vpic)\n\t\treturn;\n\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_master);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_slave);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_eclr);\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkvm->arch.vpic = NULL;\n\tkfree(vpic);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vpic"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "vpic->kvm",
            "KVM_PIO_BUS",
            "&vpic->dev_eclr"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "vpic->kvm",
            "KVM_PIO_BUS",
            "&vpic->dev_slave"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "vpic->kvm",
            "KVM_PIO_BUS",
            "&vpic->dev_master"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_pic *vpic = kvm->arch.vpic;\n\n\tif (!vpic)\n\t\treturn;\n\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_master);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_slave);\n\tkvm_io_bus_unregister_dev(vpic->kvm, KVM_PIO_BUS, &vpic->dev_eclr);\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkvm->arch.vpic = NULL;\n\tkfree(vpic);\n}"
  },
  {
    "function_name": "kvm_pic_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "585-638",
    "snippet": "int kvm_pic_init(struct kvm *kvm)\n{\n\tstruct kvm_pic *s;\n\tint ret;\n\n\ts = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL_ACCOUNT);\n\tif (!s)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&s->lock);\n\ts->kvm = kvm;\n\ts->pics[0].elcr_mask = 0xf8;\n\ts->pics[1].elcr_mask = 0xde;\n\ts->pics[0].pics_state = s;\n\ts->pics[1].pics_state = s;\n\n\t/*\n\t * Initialize PIO device\n\t */\n\tkvm_iodevice_init(&s->dev_master, &picdev_master_ops);\n\tkvm_iodevice_init(&s->dev_slave, &picdev_slave_ops);\n\tkvm_iodevice_init(&s->dev_eclr, &picdev_eclr_ops);\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2,\n\t\t\t\t      &s->dev_master);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave);\n\tif (ret < 0)\n\t\tgoto fail_unreg_2;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_eclr);\n\tif (ret < 0)\n\t\tgoto fail_unreg_1;\n\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkvm->arch.vpic = s;\n\n\treturn 0;\n\nfail_unreg_1:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_slave);\n\nfail_unreg_2:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_master);\n\nfail_unlock:\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkfree(s);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_io_device_ops picdev_master_ops = {\n\t.read     = picdev_master_read,\n\t.write    = picdev_master_write,\n};",
      "static const struct kvm_io_device_ops picdev_slave_ops = {\n\t.read     = picdev_slave_read,\n\t.write    = picdev_slave_write,\n};",
      "static const struct kvm_io_device_ops picdev_eclr_ops = {\n\t.read     = picdev_eclr_read,\n\t.write    = picdev_eclr_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "&s->dev_master"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "&s->dev_slave"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_register_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "0x4d0",
            "2",
            "&s->dev_eclr"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_register_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "0xa0",
            "2",
            "&s->dev_slave"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_register_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "0x20",
            "2",
            "&s->dev_master"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&s->dev_eclr",
            "&picdev_eclr_ops"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&s->dev_slave",
            "&picdev_slave_ops"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&s->dev_master",
            "&picdev_master_ops"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&s->lock"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kvm_pic)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic const struct kvm_io_device_ops picdev_master_ops = {\n\t.read     = picdev_master_read,\n\t.write    = picdev_master_write,\n};\nstatic const struct kvm_io_device_ops picdev_slave_ops = {\n\t.read     = picdev_slave_read,\n\t.write    = picdev_slave_write,\n};\nstatic const struct kvm_io_device_ops picdev_eclr_ops = {\n\t.read     = picdev_eclr_read,\n\t.write    = picdev_eclr_write,\n};\n\nint kvm_pic_init(struct kvm *kvm)\n{\n\tstruct kvm_pic *s;\n\tint ret;\n\n\ts = kzalloc(sizeof(struct kvm_pic), GFP_KERNEL_ACCOUNT);\n\tif (!s)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&s->lock);\n\ts->kvm = kvm;\n\ts->pics[0].elcr_mask = 0xf8;\n\ts->pics[1].elcr_mask = 0xde;\n\ts->pics[0].pics_state = s;\n\ts->pics[1].pics_state = s;\n\n\t/*\n\t * Initialize PIO device\n\t */\n\tkvm_iodevice_init(&s->dev_master, &picdev_master_ops);\n\tkvm_iodevice_init(&s->dev_slave, &picdev_slave_ops);\n\tkvm_iodevice_init(&s->dev_eclr, &picdev_eclr_ops);\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x20, 2,\n\t\t\t\t      &s->dev_master);\n\tif (ret < 0)\n\t\tgoto fail_unlock;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0xa0, 2, &s->dev_slave);\n\tif (ret < 0)\n\t\tgoto fail_unreg_2;\n\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, 0x4d0, 2, &s->dev_eclr);\n\tif (ret < 0)\n\t\tgoto fail_unreg_1;\n\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkvm->arch.vpic = s;\n\n\treturn 0;\n\nfail_unreg_1:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_slave);\n\nfail_unreg_2:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &s->dev_master);\n\nfail_unlock:\n\tmutex_unlock(&kvm->slots_lock);\n\n\tkfree(s);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pic_irq_request",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "561-568",
    "snippet": "static void pic_irq_request(struct kvm *kvm, int level)\n{\n\tstruct kvm_pic *s = kvm->arch.vpic;\n\n\tif (!s->output)\n\t\ts->wakeup_needed = true;\n\ts->output = level;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pic_irq_request(struct kvm *kvm, int level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic void pic_irq_request(struct kvm *kvm, int level)\n{\n\tstruct kvm_pic *s = kvm->arch.vpic;\n\n\tif (!s->output)\n\t\ts->wakeup_needed = true;\n\ts->output = level;\n}"
  },
  {
    "function_name": "picdev_eclr_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "551-556",
    "snippet": "static int picdev_eclr_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t    gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_eclr),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_read",
          "args": [
            "container_of(dev, struct kvm_pic, dev_eclr)",
            "addr",
            "len",
            "val"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "485-514",
          "snippet": "static int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char *data = (unsigned char *)val;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\t*data = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\t*data = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char *data = (unsigned char *)val;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\t*data = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\t*data = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_eclr"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_eclr_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t    gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_eclr),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_eclr_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "544-549",
    "snippet": "static int picdev_eclr_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t     gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_eclr),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_write",
          "args": [
            "container_of(dev, struct kvm_pic, dev_eclr)",
            "addr",
            "len",
            "val"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "451-483",
          "snippet": "static int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[0], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[0], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_eclr"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_eclr_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t     gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_eclr),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_slave_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "537-542",
    "snippet": "static int picdev_slave_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t     gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_slave),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_read",
          "args": [
            "container_of(dev, struct kvm_pic, dev_slave)",
            "addr",
            "len",
            "val"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "485-514",
          "snippet": "static int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char *data = (unsigned char *)val;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\t*data = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\t*data = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char *data = (unsigned char *)val;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\t*data = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\t*data = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_slave"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_slave_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t     gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_slave),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_slave_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "530-535",
    "snippet": "static int picdev_slave_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t      gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_slave),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_write",
          "args": [
            "container_of(dev, struct kvm_pic, dev_slave)",
            "addr",
            "len",
            "val"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "451-483",
          "snippet": "static int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[0], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[0], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_slave"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_slave_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t      gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_slave),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_master_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "523-528",
    "snippet": "static int picdev_master_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t      gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_master),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_read",
          "args": [
            "container_of(dev, struct kvm_pic, dev_master)",
            "addr",
            "len",
            "val"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "485-514",
          "snippet": "static int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char *data = (unsigned char *)val;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\t*data = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\t*data = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char *data = (unsigned char *)val;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\t*data = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\t*data = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_master"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_master_read(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t      gpa_t addr, int len, void *val)\n{\n\treturn picdev_read(container_of(dev, struct kvm_pic, dev_master),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_master_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "516-521",
    "snippet": "static int picdev_master_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t       gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_master),\n\t\t\t    addr, len, val);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "picdev_write",
          "args": [
            "container_of(dev, struct kvm_pic, dev_master)",
            "addr",
            "len",
            "val"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "picdev_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "451-483",
          "snippet": "static int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[0], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[0], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pic",
            "dev_master"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_master_write(struct kvm_vcpu *vcpu, struct kvm_io_device *dev,\n\t\t\t       gpa_t addr, int len, const void *val)\n{\n\treturn picdev_write(container_of(dev, struct kvm_pic, dev_master),\n\t\t\t    addr, len, val);\n}"
  },
  {
    "function_name": "picdev_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "485-514",
    "snippet": "static int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char *data = (unsigned char *)val;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\t*data = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\t*data = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "48-68",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elcr_ioport_read",
          "args": [
            "&s->pics[addr & 1]",
            "addr"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "elcr_ioport_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "445-449",
          "snippet": "static u32 elcr_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\treturn s->elcr;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 elcr_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\treturn s->elcr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_ioport_read",
          "args": [
            "&s->pics[addr >> 7]",
            "addr"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "pic_ioport_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "420-437",
          "snippet": "static u32 pic_ioport_read(void *opaque, u32 addr)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint ret;\n\n\tif (s->poll) {\n\t\tret = pic_poll_read(s, addr);\n\t\ts->poll = 0;\n\t} else\n\t\tif ((addr & 1) == 0)\n\t\t\tif (s->read_reg_select)\n\t\t\t\tret = s->isr;\n\t\t\telse\n\t\t\t\tret = s->irr;\n\t\telse\n\t\t\tret = s->imr;\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 pic_ioport_read(void *opaque, u32 addr)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint ret;\n\n\tif (s->poll) {\n\t\tret = pic_poll_read(s, addr);\n\t\ts->poll = 0;\n\t} else\n\t\tif ((addr & 1) == 0)\n\t\t\tif (s->read_reg_select)\n\t\t\t\tret = s->isr;\n\t\t\telse\n\t\t\t\tret = s->irr;\n\t\telse\n\t\t\tret = s->imr;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_pic_unimpl",
          "args": [
            "\"non byte read\\n\""
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val",
            "0",
            "len"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_read(struct kvm_pic *s,\n\t\t       gpa_t addr, int len, void *val)\n{\n\tunsigned char *data = (unsigned char *)val;\n\n\tif (len != 1) {\n\t\tmemset(val, 0, len);\n\t\tpr_pic_unimpl(\"non byte read\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\t*data = pic_ioport_read(&s->pics[addr >> 7], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\t*data = elcr_ioport_read(&s->pics[addr & 1], addr);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "picdev_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "451-483",
    "snippet": "static int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[0], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "48-68",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "elcr_ioport_write",
          "args": [
            "&s->pics[addr & 1]",
            "addr",
            "data"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "elcr_ioport_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "439-443",
          "snippet": "static void elcr_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\ts->elcr = val & s->elcr_mask;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void elcr_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\ts->elcr = val & s->elcr_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_ioport_write",
          "args": [
            "&s->pics[1]",
            "addr",
            "data"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "pic_ioport_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "305-396",
          "snippet": "static void pic_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint priority, cmd, irq;\n\n\taddr &= 1;\n\tif (addr == 0) {\n\t\tif (val & 0x10) {\n\t\t\ts->init4 = val & 1;\n\t\t\tif (val & 0x02)\n\t\t\t\tpr_pic_unimpl(\"single mode not supported\");\n\t\t\tif (val & 0x08)\n\t\t\t\tpr_pic_unimpl(\n\t\t\t\t\t\t\"level sensitive irq not supported\");\n\t\t\tkvm_pic_reset(s);\n\t\t} else if (val & 0x08) {\n\t\t\tif (val & 0x04)\n\t\t\t\ts->poll = 1;\n\t\t\tif (val & 0x02)\n\t\t\t\ts->read_reg_select = val & 1;\n\t\t\tif (val & 0x40)\n\t\t\t\ts->special_mask = (val >> 5) & 1;\n\t\t} else {\n\t\t\tcmd = val >> 5;\n\t\t\tswitch (cmd) {\n\t\t\tcase 0:\n\t\t\tcase 4:\n\t\t\t\ts->rotate_on_auto_eoi = cmd >> 2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* end of interrupt */\n\t\t\tcase 5:\n\t\t\t\tpriority = get_priority(s, s->isr);\n\t\t\t\tif (priority != 8) {\n\t\t\t\t\tirq = (priority + s->priority_add) & 7;\n\t\t\t\t\tif (cmd == 5)\n\t\t\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tirq = val & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ts->priority_add = (val + 1) & 7;\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tirq = val & 7;\n\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\t/* no operation */\n\t\t\t}\n\t\t}\n\t} else\n\t\tswitch (s->init_state) {\n\t\tcase 0: { /* normal mode */\n\t\t\tu8 imr_diff = s->imr ^ val,\n\t\t\t\toff = (s == &s->pics_state->pics[0]) ? 0 : 8;\n\t\t\ts->imr = val;\n\t\t\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\t\t\tif (imr_diff & (1 << irq))\n\t\t\t\t\tkvm_fire_mask_notifiers(\n\t\t\t\t\t\ts->pics_state->kvm,\n\t\t\t\t\t\tSELECT_PIC(irq + off),\n\t\t\t\t\t\tirq + off,\n\t\t\t\t\t\t!!(s->imr & (1 << irq)));\n\t\t\tpic_update_irq(s->pics_state);\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t\ts->irq_base = val & 0xf8;\n\t\t\ts->init_state = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (s->init4)\n\t\t\t\ts->init_state = 3;\n\t\t\telse\n\t\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->special_fully_nested_mode = (val >> 4) & 1;\n\t\t\ts->auto_eoi = (val >> 1) & 1;\n\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic void pic_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint priority, cmd, irq;\n\n\taddr &= 1;\n\tif (addr == 0) {\n\t\tif (val & 0x10) {\n\t\t\ts->init4 = val & 1;\n\t\t\tif (val & 0x02)\n\t\t\t\tpr_pic_unimpl(\"single mode not supported\");\n\t\t\tif (val & 0x08)\n\t\t\t\tpr_pic_unimpl(\n\t\t\t\t\t\t\"level sensitive irq not supported\");\n\t\t\tkvm_pic_reset(s);\n\t\t} else if (val & 0x08) {\n\t\t\tif (val & 0x04)\n\t\t\t\ts->poll = 1;\n\t\t\tif (val & 0x02)\n\t\t\t\ts->read_reg_select = val & 1;\n\t\t\tif (val & 0x40)\n\t\t\t\ts->special_mask = (val >> 5) & 1;\n\t\t} else {\n\t\t\tcmd = val >> 5;\n\t\t\tswitch (cmd) {\n\t\t\tcase 0:\n\t\t\tcase 4:\n\t\t\t\ts->rotate_on_auto_eoi = cmd >> 2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* end of interrupt */\n\t\t\tcase 5:\n\t\t\t\tpriority = get_priority(s, s->isr);\n\t\t\t\tif (priority != 8) {\n\t\t\t\t\tirq = (priority + s->priority_add) & 7;\n\t\t\t\t\tif (cmd == 5)\n\t\t\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tirq = val & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ts->priority_add = (val + 1) & 7;\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tirq = val & 7;\n\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\t/* no operation */\n\t\t\t}\n\t\t}\n\t} else\n\t\tswitch (s->init_state) {\n\t\tcase 0: { /* normal mode */\n\t\t\tu8 imr_diff = s->imr ^ val,\n\t\t\t\toff = (s == &s->pics_state->pics[0]) ? 0 : 8;\n\t\t\ts->imr = val;\n\t\t\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\t\t\tif (imr_diff & (1 << irq))\n\t\t\t\t\tkvm_fire_mask_notifiers(\n\t\t\t\t\t\ts->pics_state->kvm,\n\t\t\t\t\t\tSELECT_PIC(irq + off),\n\t\t\t\t\t\tirq + off,\n\t\t\t\t\t\t!!(s->imr & (1 << irq)));\n\t\t\tpic_update_irq(s->pics_state);\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t\ts->irq_base = val & 0xf8;\n\t\t\ts->init_state = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (s->init4)\n\t\t\t\ts->init_state = 3;\n\t\t\telse\n\t\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->special_fully_nested_mode = (val >> 4) & 1;\n\t\t\ts->auto_eoi = (val >> 1) & 1;\n\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_pic_unimpl",
          "args": [
            "\"non byte write\\n\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int picdev_write(struct kvm_pic *s,\n\t\t\t gpa_t addr, int len, const void *val)\n{\n\tunsigned char data = *(unsigned char *)val;\n\n\tif (len != 1) {\n\t\tpr_pic_unimpl(\"non byte write\\n\");\n\t\treturn 0;\n\t}\n\tswitch (addr) {\n\tcase 0x20:\n\tcase 0x21:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[0], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0xa0:\n\tcase 0xa1:\n\t\tpic_lock(s);\n\t\tpic_ioport_write(&s->pics[1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tcase 0x4d0:\n\tcase 0x4d1:\n\t\tpic_lock(s);\n\t\telcr_ioport_write(&s->pics[addr & 1], addr, data);\n\t\tpic_unlock(s);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "elcr_ioport_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "445-449",
    "snippet": "static u32 elcr_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\treturn s->elcr;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 elcr_ioport_read(void *opaque, u32 addr1)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\treturn s->elcr;\n}"
  },
  {
    "function_name": "elcr_ioport_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "439-443",
    "snippet": "static void elcr_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\ts->elcr = val & s->elcr_mask;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void elcr_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\ts->elcr = val & s->elcr_mask;\n}"
  },
  {
    "function_name": "pic_ioport_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "420-437",
    "snippet": "static u32 pic_ioport_read(void *opaque, u32 addr)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint ret;\n\n\tif (s->poll) {\n\t\tret = pic_poll_read(s, addr);\n\t\ts->poll = 0;\n\t} else\n\t\tif ((addr & 1) == 0)\n\t\t\tif (s->read_reg_select)\n\t\t\t\tret = s->isr;\n\t\t\telse\n\t\t\t\tret = s->irr;\n\t\telse\n\t\t\tret = s->imr;\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_poll_read",
          "args": [
            "s",
            "addr"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "pic_poll_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "398-418",
          "snippet": "static u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)\n{\n\tint ret;\n\n\tret = pic_get_irq(s);\n\tif (ret >= 0) {\n\t\tif (addr1 >> 7) {\n\t\t\ts->pics_state->pics[0].isr &= ~(1 << 2);\n\t\t\ts->pics_state->pics[0].irr &= ~(1 << 2);\n\t\t}\n\t\ts->irr &= ~(1 << ret);\n\t\tpic_clear_isr(s, ret);\n\t\tif (addr1 >> 7 || ret != 2)\n\t\t\tpic_update_irq(s->pics_state);\n\t} else {\n\t\tret = 0x07;\n\t\tpic_update_irq(s->pics_state);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)\n{\n\tint ret;\n\n\tret = pic_get_irq(s);\n\tif (ret >= 0) {\n\t\tif (addr1 >> 7) {\n\t\t\ts->pics_state->pics[0].isr &= ~(1 << 2);\n\t\t\ts->pics_state->pics[0].irr &= ~(1 << 2);\n\t\t}\n\t\ts->irr &= ~(1 << ret);\n\t\tpic_clear_isr(s, ret);\n\t\tif (addr1 >> 7 || ret != 2)\n\t\t\tpic_update_irq(s->pics_state);\n\t} else {\n\t\tret = 0x07;\n\t\tpic_update_irq(s->pics_state);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 pic_ioport_read(void *opaque, u32 addr)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint ret;\n\n\tif (s->poll) {\n\t\tret = pic_poll_read(s, addr);\n\t\ts->poll = 0;\n\t} else\n\t\tif ((addr & 1) == 0)\n\t\t\tif (s->read_reg_select)\n\t\t\t\tret = s->isr;\n\t\t\telse\n\t\t\t\tret = s->irr;\n\t\telse\n\t\t\tret = s->imr;\n\treturn ret;\n}"
  },
  {
    "function_name": "pic_poll_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "398-418",
    "snippet": "static u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)\n{\n\tint ret;\n\n\tret = pic_get_irq(s);\n\tif (ret >= 0) {\n\t\tif (addr1 >> 7) {\n\t\t\ts->pics_state->pics[0].isr &= ~(1 << 2);\n\t\t\ts->pics_state->pics[0].irr &= ~(1 << 2);\n\t\t}\n\t\ts->irr &= ~(1 << ret);\n\t\tpic_clear_isr(s, ret);\n\t\tif (addr1 >> 7 || ret != 2)\n\t\t\tpic_update_irq(s->pics_state);\n\t} else {\n\t\tret = 0x07;\n\t\tpic_update_irq(s->pics_state);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_update_irq",
          "args": [
            "s->pics_state"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_update_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "179-184",
          "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_clear_isr",
          "args": [
            "s",
            "ret"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "pic_clear_isr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "70-84",
          "snippet": "static void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_get_irq",
          "args": [
            "s"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "pic_get_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "133-157",
          "snippet": "static int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic u32 pic_poll_read(struct kvm_kpic_state *s, u32 addr1)\n{\n\tint ret;\n\n\tret = pic_get_irq(s);\n\tif (ret >= 0) {\n\t\tif (addr1 >> 7) {\n\t\t\ts->pics_state->pics[0].isr &= ~(1 << 2);\n\t\t\ts->pics_state->pics[0].irr &= ~(1 << 2);\n\t\t}\n\t\ts->irr &= ~(1 << ret);\n\t\tpic_clear_isr(s, ret);\n\t\tif (addr1 >> 7 || ret != 2)\n\t\t\tpic_update_irq(s->pics_state);\n\t} else {\n\t\tret = 0x07;\n\t\tpic_update_irq(s->pics_state);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pic_ioport_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "305-396",
    "snippet": "static void pic_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint priority, cmd, irq;\n\n\taddr &= 1;\n\tif (addr == 0) {\n\t\tif (val & 0x10) {\n\t\t\ts->init4 = val & 1;\n\t\t\tif (val & 0x02)\n\t\t\t\tpr_pic_unimpl(\"single mode not supported\");\n\t\t\tif (val & 0x08)\n\t\t\t\tpr_pic_unimpl(\n\t\t\t\t\t\t\"level sensitive irq not supported\");\n\t\t\tkvm_pic_reset(s);\n\t\t} else if (val & 0x08) {\n\t\t\tif (val & 0x04)\n\t\t\t\ts->poll = 1;\n\t\t\tif (val & 0x02)\n\t\t\t\ts->read_reg_select = val & 1;\n\t\t\tif (val & 0x40)\n\t\t\t\ts->special_mask = (val >> 5) & 1;\n\t\t} else {\n\t\t\tcmd = val >> 5;\n\t\t\tswitch (cmd) {\n\t\t\tcase 0:\n\t\t\tcase 4:\n\t\t\t\ts->rotate_on_auto_eoi = cmd >> 2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* end of interrupt */\n\t\t\tcase 5:\n\t\t\t\tpriority = get_priority(s, s->isr);\n\t\t\t\tif (priority != 8) {\n\t\t\t\t\tirq = (priority + s->priority_add) & 7;\n\t\t\t\t\tif (cmd == 5)\n\t\t\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tirq = val & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ts->priority_add = (val + 1) & 7;\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tirq = val & 7;\n\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\t/* no operation */\n\t\t\t}\n\t\t}\n\t} else\n\t\tswitch (s->init_state) {\n\t\tcase 0: { /* normal mode */\n\t\t\tu8 imr_diff = s->imr ^ val,\n\t\t\t\toff = (s == &s->pics_state->pics[0]) ? 0 : 8;\n\t\t\ts->imr = val;\n\t\t\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\t\t\tif (imr_diff & (1 << irq))\n\t\t\t\t\tkvm_fire_mask_notifiers(\n\t\t\t\t\t\ts->pics_state->kvm,\n\t\t\t\t\t\tSELECT_PIC(irq + off),\n\t\t\t\t\t\tirq + off,\n\t\t\t\t\t\t!!(s->imr & (1 << irq)));\n\t\t\tpic_update_irq(s->pics_state);\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t\ts->irq_base = val & 0xf8;\n\t\t\ts->init_state = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (s->init4)\n\t\t\t\ts->init_state = 3;\n\t\t\telse\n\t\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->special_fully_nested_mode = (val >> 4) & 1;\n\t\t\ts->auto_eoi = (val >> 1) & 1;\n\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pic_irq_request(struct kvm *kvm, int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_update_irq",
          "args": [
            "s->pics_state"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_update_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "179-184",
          "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_fire_mask_notifiers",
          "args": [
            "s->pics_state->kvm",
            "SELECT_PIC(irq + off)",
            "irq + off",
            "!!(s->imr & (1 << irq))"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_fire_mask_notifiers",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "252-265",
          "snippet": "void kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SELECT_PIC",
          "args": [
            "irq + off"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_clear_isr",
          "args": [
            "s",
            "irq"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "pic_clear_isr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "70-84",
          "snippet": "static void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_priority",
          "args": [
            "s",
            "s->isr"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "get_priority",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "119-128",
          "snippet": "static inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pic_reset",
          "args": [
            "s"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_reset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "271-303",
          "snippet": "static void kvm_pic_reset(struct kvm_kpic_state *s)\n{\n\tint irq, i;\n\tstruct kvm_vcpu *vcpu;\n\tu8 edge_irr = s->irr & ~s->elcr;\n\tbool found = false;\n\n\ts->last_irr = 0;\n\ts->irr &= s->elcr;\n\ts->imr = 0;\n\ts->priority_add = 0;\n\ts->special_mask = 0;\n\ts->read_reg_select = 0;\n\tif (!s->init4) {\n\t\ts->special_fully_nested_mode = 0;\n\t\ts->auto_eoi = 0;\n\t}\n\ts->init_state = 1;\n\n\tkvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)\n\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\n\tif (!found)\n\t\treturn;\n\n\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\tif (edge_irr & (1 << irq))\n\t\t\tpic_clear_isr(s, irq);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void kvm_pic_reset(struct kvm_kpic_state *s)\n{\n\tint irq, i;\n\tstruct kvm_vcpu *vcpu;\n\tu8 edge_irr = s->irr & ~s->elcr;\n\tbool found = false;\n\n\ts->last_irr = 0;\n\ts->irr &= s->elcr;\n\ts->imr = 0;\n\ts->priority_add = 0;\n\ts->special_mask = 0;\n\ts->read_reg_select = 0;\n\tif (!s->init4) {\n\t\ts->special_fully_nested_mode = 0;\n\t\ts->auto_eoi = 0;\n\t}\n\ts->init_state = 1;\n\n\tkvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)\n\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\n\tif (!found)\n\t\treturn;\n\n\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\tif (edge_irr & (1 << irq))\n\t\t\tpic_clear_isr(s, irq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_pic_unimpl",
          "args": [
            "\"level sensitive irq not supported\""
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_pic_unimpl",
          "args": [
            "\"single mode not supported\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic void pic_ioport_write(void *opaque, u32 addr, u32 val)\n{\n\tstruct kvm_kpic_state *s = opaque;\n\tint priority, cmd, irq;\n\n\taddr &= 1;\n\tif (addr == 0) {\n\t\tif (val & 0x10) {\n\t\t\ts->init4 = val & 1;\n\t\t\tif (val & 0x02)\n\t\t\t\tpr_pic_unimpl(\"single mode not supported\");\n\t\t\tif (val & 0x08)\n\t\t\t\tpr_pic_unimpl(\n\t\t\t\t\t\t\"level sensitive irq not supported\");\n\t\t\tkvm_pic_reset(s);\n\t\t} else if (val & 0x08) {\n\t\t\tif (val & 0x04)\n\t\t\t\ts->poll = 1;\n\t\t\tif (val & 0x02)\n\t\t\t\ts->read_reg_select = val & 1;\n\t\t\tif (val & 0x40)\n\t\t\t\ts->special_mask = (val >> 5) & 1;\n\t\t} else {\n\t\t\tcmd = val >> 5;\n\t\t\tswitch (cmd) {\n\t\t\tcase 0:\n\t\t\tcase 4:\n\t\t\t\ts->rotate_on_auto_eoi = cmd >> 2;\n\t\t\t\tbreak;\n\t\t\tcase 1:\t/* end of interrupt */\n\t\t\tcase 5:\n\t\t\t\tpriority = get_priority(s, s->isr);\n\t\t\t\tif (priority != 8) {\n\t\t\t\t\tirq = (priority + s->priority_add) & 7;\n\t\t\t\t\tif (cmd == 5)\n\t\t\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tirq = val & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ts->priority_add = (val + 1) & 7;\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\tirq = val & 7;\n\t\t\t\ts->priority_add = (irq + 1) & 7;\n\t\t\t\tpic_clear_isr(s, irq);\n\t\t\t\tpic_update_irq(s->pics_state);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\t/* no operation */\n\t\t\t}\n\t\t}\n\t} else\n\t\tswitch (s->init_state) {\n\t\tcase 0: { /* normal mode */\n\t\t\tu8 imr_diff = s->imr ^ val,\n\t\t\t\toff = (s == &s->pics_state->pics[0]) ? 0 : 8;\n\t\t\ts->imr = val;\n\t\t\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\t\t\tif (imr_diff & (1 << irq))\n\t\t\t\t\tkvm_fire_mask_notifiers(\n\t\t\t\t\t\ts->pics_state->kvm,\n\t\t\t\t\t\tSELECT_PIC(irq + off),\n\t\t\t\t\t\tirq + off,\n\t\t\t\t\t\t!!(s->imr & (1 << irq)));\n\t\t\tpic_update_irq(s->pics_state);\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:\n\t\t\ts->irq_base = val & 0xf8;\n\t\t\ts->init_state = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (s->init4)\n\t\t\t\ts->init_state = 3;\n\t\t\telse\n\t\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ts->special_fully_nested_mode = (val >> 4) & 1;\n\t\t\ts->auto_eoi = (val >> 1) & 1;\n\t\t\ts->init_state = 0;\n\t\t\tbreak;\n\t\t}\n}"
  },
  {
    "function_name": "kvm_pic_reset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "271-303",
    "snippet": "static void kvm_pic_reset(struct kvm_kpic_state *s)\n{\n\tint irq, i;\n\tstruct kvm_vcpu *vcpu;\n\tu8 edge_irr = s->irr & ~s->elcr;\n\tbool found = false;\n\n\ts->last_irr = 0;\n\ts->irr &= s->elcr;\n\ts->imr = 0;\n\ts->priority_add = 0;\n\ts->special_mask = 0;\n\ts->read_reg_select = 0;\n\tif (!s->init4) {\n\t\ts->special_fully_nested_mode = 0;\n\t\ts->auto_eoi = 0;\n\t}\n\ts->init_state = 1;\n\n\tkvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)\n\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\n\tif (!found)\n\t\treturn;\n\n\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\tif (edge_irr & (1 << irq))\n\t\t\tpic_clear_isr(s, irq);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_clear_isr",
          "args": [
            "s",
            "irq"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "pic_clear_isr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "70-84",
          "snippet": "static void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_accept_pic_intr",
          "args": [
            "vcpu"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_accept_pic_intr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2411-2421",
          "snippet": "int kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "s->pics_state->kvm"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void kvm_pic_reset(struct kvm_kpic_state *s)\n{\n\tint irq, i;\n\tstruct kvm_vcpu *vcpu;\n\tu8 edge_irr = s->irr & ~s->elcr;\n\tbool found = false;\n\n\ts->last_irr = 0;\n\ts->irr &= s->elcr;\n\ts->imr = 0;\n\ts->priority_add = 0;\n\ts->special_mask = 0;\n\ts->read_reg_select = 0;\n\tif (!s->init4) {\n\t\ts->special_fully_nested_mode = 0;\n\t\ts->auto_eoi = 0;\n\t}\n\ts->init_state = 1;\n\n\tkvm_for_each_vcpu(i, vcpu, s->pics_state->kvm)\n\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\n\tif (!found)\n\t\treturn;\n\n\tfor (irq = 0; irq < PIC_NUM_PINS/2; irq++)\n\t\tif (edge_irr & (1 << irq))\n\t\t\tpic_clear_isr(s, irq);\n}"
  },
  {
    "function_name": "kvm_pic_read_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "234-269",
    "snippet": "int kvm_pic_read_irq(struct kvm *kvm)\n{\n\tint irq, irq2, intno;\n\tstruct kvm_pic *s = kvm->arch.vpic;\n\n\ts->output = 0;\n\n\tpic_lock(s);\n\tirq = pic_get_irq(&s->pics[0]);\n\tif (irq >= 0) {\n\t\tpic_intack(&s->pics[0], irq);\n\t\tif (irq == 2) {\n\t\t\tirq2 = pic_get_irq(&s->pics[1]);\n\t\t\tif (irq2 >= 0)\n\t\t\t\tpic_intack(&s->pics[1], irq2);\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * spurious IRQ on slave controller\n\t\t\t\t */\n\t\t\t\tirq2 = 7;\n\t\t\tintno = s->pics[1].irq_base + irq2;\n\t\t\tirq = irq2 + 8;\n\t\t} else\n\t\t\tintno = s->pics[0].irq_base + irq;\n\t} else {\n\t\t/*\n\t\t * spurious IRQ on host controller\n\t\t */\n\t\tirq = 7;\n\t\tintno = s->pics[0].irq_base + irq;\n\t}\n\tpic_update_irq(s);\n\tpic_unlock(s);\n\n\treturn intno;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "48-68",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_update_irq",
          "args": [
            "s"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_update_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "179-184",
          "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_intack",
          "args": [
            "&s->pics[1]",
            "irq2"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "pic_intack",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "217-232",
          "snippet": "static inline void pic_intack(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr |= 1 << irq;\n\t/*\n\t * We don't clear a level sensitive interrupt here\n\t */\n\tif (!(s->elcr & (1 << irq)))\n\t\ts->irr &= ~(1 << irq);\n\n\tif (s->auto_eoi) {\n\t\tif (s->rotate_on_auto_eoi)\n\t\t\ts->priority_add = (irq + 1) & 7;\n\t\tpic_clear_isr(s, irq);\n\t}\n\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic inline void pic_intack(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr |= 1 << irq;\n\t/*\n\t * We don't clear a level sensitive interrupt here\n\t */\n\tif (!(s->elcr & (1 << irq)))\n\t\ts->irr &= ~(1 << irq);\n\n\tif (s->auto_eoi) {\n\t\tif (s->rotate_on_auto_eoi)\n\t\t\ts->priority_add = (irq + 1) & 7;\n\t\tpic_clear_isr(s, irq);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_get_irq",
          "args": [
            "&s->pics[1]"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "pic_get_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "133-157",
          "snippet": "static int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint kvm_pic_read_irq(struct kvm *kvm)\n{\n\tint irq, irq2, intno;\n\tstruct kvm_pic *s = kvm->arch.vpic;\n\n\ts->output = 0;\n\n\tpic_lock(s);\n\tirq = pic_get_irq(&s->pics[0]);\n\tif (irq >= 0) {\n\t\tpic_intack(&s->pics[0], irq);\n\t\tif (irq == 2) {\n\t\t\tirq2 = pic_get_irq(&s->pics[1]);\n\t\t\tif (irq2 >= 0)\n\t\t\t\tpic_intack(&s->pics[1], irq2);\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * spurious IRQ on slave controller\n\t\t\t\t */\n\t\t\t\tirq2 = 7;\n\t\t\tintno = s->pics[1].irq_base + irq2;\n\t\t\tirq = irq2 + 8;\n\t\t} else\n\t\t\tintno = s->pics[0].irq_base + irq;\n\t} else {\n\t\t/*\n\t\t * spurious IRQ on host controller\n\t\t */\n\t\tirq = 7;\n\t\tintno = s->pics[0].irq_base + irq;\n\t}\n\tpic_update_irq(s);\n\tpic_unlock(s);\n\n\treturn intno;\n}"
  },
  {
    "function_name": "pic_intack",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "217-232",
    "snippet": "static inline void pic_intack(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr |= 1 << irq;\n\t/*\n\t * We don't clear a level sensitive interrupt here\n\t */\n\tif (!(s->elcr & (1 << irq)))\n\t\ts->irr &= ~(1 << irq);\n\n\tif (s->auto_eoi) {\n\t\tif (s->rotate_on_auto_eoi)\n\t\t\ts->priority_add = (irq + 1) & 7;\n\t\tpic_clear_isr(s, irq);\n\t}\n\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pic_irq_request(struct kvm *kvm, int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_clear_isr",
          "args": [
            "s",
            "irq"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "pic_clear_isr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "70-84",
          "snippet": "static void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic inline void pic_intack(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr |= 1 << irq;\n\t/*\n\t * We don't clear a level sensitive interrupt here\n\t */\n\tif (!(s->elcr & (1 << irq)))\n\t\ts->irr &= ~(1 << irq);\n\n\tif (s->auto_eoi) {\n\t\tif (s->rotate_on_auto_eoi)\n\t\t\ts->priority_add = (irq + 1) & 7;\n\t\tpic_clear_isr(s, irq);\n\t}\n\n}"
  },
  {
    "function_name": "kvm_pic_clear_all",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "204-212",
    "snippet": "void kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)\n{\n\tint i;\n\n\tpic_lock(s);\n\tfor (i = 0; i < PIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &s->irq_states[i]);\n\tpic_unlock(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "48-68",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "irq_source_id",
            "&s->irq_states[i]"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_clear_all(struct kvm_pic *s, int irq_source_id)\n{\n\tint i;\n\n\tpic_lock(s);\n\tfor (i = 0; i < PIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &s->irq_states[i]);\n\tpic_unlock(s);\n}"
  },
  {
    "function_name": "kvm_pic_set_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "186-202",
    "snippet": "int kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= PIC_NUM_PINS);\n\n\tpic_lock(s);\n\tirq_level = __kvm_irq_line_state(&s->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);\n\tpic_update_irq(s);\n\ttrace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,\n\t\t\t      s->pics[irq >> 3].imr, ret == 0);\n\tpic_unlock(s);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pic_irq_request(struct kvm *kvm, int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "48-68",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_pic_set_irq",
          "args": [
            "irq >> 3",
            "irq & 7",
            "s->pics[irq >> 3].elcr",
            "s->pics[irq >> 3].imr",
            "ret == 0"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_update_irq",
          "args": [
            "s"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_update_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "179-184",
          "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_set_irq1",
          "args": [
            "&s->pics[irq >> 3]",
            "irq & 7",
            "irq_level"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "pic_set_irq1",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "89-113",
          "snippet": "static inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kvm_irq_line_state",
          "args": [
            "&s->irq_states[irq]",
            "irq_source_id",
            "level"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "irq < 0 || irq >= PIC_NUM_PINS"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nint kvm_pic_set_irq(struct kvm_pic *s, int irq, int irq_source_id, int level)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= PIC_NUM_PINS);\n\n\tpic_lock(s);\n\tirq_level = __kvm_irq_line_state(&s->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = pic_set_irq1(&s->pics[irq >> 3], irq & 7, irq_level);\n\tpic_update_irq(s);\n\ttrace_kvm_pic_set_irq(irq >> 3, irq & 7, s->pics[irq >> 3].elcr,\n\t\t\t      s->pics[irq >> 3].imr, ret == 0);\n\tpic_unlock(s);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_pic_update_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "179-184",
    "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "48-68",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_update_irq",
          "args": [
            "s"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_update_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "179-184",
          "snippet": "void kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid kvm_pic_update_irq(struct kvm_pic *s)\n{\n\tpic_lock(s);\n\tpic_update_irq(s);\n\tpic_unlock(s);\n}"
  },
  {
    "function_name": "pic_update_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "163-177",
    "snippet": "static void pic_update_irq(struct kvm_pic *s)\n{\n\tint irq2, irq;\n\n\tirq2 = pic_get_irq(&s->pics[1]);\n\tif (irq2 >= 0) {\n\t\t/*\n\t\t * if irq request by slave pic, signal master PIC\n\t\t */\n\t\tpic_set_irq1(&s->pics[0], 2, 1);\n\t\tpic_set_irq1(&s->pics[0], 2, 0);\n\t}\n\tirq = pic_get_irq(&s->pics[0]);\n\tpic_irq_request(s->kvm, irq >= 0);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_irq_request",
          "args": [
            "s->kvm",
            "irq >= 0"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "pic_irq_request",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "561-568",
          "snippet": "static void pic_irq_request(struct kvm *kvm, int level)\n{\n\tstruct kvm_pic *s = kvm->arch.vpic;\n\n\tif (!s->output)\n\t\ts->wakeup_needed = true;\n\ts->output = level;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic void pic_irq_request(struct kvm *kvm, int level)\n{\n\tstruct kvm_pic *s = kvm->arch.vpic;\n\n\tif (!s->output)\n\t\ts->wakeup_needed = true;\n\ts->output = level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_get_irq",
          "args": [
            "&s->pics[0]"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "pic_get_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "133-157",
          "snippet": "static int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pic_set_irq1",
          "args": [
            "&s->pics[0]",
            "2",
            "0"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "pic_set_irq1",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "89-113",
          "snippet": "static inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void pic_irq_request(struct kvm *kvm, int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_update_irq(struct kvm_pic *s)\n{\n\tint irq2, irq;\n\n\tirq2 = pic_get_irq(&s->pics[1]);\n\tif (irq2 >= 0) {\n\t\t/*\n\t\t * if irq request by slave pic, signal master PIC\n\t\t */\n\t\tpic_set_irq1(&s->pics[0], 2, 1);\n\t\tpic_set_irq1(&s->pics[0], 2, 0);\n\t}\n\tirq = pic_get_irq(&s->pics[0]);\n\tpic_irq_request(s->kvm, irq >= 0);\n}"
  },
  {
    "function_name": "pic_get_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "133-157",
    "snippet": "static int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_priority",
          "args": [
            "s",
            "mask"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "get_priority",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "119-128",
          "snippet": "static inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic int pic_get_irq(struct kvm_kpic_state *s)\n{\n\tint mask, cur_priority, priority;\n\n\tmask = s->irr & ~s->imr;\n\tpriority = get_priority(s, mask);\n\tif (priority == 8)\n\t\treturn -1;\n\t/*\n\t * compute current priority. If special fully nested mode on the\n\t * master, the IRQ coming from the slave is not taken into account\n\t * for the priority computation.\n\t */\n\tmask = s->isr;\n\tif (s->special_fully_nested_mode && s == &s->pics_state->pics[0])\n\t\tmask &= ~(1 << 2);\n\tcur_priority = get_priority(s, mask);\n\tif (priority < cur_priority)\n\t\t/*\n\t\t * higher priority found: an irq should be generated\n\t\t */\n\t\treturn (priority + s->priority_add) & 7;\n\telse\n\t\treturn -1;\n}"
  },
  {
    "function_name": "get_priority",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "119-128",
    "snippet": "static inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic inline int get_priority(struct kvm_kpic_state *s, int mask)\n{\n\tint priority;\n\tif (mask == 0)\n\t\treturn 8;\n\tpriority = 0;\n\twhile ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)\n\t\tpriority++;\n\treturn priority;\n}"
  },
  {
    "function_name": "pic_set_irq1",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "89-113",
    "snippet": "static inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void pic_irq_request(struct kvm *kvm, int level);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_irq_request(struct kvm *kvm, int level);\n\nstatic inline int pic_set_irq1(struct kvm_kpic_state *s, int irq, int level)\n{\n\tint mask, ret = 1;\n\tmask = 1 << irq;\n\tif (s->elcr & mask)\t/* level triggered */\n\t\tif (level) {\n\t\t\tret = !(s->irr & mask);\n\t\t\ts->irr |= mask;\n\t\t\ts->last_irr |= mask;\n\t\t} else {\n\t\t\ts->irr &= ~mask;\n\t\t\ts->last_irr &= ~mask;\n\t\t}\n\telse\t/* edge triggered */\n\t\tif (level) {\n\t\t\tif ((s->last_irr & mask) == 0) {\n\t\t\t\tret = !(s->irr & mask);\n\t\t\t\ts->irr |= mask;\n\t\t\t}\n\t\t\ts->last_irr |= mask;\n\t\t} else\n\t\t\ts->last_irr &= ~mask;\n\n\treturn (s->imr & mask) ? -1 : ret;\n}"
  },
  {
    "function_name": "pic_clear_isr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "70-84",
    "snippet": "static void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pic_lock",
          "args": [
            "s->pics_state"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "pic_lock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "42-46",
          "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_notify_acked_irq",
          "args": [
            "s->pics_state->kvm",
            "SELECT_PIC(irq)",
            "irq"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SELECT_PIC",
          "args": [
            "irq"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pic_unlock",
          "args": [
            "s->pics_state"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "pic_unlock",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "48-68",
          "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_clear_isr(struct kvm_kpic_state *s, int irq)\n{\n\ts->isr &= ~(1 << irq);\n\tif (s != &s->pics_state->pics[0])\n\t\tirq += 8;\n\t/*\n\t * We are dropping lock while calling ack notifiers since ack\n\t * notifier callbacks for assigned devices call into PIC recursively.\n\t * Other interrupt may be delivered to PIC while lock is dropped but\n\t * it should be safe since PIC state is already updated at this stage.\n\t */\n\tpic_unlock(s->pics_state);\n\tkvm_notify_acked_irq(s->pics_state->kvm, SELECT_PIC(irq), irq);\n\tpic_lock(s->pics_state);\n}"
  },
  {
    "function_name": "pic_unlock",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "48-68",
    "snippet": "static void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_accept_pic_intr",
          "args": [
            "vcpu"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_accept_pic_intr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2411-2421",
          "snippet": "int kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "s->kvm"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&s->lock"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&s->lock"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_unlock(struct kvm_pic *s)\n\t__releases(&s->lock)\n{\n\tbool wakeup = s->wakeup_needed;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\ts->wakeup_needed = false;\n\n\tspin_unlock(&s->lock);\n\n\tif (wakeup) {\n\t\tkvm_for_each_vcpu(i, vcpu, s->kvm) {\n\t\t\tif (kvm_apic_accept_pic_intr(vcpu)) {\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\t\tkvm_vcpu_kick(vcpu);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pic_lock",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
    "lines": "42-46",
    "snippet": "static void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include <linux/kvm_host.h>",
      "#include \"irq.h\"",
      "#include <linux/bitops.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&s->lock"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&s->lock"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstatic void pic_lock(struct kvm_pic *s)\n\t__acquires(&s->lock)\n{\n\tspin_lock(&s->lock);\n}"
  }
]