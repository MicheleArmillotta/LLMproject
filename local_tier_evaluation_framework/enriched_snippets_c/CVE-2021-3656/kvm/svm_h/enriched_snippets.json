[
  {
    "function_name": "svm_nested_virtualize_tpr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "364-367",
    "snippet": "static inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}"
  },
  {
    "function_name": "nested_svm_nmi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "350-362",
    "snippet": "static inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "gif_set",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "325-331",
    "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vgif_enabled",
          "args": [
            "svm"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "vgif_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "304-307",
          "snippet": "static inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
  },
  {
    "function_name": "disable_gif",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "317-323",
    "snippet": "static inline void disable_gif(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\tsvm->vmcb->control.int_ctl &= ~V_GIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vgif_enabled",
          "args": [
            "svm"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "vgif_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "304-307",
          "snippet": "static inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void disable_gif(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\tsvm->vmcb->control.int_ctl &= ~V_GIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}"
  },
  {
    "function_name": "enable_gif",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "309-315",
    "snippet": "static inline void enable_gif(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vgif_enabled",
          "args": [
            "svm"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "vgif_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "304-307",
          "snippet": "static inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void enable_gif(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}"
  },
  {
    "function_name": "vgif_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "304-307",
    "snippet": "static inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}"
  },
  {
    "function_name": "is_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "299-302",
    "snippet": "static inline bool is_intercept(struct vcpu_svm *svm, int bit)\n{\n\treturn (svm->vmcb->control.intercept & (1ULL << bit)) != 0;\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool is_intercept(struct vcpu_svm *svm, int bit)\n{\n\treturn (svm->vmcb->control.intercept & (1ULL << bit)) != 0;\n}"
  },
  {
    "function_name": "clr_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "290-297",
    "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "99-138",
          "snippet": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "197-203",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "set_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "281-288",
    "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "99-138",
          "snippet": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "197-203",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "clr_exception_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "272-279",
    "snippet": "static inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "99-138",
          "snippet": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "197-203",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "set_exception_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "263-270",
    "snippet": "static inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "99-138",
          "snippet": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "197-203",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "clr_dr_intercepts",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "254-261",
    "snippet": "static inline void clr_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = 0;\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "99-138",
          "snippet": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "197-203",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = 0;\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "set_dr_intercepts",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "230-252",
    "snippet": "static inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "99-138",
          "snippet": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "197-203",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "is_cr_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "223-228",
    "snippet": "static inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "197-203",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}"
  },
  {
    "function_name": "clr_cr_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "214-221",
    "snippet": "static inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "99-138",
          "snippet": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "197-203",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "set_cr_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "205-212",
    "snippet": "static inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_intercepts",
          "args": [
            "svm"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_intercepts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "99-138",
          "snippet": "void recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid recalc_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *c, *h;\n\tstruct nested_state *g;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn;\n\n\tc = &svm->vmcb->control;\n\th = &svm->nested.hsave->control;\n\tg = &svm->nested;\n\n\tc->intercept_cr = h->intercept_cr;\n\tc->intercept_dr = h->intercept_dr;\n\tc->intercept_exceptions = h->intercept_exceptions;\n\tc->intercept = h->intercept;\n\n\tif (svm->vcpu.arch.hflags & HF_VINTR_MASK) {\n\t\t/* We only want the cr8 intercept bits of L1 */\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_READ);\n\t\tc->intercept_cr &= ~(1U << INTERCEPT_CR8_WRITE);\n\n\t\t/*\n\t\t * Once running L2 with HF_VINTR_MASK, EFLAGS.IF does not\n\t\t * affect any interrupt we may want to inject; therefore,\n\t\t * interrupt window vmexits are irrelevant to L0.\n\t\t */\n\t\tc->intercept &= ~(1ULL << INTERCEPT_VINTR);\n\t}\n\n\t/* We don't want to see VMMCALLs from a nested guest */\n\tc->intercept &= ~(1ULL << INTERCEPT_VMMCALL);\n\n\tc->intercept_cr |= g->intercept_cr;\n\tc->intercept_dr |= g->intercept_dr;\n\tc->intercept_exceptions |= g->intercept_exceptions;\n\tc->intercept |= g->intercept;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_host_vmcb",
          "args": [
            "svm"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "get_host_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "197-203",
          "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
  },
  {
    "function_name": "get_host_vmcb",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "197-203",
    "snippet": "static inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vmcb *get_host_vmcb(struct vcpu_svm *svm)\n{\n\tif (is_guest_mode(&svm->vcpu))\n\t\treturn svm->nested.hsave;\n\telse\n\t\treturn svm->vmcb;\n}"
  },
  {
    "function_name": "to_svm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "192-195",
    "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "vcpu",
            "structvcpu_svm",
            "vcpu"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
  },
  {
    "function_name": "mark_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "187-190",
    "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
  },
  {
    "function_name": "mark_all_clean",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "181-185",
    "snippet": "static inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [
      "#define VMCB_ALWAYS_DIRTY_MASK\t((1U << VMCB_INTR) | (1U << VMCB_CR2))"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\n#define VMCB_ALWAYS_DIRTY_MASK\t((1U << VMCB_INTR) | (1U << VMCB_CR2))\n\nstatic inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}"
  },
  {
    "function_name": "mark_all_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
    "lines": "176-179",
    "snippet": "static inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}",
    "includes": [
      "#include <asm/svm.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kvm_types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}"
  }
]