[
  {
    "function_name": "kvm_free_pit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "734-749",
    "snippet": "void kvm_free_pit(struct kvm *kvm)\n{\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tif (pit) {\n\t\tmutex_lock(&kvm->slots_lock);\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->speaker_dev);\n\t\tmutex_unlock(&kvm->slots_lock);\n\t\tkvm_pit_set_reinject(pit, false);\n\t\thrtimer_cancel(&pit->pit_state.timer);\n\t\tkthread_destroy_worker(pit->worker);\n\t\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\t\tkfree(pit);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pit"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_free_irq_source_id",
          "args": [
            "kvm",
            "pit->irq_source_id"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_irq_source_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "213-232",
          "snippet": "void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!irqchip_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(kvm->arch.vpic, irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!irqchip_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(kvm->arch.vpic, irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_destroy_worker",
          "args": [
            "pit->worker"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&pit->pit_state.timer"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pit_set_reinject",
          "args": [
            "pit",
            "false"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pit_set_reinject",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "290-321",
          "snippet": "void kvm_pit_set_reinject(struct kvm_pit *pit, bool reinject)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\n\tif (atomic_read(&ps->reinject) == reinject)\n\t\treturn;\n\n\t/*\n\t * AMD SVM AVIC accelerates EOI write and does not trap.\n\t * This cause in-kernel PIT re-inject mode to fail\n\t * since it checks ps->irq_ack before kvm_set_irq()\n\t * and relies on the ack notifier to timely queue\n\t * the pt->worker work iterm and reinject the missed tick.\n\t * So, deactivate APICv when PIT is in reinject mode.\n\t */\n\tif (reinject) {\n\t\tkvm_request_apicv_update(kvm, false,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\t/* The initial state is preserved while ps->reinject == 0. */\n\t\tkvm_pit_reset_reinject(pit);\n\t\tkvm_register_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t} else {\n\t\tkvm_request_apicv_update(kvm, true,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\tkvm_unregister_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t}\n\n\tatomic_set(&ps->reinject, reinject);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_pit_set_reinject(struct kvm_pit *pit, bool reinject)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\n\tif (atomic_read(&ps->reinject) == reinject)\n\t\treturn;\n\n\t/*\n\t * AMD SVM AVIC accelerates EOI write and does not trap.\n\t * This cause in-kernel PIT re-inject mode to fail\n\t * since it checks ps->irq_ack before kvm_set_irq()\n\t * and relies on the ack notifier to timely queue\n\t * the pt->worker work iterm and reinject the missed tick.\n\t * So, deactivate APICv when PIT is in reinject mode.\n\t */\n\tif (reinject) {\n\t\tkvm_request_apicv_update(kvm, false,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\t/* The initial state is preserved while ps->reinject == 0. */\n\t\tkvm_pit_reset_reinject(pit);\n\t\tkvm_register_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t} else {\n\t\tkvm_request_apicv_update(kvm, true,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\tkvm_unregister_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t}\n\n\tatomic_set(&ps->reinject, reinject);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "&pit->speaker_dev"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "&pit->dev"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_pit(struct kvm *kvm)\n{\n\tstruct kvm_pit *pit = kvm->arch.vpit;\n\n\tif (pit) {\n\t\tmutex_lock(&kvm->slots_lock);\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\n\t\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->speaker_dev);\n\t\tmutex_unlock(&kvm->slots_lock);\n\t\tkvm_pit_set_reinject(pit, false);\n\t\thrtimer_cancel(&pit->pit_state.timer);\n\t\tkthread_destroy_worker(pit->worker);\n\t\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\n\t\tkfree(pit);\n\t}\n}"
  },
  {
    "function_name": "kvm_create_pit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "660-732",
    "snippet": "struct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)\n{\n\tstruct kvm_pit *pit;\n\tstruct kvm_kpit_state *pit_state;\n\tstruct pid *pid;\n\tpid_t pid_nr;\n\tint ret;\n\n\tpit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL_ACCOUNT);\n\tif (!pit)\n\t\treturn NULL;\n\n\tpit->irq_source_id = kvm_request_irq_source_id(kvm);\n\tif (pit->irq_source_id < 0)\n\t\tgoto fail_request;\n\n\tmutex_init(&pit->pit_state.lock);\n\n\tpid = get_pid(task_tgid(current));\n\tpid_nr = pid_vnr(pid);\n\tput_pid(pid);\n\n\tpit->worker = kthread_create_worker(0, \"kvm-pit/%d\", pid_nr);\n\tif (IS_ERR(pit->worker))\n\t\tgoto fail_kthread;\n\n\tkthread_init_work(&pit->expired, pit_do_work);\n\n\tpit->kvm = kvm;\n\n\tpit_state = &pit->pit_state;\n\thrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpit_state->timer.function = pit_timer_fn;\n\n\tpit_state->irq_ack_notifier.gsi = 0;\n\tpit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;\n\tpit->mask_notifier.func = pit_mask_notifer;\n\n\tkvm_pit_reset(pit);\n\n\tkvm_pit_set_reinject(pit, true);\n\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_iodevice_init(&pit->dev, &pit_dev_ops);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,\n\t\t\t\t      KVM_PIT_MEM_LENGTH, &pit->dev);\n\tif (ret < 0)\n\t\tgoto fail_register_pit;\n\n\tif (flags & KVM_PIT_SPEAKER_DUMMY) {\n\t\tkvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);\n\t\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t      KVM_SPEAKER_BASE_ADDRESS, 4,\n\t\t\t\t\t      &pit->speaker_dev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_register_speaker;\n\t}\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn pit;\n\nfail_register_speaker:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\nfail_register_pit:\n\tmutex_unlock(&kvm->slots_lock);\n\tkvm_pit_set_reinject(pit, false);\n\tkthread_destroy_worker(pit->worker);\nfail_kthread:\n\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\nfail_request:\n\tkfree(pit);\n\treturn NULL;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_io_device_ops pit_dev_ops = {\n\t.read     = pit_ioport_read,\n\t.write    = pit_ioport_write,\n};",
      "static const struct kvm_io_device_ops speaker_dev_ops = {\n\t.read     = speaker_ioport_read,\n\t.write    = speaker_ioport_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pit"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_free_irq_source_id",
          "args": [
            "kvm",
            "pit->irq_source_id"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_free_irq_source_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "213-232",
          "snippet": "void kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!irqchip_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(kvm->arch.vpic, irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_free_irq_source_id(struct kvm *kvm, int irq_source_id)\n{\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\n\tmutex_lock(&kvm->irq_lock);\n\tif (irq_source_id < 0 ||\n\t    irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_ERR \"kvm: IRQ source ID out of range!\\n\");\n\t\tgoto unlock;\n\t}\n\tclear_bit(irq_source_id, &kvm->arch.irq_sources_bitmap);\n\tif (!irqchip_kernel(kvm))\n\t\tgoto unlock;\n\n\tkvm_ioapic_clear_all(kvm->arch.vioapic, irq_source_id);\n\tkvm_pic_clear_all(kvm->arch.vpic, irq_source_id);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_destroy_worker",
          "args": [
            "pit->worker"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pit_set_reinject",
          "args": [
            "pit",
            "false"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pit_set_reinject",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "290-321",
          "snippet": "void kvm_pit_set_reinject(struct kvm_pit *pit, bool reinject)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\n\tif (atomic_read(&ps->reinject) == reinject)\n\t\treturn;\n\n\t/*\n\t * AMD SVM AVIC accelerates EOI write and does not trap.\n\t * This cause in-kernel PIT re-inject mode to fail\n\t * since it checks ps->irq_ack before kvm_set_irq()\n\t * and relies on the ack notifier to timely queue\n\t * the pt->worker work iterm and reinject the missed tick.\n\t * So, deactivate APICv when PIT is in reinject mode.\n\t */\n\tif (reinject) {\n\t\tkvm_request_apicv_update(kvm, false,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\t/* The initial state is preserved while ps->reinject == 0. */\n\t\tkvm_pit_reset_reinject(pit);\n\t\tkvm_register_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t} else {\n\t\tkvm_request_apicv_update(kvm, true,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\tkvm_unregister_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t}\n\n\tatomic_set(&ps->reinject, reinject);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_pit_set_reinject(struct kvm_pit *pit, bool reinject)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\n\tif (atomic_read(&ps->reinject) == reinject)\n\t\treturn;\n\n\t/*\n\t * AMD SVM AVIC accelerates EOI write and does not trap.\n\t * This cause in-kernel PIT re-inject mode to fail\n\t * since it checks ps->irq_ack before kvm_set_irq()\n\t * and relies on the ack notifier to timely queue\n\t * the pt->worker work iterm and reinject the missed tick.\n\t * So, deactivate APICv when PIT is in reinject mode.\n\t */\n\tif (reinject) {\n\t\tkvm_request_apicv_update(kvm, false,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\t/* The initial state is preserved while ps->reinject == 0. */\n\t\tkvm_pit_reset_reinject(pit);\n\t\tkvm_register_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t} else {\n\t\tkvm_request_apicv_update(kvm, true,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\tkvm_unregister_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t}\n\n\tatomic_set(&ps->reinject, reinject);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "&pit->dev"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_register_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "KVM_SPEAKER_BASE_ADDRESS",
            "4",
            "&pit->speaker_dev"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&pit->speaker_dev",
            "&speaker_dev_ops"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_register_dev",
          "args": [
            "kvm",
            "KVM_PIO_BUS",
            "KVM_PIT_BASE_ADDRESS",
            "KVM_PIT_MEM_LENGTH",
            "&pit->dev"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&pit->dev",
            "&pit_dev_ops"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pit_reset",
          "args": [
            "pit"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pit_reset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "626-640",
          "snippet": "static void kvm_pit_reset(struct kvm_pit *pit)\n{\n\tint i;\n\tstruct kvm_kpit_channel_state *c;\n\n\tpit->pit_state.flags = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tc = &pit->pit_state.channels[i];\n\t\tc->mode = 0xff;\n\t\tc->gate = (i != 2);\n\t\tpit_load_count(pit, i, 0);\n\t}\n\n\tkvm_pit_reset_reinject(pit);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_pit_reset(struct kvm_pit *pit)\n{\n\tint i;\n\tstruct kvm_kpit_channel_state *c;\n\n\tpit->pit_state.flags = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tc = &pit->pit_state.channels[i];\n\t\tc->mode = 0xff;\n\t\tc->gate = (i != 2);\n\t\tpit_load_count(pit, i, 0);\n\t}\n\n\tkvm_pit_reset_reinject(pit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&pit_state->timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_init_work",
          "args": [
            "&pit->expired",
            "pit_do_work"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "pit->worker"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create_worker",
          "args": [
            "0",
            "\"kvm-pit/%d\"",
            "pid_nr"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid",
          "args": [
            "pid"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_vnr",
          "args": [
            "pid"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid",
          "args": [
            "task_tgid(current)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid",
          "args": [
            "current"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&pit->pit_state.lock"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_request_irq_source_id",
          "args": [
            "kvm"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_request_irq_source_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "190-211",
          "snippet": "int kvm_request_irq_source_id(struct kvm *kvm)\n{\n\tunsigned long *bitmap = &kvm->arch.irq_sources_bitmap;\n\tint irq_source_id;\n\n\tmutex_lock(&kvm->irq_lock);\n\tirq_source_id = find_first_zero_bit(bitmap, BITS_PER_LONG);\n\n\tif (irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_WARNING \"kvm: exhaust allocatable IRQ sources!\\n\");\n\t\tirq_source_id = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\tset_bit(irq_source_id, bitmap);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n\n\treturn irq_source_id;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_request_irq_source_id(struct kvm *kvm)\n{\n\tunsigned long *bitmap = &kvm->arch.irq_sources_bitmap;\n\tint irq_source_id;\n\n\tmutex_lock(&kvm->irq_lock);\n\tirq_source_id = find_first_zero_bit(bitmap, BITS_PER_LONG);\n\n\tif (irq_source_id >= BITS_PER_LONG) {\n\t\tprintk(KERN_WARNING \"kvm: exhaust allocatable IRQ sources!\\n\");\n\t\tirq_source_id = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tASSERT(irq_source_id != KVM_USERSPACE_IRQ_SOURCE_ID);\n\tASSERT(irq_source_id != KVM_IRQFD_RESAMPLE_IRQ_SOURCE_ID);\n\tset_bit(irq_source_id, bitmap);\nunlock:\n\tmutex_unlock(&kvm->irq_lock);\n\n\treturn irq_source_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kvm_pit)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic const struct kvm_io_device_ops pit_dev_ops = {\n\t.read     = pit_ioport_read,\n\t.write    = pit_ioport_write,\n};\nstatic const struct kvm_io_device_ops speaker_dev_ops = {\n\t.read     = speaker_ioport_read,\n\t.write    = speaker_ioport_write,\n};\n\nstruct kvm_pit *kvm_create_pit(struct kvm *kvm, u32 flags)\n{\n\tstruct kvm_pit *pit;\n\tstruct kvm_kpit_state *pit_state;\n\tstruct pid *pid;\n\tpid_t pid_nr;\n\tint ret;\n\n\tpit = kzalloc(sizeof(struct kvm_pit), GFP_KERNEL_ACCOUNT);\n\tif (!pit)\n\t\treturn NULL;\n\n\tpit->irq_source_id = kvm_request_irq_source_id(kvm);\n\tif (pit->irq_source_id < 0)\n\t\tgoto fail_request;\n\n\tmutex_init(&pit->pit_state.lock);\n\n\tpid = get_pid(task_tgid(current));\n\tpid_nr = pid_vnr(pid);\n\tput_pid(pid);\n\n\tpit->worker = kthread_create_worker(0, \"kvm-pit/%d\", pid_nr);\n\tif (IS_ERR(pit->worker))\n\t\tgoto fail_kthread;\n\n\tkthread_init_work(&pit->expired, pit_do_work);\n\n\tpit->kvm = kvm;\n\n\tpit_state = &pit->pit_state;\n\thrtimer_init(&pit_state->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tpit_state->timer.function = pit_timer_fn;\n\n\tpit_state->irq_ack_notifier.gsi = 0;\n\tpit_state->irq_ack_notifier.irq_acked = kvm_pit_ack_irq;\n\tpit->mask_notifier.func = pit_mask_notifer;\n\n\tkvm_pit_reset(pit);\n\n\tkvm_pit_set_reinject(pit, true);\n\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_iodevice_init(&pit->dev, &pit_dev_ops);\n\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS, KVM_PIT_BASE_ADDRESS,\n\t\t\t\t      KVM_PIT_MEM_LENGTH, &pit->dev);\n\tif (ret < 0)\n\t\tgoto fail_register_pit;\n\n\tif (flags & KVM_PIT_SPEAKER_DUMMY) {\n\t\tkvm_iodevice_init(&pit->speaker_dev, &speaker_dev_ops);\n\t\tret = kvm_io_bus_register_dev(kvm, KVM_PIO_BUS,\n\t\t\t\t\t      KVM_SPEAKER_BASE_ADDRESS, 4,\n\t\t\t\t\t      &pit->speaker_dev);\n\t\tif (ret < 0)\n\t\t\tgoto fail_register_speaker;\n\t}\n\tmutex_unlock(&kvm->slots_lock);\n\n\treturn pit;\n\nfail_register_speaker:\n\tkvm_io_bus_unregister_dev(kvm, KVM_PIO_BUS, &pit->dev);\nfail_register_pit:\n\tmutex_unlock(&kvm->slots_lock);\n\tkvm_pit_set_reinject(pit, false);\n\tkthread_destroy_worker(pit->worker);\nfail_kthread:\n\tkvm_free_irq_source_id(kvm, pit->irq_source_id);\nfail_request:\n\tkfree(pit);\n\treturn NULL;\n}"
  },
  {
    "function_name": "pit_mask_notifer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "642-648",
    "snippet": "static void pit_mask_notifer(struct kvm_irq_mask_notifier *kimn, bool mask)\n{\n\tstruct kvm_pit *pit = container_of(kimn, struct kvm_pit, mask_notifier);\n\n\tif (!mask)\n\t\tkvm_pit_reset_reinject(pit);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pit_reset_reinject",
          "args": [
            "pit"
          ],
          "line": 647
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pit_reset_reinject",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "284-288",
          "snippet": "static inline void kvm_pit_reset_reinject(struct kvm_pit *pit)\n{\n\tatomic_set(&pit->pit_state.pending, 0);\n\tatomic_set(&pit->pit_state.irq_ack, 1);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_pit_reset_reinject(struct kvm_pit *pit)\n{\n\tatomic_set(&pit->pit_state.pending, 0);\n\tatomic_set(&pit->pit_state.irq_ack, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kimn",
            "structkvm_pit",
            "mask_notifier"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_mask_notifer(struct kvm_irq_mask_notifier *kimn, bool mask)\n{\n\tstruct kvm_pit *pit = container_of(kimn, struct kvm_pit, mask_notifier);\n\n\tif (!mask)\n\t\tkvm_pit_reset_reinject(pit);\n}"
  },
  {
    "function_name": "kvm_pit_reset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "626-640",
    "snippet": "static void kvm_pit_reset(struct kvm_pit *pit)\n{\n\tint i;\n\tstruct kvm_kpit_channel_state *c;\n\n\tpit->pit_state.flags = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tc = &pit->pit_state.channels[i];\n\t\tc->mode = 0xff;\n\t\tc->gate = (i != 2);\n\t\tpit_load_count(pit, i, 0);\n\t}\n\n\tkvm_pit_reset_reinject(pit);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pit_reset_reinject",
          "args": [
            "pit"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pit_reset_reinject",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "284-288",
          "snippet": "static inline void kvm_pit_reset_reinject(struct kvm_pit *pit)\n{\n\tatomic_set(&pit->pit_state.pending, 0);\n\tatomic_set(&pit->pit_state.irq_ack, 1);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_pit_reset_reinject(struct kvm_pit *pit)\n{\n\tatomic_set(&pit->pit_state.pending, 0);\n\tatomic_set(&pit->pit_state.irq_ack, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pit_load_count",
          "args": [
            "pit",
            "i",
            "0"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "pit_load_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "366-402",
          "snippet": "static void pit_load_count(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tpr_debug(\"load_count val is %u, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tcreate_pit_timer(pit, val, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tcreate_pit_timer(pit, val, 1);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(pit);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_load_count(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tpr_debug(\"load_count val is %u, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tcreate_pit_timer(pit, val, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tcreate_pit_timer(pit, val, 1);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(pit);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_pit_reset(struct kvm_pit *pit)\n{\n\tint i;\n\tstruct kvm_kpit_channel_state *c;\n\n\tpit->pit_state.flags = 0;\n\tfor (i = 0; i < 3; i++) {\n\t\tc = &pit->pit_state.channels[i];\n\t\tc->mode = 0xff;\n\t\tc->gate = (i != 2);\n\t\tpit_load_count(pit, i, 0);\n\t}\n\n\tkvm_pit_reset_reinject(pit);\n}"
  },
  {
    "function_name": "speaker_ioport_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "602-624",
    "snippet": "static int speaker_ioport_read(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_io_device *this,\n\t\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tunsigned int refresh_clock;\n\tint ret;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Refresh clock toggles at about 15us. We approximate as 2^14ns. */\n\trefresh_clock = ((unsigned int)ktime_to_ns(ktime_get()) >> 14) & 1;\n\n\tmutex_lock(&pit_state->lock);\n\tret = ((pit_state->speaker_data_on << 1) | pit_get_gate(pit, 2) |\n\t\t(pit_get_out(pit, 2) << 5) | (refresh_clock << 4));\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pit_state->lock"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "(char *)&ret",
            "len"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pit_get_out",
          "args": [
            "pit",
            "2"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "pit_get_out",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "142-172",
          "snippet": "static int pit_get_out(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int pit_get_out(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\n\treturn out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pit_get_gate",
          "args": [
            "pit",
            "2"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "pit_get_gate",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "77-80",
          "snippet": "static int pit_get_gate(struct kvm_pit *pit, int channel)\n{\n\treturn pit->pit_state.channels[channel].gate;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int pit_get_gate(struct kvm_pit *pit, int channel)\n{\n\treturn pit->pit_state.channels[channel].gate;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pit_state->lock"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_get()"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "speaker_to_pit",
          "args": [
            "this"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "speaker_to_pit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "428-431",
          "snippet": "static inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int speaker_ioport_read(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_io_device *this,\n\t\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tunsigned int refresh_clock;\n\tint ret;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\t/* Refresh clock toggles at about 15us. We approximate as 2^14ns. */\n\trefresh_clock = ((unsigned int)ktime_to_ns(ktime_get()) >> 14) & 1;\n\n\tmutex_lock(&pit_state->lock);\n\tret = ((pit_state->speaker_data_on << 1) | pit_get_gate(pit, 2) |\n\t\t(pit_get_out(pit, 2) << 5) | (refresh_clock << 4));\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "speaker_ioport_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "585-600",
    "snippet": "static int speaker_ioport_write(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_io_device *this,\n\t\t\t\tgpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tu32 val = *(u32 *) data;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&pit_state->lock);\n\tpit_state->speaker_data_on = (val >> 1) & 1;\n\tpit_set_gate(pit, 2, val & 1);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pit_state->lock"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pit_set_gate",
          "args": [
            "pit",
            "2",
            "val & 1"
          ],
          "line": 597
        },
        "resolved": true,
        "details": {
          "function_name": "pit_set_gate",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "54-75",
          "snippet": "static void pit_set_gate(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\tcase 4:\n\t\t/* XXX: just disable/enable counting */\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 5:\n\t\t/* Restart counting on rising edge. */\n\t\tif (c->gate < val)\n\t\t\tc->count_load_time = ktime_get();\n\t\tbreak;\n\t}\n\n\tc->gate = val;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_set_gate(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\tcase 4:\n\t\t/* XXX: just disable/enable counting */\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 5:\n\t\t/* Restart counting on rising edge. */\n\t\tif (c->gate < val)\n\t\t\tc->count_load_time = ktime_get();\n\t\tbreak;\n\t}\n\n\tc->gate = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pit_state->lock"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "speaker_to_pit",
          "args": [
            "this"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "speaker_to_pit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "428-431",
          "snippet": "static inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int speaker_ioport_write(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_io_device *this,\n\t\t\t\tgpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = speaker_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tu32 val = *(u32 *) data;\n\tif (addr != KVM_SPEAKER_BASE_ADDRESS)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&pit_state->lock);\n\tpit_state->speaker_data_on = (val >> 1) & 1;\n\tpit_set_gate(pit, 2, val & 1);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "pit_ioport_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "515-583",
    "snippet": "static int pit_ioport_read(struct kvm_vcpu *vcpu,\n\t\t\t   struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tif (addr == 3)\n\t\treturn 0;\n\n\ts = &pit_state->channels[addr];\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(pit, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(pit, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(pit, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(pit, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define RW_STATE_WORD1 4",
      "#define RW_STATE_WORD0 3",
      "#define RW_STATE_MSB 2",
      "#define RW_STATE_LSB 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pit_state->lock"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "(char *)&ret",
            "len"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pit_get_count",
          "args": [
            "pit",
            "addr"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "pit_get_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "115-140",
          "snippet": "static int pit_get_count(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\t/* XXX: may be incorrect for odd counts */\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int pit_get_count(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\t/* XXX: may be incorrect for odd counts */\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pit_state->lock"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pit_in_range",
          "args": [
            "addr"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "pit_in_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "433-437",
          "snippet": "static inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_pit",
          "args": [
            "this"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_pit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "423-426",
          "snippet": "static inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\n#define RW_STATE_WORD1 4\n#define RW_STATE_WORD0 3\n#define RW_STATE_MSB 2\n#define RW_STATE_LSB 1\n\nstatic int pit_ioport_read(struct kvm_vcpu *vcpu,\n\t\t\t   struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tif (addr == 3)\n\t\treturn 0;\n\n\ts = &pit_state->channels[addr];\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(pit, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(pit, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(pit, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(pit, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "pit_ioport_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "439-513",
    "snippet": "static int pit_ioport_write(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_io_device *this,\n\t\t\t    gpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tint channel, access;\n\tstruct kvm_kpit_channel_state *s;\n\tu32 val = *(u32 *) data;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tval  &= 0xff;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (val != 0)\n\t\tpr_debug(\"write addr is 0x%x, len is %d, val is 0x%x\\n\",\n\t\t\t (unsigned int)addr, len, val);\n\n\tif (addr == 3) {\n\t\tchannel = val >> 6;\n\t\tif (channel == 3) {\n\t\t\t/* Read-Back Command. */\n\t\t\tfor (channel = 0; channel < 3; channel++) {\n\t\t\t\ts = &pit_state->channels[channel];\n\t\t\t\tif (val & (2 << channel)) {\n\t\t\t\t\tif (!(val & 0x20))\n\t\t\t\t\t\tpit_latch_count(pit, channel);\n\t\t\t\t\tif (!(val & 0x10))\n\t\t\t\t\t\tpit_latch_status(pit, channel);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* Select Counter <channel>. */\n\t\t\ts = &pit_state->channels[channel];\n\t\t\taccess = (val >> 4) & KVM_PIT_CHANNEL_MASK;\n\t\t\tif (access == 0) {\n\t\t\t\tpit_latch_count(pit, channel);\n\t\t\t} else {\n\t\t\t\ts->rw_mode = access;\n\t\t\t\ts->read_state = access;\n\t\t\t\ts->write_state = access;\n\t\t\t\ts->mode = (val >> 1) & 7;\n\t\t\t\tif (s->mode > 5)\n\t\t\t\t\ts->mode -= 4;\n\t\t\t\ts->bcd = val & 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Write Count. */\n\t\ts = &pit_state->channels[addr];\n\t\tswitch (s->write_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tpit_load_count(pit, addr, val);\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tpit_load_count(pit, addr, val << 8);\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\ts->write_latch = val;\n\t\t\ts->write_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tpit_load_count(pit, addr, s->write_latch | (val << 8));\n\t\t\ts->write_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define RW_STATE_WORD1 4",
      "#define RW_STATE_WORD0 3",
      "#define RW_STATE_MSB 2",
      "#define RW_STATE_LSB 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pit_state->lock"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pit_load_count",
          "args": [
            "pit",
            "addr",
            "s->write_latch | (val << 8)"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "pit_load_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "366-402",
          "snippet": "static void pit_load_count(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tpr_debug(\"load_count val is %u, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tcreate_pit_timer(pit, val, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tcreate_pit_timer(pit, val, 1);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(pit);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_load_count(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tpr_debug(\"load_count val is %u, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tcreate_pit_timer(pit, val, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tcreate_pit_timer(pit, val, 1);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(pit);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pit_latch_count",
          "args": [
            "pit",
            "channel"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "pit_latch_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "174-182",
          "snippet": "static void pit_latch_count(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tif (!c->count_latched) {\n\t\tc->latched_count = pit_get_count(pit, channel);\n\t\tc->count_latched = c->rw_mode;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_latch_count(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tif (!c->count_latched) {\n\t\tc->latched_count = pit_get_count(pit, channel);\n\t\tc->count_latched = c->rw_mode;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pit_latch_status",
          "args": [
            "pit",
            "channel"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "pit_latch_status",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "184-196",
          "snippet": "static void pit_latch_status(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tif (!c->status_latched) {\n\t\t/* TODO: Return NULL COUNT (bit 6). */\n\t\tc->status = ((pit_get_out(pit, channel) << 7) |\n\t\t\t\t(c->rw_mode << 4) |\n\t\t\t\t(c->mode << 1) |\n\t\t\t\tc->bcd);\n\t\tc->status_latched = 1;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_latch_status(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tif (!c->status_latched) {\n\t\t/* TODO: Return NULL COUNT (bit 6). */\n\t\tc->status = ((pit_get_out(pit, channel) << 7) |\n\t\t\t\t(c->rw_mode << 4) |\n\t\t\t\t(c->mode << 1) |\n\t\t\t\tc->bcd);\n\t\tc->status_latched = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"write addr is 0x%x, len is %d, val is 0x%x\\n\"",
            "(unsigned int)addr",
            "len",
            "val"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pit_state->lock"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pit_in_range",
          "args": [
            "addr"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "pit_in_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "433-437",
          "snippet": "static inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_to_pit",
          "args": [
            "this"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "dev_to_pit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "423-426",
          "snippet": "static inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\n#define RW_STATE_WORD1 4\n#define RW_STATE_WORD0 3\n#define RW_STATE_MSB 2\n#define RW_STATE_LSB 1\n\nstatic int pit_ioport_write(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_io_device *this,\n\t\t\t    gpa_t addr, int len, const void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tint channel, access;\n\tstruct kvm_kpit_channel_state *s;\n\tu32 val = *(u32 *) data;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\n\tval  &= 0xff;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\n\tmutex_lock(&pit_state->lock);\n\n\tif (val != 0)\n\t\tpr_debug(\"write addr is 0x%x, len is %d, val is 0x%x\\n\",\n\t\t\t (unsigned int)addr, len, val);\n\n\tif (addr == 3) {\n\t\tchannel = val >> 6;\n\t\tif (channel == 3) {\n\t\t\t/* Read-Back Command. */\n\t\t\tfor (channel = 0; channel < 3; channel++) {\n\t\t\t\ts = &pit_state->channels[channel];\n\t\t\t\tif (val & (2 << channel)) {\n\t\t\t\t\tif (!(val & 0x20))\n\t\t\t\t\t\tpit_latch_count(pit, channel);\n\t\t\t\t\tif (!(val & 0x10))\n\t\t\t\t\t\tpit_latch_status(pit, channel);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* Select Counter <channel>. */\n\t\t\ts = &pit_state->channels[channel];\n\t\t\taccess = (val >> 4) & KVM_PIT_CHANNEL_MASK;\n\t\t\tif (access == 0) {\n\t\t\t\tpit_latch_count(pit, channel);\n\t\t\t} else {\n\t\t\t\ts->rw_mode = access;\n\t\t\t\ts->read_state = access;\n\t\t\t\ts->write_state = access;\n\t\t\t\ts->mode = (val >> 1) & 7;\n\t\t\t\tif (s->mode > 5)\n\t\t\t\t\ts->mode -= 4;\n\t\t\t\ts->bcd = val & 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t/* Write Count. */\n\t\ts = &pit_state->channels[addr];\n\t\tswitch (s->write_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tpit_load_count(pit, addr, val);\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tpit_load_count(pit, addr, val << 8);\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\ts->write_latch = val;\n\t\t\ts->write_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tpit_load_count(pit, addr, s->write_latch | (val << 8));\n\t\t\ts->write_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "pit_in_range",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "433-437",
    "snippet": "static inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline int pit_in_range(gpa_t addr)\n{\n\treturn ((addr >= KVM_PIT_BASE_ADDRESS) &&\n\t\t(addr < KVM_PIT_BASE_ADDRESS + KVM_PIT_MEM_LENGTH));\n}"
  },
  {
    "function_name": "speaker_to_pit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "428-431",
    "snippet": "static inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pit",
            "speaker_dev"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_pit *speaker_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, speaker_dev);\n}"
  },
  {
    "function_name": "dev_to_pit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "423-426",
    "snippet": "static inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_pit",
            "dev"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_pit *dev_to_pit(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_pit, dev);\n}"
  },
  {
    "function_name": "kvm_pit_load_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "404-421",
    "snippet": "void kvm_pit_load_count(struct kvm_pit *pit, int channel, u32 val,\n\t\tint hpet_legacy_start)\n{\n\tu8 saved_mode;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&pit->pit_state.lock));\n\n\tif (hpet_legacy_start) {\n\t\t/* save existing mode for later reenablement */\n\t\tWARN_ON(channel != 0);\n\t\tsaved_mode = pit->pit_state.channels[0].mode;\n\t\tpit->pit_state.channels[0].mode = 0xff; /* disable timer */\n\t\tpit_load_count(pit, channel, val);\n\t\tpit->pit_state.channels[0].mode = saved_mode;\n\t} else {\n\t\tpit_load_count(pit, channel, val);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pit_load_count",
          "args": [
            "pit",
            "channel",
            "val"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "pit_load_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "366-402",
          "snippet": "static void pit_load_count(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tpr_debug(\"load_count val is %u, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tcreate_pit_timer(pit, val, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tcreate_pit_timer(pit, val, 1);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(pit);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_load_count(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tpr_debug(\"load_count val is %u, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tcreate_pit_timer(pit, val, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tcreate_pit_timer(pit, val, 1);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(pit);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "channel != 0"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!mutex_is_locked(&pit->pit_state.lock)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_is_locked",
          "args": [
            "&pit->pit_state.lock"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_pit_load_count(struct kvm_pit *pit, int channel, u32 val,\n\t\tint hpet_legacy_start)\n{\n\tu8 saved_mode;\n\n\tWARN_ON_ONCE(!mutex_is_locked(&pit->pit_state.lock));\n\n\tif (hpet_legacy_start) {\n\t\t/* save existing mode for later reenablement */\n\t\tWARN_ON(channel != 0);\n\t\tsaved_mode = pit->pit_state.channels[0].mode;\n\t\tpit->pit_state.channels[0].mode = 0xff; /* disable timer */\n\t\tpit_load_count(pit, channel, val);\n\t\tpit->pit_state.channels[0].mode = saved_mode;\n\t} else {\n\t\tpit_load_count(pit, channel, val);\n\t}\n}"
  },
  {
    "function_name": "pit_load_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "366-402",
    "snippet": "static void pit_load_count(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tpr_debug(\"load_count val is %u, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tcreate_pit_timer(pit, val, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tcreate_pit_timer(pit, val, 1);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(pit);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_pit_timer",
          "args": [
            "pit"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_pit_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "233-237",
          "snippet": "static void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tkthread_flush_work(&pit->expired);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tkthread_flush_work(&pit->expired);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_pit_timer",
          "args": [
            "pit",
            "val",
            "1"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "create_pit_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "323-364",
          "snippet": "static void create_pit_timer(struct kvm_pit *pit, u32 val, int is_period)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\ts64 interval;\n\n\tif (!ioapic_in_kernel(kvm) ||\n\t    ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)\n\t\treturn;\n\n\tinterval = mul_u64_u32_div(val, NSEC_PER_SEC, KVM_PIT_FREQ);\n\n\tpr_debug(\"create pit timer, interval is %llu nsec\\n\", interval);\n\n\t/* TODO The new value only affected after the retriggered */\n\thrtimer_cancel(&ps->timer);\n\tkthread_flush_work(&pit->expired);\n\tps->period = interval;\n\tps->is_periodic = is_period;\n\n\tkvm_pit_reset_reinject(pit);\n\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (ps->is_periodic) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (ps->period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: requested %lld ns \"\n\t\t\t    \"i8254 timer period limited to %lld ns\\n\",\n\t\t\t    ps->period, min_period);\n\t\t\tps->period = min_period;\n\t\t}\n\t}\n\n\thrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval),\n\t\t      HRTIMER_MODE_ABS);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void create_pit_timer(struct kvm_pit *pit, u32 val, int is_period)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\ts64 interval;\n\n\tif (!ioapic_in_kernel(kvm) ||\n\t    ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)\n\t\treturn;\n\n\tinterval = mul_u64_u32_div(val, NSEC_PER_SEC, KVM_PIT_FREQ);\n\n\tpr_debug(\"create pit timer, interval is %llu nsec\\n\", interval);\n\n\t/* TODO The new value only affected after the retriggered */\n\thrtimer_cancel(&ps->timer);\n\tkthread_flush_work(&pit->expired);\n\tps->period = interval;\n\tps->is_periodic = is_period;\n\n\tkvm_pit_reset_reinject(pit);\n\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (ps->is_periodic) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (ps->period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: requested %lld ns \"\n\t\t\t    \"i8254 timer period limited to %lld ns\\n\",\n\t\t\t    ps->period, min_period);\n\t\t\tps->period = min_period;\n\t\t}\n\t}\n\n\thrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval),\n\t\t      HRTIMER_MODE_ABS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"load_count val is %u, channel is %d\\n\"",
            "val",
            "channel"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_load_count(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tpr_debug(\"load_count val is %u, channel is %d\\n\", val, channel);\n\n\t/*\n\t * The largest possible initial count is 0; this is equivalent\n\t * to 216 for binary counting and 104 for BCD counting.\n\t */\n\tif (val == 0)\n\t\tval = 0x10000;\n\n\tps->channels[channel].count = val;\n\n\tif (channel != 0) {\n\t\tps->channels[channel].count_load_time = ktime_get();\n\t\treturn;\n\t}\n\n\t/* Two types of timer\n\t * mode 1 is one shot, mode 2 is period, otherwise del timer */\n\tswitch (ps->channels[0].mode) {\n\tcase 0:\n\tcase 1:\n        /* FIXME: enhance mode 4 precision */\n\tcase 4:\n\t\tcreate_pit_timer(pit, val, 0);\n\t\tbreak;\n\tcase 2:\n\tcase 3:\n\t\tcreate_pit_timer(pit, val, 1);\n\t\tbreak;\n\tdefault:\n\t\tdestroy_pit_timer(pit);\n\t}\n}"
  },
  {
    "function_name": "create_pit_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "323-364",
    "snippet": "static void create_pit_timer(struct kvm_pit *pit, u32 val, int is_period)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\ts64 interval;\n\n\tif (!ioapic_in_kernel(kvm) ||\n\t    ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)\n\t\treturn;\n\n\tinterval = mul_u64_u32_div(val, NSEC_PER_SEC, KVM_PIT_FREQ);\n\n\tpr_debug(\"create pit timer, interval is %llu nsec\\n\", interval);\n\n\t/* TODO The new value only affected after the retriggered */\n\thrtimer_cancel(&ps->timer);\n\tkthread_flush_work(&pit->expired);\n\tps->period = interval;\n\tps->is_periodic = is_period;\n\n\tkvm_pit_reset_reinject(pit);\n\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (ps->is_periodic) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (ps->period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: requested %lld ns \"\n\t\t\t    \"i8254 timer period limited to %lld ns\\n\",\n\t\t\t    ps->period, min_period);\n\t\t\tps->period = min_period;\n\t\t}\n\t}\n\n\thrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval),\n\t\t      HRTIMER_MODE_ABS);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&ps->timer",
            "ktime_add_ns(ktime_get(), interval)",
            "HRTIMER_MODE_ABS"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "ktime_get()",
            "interval"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info_ratelimited",
          "args": [
            "\"kvm: requested %lld ns \"\n\t\t\t    \"i8254 timer period limited to %lld ns\\n\"",
            "ps->period",
            "min_period"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pit_reset_reinject",
          "args": [
            "pit"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pit_reset_reinject",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "284-288",
          "snippet": "static inline void kvm_pit_reset_reinject(struct kvm_pit *pit)\n{\n\tatomic_set(&pit->pit_state.pending, 0);\n\tatomic_set(&pit->pit_state.irq_ack, 1);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_pit_reset_reinject(struct kvm_pit *pit)\n{\n\tatomic_set(&pit->pit_state.pending, 0);\n\tatomic_set(&pit->pit_state.irq_ack, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_flush_work",
          "args": [
            "&pit->expired"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&ps->timer"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"create pit timer, interval is %llu nsec\\n\"",
            "interval"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_u64_u32_div",
          "args": [
            "val",
            "NSEC_PER_SEC",
            "KVM_PIT_FREQ"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.h",
          "lines": "109-116",
          "snippet": "static inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void create_pit_timer(struct kvm_pit *pit, u32 val, int is_period)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\ts64 interval;\n\n\tif (!ioapic_in_kernel(kvm) ||\n\t    ps->flags & KVM_PIT_FLAGS_HPET_LEGACY)\n\t\treturn;\n\n\tinterval = mul_u64_u32_div(val, NSEC_PER_SEC, KVM_PIT_FREQ);\n\n\tpr_debug(\"create pit timer, interval is %llu nsec\\n\", interval);\n\n\t/* TODO The new value only affected after the retriggered */\n\thrtimer_cancel(&ps->timer);\n\tkthread_flush_work(&pit->expired);\n\tps->period = interval;\n\tps->is_periodic = is_period;\n\n\tkvm_pit_reset_reinject(pit);\n\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (ps->is_periodic) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (ps->period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: requested %lld ns \"\n\t\t\t    \"i8254 timer period limited to %lld ns\\n\",\n\t\t\t    ps->period, min_period);\n\t\t\tps->period = min_period;\n\t\t}\n\t}\n\n\thrtimer_start(&ps->timer, ktime_add_ns(ktime_get(), interval),\n\t\t      HRTIMER_MODE_ABS);\n}"
  },
  {
    "function_name": "kvm_pit_set_reinject",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "290-321",
    "snippet": "void kvm_pit_set_reinject(struct kvm_pit *pit, bool reinject)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\n\tif (atomic_read(&ps->reinject) == reinject)\n\t\treturn;\n\n\t/*\n\t * AMD SVM AVIC accelerates EOI write and does not trap.\n\t * This cause in-kernel PIT re-inject mode to fail\n\t * since it checks ps->irq_ack before kvm_set_irq()\n\t * and relies on the ack notifier to timely queue\n\t * the pt->worker work iterm and reinject the missed tick.\n\t * So, deactivate APICv when PIT is in reinject mode.\n\t */\n\tif (reinject) {\n\t\tkvm_request_apicv_update(kvm, false,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\t/* The initial state is preserved while ps->reinject == 0. */\n\t\tkvm_pit_reset_reinject(pit);\n\t\tkvm_register_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t} else {\n\t\tkvm_request_apicv_update(kvm, true,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\tkvm_unregister_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t}\n\n\tatomic_set(&ps->reinject, reinject);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ps->reinject",
            "reinject"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_unregister_irq_mask_notifier",
          "args": [
            "kvm",
            "0",
            "&pit->mask_notifier"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unregister_irq_mask_notifier",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "243-250",
          "snippet": "void kvm_unregister_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t      struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\thlist_del_rcu(&kimn->link);\n\tmutex_unlock(&kvm->irq_lock);\n\tsynchronize_srcu(&kvm->irq_srcu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_unregister_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t      struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\thlist_del_rcu(&kimn->link);\n\tmutex_unlock(&kvm->irq_lock);\n\tsynchronize_srcu(&kvm->irq_srcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_unregister_irq_ack_notifier",
          "args": [
            "kvm",
            "&ps->irq_ack_notifier"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_request_apicv_update",
          "args": [
            "kvm",
            "true",
            "APICV_INHIBIT_REASON_PIT_REINJ"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_request_apicv_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8057-8084",
          "snippet": "void kvm_request_apicv_update(struct kvm *kvm, bool activate, ulong bit)\n{\n\tunsigned long old, new, expected;\n\n\tif (!kvm_x86_ops.check_apicv_inhibit_reasons ||\n\t    !kvm_x86_ops.check_apicv_inhibit_reasons(bit))\n\t\treturn;\n\n\told = READ_ONCE(kvm->arch.apicv_inhibit_reasons);\n\tdo {\n\t\texpected = new = old;\n\t\tif (activate)\n\t\t\t__clear_bit(bit, &new);\n\t\telse\n\t\t\t__set_bit(bit, &new);\n\t\tif (new == old)\n\t\t\tbreak;\n\t\told = cmpxchg(&kvm->arch.apicv_inhibit_reasons, expected, new);\n\t} while (old != expected);\n\n\tif (!!old == !!new)\n\t\treturn;\n\n\ttrace_kvm_apicv_update_request(activate, bit);\n\tif (kvm_x86_ops.pre_update_apicv_exec_ctrl)\n\t\tkvm_x86_ops.pre_update_apicv_exec_ctrl(kvm, activate);\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kvm_x86_ops kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops kvm_x86_ops;\n\nvoid kvm_request_apicv_update(struct kvm *kvm, bool activate, ulong bit)\n{\n\tunsigned long old, new, expected;\n\n\tif (!kvm_x86_ops.check_apicv_inhibit_reasons ||\n\t    !kvm_x86_ops.check_apicv_inhibit_reasons(bit))\n\t\treturn;\n\n\told = READ_ONCE(kvm->arch.apicv_inhibit_reasons);\n\tdo {\n\t\texpected = new = old;\n\t\tif (activate)\n\t\t\t__clear_bit(bit, &new);\n\t\telse\n\t\t\t__set_bit(bit, &new);\n\t\tif (new == old)\n\t\t\tbreak;\n\t\told = cmpxchg(&kvm->arch.apicv_inhibit_reasons, expected, new);\n\t} while (old != expected);\n\n\tif (!!old == !!new)\n\t\treturn;\n\n\ttrace_kvm_apicv_update_request(activate, bit);\n\tif (kvm_x86_ops.pre_update_apicv_exec_ctrl)\n\t\tkvm_x86_ops.pre_update_apicv_exec_ctrl(kvm, activate);\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_irq_mask_notifier",
          "args": [
            "kvm",
            "0",
            "&pit->mask_notifier"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_irq_mask_notifier",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "234-241",
          "snippet": "void kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t    struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\tkimn->irq = irq;\n\thlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);\n\tmutex_unlock(&kvm->irq_lock);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_register_irq_mask_notifier(struct kvm *kvm, int irq,\n\t\t\t\t    struct kvm_irq_mask_notifier *kimn)\n{\n\tmutex_lock(&kvm->irq_lock);\n\tkimn->irq = irq;\n\thlist_add_head_rcu(&kimn->link, &kvm->arch.mask_notifier_list);\n\tmutex_unlock(&kvm->irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_irq_ack_notifier",
          "args": [
            "kvm",
            "&ps->irq_ack_notifier"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_pit_reset_reinject",
          "args": [
            "pit"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pit_reset_reinject",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "284-288",
          "snippet": "static inline void kvm_pit_reset_reinject(struct kvm_pit *pit)\n{\n\tatomic_set(&pit->pit_state.pending, 0);\n\tatomic_set(&pit->pit_state.irq_ack, 1);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_pit_reset_reinject(struct kvm_pit *pit)\n{\n\tatomic_set(&pit->pit_state.pending, 0);\n\tatomic_set(&pit->pit_state.irq_ack, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ps->reinject"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_pit_set_reinject(struct kvm_pit *pit, bool reinject)\n{\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\n\tif (atomic_read(&ps->reinject) == reinject)\n\t\treturn;\n\n\t/*\n\t * AMD SVM AVIC accelerates EOI write and does not trap.\n\t * This cause in-kernel PIT re-inject mode to fail\n\t * since it checks ps->irq_ack before kvm_set_irq()\n\t * and relies on the ack notifier to timely queue\n\t * the pt->worker work iterm and reinject the missed tick.\n\t * So, deactivate APICv when PIT is in reinject mode.\n\t */\n\tif (reinject) {\n\t\tkvm_request_apicv_update(kvm, false,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\t/* The initial state is preserved while ps->reinject == 0. */\n\t\tkvm_pit_reset_reinject(pit);\n\t\tkvm_register_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_register_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t} else {\n\t\tkvm_request_apicv_update(kvm, true,\n\t\t\t\t\t APICV_INHIBIT_REASON_PIT_REINJ);\n\t\tkvm_unregister_irq_ack_notifier(kvm, &ps->irq_ack_notifier);\n\t\tkvm_unregister_irq_mask_notifier(kvm, 0, &pit->mask_notifier);\n\t}\n\n\tatomic_set(&ps->reinject, reinject);\n}"
  },
  {
    "function_name": "kvm_pit_reset_reinject",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "284-288",
    "snippet": "static inline void kvm_pit_reset_reinject(struct kvm_pit *pit)\n{\n\tatomic_set(&pit->pit_state.pending, 0);\n\tatomic_set(&pit->pit_state.irq_ack, 1);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pit->pit_state.irq_ack",
            "1"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&pit->pit_state.pending",
            "0"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_pit_reset_reinject(struct kvm_pit *pit)\n{\n\tatomic_set(&pit->pit_state.pending, 0);\n\tatomic_set(&pit->pit_state.irq_ack, 1);\n}"
  },
  {
    "function_name": "pit_timer_fn",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "267-282",
    "snippet": "static enum hrtimer_restart pit_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_kpit_state *ps = container_of(data, struct kvm_kpit_state, timer);\n\tstruct kvm_pit *pt = pit_state_to_pit(ps);\n\n\tif (atomic_read(&ps->reinject))\n\t\tatomic_inc(&ps->pending);\n\n\tkthread_queue_work(pt->worker, &pt->expired);\n\n\tif (ps->is_periodic) {\n\t\thrtimer_add_expires_ns(&ps->timer, ps->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_add_expires_ns",
          "args": [
            "&ps->timer",
            "ps->period"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_queue_work",
          "args": [
            "pt->worker",
            "&pt->expired"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&ps->pending"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ps->reinject"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pit_state_to_pit",
          "args": [
            "ps"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "pit_state_to_pit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "198-201",
          "snippet": "static inline struct kvm_pit *pit_state_to_pit(struct kvm_kpit_state *ps)\n{\n\treturn container_of(ps, struct kvm_pit, pit_state);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_pit *pit_state_to_pit(struct kvm_kpit_state *ps)\n{\n\treturn container_of(ps, struct kvm_pit, pit_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "data",
            "structkvm_kpit_state",
            "timer"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic enum hrtimer_restart pit_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_kpit_state *ps = container_of(data, struct kvm_kpit_state, timer);\n\tstruct kvm_pit *pt = pit_state_to_pit(ps);\n\n\tif (atomic_read(&ps->reinject))\n\t\tatomic_inc(&ps->pending);\n\n\tkthread_queue_work(pt->worker, &pt->expired);\n\n\tif (ps->is_periodic) {\n\t\thrtimer_add_expires_ns(&ps->timer, ps->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "pit_do_work",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "239-265",
    "snippet": "static void pit_do_work(struct kthread_work *work)\n{\n\tstruct kvm_pit *pit = container_of(work, struct kvm_pit, expired);\n\tstruct kvm *kvm = pit->kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tif (atomic_read(&ps->reinject) && !atomic_xchg(&ps->irq_ack, 0))\n\t\treturn;\n\n\tkvm_set_irq(kvm, pit->irq_source_id, 0, 1, false);\n\tkvm_set_irq(kvm, pit->irq_source_id, 0, 0, false);\n\n\t/*\n\t * Provides NMI watchdog support via Virtual Wire mode.\n\t * The route is: PIT -> LVT0 in NMI mode.\n\t *\n\t * Note: Our Virtual Wire implementation does not follow\n\t * the MP specification.  We propagate a PIT interrupt to all\n\t * VCPUs and only when LVT0 is in NMI mode.  The interrupt can\n\t * also be simultaneously delivered through PIC and IOAPIC.\n\t */\n\tif (atomic_read(&kvm->arch.vapics_in_nmi_mode) > 0)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tkvm_apic_nmi_wd_deliver(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_nmi_wd_deliver",
          "args": [
            "vcpu"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_nmi_wd_deliver",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2324-2330",
          "snippet": "void kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic)\n\t\tkvm_apic_local_deliver(apic, APIC_LVT0);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic)\n\t\tkvm_apic_local_deliver(apic, APIC_LVT0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kvm->arch.vapics_in_nmi_mode"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_irq",
          "args": [
            "kvm",
            "pit->irq_source_id",
            "0",
            "0",
            "false"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_irq",
          "args": [
            "kvm",
            "pit->irq_source_id",
            "0",
            "1",
            "false"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_xchg",
          "args": [
            "&ps->irq_ack",
            "0"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ps->reinject"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structkvm_pit",
            "expired"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_do_work(struct kthread_work *work)\n{\n\tstruct kvm_pit *pit = container_of(work, struct kvm_pit, expired);\n\tstruct kvm *kvm = pit->kvm;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tif (atomic_read(&ps->reinject) && !atomic_xchg(&ps->irq_ack, 0))\n\t\treturn;\n\n\tkvm_set_irq(kvm, pit->irq_source_id, 0, 1, false);\n\tkvm_set_irq(kvm, pit->irq_source_id, 0, 0, false);\n\n\t/*\n\t * Provides NMI watchdog support via Virtual Wire mode.\n\t * The route is: PIT -> LVT0 in NMI mode.\n\t *\n\t * Note: Our Virtual Wire implementation does not follow\n\t * the MP specification.  We propagate a PIT interrupt to all\n\t * VCPUs and only when LVT0 is in NMI mode.  The interrupt can\n\t * also be simultaneously delivered through PIC and IOAPIC.\n\t */\n\tif (atomic_read(&kvm->arch.vapics_in_nmi_mode) > 0)\n\t\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\t\tkvm_apic_nmi_wd_deliver(vcpu);\n}"
  },
  {
    "function_name": "destroy_pit_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "233-237",
    "snippet": "static void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tkthread_flush_work(&pit->expired);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_flush_work",
          "args": [
            "&pit->expired"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&pit->pit_state.timer"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void destroy_pit_timer(struct kvm_pit *pit)\n{\n\thrtimer_cancel(&pit->pit_state.timer);\n\tkthread_flush_work(&pit->expired);\n}"
  },
  {
    "function_name": "__kvm_migrate_pit_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "218-231",
    "snippet": "void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\n\ttimer = &pit->pit_state.timer;\n\tmutex_lock(&pit->pit_state.lock);\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n\tmutex_unlock(&pit->pit_state.lock);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pit->pit_state.lock"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "timer",
            "HRTIMER_MODE_ABS"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "timer"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pit->pit_state.lock"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_is_bsp",
          "args": [
            "vcpu"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_is_bsp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9694-9697",
          "snippet": "bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\n\ttimer = &pit->pit_state.timer;\n\tmutex_lock(&pit->pit_state.lock);\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n\tmutex_unlock(&pit->pit_state.lock);\n}"
  },
  {
    "function_name": "kvm_pit_ack_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "203-216",
    "snippet": "static void kvm_pit_ack_irq(struct kvm_irq_ack_notifier *kian)\n{\n\tstruct kvm_kpit_state *ps = container_of(kian, struct kvm_kpit_state,\n\t\t\t\t\t\t irq_ack_notifier);\n\tstruct kvm_pit *pit = pit_state_to_pit(ps);\n\n\tatomic_set(&ps->irq_ack, 1);\n\t/* irq_ack should be set before pending is read.  Order accesses with\n\t * inc(pending) in pit_timer_fn and xchg(irq_ack, 0) in pit_do_work.\n\t */\n\tsmp_mb();\n\tif (atomic_dec_if_positive(&ps->pending) > 0)\n\t\tkthread_queue_work(pit->worker, &pit->expired);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_queue_work",
          "args": [
            "pit->worker",
            "&pit->expired"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_if_positive",
          "args": [
            "&ps->pending"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ps->irq_ack",
            "1"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pit_state_to_pit",
          "args": [
            "ps"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "pit_state_to_pit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "198-201",
          "snippet": "static inline struct kvm_pit *pit_state_to_pit(struct kvm_kpit_state *ps)\n{\n\treturn container_of(ps, struct kvm_pit, pit_state);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_pit *pit_state_to_pit(struct kvm_kpit_state *ps)\n{\n\treturn container_of(ps, struct kvm_pit, pit_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kian",
            "structkvm_kpit_state",
            "irq_ack_notifier"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_pit_ack_irq(struct kvm_irq_ack_notifier *kian)\n{\n\tstruct kvm_kpit_state *ps = container_of(kian, struct kvm_kpit_state,\n\t\t\t\t\t\t irq_ack_notifier);\n\tstruct kvm_pit *pit = pit_state_to_pit(ps);\n\n\tatomic_set(&ps->irq_ack, 1);\n\t/* irq_ack should be set before pending is read.  Order accesses with\n\t * inc(pending) in pit_timer_fn and xchg(irq_ack, 0) in pit_do_work.\n\t */\n\tsmp_mb();\n\tif (atomic_dec_if_positive(&ps->pending) > 0)\n\t\tkthread_queue_work(pit->worker, &pit->expired);\n}"
  },
  {
    "function_name": "pit_state_to_pit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "198-201",
    "snippet": "static inline struct kvm_pit *pit_state_to_pit(struct kvm_kpit_state *ps)\n{\n\treturn container_of(ps, struct kvm_pit, pit_state);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ps",
            "structkvm_pit",
            "pit_state"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_pit *pit_state_to_pit(struct kvm_kpit_state *ps)\n{\n\treturn container_of(ps, struct kvm_pit, pit_state);\n}"
  },
  {
    "function_name": "pit_latch_status",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "184-196",
    "snippet": "static void pit_latch_status(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tif (!c->status_latched) {\n\t\t/* TODO: Return NULL COUNT (bit 6). */\n\t\tc->status = ((pit_get_out(pit, channel) << 7) |\n\t\t\t\t(c->rw_mode << 4) |\n\t\t\t\t(c->mode << 1) |\n\t\t\t\tc->bcd);\n\t\tc->status_latched = 1;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pit_get_out",
          "args": [
            "pit",
            "channel"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "pit_get_out",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "142-172",
          "snippet": "static int pit_get_out(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\n\treturn out;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int pit_get_out(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\n\treturn out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_latch_status(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tif (!c->status_latched) {\n\t\t/* TODO: Return NULL COUNT (bit 6). */\n\t\tc->status = ((pit_get_out(pit, channel) << 7) |\n\t\t\t\t(c->rw_mode << 4) |\n\t\t\t\t(c->mode << 1) |\n\t\t\t\tc->bcd);\n\t\tc->status_latched = 1;\n\t}\n}"
  },
  {
    "function_name": "pit_latch_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "174-182",
    "snippet": "static void pit_latch_count(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tif (!c->count_latched) {\n\t\tc->latched_count = pit_get_count(pit, channel);\n\t\tc->count_latched = c->rw_mode;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pit_get_count",
          "args": [
            "pit",
            "channel"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "pit_get_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "115-140",
          "snippet": "static int pit_get_count(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\t/* XXX: may be incorrect for odd counts */\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int pit_get_count(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\t/* XXX: may be incorrect for odd counts */\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_latch_count(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tif (!c->count_latched) {\n\t\tc->latched_count = pit_get_count(pit, channel);\n\t\tc->count_latched = c->rw_mode;\n\t}\n}"
  },
  {
    "function_name": "pit_get_out",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "142-172",
    "snippet": "static int pit_get_out(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\n\treturn out;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_64",
          "args": [
            "d",
            "c->count"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_64",
          "args": [
            "d",
            "c->count"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_u64_u32_div",
          "args": [
            "t",
            "KVM_PIT_FREQ",
            "NSEC_PER_SEC"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kpit_elapsed",
          "args": [
            "pit",
            "c",
            "channel"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "kpit_elapsed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "106-113",
          "snippet": "static s64 kpit_elapsed(struct kvm_pit *pit, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(pit);\n\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic s64 kpit_elapsed(struct kvm_pit *pit, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(pit);\n\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int pit_get_out(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint out;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\t\tout = (d >= c->count);\n\t\tbreak;\n\tcase 1:\n\t\tout = (d < c->count);\n\t\tbreak;\n\tcase 2:\n\t\tout = ((mod_64(d, c->count) == 0) && (d != 0));\n\t\tbreak;\n\tcase 3:\n\t\tout = (mod_64(d, c->count) < ((c->count + 1) >> 1));\n\t\tbreak;\n\tcase 4:\n\tcase 5:\n\t\tout = (d == c->count);\n\t\tbreak;\n\t}\n\n\treturn out;\n}"
  },
  {
    "function_name": "pit_get_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "115-140",
    "snippet": "static int pit_get_count(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\t/* XXX: may be incorrect for odd counts */\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_64",
          "args": [
            "d",
            "c->count"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_64",
          "args": [
            "(2 * d)",
            "c->count"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_u64_u32_div",
          "args": [
            "t",
            "KVM_PIT_FREQ",
            "NSEC_PER_SEC"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kpit_elapsed",
          "args": [
            "pit",
            "c",
            "channel"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "kpit_elapsed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "106-113",
          "snippet": "static s64 kpit_elapsed(struct kvm_pit *pit, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(pit);\n\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic s64 kpit_elapsed(struct kvm_pit *pit, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(pit);\n\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int pit_get_count(struct kvm_pit *pit, int channel)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\ts64 d, t;\n\tint counter;\n\n\tt = kpit_elapsed(pit, c, channel);\n\td = mul_u64_u32_div(t, KVM_PIT_FREQ, NSEC_PER_SEC);\n\n\tswitch (c->mode) {\n\tcase 0:\n\tcase 1:\n\tcase 4:\n\tcase 5:\n\t\tcounter = (c->count - d) & 0xffff;\n\t\tbreak;\n\tcase 3:\n\t\t/* XXX: may be incorrect for odd counts */\n\t\tcounter = c->count - (mod_64((2 * d), c->count));\n\t\tbreak;\n\tdefault:\n\t\tcounter = c->count - mod_64(d, c->count);\n\t\tbreak;\n\t}\n\treturn counter;\n}"
  },
  {
    "function_name": "kpit_elapsed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "106-113",
    "snippet": "static s64 kpit_elapsed(struct kvm_pit *pit, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(pit);\n\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ktime_get(), c->count_load_time)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "c->count_load_time"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kpit_elapsed",
          "args": [
            "pit"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "__kpit_elapsed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "82-104",
          "snippet": "static s64 __kpit_elapsed(struct kvm_pit *pit)\n{\n\ts64 elapsed;\n\tktime_t remaining;\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tif (!ps->period)\n\t\treturn 0;\n\n\t/*\n\t * The Counter does not stop when it reaches zero. In\n\t * Modes 0, 1, 4, and 5 the Counter ``wraps around'' to\n\t * the highest count, either FFFF hex for binary counting\n\t * or 9999 for BCD counting, and continues counting.\n\t * Modes 2 and 3 are periodic; the Counter reloads\n\t * itself with the initial count and continues counting\n\t * from there.\n\t */\n\tremaining = hrtimer_get_remaining(&ps->timer);\n\telapsed = ps->period - ktime_to_ns(remaining);\n\n\treturn elapsed;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic s64 __kpit_elapsed(struct kvm_pit *pit)\n{\n\ts64 elapsed;\n\tktime_t remaining;\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tif (!ps->period)\n\t\treturn 0;\n\n\t/*\n\t * The Counter does not stop when it reaches zero. In\n\t * Modes 0, 1, 4, and 5 the Counter ``wraps around'' to\n\t * the highest count, either FFFF hex for binary counting\n\t * or 9999 for BCD counting, and continues counting.\n\t * Modes 2 and 3 are periodic; the Counter reloads\n\t * itself with the initial count and continues counting\n\t * from there.\n\t */\n\tremaining = hrtimer_get_remaining(&ps->timer);\n\telapsed = ps->period - ktime_to_ns(remaining);\n\n\treturn elapsed;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic s64 kpit_elapsed(struct kvm_pit *pit, struct kvm_kpit_channel_state *c,\n\t\t\tint channel)\n{\n\tif (channel == 0)\n\t\treturn __kpit_elapsed(pit);\n\n\treturn ktime_to_ns(ktime_sub(ktime_get(), c->count_load_time));\n}"
  },
  {
    "function_name": "__kpit_elapsed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "82-104",
    "snippet": "static s64 __kpit_elapsed(struct kvm_pit *pit)\n{\n\ts64 elapsed;\n\tktime_t remaining;\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tif (!ps->period)\n\t\treturn 0;\n\n\t/*\n\t * The Counter does not stop when it reaches zero. In\n\t * Modes 0, 1, 4, and 5 the Counter ``wraps around'' to\n\t * the highest count, either FFFF hex for binary counting\n\t * or 9999 for BCD counting, and continues counting.\n\t * Modes 2 and 3 are periodic; the Counter reloads\n\t * itself with the initial count and continues counting\n\t * from there.\n\t */\n\tremaining = hrtimer_get_remaining(&ps->timer);\n\telapsed = ps->period - ktime_to_ns(remaining);\n\n\treturn elapsed;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "remaining"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_remaining",
          "args": [
            "&ps->timer"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic s64 __kpit_elapsed(struct kvm_pit *pit)\n{\n\ts64 elapsed;\n\tktime_t remaining;\n\tstruct kvm_kpit_state *ps = &pit->pit_state;\n\n\tif (!ps->period)\n\t\treturn 0;\n\n\t/*\n\t * The Counter does not stop when it reaches zero. In\n\t * Modes 0, 1, 4, and 5 the Counter ``wraps around'' to\n\t * the highest count, either FFFF hex for binary counting\n\t * or 9999 for BCD counting, and continues counting.\n\t * Modes 2 and 3 are periodic; the Counter reloads\n\t * itself with the initial count and continues counting\n\t * from there.\n\t */\n\tremaining = hrtimer_get_remaining(&ps->timer);\n\telapsed = ps->period - ktime_to_ns(remaining);\n\n\treturn elapsed;\n}"
  },
  {
    "function_name": "pit_get_gate",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "77-80",
    "snippet": "static int pit_get_gate(struct kvm_pit *pit, int channel)\n{\n\treturn pit->pit_state.channels[channel].gate;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic int pit_get_gate(struct kvm_pit *pit, int channel)\n{\n\treturn pit->pit_state.channels[channel].gate;\n}"
  },
  {
    "function_name": "pit_set_gate",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
    "lines": "54-75",
    "snippet": "static void pit_set_gate(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\tcase 4:\n\t\t/* XXX: just disable/enable counting */\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 5:\n\t\t/* Restart counting on rising edge. */\n\t\tif (c->gate < val)\n\t\t\tc->count_load_time = ktime_get();\n\t\tbreak;\n\t}\n\n\tc->gate = val;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include \"ioapic.h\"",
      "#include <linux/slab.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nstatic void pit_set_gate(struct kvm_pit *pit, int channel, u32 val)\n{\n\tstruct kvm_kpit_channel_state *c = &pit->pit_state.channels[channel];\n\n\tswitch (c->mode) {\n\tdefault:\n\tcase 0:\n\tcase 4:\n\t\t/* XXX: just disable/enable counting */\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\tcase 5:\n\t\t/* Restart counting on rising edge. */\n\t\tif (c->gate < val)\n\t\t\tc->count_load_time = ktime_get();\n\t\tbreak;\n\t}\n\n\tc->gate = val;\n}"
  }
]