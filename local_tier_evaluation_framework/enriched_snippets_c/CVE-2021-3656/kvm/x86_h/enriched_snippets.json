[
  {
    "function_name": "kvm_dr7_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "352-356",
    "snippet": "static inline bool kvm_dr7_valid(u64 data)\n{\n\t/* Bits [63:32] are reserved */\n\treturn !(data >> 32);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_dr7_valid(u64 data)\n{\n\t/* Bits [63:32] are reserved */\n\treturn !(data >> 32);\n}"
  },
  {
    "function_name": "kvm_pat_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "344-350",
    "snippet": "static inline bool kvm_pat_valid(u64 data)\n{\n\tif (data & 0xF8F8F8F8F8F8F8F8ull)\n\t\treturn false;\n\t/* 0, 1, 4, 5, 6, 7 are valid values.  */\n\treturn (data | ((data & 0x0202020202020202ull) << 1)) == data;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_pat_valid(u64 data)\n{\n\tif (data & 0xF8F8F8F8F8F8F8F8ull)\n\t\treturn false;\n\t/* 0, 1, 4, 5, 6, 7 are valid values.  */\n\treturn (data | ((data & 0x0202020202020202ull) << 1)) == data;\n}"
  },
  {
    "function_name": "kvm_after_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "338-341",
    "snippet": "static inline void kvm_after_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_vcpu",
            "NULL"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_after_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}"
  },
  {
    "function_name": "kvm_before_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "333-336",
    "snippet": "static inline void kvm_before_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_vcpu",
            "vcpu"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_before_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}"
  },
  {
    "function_name": "kvm_cstate_in_guest",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "326-329",
    "snippet": "static inline bool kvm_cstate_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.cstate_in_guest;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_cstate_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.cstate_in_guest;\n}"
  },
  {
    "function_name": "kvm_pause_in_guest",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "321-324",
    "snippet": "static inline bool kvm_pause_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.pause_in_guest;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_pause_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.pause_in_guest;\n}"
  },
  {
    "function_name": "kvm_hlt_in_guest",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "316-319",
    "snippet": "static inline bool kvm_hlt_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.hlt_in_guest;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_hlt_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.hlt_in_guest;\n}"
  },
  {
    "function_name": "kvm_mwait_in_guest",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "311-314",
    "snippet": "static inline bool kvm_mwait_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.mwait_in_guest;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_mwait_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.mwait_in_guest;\n}"
  },
  {
    "function_name": "nsec_to_cycles",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "291-295",
    "snippet": "static inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pvclock_scale_delta",
          "args": [
            "nsec",
            "vcpu->arch.virtual_tsc_mult",
            "vcpu->arch.virtual_tsc_shift"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}"
  },
  {
    "function_name": "kvm_mpx_supported",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "277-281",
    "snippet": "static inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}"
  },
  {
    "function_name": "kvm_vcpu_latch_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "238-241",
    "snippet": "static inline bool kvm_vcpu_latch_init(struct kvm_vcpu *vcpu)\n{\n\treturn is_smm(vcpu) || kvm_x86_ops.apic_init_signal_blocked(vcpu);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops.apic_init_signal_blocked",
          "args": [
            "vcpu"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_smm",
          "args": [
            "vcpu"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "is_smm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "175-178",
          "snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_vcpu_latch_init(struct kvm_vcpu *vcpu)\n{\n\treturn is_smm(vcpu) || kvm_x86_ops.apic_init_signal_blocked(vcpu);\n}"
  },
  {
    "function_name": "kvm_check_has_quirk",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "233-236",
    "snippet": "static inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}"
  },
  {
    "function_name": "kvm_register_writel",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "225-231",
    "snippet": "static inline void kvm_register_writel(struct kvm_vcpu *vcpu,\n\t\t\t\t       int reg, unsigned long val)\n{\n\tif (!is_64_bit_mode(vcpu))\n\t\tval = (u32)val;\n\treturn kvm_register_write(vcpu, reg, val);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "vcpu",
            "reg",
            "val"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "225-231",
          "snippet": "static inline void kvm_register_writel(struct kvm_vcpu *vcpu,\n\t\t\t\t       int reg, unsigned long val)\n{\n\tif (!is_64_bit_mode(vcpu))\n\t\tval = (u32)val;\n\treturn kvm_register_write(vcpu, reg, val);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "is_64_bit_mode",
          "args": [
            "vcpu"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "is_64_bit_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "94-102",
          "snippet": "static inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_writel(struct kvm_vcpu *vcpu,\n\t\t\t\t       int reg, unsigned long val)\n{\n\tif (!is_64_bit_mode(vcpu))\n\t\tval = (u32)val;\n\treturn kvm_register_write(vcpu, reg, val);\n}"
  },
  {
    "function_name": "kvm_register_readl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "218-223",
    "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu, int reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_64_bit_mode",
          "args": [
            "vcpu"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "is_64_bit_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "94-102",
          "snippet": "static inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "vcpu",
            "reg"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "218-223",
          "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu, int reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu, int reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}"
  },
  {
    "function_name": "vcpu_match_mmio_gpa",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "209-216",
    "snippet": "static inline bool vcpu_match_mmio_gpa(struct kvm_vcpu *vcpu, gpa_t gpa)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gfn &&\n\t      vcpu->arch.mmio_gfn == gpa >> PAGE_SHIFT)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_match_mmio_gen",
          "args": [
            "vcpu"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_match_mmio_gen",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "181-184",
          "snippet": "static inline bool vcpu_match_mmio_gen(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.mmio_gen == kvm_memslots(vcpu->kvm)->generation;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool vcpu_match_mmio_gen(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.mmio_gen == kvm_memslots(vcpu->kvm)->generation;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool vcpu_match_mmio_gpa(struct kvm_vcpu *vcpu, gpa_t gpa)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gfn &&\n\t      vcpu->arch.mmio_gfn == gpa >> PAGE_SHIFT)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "vcpu_match_mmio_gva",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "200-207",
    "snippet": "static inline bool vcpu_match_mmio_gva(struct kvm_vcpu *vcpu, unsigned long gva)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gva &&\n\t      vcpu->arch.mmio_gva == (gva & PAGE_MASK))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_match_mmio_gen",
          "args": [
            "vcpu"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_match_mmio_gen",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "181-184",
          "snippet": "static inline bool vcpu_match_mmio_gen(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.mmio_gen == kvm_memslots(vcpu->kvm)->generation;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool vcpu_match_mmio_gen(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.mmio_gen == kvm_memslots(vcpu->kvm)->generation;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool vcpu_match_mmio_gva(struct kvm_vcpu *vcpu, unsigned long gva)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gva &&\n\t      vcpu->arch.mmio_gva == (gva & PAGE_MASK))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "vcpu_clear_mmio_info",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "192-198",
    "snippet": "static inline void vcpu_clear_mmio_info(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tif (gva != MMIO_GVA_ANY && vcpu->arch.mmio_gva != (gva & PAGE_MASK))\n\t\treturn;\n\n\tvcpu->arch.mmio_gva = 0;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MMIO_GVA_ANY (~(gva_t)0)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\n#define MMIO_GVA_ANY (~(gva_t)0)\n\nstatic inline void vcpu_clear_mmio_info(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tif (gva != MMIO_GVA_ANY && vcpu->arch.mmio_gva != (gva & PAGE_MASK))\n\t\treturn;\n\n\tvcpu->arch.mmio_gva = 0;\n}"
  },
  {
    "function_name": "vcpu_match_mmio_gen",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "181-184",
    "snippet": "static inline bool vcpu_match_mmio_gen(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.mmio_gen == kvm_memslots(vcpu->kvm)->generation;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_memslots",
          "args": [
            "vcpu->kvm"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool vcpu_match_mmio_gen(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.mmio_gen == kvm_memslots(vcpu->kvm)->generation;\n}"
  },
  {
    "function_name": "vcpu_cache_mmio_info",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "163-179",
    "snippet": "static inline void vcpu_cache_mmio_info(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgva_t gva, gfn_t gfn, unsigned access)\n{\n\tu64 gen = kvm_memslots(vcpu->kvm)->generation;\n\n\tif (unlikely(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS))\n\t\treturn;\n\n\t/*\n\t * If this is a shadow nested page table, the \"GVA\" is\n\t * actually a nGPA.\n\t */\n\tvcpu->arch.mmio_gva = mmu_is_nested(vcpu) ? 0 : gva & PAGE_MASK;\n\tvcpu->arch.mmio_access = access;\n\tvcpu->arch.mmio_gfn = gfn;\n\tvcpu->arch.mmio_gen = gen;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_is_nested",
          "args": [
            "vcpu"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_is_nested",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "123-126",
          "snippet": "static inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots",
          "args": [
            "vcpu->kvm"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void vcpu_cache_mmio_info(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgva_t gva, gfn_t gfn, unsigned access)\n{\n\tu64 gen = kvm_memslots(vcpu->kvm)->generation;\n\n\tif (unlikely(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS))\n\t\treturn;\n\n\t/*\n\t * If this is a shadow nested page table, the \"GVA\" is\n\t * actually a nGPA.\n\t */\n\tvcpu->arch.mmio_gva = mmu_is_nested(vcpu) ? 0 : gva & PAGE_MASK;\n\tvcpu->arch.mmio_access = access;\n\tvcpu->arch.mmio_gfn = gfn;\n\tvcpu->arch.mmio_gen = gen;\n}"
  },
  {
    "function_name": "is_noncanonical_address",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "158-161",
    "snippet": "static inline bool is_noncanonical_address(u64 la, struct kvm_vcpu *vcpu)\n{\n\treturn get_canonical(la, vcpu_virt_addr_bits(vcpu)) != la;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_canonical",
          "args": [
            "la",
            "vcpu_virt_addr_bits(vcpu)"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "get_canonical",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "153-156",
          "snippet": "static inline u64 get_canonical(u64 la, u8 vaddr_bits)\n{\n\treturn ((int64_t)la << (64 - vaddr_bits)) >> (64 - vaddr_bits);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline u64 get_canonical(u64 la, u8 vaddr_bits)\n{\n\treturn ((int64_t)la << (64 - vaddr_bits)) >> (64 - vaddr_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_virt_addr_bits",
          "args": [
            "vcpu"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_virt_addr_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "148-151",
          "snippet": "static inline u8 vcpu_virt_addr_bits(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_LA57) ? 57 : 48;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline u8 vcpu_virt_addr_bits(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_LA57) ? 57 : 48;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_noncanonical_address(u64 la, struct kvm_vcpu *vcpu)\n{\n\treturn get_canonical(la, vcpu_virt_addr_bits(vcpu)) != la;\n}"
  },
  {
    "function_name": "get_canonical",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "153-156",
    "snippet": "static inline u64 get_canonical(u64 la, u8 vaddr_bits)\n{\n\treturn ((int64_t)la << (64 - vaddr_bits)) >> (64 - vaddr_bits);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline u64 get_canonical(u64 la, u8 vaddr_bits)\n{\n\treturn ((int64_t)la << (64 - vaddr_bits)) >> (64 - vaddr_bits);\n}"
  },
  {
    "function_name": "vcpu_virt_addr_bits",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "148-151",
    "snippet": "static inline u8 vcpu_virt_addr_bits(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_LA57) ? 57 : 48;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_LA57"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "129-135",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline u8 vcpu_virt_addr_bits(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_LA57) ? 57 : 48;\n}"
  },
  {
    "function_name": "is_pae_paging",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "143-146",
    "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "143-146",
          "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "85-92",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}"
  },
  {
    "function_name": "is_paging",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "138-141",
    "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "kvm_read_cr0_bits(vcpu, X86_CR0_PG)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0_bits",
          "args": [
            "vcpu",
            "X86_CR0_PG"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "116-122",
          "snippet": "static inline ulong kvm_read_cr0_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR0_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr0_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr0_guest_bits(vcpu);\n\treturn vcpu->arch.cr0 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR0_GUEST_BITS X86_CR0_TS"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR0_GUEST_BITS X86_CR0_TS\n\nstatic inline ulong kvm_read_cr0_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR0_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr0_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr0_guest_bits(vcpu);\n\treturn vcpu->arch.cr0 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
  },
  {
    "function_name": "is_pse",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "133-136",
    "snippet": "static inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_PSE"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "129-135",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}"
  },
  {
    "function_name": "is_pae",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "128-131",
    "snippet": "static inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_PAE"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "129-135",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_pae(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PAE);\n}"
  },
  {
    "function_name": "mmu_is_nested",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "123-126",
    "snippet": "static inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}"
  },
  {
    "function_name": "x86_exception_has_error_code",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "114-121",
    "snippet": "static inline bool x86_exception_has_error_code(unsigned int vector)\n{\n\tstatic u32 exception_has_error_code = BIT(DF_VECTOR) | BIT(TS_VECTOR) |\n\t\t\tBIT(NP_VECTOR) | BIT(SS_VECTOR) | BIT(GP_VECTOR) |\n\t\t\tBIT(PF_VECTOR) | BIT(AC_VECTOR);\n\n\treturn (1U << vector) & exception_has_error_code;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "AC_VECTOR"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "PF_VECTOR"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "GP_VECTOR"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "SS_VECTOR"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "NP_VECTOR"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "TS_VECTOR"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "DF_VECTOR"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool x86_exception_has_error_code(unsigned int vector)\n{\n\tstatic u32 exception_has_error_code = BIT(DF_VECTOR) | BIT(TS_VECTOR) |\n\t\t\tBIT(NP_VECTOR) | BIT(SS_VECTOR) | BIT(GP_VECTOR) |\n\t\t\tBIT(PF_VECTOR) | BIT(AC_VECTOR);\n\n\treturn (1U << vector) & exception_has_error_code;\n}"
  },
  {
    "function_name": "is_la57_mode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "104-112",
    "snippet": "static inline bool is_la57_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn (vcpu->arch.efer & EFER_LMA) &&\n\t\t kvm_read_cr4_bits(vcpu, X86_CR4_LA57);\n#else\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_LA57"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "129-135",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_la57_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn (vcpu->arch.efer & EFER_LMA) &&\n\t\t kvm_read_cr4_bits(vcpu, X86_CR4_LA57);\n#else\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "is_64_bit_mode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "94-102",
    "snippet": "static inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops.get_cs_db_l_bits",
          "args": [
            "vcpu",
            "&cs_db",
            "&cs_l"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "85-92",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}"
  },
  {
    "function_name": "is_long_mode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "85-92",
    "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "is_protmode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "80-83",
    "snippet": "static inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_cr0_bits",
          "args": [
            "vcpu",
            "X86_CR0_PE"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "116-122",
          "snippet": "static inline ulong kvm_read_cr0_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR0_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr0_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr0_guest_bits(vcpu);\n\treturn vcpu->arch.cr0 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR0_GUEST_BITS X86_CR0_TS"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR0_GUEST_BITS X86_CR0_TS\n\nstatic inline ulong kvm_read_cr0_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR0_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr0_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr0_guest_bits(vcpu);\n\treturn vcpu->arch.cr0 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}"
  },
  {
    "function_name": "kvm_exception_is_soft",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "75-78",
    "snippet": "static inline bool kvm_exception_is_soft(unsigned int nr)\n{\n\treturn (nr == BP_VECTOR) || (nr == OF_VECTOR);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_exception_is_soft(unsigned int nr)\n{\n\treturn (nr == BP_VECTOR) || (nr == OF_VECTOR);\n}"
  },
  {
    "function_name": "kvm_event_needs_reinjection",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "69-73",
    "snippet": "static inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.injected || vcpu->arch.interrupt.injected ||\n\t\tvcpu->arch.nmi_injected;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.injected || vcpu->arch.interrupt.injected ||\n\t\tvcpu->arch.nmi_injected;\n}"
  },
  {
    "function_name": "kvm_clear_interrupt_queue",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "64-67",
    "snippet": "static inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.injected = false;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.injected = false;\n}"
  },
  {
    "function_name": "kvm_queue_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "56-62",
    "snippet": "static inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.injected = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.injected = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}"
  },
  {
    "function_name": "kvm_clear_exception_queue",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "50-54",
    "snippet": "static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n\tvcpu->arch.exception.injected = false;\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n\tvcpu->arch.exception.injected = false;\n}"
  },
  {
    "function_name": "__shrink_ple_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "34-46",
    "snippet": "static inline unsigned int __shrink_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int min)\n{\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tval /= modifier;\n\telse\n\t\tval -= modifier;\n\n\treturn max(val, min);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "val",
            "min"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline unsigned int __shrink_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int min)\n{\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tval /= modifier;\n\telse\n\t\tval -= modifier;\n\n\treturn max(val, min);\n}"
  },
  {
    "function_name": "__grow_ple_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
    "lines": "18-32",
    "snippet": "static inline unsigned int __grow_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int max)\n{\n\tu64 ret = val;\n\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tret *= modifier;\n\telse\n\t\tret += modifier;\n\n\treturn min(ret, (u64)max);\n}",
    "includes": [
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <asm/pvclock.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "ret",
            "(u64)max"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline unsigned int __grow_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int max)\n{\n\tu64 ret = val;\n\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tret *= modifier;\n\telse\n\t\tret += modifier;\n\n\treturn min(ret, (u64)max);\n}"
  }
]