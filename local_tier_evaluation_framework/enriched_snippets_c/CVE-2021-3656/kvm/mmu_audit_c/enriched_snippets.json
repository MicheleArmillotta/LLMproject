[
  {
    "function_name": "mmu_audit_set",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "275-296",
    "snippet": "static int mmu_audit_set(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tunsigned long enable;\n\n\tret = kstrtoul(val, 10, &enable);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tswitch (enable) {\n\tcase 0:\n\t\tmmu_audit_disable();\n\t\tbreak;\n\tcase 1:\n\t\tmmu_audit_enable();\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_audit_enable",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_audit_enable",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "257-264",
          "snippet": "static void mmu_audit_enable(void)\n{\n\tif (mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_inc(&mmu_audit_key);\n\tmmu_audit = true;\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool mmu_audit;",
            "static struct static_key mmu_audit_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic bool mmu_audit;\nstatic struct static_key mmu_audit_key;\n\nstatic void mmu_audit_enable(void)\n{\n\tif (mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_inc(&mmu_audit_key);\n\tmmu_audit = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_audit_disable",
          "args": [],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_audit_disable",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "266-273",
          "snippet": "static void mmu_audit_disable(void)\n{\n\tif (!mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_dec(&mmu_audit_key);\n\tmmu_audit = false;\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool mmu_audit;",
            "static struct static_key mmu_audit_key;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic bool mmu_audit;\nstatic struct static_key mmu_audit_key;\n\nstatic void mmu_audit_disable(void)\n{\n\tif (!mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_dec(&mmu_audit_key);\n\tmmu_audit = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "val",
            "10",
            "&enable"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic int mmu_audit_set(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tunsigned long enable;\n\n\tret = kstrtoul(val, 10, &enable);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tswitch (enable) {\n\tcase 0:\n\t\tmmu_audit_disable();\n\t\tbreak;\n\tcase 1:\n\t\tmmu_audit_enable();\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mmu_audit_disable",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "266-273",
    "snippet": "static void mmu_audit_disable(void)\n{\n\tif (!mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_dec(&mmu_audit_key);\n\tmmu_audit = false;\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool mmu_audit;",
      "static struct static_key mmu_audit_key;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_slow_dec",
          "args": [
            "&mmu_audit_key"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic bool mmu_audit;\nstatic struct static_key mmu_audit_key;\n\nstatic void mmu_audit_disable(void)\n{\n\tif (!mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_dec(&mmu_audit_key);\n\tmmu_audit = false;\n}"
  },
  {
    "function_name": "mmu_audit_enable",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "257-264",
    "snippet": "static void mmu_audit_enable(void)\n{\n\tif (mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_inc(&mmu_audit_key);\n\tmmu_audit = true;\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool mmu_audit;",
      "static struct static_key mmu_audit_key;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_slow_inc",
          "args": [
            "&mmu_audit_key"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic bool mmu_audit;\nstatic struct static_key mmu_audit_key;\n\nstatic void mmu_audit_enable(void)\n{\n\tif (mmu_audit)\n\t\treturn;\n\n\tstatic_key_slow_inc(&mmu_audit_key);\n\tmmu_audit = true;\n}"
  },
  {
    "function_name": "kvm_mmu_audit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "251-255",
    "snippet": "static inline void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tif (static_key_false((&mmu_audit_key)))\n\t\t__kvm_mmu_audit(vcpu, point);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct static_key mmu_audit_key;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kvm_mmu_audit",
          "args": [
            "vcpu",
            "point"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_mmu_audit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "239-249",
          "snippet": "static void __kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tvcpu->kvm->arch.audit_point = point;\n\taudit_all_active_sps(vcpu->kvm);\n\taudit_vcpu_spte(vcpu);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void __kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tvcpu->kvm->arch.audit_point = point;\n\taudit_all_active_sps(vcpu->kvm);\n\taudit_vcpu_spte(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_false",
          "args": [
            "(&mmu_audit_key)"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic struct static_key mmu_audit_key;\n\nstatic inline void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tif (static_key_false((&mmu_audit_key)))\n\t\t__kvm_mmu_audit(vcpu, point);\n}"
  },
  {
    "function_name": "__kvm_mmu_audit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "239-249",
    "snippet": "static void __kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tvcpu->kvm->arch.audit_point = point;\n\taudit_all_active_sps(vcpu->kvm);\n\taudit_vcpu_spte(vcpu);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_vcpu_spte",
          "args": [
            "vcpu"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "audit_vcpu_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "231-234",
          "snippet": "static void audit_vcpu_spte(struct kvm_vcpu *vcpu)\n{\n\tmmu_spte_walk(vcpu, audit_spte);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_vcpu_spte(struct kvm_vcpu *vcpu)\n{\n\tmmu_spte_walk(vcpu, audit_spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_all_active_sps",
          "args": [
            "vcpu->kvm"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "audit_all_active_sps",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "219-222",
          "snippet": "static void audit_all_active_sps(struct kvm *kvm)\n{\n\twalk_all_active_sps(kvm, audit_sp);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_all_active_sps(struct kvm *kvm)\n{\n\twalk_all_active_sps(kvm, audit_sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&ratelimit_state"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void __kvm_mmu_audit(struct kvm_vcpu *vcpu, int point)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tvcpu->kvm->arch.audit_point = point;\n\taudit_all_active_sps(vcpu->kvm);\n\taudit_vcpu_spte(vcpu);\n}"
  },
  {
    "function_name": "audit_vcpu_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "231-234",
    "snippet": "static void audit_vcpu_spte(struct kvm_vcpu *vcpu)\n{\n\tmmu_spte_walk(vcpu, audit_spte);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_walk",
          "args": [
            "vcpu",
            "audit_spte"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_walk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "54-81",
          "snippet": "static void mmu_spte_walk(struct kvm_vcpu *vcpu, inspect_spte_fn fn)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\n\t\tsp = page_header(root);\n\t\t__mmu_spte_walk(vcpu, sp, fn, vcpu->arch.mmu->root_level);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t__mmu_spte_walk(vcpu, sp, fn, 2);\n\t\t}\n\t}\n\n\treturn;\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void mmu_spte_walk(struct kvm_vcpu *vcpu, inspect_spte_fn fn)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\n\t\tsp = page_header(root);\n\t\t__mmu_spte_walk(vcpu, sp, fn, vcpu->arch.mmu->root_level);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t__mmu_spte_walk(vcpu, sp, fn, 2);\n\t\t}\n\t}\n\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_vcpu_spte(struct kvm_vcpu *vcpu)\n{\n\tmmu_spte_walk(vcpu, audit_spte);\n}"
  },
  {
    "function_name": "audit_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "224-229",
    "snippet": "static void audit_spte(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\taudit_sptes_have_rmaps(vcpu, sptep, level);\n\taudit_mappings(vcpu, sptep, level);\n\taudit_spte_after_sync(vcpu, sptep, level);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_spte_after_sync",
          "args": [
            "vcpu",
            "sptep",
            "level"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "audit_spte_after_sync",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "166-173",
          "snippet": "static void audit_spte_after_sync(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\tif (vcpu->kvm->arch.audit_point == AUDIT_POST_SYNC && sp->unsync)\n\t\taudit_printk(vcpu->kvm, \"meet unsync sp(%p) after sync \"\n\t\t\t     \"root.\\n\", sp);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_spte_after_sync(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\tif (vcpu->kvm->arch.audit_point == AUDIT_POST_SYNC && sp->unsync)\n\t\taudit_printk(vcpu->kvm, \"meet unsync sp(%p) after sync \"\n\t\t\t     \"root.\\n\", sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_mappings",
          "args": [
            "vcpu",
            "sptep",
            "level"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mappings",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "93-124",
          "snippet": "static void audit_mappings(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\thpa_t hpa;\n\n\tsp = page_header(__pa(sptep));\n\n\tif (sp->unsync) {\n\t\tif (level != PT_PAGE_TABLE_LEVEL) {\n\t\t\taudit_printk(vcpu->kvm, \"unsync sp: %p \"\n\t\t\t\t     \"level = %d\\n\", sp, level);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!is_shadow_present_pte(*sptep) || !is_last_spte(*sptep, level))\n\t\treturn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\tpfn = kvm_vcpu_gfn_to_pfn_atomic(vcpu, gfn);\n\n\tif (is_error_pfn(pfn))\n\t\treturn;\n\n\thpa =  pfn << PAGE_SHIFT;\n\tif ((*sptep & PT64_BASE_ADDR_MASK) != hpa)\n\t\taudit_printk(vcpu->kvm, \"levels %d pfn %llx hpa %llx \"\n\t\t\t     \"ent %llxn\", vcpu->arch.mmu->root_level, pfn,\n\t\t\t     hpa, *sptep);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_mappings(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\thpa_t hpa;\n\n\tsp = page_header(__pa(sptep));\n\n\tif (sp->unsync) {\n\t\tif (level != PT_PAGE_TABLE_LEVEL) {\n\t\t\taudit_printk(vcpu->kvm, \"unsync sp: %p \"\n\t\t\t\t     \"level = %d\\n\", sp, level);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!is_shadow_present_pte(*sptep) || !is_last_spte(*sptep, level))\n\t\treturn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\tpfn = kvm_vcpu_gfn_to_pfn_atomic(vcpu, gfn);\n\n\tif (is_error_pfn(pfn))\n\t\treturn;\n\n\thpa =  pfn << PAGE_SHIFT;\n\tif ((*sptep & PT64_BASE_ADDR_MASK) != hpa)\n\t\taudit_printk(vcpu->kvm, \"levels %d pfn %llx hpa %llx \"\n\t\t\t     \"ent %llxn\", vcpu->arch.mmu->root_level, pfn,\n\t\t\t     hpa, *sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_sptes_have_rmaps",
          "args": [
            "vcpu",
            "sptep",
            "level"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "audit_sptes_have_rmaps",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "160-164",
          "snippet": "static void audit_sptes_have_rmaps(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tif (is_shadow_present_pte(*sptep) && is_last_spte(*sptep, level))\n\t\tinspect_spte_has_rmap(vcpu->kvm, sptep);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_sptes_have_rmaps(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tif (is_shadow_present_pte(*sptep) && is_last_spte(*sptep, level))\n\t\tinspect_spte_has_rmap(vcpu->kvm, sptep);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_spte(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\taudit_sptes_have_rmaps(vcpu, sptep, level);\n\taudit_mappings(vcpu, sptep, level);\n\taudit_spte_after_sync(vcpu, sptep, level);\n}"
  },
  {
    "function_name": "audit_all_active_sps",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "219-222",
    "snippet": "static void audit_all_active_sps(struct kvm *kvm)\n{\n\twalk_all_active_sps(kvm, audit_sp);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_all_active_sps",
          "args": [
            "kvm",
            "audit_sp"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "walk_all_active_sps",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "85-91",
          "snippet": "static void walk_all_active_sps(struct kvm *kvm, sp_handler fn)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tlist_for_each_entry(sp, &kvm->arch.active_mmu_pages, link)\n\t\tfn(kvm, sp);\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void walk_all_active_sps(struct kvm *kvm, sp_handler fn)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tlist_for_each_entry(sp, &kvm->arch.active_mmu_pages, link)\n\t\tfn(kvm, sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_all_active_sps(struct kvm *kvm)\n{\n\twalk_all_active_sps(kvm, audit_sp);\n}"
  },
  {
    "function_name": "audit_sp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "213-217",
    "snippet": "static void audit_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tcheck_mappings_rmap(kvm, sp);\n\taudit_write_protection(kvm, sp);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_write_protection",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "audit_write_protection",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "190-211",
          "snippet": "static void audit_write_protection(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tif (sp->role.direct || sp->unsync || sp->role.invalid)\n\t\treturn;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, sp->gfn);\n\trmap_head = __gfn_to_rmap(sp->gfn, PT_PAGE_TABLE_LEVEL, slot);\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (is_writable_pte(*sptep))\n\t\t\taudit_printk(kvm, \"shadow page has writable \"\n\t\t\t\t     \"mappings: gfn %llx role %x\\n\",\n\t\t\t\t     sp->gfn, sp->role.word);\n\t}\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_write_protection(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tif (sp->role.direct || sp->unsync || sp->role.invalid)\n\t\treturn;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, sp->gfn);\n\trmap_head = __gfn_to_rmap(sp->gfn, PT_PAGE_TABLE_LEVEL, slot);\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (is_writable_pte(*sptep))\n\t\t\taudit_printk(kvm, \"shadow page has writable \"\n\t\t\t\t     \"mappings: gfn %llx role %x\\n\",\n\t\t\t\t     sp->gfn, sp->role.word);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_mappings_rmap",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "check_mappings_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "175-188",
          "snippet": "static void check_mappings_rmap(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tint i;\n\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tif (!is_shadow_present_pte(sp->spt[i]))\n\t\t\tcontinue;\n\n\t\tinspect_spte_has_rmap(kvm, sp->spt + i);\n\t}\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void check_mappings_rmap(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tint i;\n\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tif (!is_shadow_present_pte(sp->spt[i]))\n\t\t\tcontinue;\n\n\t\tinspect_spte_has_rmap(kvm, sp->spt + i);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tcheck_mappings_rmap(kvm, sp);\n\taudit_write_protection(kvm, sp);\n}"
  },
  {
    "function_name": "audit_write_protection",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "190-211",
    "snippet": "static void audit_write_protection(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tif (sp->role.direct || sp->unsync || sp->role.invalid)\n\t\treturn;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, sp->gfn);\n\trmap_head = __gfn_to_rmap(sp->gfn, PT_PAGE_TABLE_LEVEL, slot);\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (is_writable_pte(*sptep))\n\t\t\taudit_printk(kvm, \"shadow page has writable \"\n\t\t\t\t     \"mappings: gfn %llx role %x\\n\",\n\t\t\t\t     sp->gfn, sp->role.word);\n\t}\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "kvm",
            "\"shadow page has writable \"\n\t\t\t\t     \"mappings: gfn %llx role %x\\n\"",
            "sp->gfn",
            "sp->role.word"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "*sptep"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "151-154",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "sp->gfn",
            "PT_PAGE_TABLE_LEVEL",
            "slot"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1395-1402",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_memslot",
          "args": [
            "slots",
            "sp->gfn"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots_for_spte_role",
          "args": [
            "kvm",
            "sp->role"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_write_protection(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tif (sp->role.direct || sp->unsync || sp->role.invalid)\n\t\treturn;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, sp->gfn);\n\trmap_head = __gfn_to_rmap(sp->gfn, PT_PAGE_TABLE_LEVEL, slot);\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tif (is_writable_pte(*sptep))\n\t\t\taudit_printk(kvm, \"shadow page has writable \"\n\t\t\t\t     \"mappings: gfn %llx role %x\\n\",\n\t\t\t\t     sp->gfn, sp->role.word);\n\t}\n}"
  },
  {
    "function_name": "check_mappings_rmap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "175-188",
    "snippet": "static void check_mappings_rmap(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tint i;\n\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tif (!is_shadow_present_pte(sp->spt[i]))\n\t\t\tcontinue;\n\n\t\tinspect_spte_has_rmap(kvm, sp->spt + i);\n\t}\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inspect_spte_has_rmap",
          "args": [
            "kvm",
            "sp->spt + i"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "inspect_spte_has_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "126-158",
          "snippet": "static void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "sp->spt[i]"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void check_mappings_rmap(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tint i;\n\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tif (!is_shadow_present_pte(sp->spt[i]))\n\t\t\tcontinue;\n\n\t\tinspect_spte_has_rmap(kvm, sp->spt + i);\n\t}\n}"
  },
  {
    "function_name": "audit_spte_after_sync",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "166-173",
    "snippet": "static void audit_spte_after_sync(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\tif (vcpu->kvm->arch.audit_point == AUDIT_POST_SYNC && sp->unsync)\n\t\taudit_printk(vcpu->kvm, \"meet unsync sp(%p) after sync \"\n\t\t\t     \"root.\\n\", sp);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "vcpu->kvm",
            "\"meet unsync sp(%p) after sync \"\n\t\t\t     \"root.\\n\"",
            "sp"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_spte_after_sync(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\tif (vcpu->kvm->arch.audit_point == AUDIT_POST_SYNC && sp->unsync)\n\t\taudit_printk(vcpu->kvm, \"meet unsync sp(%p) after sync \"\n\t\t\t     \"root.\\n\", sp);\n}"
  },
  {
    "function_name": "audit_sptes_have_rmaps",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "160-164",
    "snippet": "static void audit_sptes_have_rmaps(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tif (is_shadow_present_pte(*sptep) && is_last_spte(*sptep, level))\n\t\tinspect_spte_has_rmap(vcpu->kvm, sptep);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inspect_spte_has_rmap",
          "args": [
            "vcpu->kvm",
            "sptep"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "inspect_spte_has_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "126-158",
          "snippet": "static void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "*sptep",
            "level"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "621-628",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_sptes_have_rmaps(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tif (is_shadow_present_pte(*sptep) && is_last_spte(*sptep, level))\n\t\tinspect_spte_has_rmap(vcpu->kvm, sptep);\n}"
  },
  {
    "function_name": "inspect_spte_has_rmap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "126-158",
    "snippet": "static void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "kvm",
            "\"no rmap for writable spte %llx\\n\"",
            "*sptep"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&ratelimit_state"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "gfn",
            "rev_sp->role.level",
            "slot"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1395-1402",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "kvm",
            "\"index %ld of sp (gfn=%llx)\\n\"",
            "(long int)(sptep - rev_sp->spt)",
            "rev_sp->gfn"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "kvm",
            "\"no memslot for gfn %llx\\n\"",
            "gfn"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&ratelimit_state"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gfn_to_memslot",
          "args": [
            "slots",
            "gfn"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots_for_spte_role",
          "args": [
            "kvm",
            "rev_sp->role"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "rev_sp",
            "sptep - rev_sp->spt"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1157-1163",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void inspect_spte_has_rmap(struct kvm *kvm, u64 *sptep)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *rev_sp;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\trev_sp = page_header(__pa(sptep));\n\tgfn = kvm_mmu_page_get_gfn(rev_sp, sptep - rev_sp->spt);\n\n\tslots = kvm_memslots_for_spte_role(kvm, rev_sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (!slot) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no memslot for gfn %llx\\n\", gfn);\n\t\taudit_printk(kvm, \"index %ld of sp (gfn=%llx)\\n\",\n\t\t       (long int)(sptep - rev_sp->spt), rev_sp->gfn);\n\t\tdump_stack();\n\t\treturn;\n\t}\n\n\trmap_head = __gfn_to_rmap(gfn, rev_sp->role.level, slot);\n\tif (!rmap_head->val) {\n\t\tif (!__ratelimit(&ratelimit_state))\n\t\t\treturn;\n\t\taudit_printk(kvm, \"no rmap for writable spte %llx\\n\",\n\t\t\t     *sptep);\n\t\tdump_stack();\n\t}\n}"
  },
  {
    "function_name": "audit_mappings",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "93-124",
    "snippet": "static void audit_mappings(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\thpa_t hpa;\n\n\tsp = page_header(__pa(sptep));\n\n\tif (sp->unsync) {\n\t\tif (level != PT_PAGE_TABLE_LEVEL) {\n\t\t\taudit_printk(vcpu->kvm, \"unsync sp: %p \"\n\t\t\t\t     \"level = %d\\n\", sp, level);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!is_shadow_present_pte(*sptep) || !is_last_spte(*sptep, level))\n\t\treturn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\tpfn = kvm_vcpu_gfn_to_pfn_atomic(vcpu, gfn);\n\n\tif (is_error_pfn(pfn))\n\t\treturn;\n\n\thpa =  pfn << PAGE_SHIFT;\n\tif ((*sptep & PT64_BASE_ADDR_MASK) != hpa)\n\t\taudit_printk(vcpu->kvm, \"levels %d pfn %llx hpa %llx \"\n\t\t\t     \"ent %llxn\", vcpu->arch.mmu->root_level, pfn,\n\t\t\t     hpa, *sptep);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "vcpu->kvm",
            "\"levels %d pfn %llx hpa %llx \"\n\t\t\t     \"ent %llxn\"",
            "vcpu->arch.mmu->root_level",
            "pfn",
            "hpa",
            "*sptep"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_pfn",
          "args": [
            "pfn"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_pfn_atomic",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "sp",
            "sptep - sp->spt"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1157-1163",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "*sptep",
            "level"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "621-628",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_printk",
          "args": [
            "vcpu->kvm",
            "\"unsync sp: %p \"\n\t\t\t\t     \"level = %d\\n\"",
            "sp",
            "level"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void audit_mappings(struct kvm_vcpu *vcpu, u64 *sptep, int level)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tkvm_pfn_t pfn;\n\thpa_t hpa;\n\n\tsp = page_header(__pa(sptep));\n\n\tif (sp->unsync) {\n\t\tif (level != PT_PAGE_TABLE_LEVEL) {\n\t\t\taudit_printk(vcpu->kvm, \"unsync sp: %p \"\n\t\t\t\t     \"level = %d\\n\", sp, level);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!is_shadow_present_pte(*sptep) || !is_last_spte(*sptep, level))\n\t\treturn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\tpfn = kvm_vcpu_gfn_to_pfn_atomic(vcpu, gfn);\n\n\tif (is_error_pfn(pfn))\n\t\treturn;\n\n\thpa =  pfn << PAGE_SHIFT;\n\tif ((*sptep & PT64_BASE_ADDR_MASK) != hpa)\n\t\taudit_printk(vcpu->kvm, \"levels %d pfn %llx hpa %llx \"\n\t\t\t     \"ent %llxn\", vcpu->arch.mmu->root_level, pfn,\n\t\t\t     hpa, *sptep);\n}"
  },
  {
    "function_name": "walk_all_active_sps",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "85-91",
    "snippet": "static void walk_all_active_sps(struct kvm *kvm, sp_handler fn)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tlist_for_each_entry(sp, &kvm->arch.active_mmu_pages, link)\n\t\tfn(kvm, sp);\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_del_async_pf_gfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10304-10325",
          "snippet": "static void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic void kvm_del_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tu32 i, j, k;\n\n\ti = j = kvm_async_pf_gfn_slot(vcpu, gfn);\n\twhile (true) {\n\t\tvcpu->arch.apf.gfns[i] = ~0;\n\t\tdo {\n\t\t\tj = kvm_async_pf_next_probe(j);\n\t\t\tif (vcpu->arch.apf.gfns[j] == ~0)\n\t\t\t\treturn;\n\t\t\tk = kvm_async_pf_hash_fn(vcpu->arch.apf.gfns[j]);\n\t\t\t/*\n\t\t\t * k lies cyclically in ]i,j]\n\t\t\t * |    i.k.j |\n\t\t\t * |....j i.k.| or  |.k..j i...|\n\t\t\t */\n\t\t} while ((i <= j) ? (i < k && k <= j) : (i < k || k <= j));\n\t\tvcpu->arch.apf.gfns[i] = vcpu->arch.apf.gfns[j];\n\t\ti = j;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sp",
            "&kvm->arch.active_mmu_pages",
            "link"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void walk_all_active_sps(struct kvm *kvm, sp_handler fn)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tlist_for_each_entry(sp, &kvm->arch.active_mmu_pages, link)\n\t\tfn(kvm, sp);\n}"
  },
  {
    "function_name": "mmu_spte_walk",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "54-81",
    "snippet": "static void mmu_spte_walk(struct kvm_vcpu *vcpu, inspect_spte_fn fn)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\n\t\tsp = page_header(root);\n\t\t__mmu_spte_walk(vcpu, sp, fn, vcpu->arch.mmu->root_level);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t__mmu_spte_walk(vcpu, sp, fn, 2);\n\t\t}\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mmu_spte_walk",
          "args": [
            "vcpu",
            "sp",
            "fn",
            "2"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_spte_walk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "34-52",
          "snippet": "static void __mmu_spte_walk(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    inspect_spte_fn fn, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tu64 *ent = sp->spt;\n\n\t\tfn(vcpu, ent + i, level);\n\n\t\tif (is_shadow_present_pte(ent[i]) &&\n\t\t      !is_last_spte(ent[i], level)) {\n\t\t\tstruct kvm_mmu_page *child;\n\n\t\t\tchild = page_header(ent[i] & PT64_BASE_ADDR_MASK);\n\t\t\t__mmu_spte_walk(vcpu, child, fn, level - 1);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/ratelimit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void __mmu_spte_walk(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    inspect_spte_fn fn, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tu64 *ent = sp->spt;\n\n\t\tfn(vcpu, ent + i, level);\n\n\t\tif (is_shadow_present_pte(ent[i]) &&\n\t\t      !is_last_spte(ent[i], level)) {\n\t\t\tstruct kvm_mmu_page *child;\n\n\t\t\tchild = page_header(ent[i] & PT64_BASE_ADDR_MASK);\n\t\t\t__mmu_spte_walk(vcpu, child, fn, level - 1);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "root"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu->root_hpa"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void mmu_spte_walk(struct kvm_vcpu *vcpu, inspect_spte_fn fn)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\treturn;\n\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\n\t\tsp = page_header(root);\n\t\t__mmu_spte_walk(vcpu, sp, fn, vcpu->arch.mmu->root_level);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\t__mmu_spte_walk(vcpu, sp, fn, 2);\n\t\t}\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "__mmu_spte_walk",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
    "lines": "34-52",
    "snippet": "static void __mmu_spte_walk(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    inspect_spte_fn fn, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tu64 *ent = sp->spt;\n\n\t\tfn(vcpu, ent + i, level);\n\n\t\tif (is_shadow_present_pte(ent[i]) &&\n\t\t      !is_last_spte(ent[i], level)) {\n\t\t\tstruct kvm_mmu_page *child;\n\n\t\t\tchild = page_header(ent[i] & PT64_BASE_ADDR_MASK);\n\t\t\t__mmu_spte_walk(vcpu, child, fn, level - 1);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/ratelimit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mmu_spte_walk",
          "args": [
            "vcpu",
            "child",
            "fn",
            "level - 1"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_spte_walk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu_audit.c",
          "lines": "34-52",
          "snippet": "static void __mmu_spte_walk(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    inspect_spte_fn fn, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tu64 *ent = sp->spt;\n\n\t\tfn(vcpu, ent + i, level);\n\n\t\tif (is_shadow_present_pte(ent[i]) &&\n\t\t      !is_last_spte(ent[i], level)) {\n\t\t\tstruct kvm_mmu_page *child;\n\n\t\t\tchild = page_header(ent[i] & PT64_BASE_ADDR_MASK);\n\t\t\t__mmu_spte_walk(vcpu, child, fn, level - 1);\n\t\t}\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "ent[i] & PT64_BASE_ADDR_MASK"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "ent[i]",
            "level"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "621-628",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "ent[i]"
          ],
          "line": 44
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "vcpu",
            "ent + i",
            "level"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mtrr_check_gfn_range_consistency",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mtrr.c",
          "lines": "695-725",
          "snippet": "bool kvm_mtrr_check_gfn_range_consistency(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\t  int page_num)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\n\tstart = gfn_to_gpa(gfn);\n\tend = gfn_to_gpa(gfn + page_num);\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tif (type == -1) {\n\t\t\ttype = iter.mem_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type != iter.mem_type)\n\t\t\treturn false;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn true;\n\n\tif (!iter.partial_map)\n\t\treturn true;\n\n\tif (type == -1)\n\t\treturn true;\n\n\treturn type == mtrr_default_type(mtrr_state);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nbool kvm_mtrr_check_gfn_range_consistency(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\t  int page_num)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\n\tstart = gfn_to_gpa(gfn);\n\tend = gfn_to_gpa(gfn + page_num);\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tif (type == -1) {\n\t\t\ttype = iter.mem_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type != iter.mem_type)\n\t\t\treturn false;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn true;\n\n\tif (!iter.partial_map)\n\t\treturn true;\n\n\tif (type == -1)\n\t\treturn true;\n\n\treturn type == mtrr_default_type(mtrr_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ratelimit.h>\n\nstatic void __mmu_spte_walk(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    inspect_spte_fn fn, int level)\n{\n\tint i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i) {\n\t\tu64 *ent = sp->spt;\n\n\t\tfn(vcpu, ent + i, level);\n\n\t\tif (is_shadow_present_pte(ent[i]) &&\n\t\t      !is_last_spte(ent[i], level)) {\n\t\t\tstruct kvm_mmu_page *child;\n\n\t\t\tchild = page_header(ent[i] & PT64_BASE_ADDR_MASK);\n\t\t\t__mmu_spte_walk(vcpu, child, fn, level - 1);\n\t\t}\n\t}\n}"
  }
]