[
  {
    "function_name": "kvm_lapic_exit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2817-2821",
    "snippet": "void kvm_lapic_exit(void)\n{\n\tstatic_key_deferred_flush(&apic_hw_disabled);\n\tstatic_key_deferred_flush(&apic_sw_disabled);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct static_key_deferred apic_hw_disabled",
      "struct static_key_deferred apic_sw_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_deferred_flush",
          "args": [
            "&apic_sw_disabled"
          ],
          "line": 2820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_deferred_flush",
          "args": [
            "&apic_hw_disabled"
          ],
          "line": 2819
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_hw_disabled;\nstruct static_key_deferred apic_sw_disabled;\n\nvoid kvm_lapic_exit(void)\n{\n\tstatic_key_deferred_flush(&apic_hw_disabled);\n\tstatic_key_deferred_flush(&apic_sw_disabled);\n}"
  },
  {
    "function_name": "kvm_lapic_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2810-2815",
    "snippet": "void kvm_lapic_init(void)\n{\n\t/* do not patch jump label more than once per second */\n\tjump_label_rate_limit(&apic_hw_disabled, HZ);\n\tjump_label_rate_limit(&apic_sw_disabled, HZ);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct static_key_deferred apic_hw_disabled",
      "struct static_key_deferred apic_sw_disabled"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_label_rate_limit",
          "args": [
            "&apic_sw_disabled",
            "HZ"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_label_rate_limit",
          "args": [
            "&apic_hw_disabled",
            "HZ"
          ],
          "line": 2813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_hw_disabled;\nstruct static_key_deferred apic_sw_disabled;\n\nvoid kvm_lapic_init(void)\n{\n\t/* do not patch jump label more than once per second */\n\tjump_label_rate_limit(&apic_hw_disabled, HZ);\n\tjump_label_rate_limit(&apic_sw_disabled, HZ);\n}"
  },
  {
    "function_name": "kvm_apic_accept_events",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2768-2808",
    "snippet": "void kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while CPU is in specific states\n\t * (SMM, VMX non-root mode, SVM with GIF=0).\n\t * Because a CPU cannot be in these states immediately\n\t * after it has processed an INIT signal (and thus in\n\t * KVM_MP_STATE_INIT_RECEIVED state), just eat SIPIs\n\t * and leave the INIT pending.\n\t */\n\tif (kvm_vcpu_latch_init(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_deliver_sipi_vector",
          "args": [
            "vcpu",
            "sipi_vector"
          ],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_deliver_sipi_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9523-9532",
          "snippet": "void kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_vcpu_deliver_sipi_vector(struct kvm_vcpu *vcpu, u8 vector)\n{\n\tstruct kvm_segment cs;\n\n\tkvm_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs.selector = vector << 8;\n\tcs.base = vector << 12;\n\tkvm_set_segment(vcpu, &cs, VCPU_SREG_CS);\n\tkvm_rip_write(vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_SIPI",
            "&pe"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_is_bsp",
          "args": [
            "apic->vcpu"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_is_bsp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9694-9697",
          "snippet": "bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_reset",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_reset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9451-9521",
          "snippet": "void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tkvm_lapic_reset(vcpu, init_event);\n\n\tvcpu->arch.hflags = 0;\n\n\tvcpu->arch.smi_pending = 0;\n\tvcpu->arch.smi_count = 0;\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = DR6_INIT;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tvcpu->arch.cr2 = 0;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tif (kvm_mpx_supported()) {\n\t\tvoid *mpx_state_buffer;\n\n\t\t/*\n\t\t * To avoid have the INIT path from kvm_apic_has_events() that be\n\t\t * called with loaded FPU and does not let userspace fix the state.\n\t\t */\n\t\tif (init_event)\n\t\t\tkvm_put_guest_fpu(vcpu);\n\t\tmpx_state_buffer = get_xsave_addr(&vcpu->arch.guest_fpu->state.xsave,\n\t\t\t\t\tXFEATURE_BNDREGS);\n\t\tif (mpx_state_buffer)\n\t\t\tmemset(mpx_state_buffer, 0, sizeof(struct mpx_bndreg_state));\n\t\tmpx_state_buffer = get_xsave_addr(&vcpu->arch.guest_fpu->state.xsave,\n\t\t\t\t\tXFEATURE_BNDCSR);\n\t\tif (mpx_state_buffer)\n\t\t\tmemset(mpx_state_buffer, 0, sizeof(struct mpx_bndcsr));\n\t\tif (init_event)\n\t\t\tkvm_load_guest_fpu(vcpu);\n\t}\n\n\tif (!init_event) {\n\t\tkvm_pmu_reset(vcpu);\n\t\tvcpu->arch.smbase = 0x30000;\n\n\t\tvcpu->arch.msr_misc_features_enables = 0;\n\n\t\tvcpu->arch.xcr0 = XFEATURE_MASK_FP;\n\t}\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tvcpu->arch.ia32_xss = 0;\n\n\tkvm_x86_ops.vcpu_reset(vcpu, init_event);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tkvm_lapic_reset(vcpu, init_event);\n\n\tvcpu->arch.hflags = 0;\n\n\tvcpu->arch.smi_pending = 0;\n\tvcpu->arch.smi_count = 0;\n\tatomic_set(&vcpu->arch.nmi_queued, 0);\n\tvcpu->arch.nmi_pending = 0;\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_interrupt_queue(vcpu);\n\tkvm_clear_exception_queue(vcpu);\n\n\tmemset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));\n\tkvm_update_dr0123(vcpu);\n\tvcpu->arch.dr6 = DR6_INIT;\n\tkvm_update_dr6(vcpu);\n\tvcpu->arch.dr7 = DR7_FIXED_1;\n\tkvm_update_dr7(vcpu);\n\n\tvcpu->arch.cr2 = 0;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tvcpu->arch.apf.msr_val = 0;\n\tvcpu->arch.st.msr_val = 0;\n\n\tkvmclock_reset(vcpu);\n\n\tkvm_clear_async_pf_completion_queue(vcpu);\n\tkvm_async_pf_hash_reset(vcpu);\n\tvcpu->arch.apf.halted = false;\n\n\tif (kvm_mpx_supported()) {\n\t\tvoid *mpx_state_buffer;\n\n\t\t/*\n\t\t * To avoid have the INIT path from kvm_apic_has_events() that be\n\t\t * called with loaded FPU and does not let userspace fix the state.\n\t\t */\n\t\tif (init_event)\n\t\t\tkvm_put_guest_fpu(vcpu);\n\t\tmpx_state_buffer = get_xsave_addr(&vcpu->arch.guest_fpu->state.xsave,\n\t\t\t\t\tXFEATURE_BNDREGS);\n\t\tif (mpx_state_buffer)\n\t\t\tmemset(mpx_state_buffer, 0, sizeof(struct mpx_bndreg_state));\n\t\tmpx_state_buffer = get_xsave_addr(&vcpu->arch.guest_fpu->state.xsave,\n\t\t\t\t\tXFEATURE_BNDCSR);\n\t\tif (mpx_state_buffer)\n\t\t\tmemset(mpx_state_buffer, 0, sizeof(struct mpx_bndcsr));\n\t\tif (init_event)\n\t\t\tkvm_load_guest_fpu(vcpu);\n\t}\n\n\tif (!init_event) {\n\t\tkvm_pmu_reset(vcpu);\n\t\tvcpu->arch.smbase = 0x30000;\n\n\t\tvcpu->arch.msr_misc_features_enables = 0;\n\n\t\tvcpu->arch.xcr0 = XFEATURE_MASK_FP;\n\t}\n\n\tmemset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));\n\tvcpu->arch.regs_avail = ~0;\n\tvcpu->arch.regs_dirty = ~0;\n\n\tvcpu->arch.ia32_xss = 0;\n\n\tkvm_x86_ops.vcpu_reset(vcpu, init_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_INIT",
            "&pe"
          ],
          "line": 2793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&apic->pending_events",
            "0"
          ],
          "line": 2792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "KVM_APIC_SIPI",
            "&apic->pending_events"
          ],
          "line": 2788
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "214-222",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_SIPI",
            "&apic->pending_events"
          ],
          "line": 2787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_latch_init",
          "args": [
            "vcpu"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_latch_init",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "238-241",
          "snippet": "static inline bool kvm_vcpu_latch_init(struct kvm_vcpu *vcpu)\n{\n\treturn is_smm(vcpu) || kvm_x86_ops.apic_init_signal_blocked(vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_vcpu_latch_init(struct kvm_vcpu *vcpu)\n{\n\treturn is_smm(vcpu) || kvm_x86_ops.apic_init_signal_blocked(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2774
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_accept_events(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu8 sipi_vector;\n\tunsigned long pe;\n\n\tif (!lapic_in_kernel(vcpu) || !apic->pending_events)\n\t\treturn;\n\n\t/*\n\t * INITs are latched while CPU is in specific states\n\t * (SMM, VMX non-root mode, SVM with GIF=0).\n\t * Because a CPU cannot be in these states immediately\n\t * after it has processed an INIT signal (and thus in\n\t * KVM_MP_STATE_INIT_RECEIVED state), just eat SIPIs\n\t * and leave the INIT pending.\n\t */\n\tif (kvm_vcpu_latch_init(vcpu)) {\n\t\tWARN_ON_ONCE(vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED);\n\t\tif (test_bit(KVM_APIC_SIPI, &apic->pending_events))\n\t\t\tclear_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\treturn;\n\t}\n\n\tpe = xchg(&apic->pending_events, 0);\n\tif (test_bit(KVM_APIC_INIT, &pe)) {\n\t\tkvm_vcpu_reset(vcpu, true);\n\t\tif (kvm_vcpu_is_bsp(apic->vcpu))\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t\telse\n\t\t\tvcpu->arch.mp_state = KVM_MP_STATE_INIT_RECEIVED;\n\t}\n\tif (test_bit(KVM_APIC_SIPI, &pe) &&\n\t    vcpu->arch.mp_state == KVM_MP_STATE_INIT_RECEIVED) {\n\t\t/* evaluate pending_events before reading the vector */\n\t\tsmp_rmb();\n\t\tsipi_vector = apic->sipi_vector;\n\t\tkvm_vcpu_deliver_sipi_vector(vcpu, sipi_vector);\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\t}\n}"
  },
  {
    "function_name": "kvm_lapic_enable_pv_eoi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2747-2766",
    "snippet": "int kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tstruct gfn_to_hva_cache *ghc = &vcpu->arch.pv_eoi.data;\n\tunsigned long new_len;\n\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\n\tif (addr == ghc->gpa && len <= ghc->len)\n\t\tnew_len = ghc->len;\n\telse\n\t\tnew_len = len;\n\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc, addr, new_len);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_gfn_to_hva_cache_init",
          "args": [
            "vcpu->kvm",
            "ghc",
            "addr",
            "new_len"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_eoi_enabled",
          "args": [
            "vcpu"
          ],
          "line": 2757
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "637-640",
          "snippet": "static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "addr",
            "4"
          ],
          "line": 2753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tstruct gfn_to_hva_cache *ghc = &vcpu->arch.pv_eoi.data;\n\tunsigned long new_len;\n\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\n\tif (addr == ghc->gpa && len <= ghc->len)\n\t\tnew_len = ghc->len;\n\telse\n\t\tnew_len = len;\n\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc, addr, new_len);\n}"
  },
  {
    "function_name": "kvm_hv_vapic_msr_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2729-2745",
    "snippet": "int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_read",
          "args": [
            "apic",
            "APIC_ICR2",
            "4",
            "&high"
          ],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1347-1400",
          "snippet": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tu64 valid_reg_mask =\n\t\tAPIC_REG_MASK(APIC_ID) |\n\t\tAPIC_REG_MASK(APIC_LVR) |\n\t\tAPIC_REG_MASK(APIC_TASKPRI) |\n\t\tAPIC_REG_MASK(APIC_PROCPRI) |\n\t\tAPIC_REG_MASK(APIC_LDR) |\n\t\tAPIC_REG_MASK(APIC_DFR) |\n\t\tAPIC_REG_MASK(APIC_SPIV) |\n\t\tAPIC_REGS_MASK(APIC_ISR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_TMR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_IRR, APIC_ISR_NR) |\n\t\tAPIC_REG_MASK(APIC_ESR) |\n\t\tAPIC_REG_MASK(APIC_ICR) |\n\t\tAPIC_REG_MASK(APIC_ICR2) |\n\t\tAPIC_REG_MASK(APIC_LVTT) |\n\t\tAPIC_REG_MASK(APIC_LVTTHMR) |\n\t\tAPIC_REG_MASK(APIC_LVTPC) |\n\t\tAPIC_REG_MASK(APIC_LVT0) |\n\t\tAPIC_REG_MASK(APIC_LVT1) |\n\t\tAPIC_REG_MASK(APIC_LVTERR) |\n\t\tAPIC_REG_MASK(APIC_TMICT) |\n\t\tAPIC_REG_MASK(APIC_TMCCT) |\n\t\tAPIC_REG_MASK(APIC_TDCR);\n\n\t/* ARBPRI is not valid on x2APIC */\n\tif (!apic_x2apic_mode(apic))\n\t\tvalid_reg_mask |= APIC_REG_MASK(APIC_ARBPRI);\n\n\tif (offset > 0x3f0 || !(valid_reg_mask & APIC_REG_MASK(offset)))\n\t\treturn 1;\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tu64 valid_reg_mask =\n\t\tAPIC_REG_MASK(APIC_ID) |\n\t\tAPIC_REG_MASK(APIC_LVR) |\n\t\tAPIC_REG_MASK(APIC_TASKPRI) |\n\t\tAPIC_REG_MASK(APIC_PROCPRI) |\n\t\tAPIC_REG_MASK(APIC_LDR) |\n\t\tAPIC_REG_MASK(APIC_DFR) |\n\t\tAPIC_REG_MASK(APIC_SPIV) |\n\t\tAPIC_REGS_MASK(APIC_ISR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_TMR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_IRR, APIC_ISR_NR) |\n\t\tAPIC_REG_MASK(APIC_ESR) |\n\t\tAPIC_REG_MASK(APIC_ICR) |\n\t\tAPIC_REG_MASK(APIC_ICR2) |\n\t\tAPIC_REG_MASK(APIC_LVTT) |\n\t\tAPIC_REG_MASK(APIC_LVTTHMR) |\n\t\tAPIC_REG_MASK(APIC_LVTPC) |\n\t\tAPIC_REG_MASK(APIC_LVT0) |\n\t\tAPIC_REG_MASK(APIC_LVT1) |\n\t\tAPIC_REG_MASK(APIC_LVTERR) |\n\t\tAPIC_REG_MASK(APIC_TMICT) |\n\t\tAPIC_REG_MASK(APIC_TMCCT) |\n\t\tAPIC_REG_MASK(APIC_TDCR);\n\n\t/* ARBPRI is not valid on x2APIC */\n\tif (!apic_x2apic_mode(apic))\n\t\tvalid_reg_mask |= APIC_REG_MASK(APIC_ARBPRI);\n\n\tif (offset > 0x3f0 || !(valid_reg_mask & APIC_REG_MASK(offset)))\n\t\treturn 1;\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2734
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_vapic_msr_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2716-2727",
    "snippet": "int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "reg",
            "(u32)data"
          ],
          "line": 2726
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1902-2044",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data >> 32"
          ],
          "line": 2725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}"
  },
  {
    "function_name": "kvm_x2apic_msr_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2695-2714",
    "snippet": "int kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4, low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_DFR || reg == APIC_ICR2)\n\t\treturn 1;\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_read",
          "args": [
            "apic",
            "APIC_ICR2",
            "4",
            "&high"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1347-1400",
          "snippet": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tu64 valid_reg_mask =\n\t\tAPIC_REG_MASK(APIC_ID) |\n\t\tAPIC_REG_MASK(APIC_LVR) |\n\t\tAPIC_REG_MASK(APIC_TASKPRI) |\n\t\tAPIC_REG_MASK(APIC_PROCPRI) |\n\t\tAPIC_REG_MASK(APIC_LDR) |\n\t\tAPIC_REG_MASK(APIC_DFR) |\n\t\tAPIC_REG_MASK(APIC_SPIV) |\n\t\tAPIC_REGS_MASK(APIC_ISR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_TMR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_IRR, APIC_ISR_NR) |\n\t\tAPIC_REG_MASK(APIC_ESR) |\n\t\tAPIC_REG_MASK(APIC_ICR) |\n\t\tAPIC_REG_MASK(APIC_ICR2) |\n\t\tAPIC_REG_MASK(APIC_LVTT) |\n\t\tAPIC_REG_MASK(APIC_LVTTHMR) |\n\t\tAPIC_REG_MASK(APIC_LVTPC) |\n\t\tAPIC_REG_MASK(APIC_LVT0) |\n\t\tAPIC_REG_MASK(APIC_LVT1) |\n\t\tAPIC_REG_MASK(APIC_LVTERR) |\n\t\tAPIC_REG_MASK(APIC_TMICT) |\n\t\tAPIC_REG_MASK(APIC_TMCCT) |\n\t\tAPIC_REG_MASK(APIC_TDCR);\n\n\t/* ARBPRI is not valid on x2APIC */\n\tif (!apic_x2apic_mode(apic))\n\t\tvalid_reg_mask |= APIC_REG_MASK(APIC_ARBPRI);\n\n\tif (offset > 0x3f0 || !(valid_reg_mask & APIC_REG_MASK(offset)))\n\t\treturn 1;\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tu64 valid_reg_mask =\n\t\tAPIC_REG_MASK(APIC_ID) |\n\t\tAPIC_REG_MASK(APIC_LVR) |\n\t\tAPIC_REG_MASK(APIC_TASKPRI) |\n\t\tAPIC_REG_MASK(APIC_PROCPRI) |\n\t\tAPIC_REG_MASK(APIC_LDR) |\n\t\tAPIC_REG_MASK(APIC_DFR) |\n\t\tAPIC_REG_MASK(APIC_SPIV) |\n\t\tAPIC_REGS_MASK(APIC_ISR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_TMR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_IRR, APIC_ISR_NR) |\n\t\tAPIC_REG_MASK(APIC_ESR) |\n\t\tAPIC_REG_MASK(APIC_ICR) |\n\t\tAPIC_REG_MASK(APIC_ICR2) |\n\t\tAPIC_REG_MASK(APIC_LVTT) |\n\t\tAPIC_REG_MASK(APIC_LVTTHMR) |\n\t\tAPIC_REG_MASK(APIC_LVTPC) |\n\t\tAPIC_REG_MASK(APIC_LVT0) |\n\t\tAPIC_REG_MASK(APIC_LVT1) |\n\t\tAPIC_REG_MASK(APIC_LVTERR) |\n\t\tAPIC_REG_MASK(APIC_TMICT) |\n\t\tAPIC_REG_MASK(APIC_TMCCT) |\n\t\tAPIC_REG_MASK(APIC_TDCR);\n\n\t/* ARBPRI is not valid on x2APIC */\n\tif (!apic_x2apic_mode(apic))\n\t\tvalid_reg_mask |= APIC_REG_MASK(APIC_ARBPRI);\n\n\tif (offset > 0x3f0 || !(valid_reg_mask & APIC_REG_MASK(offset)))\n\t\treturn 1;\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2700
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_x2apic_msr_read(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4, low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_DFR || reg == APIC_ICR2)\n\t\treturn 1;\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_x2apic_msr_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2678-2693",
    "snippet": "int kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_ICR2)\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "reg",
            "(u32)data"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1902-2044",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "data >> 32"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_x2apic_msr_write(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = (msr - APIC_BASE_MSR) << 4;\n\n\tif (!lapic_in_kernel(vcpu) || !apic_x2apic_mode(apic))\n\t\treturn 1;\n\n\tif (reg == APIC_ICR2)\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}"
  },
  {
    "function_name": "kvm_lapic_set_vapic_addr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2662-2676",
    "snippet": "int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "KVM_APIC_CHECK_VAPIC",
            "&vcpu->arch.apic_attention"
          ],
          "line": 2671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "KVM_APIC_CHECK_VAPIC",
            "&vcpu->arch.apic_attention"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_gfn_to_hva_cache_init",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.apic->vapic_cache",
            "vapic_addr",
            "sizeof(u32)"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_lapic_sync_to_vapic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2638-2660",
    "snippet": "void kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_write_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.apic->vapic_cache",
            "&data",
            "sizeof(u32)"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_isr",
          "args": [
            "apic"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "apic_find_highest_isr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "504-521",
          "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_find_highest_irr",
          "args": [
            "apic"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "548-556",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TASKPRI"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_CHECK_VAPIC",
            "&vcpu->arch.apic_attention"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_sync_pv_eoi_to_guest",
          "args": [
            "vcpu",
            "apic"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "apic_sync_pv_eoi_to_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2618-2636",
          "snippet": "static void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_sync_to_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data, tpr;\n\tint max_irr, max_isr;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_sync_pv_eoi_to_guest(vcpu, apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI) & 0xff;\n\tmax_irr = apic_find_highest_irr(apic);\n\tif (max_irr < 0)\n\t\tmax_irr = 0;\n\tmax_isr = apic_find_highest_isr(apic);\n\tif (max_isr < 0)\n\t\tmax_isr = 0;\n\tdata = (tpr & 0xff) | ((max_isr & 0xf0) << 8) | (max_irr << 24);\n\n\tkvm_write_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\tsizeof(u32));\n}"
  },
  {
    "function_name": "apic_sync_pv_eoi_to_guest",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2618-2636",
    "snippet": "static void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pv_eoi_set_pending",
          "args": [
            "apic->vcpu"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_set_pending",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "653-661",
          "snippet": "static void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tprintk(KERN_WARNING \"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tprintk(KERN_WARNING \"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_handles_vector",
          "args": [
            "apic",
            "apic->highest_isr_cache"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_handles_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1177-1180",
          "snippet": "static bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pv_eoi_enabled",
          "args": [
            "vcpu"
          ],
          "line": 2621
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "637-640",
          "snippet": "static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_sync_pv_eoi_to_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tif (!pv_eoi_enabled(vcpu) ||\n\t    /* IRR set or many bits in ISR: could be nested. */\n\t    apic->irr_pending ||\n\t    /* Cache not set: could be safe but we don't bother. */\n\t    apic->highest_isr_cache == -1 ||\n\t    /* Need EOI to update ioapic. */\n\t    kvm_ioapic_handles_vector(apic, apic->highest_isr_cache)) {\n\t\t/*\n\t\t * PV EOI was disabled by apic_sync_pv_eoi_from_guest\n\t\t * so we need not do anything here.\n\t\t */\n\t\treturn;\n\t}\n\n\tpv_eoi_set_pending(apic->vcpu);\n}"
  },
  {
    "function_name": "kvm_lapic_sync_from_vapic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2595-2610",
    "snippet": "void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tif (kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\t  sizeof(u32)))\n\t\treturn;\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_set_tpr",
          "args": [
            "vcpu->arch.apic",
            "data & 0xff"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_tpr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2151-2157",
          "snippet": "void kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.apic->vapic_cache",
            "&data",
            "sizeof(u32)"
          ],
          "line": 2605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_CHECK_VAPIC",
            "&vcpu->arch.apic_attention"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_sync_pv_eoi_from_guest",
          "args": [
            "vcpu",
            "vcpu->arch.apic"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "apic_sync_pv_eoi_from_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2565-2593",
          "snippet": "static void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KVM_APIC_PV_EOI_PENDING",
            "&vcpu->arch.apic_attention"
          ],
          "line": 2599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)\n{\n\tu32 data;\n\n\tif (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))\n\t\tapic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);\n\n\tif (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))\n\t\treturn;\n\n\tif (kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.apic->vapic_cache, &data,\n\t\t\t\t  sizeof(u32)))\n\t\treturn;\n\n\tapic_set_tpr(vcpu->arch.apic, data & 0xff);\n}"
  },
  {
    "function_name": "apic_sync_pv_eoi_from_guest",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2565-2593",
    "snippet": "static void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_pv_eoi",
          "args": [
            "apic",
            "vector"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_set_eoi",
          "args": [
            "apic"
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2080-2083",
          "snippet": "void kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pv_eoi_clr_pending",
          "args": [
            "vcpu"
          ],
          "line": 2588
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_clr_pending",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "663-671",
          "snippet": "static void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tprintk(KERN_WARNING \"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tprintk(KERN_WARNING \"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pv_eoi_get_pending",
          "args": [
            "vcpu"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_get_pending",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "642-651",
          "snippet": "static bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0) {\n\t\tprintk(KERN_WARNING \"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn false;\n\t}\n\treturn val & 0x1;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0) {\n\t\tprintk(KERN_WARNING \"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn false;\n\t}\n\treturn val & 0x1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!pv_eoi_enabled(vcpu)"
          ],
          "line": 2581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_eoi_enabled",
          "args": [
            "vcpu"
          ],
          "line": 2581
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "637-640",
          "snippet": "static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_sync_pv_eoi_from_guest(struct kvm_vcpu *vcpu,\n\t\t\t\t\tstruct kvm_lapic *apic)\n{\n\tbool pending;\n\tint vector;\n\t/*\n\t * PV EOI state is derived from KVM_APIC_PV_EOI_PENDING in host\n\t * and KVM_PV_EOI_ENABLED in guest memory as follows:\n\t *\n\t * KVM_APIC_PV_EOI_PENDING is unset:\n\t * \t-> host disabled PV EOI.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is set:\n\t * \t-> host enabled PV EOI, guest did not execute EOI yet.\n\t * KVM_APIC_PV_EOI_PENDING is set, KVM_PV_EOI_ENABLED is unset:\n\t * \t-> host enabled PV EOI, guest executed EOI.\n\t */\n\tBUG_ON(!pv_eoi_enabled(vcpu));\n\tpending = pv_eoi_get_pending(vcpu);\n\t/*\n\t * Clear pending bit in any case: it will be set again on vmentry.\n\t * While this might not be ideal from performance point of view,\n\t * this makes sure pv eoi is only enabled when we know it's safe.\n\t */\n\tpv_eoi_clr_pending(vcpu);\n\tif (pending)\n\t\treturn;\n\tvector = apic_set_eoi(apic);\n\ttrace_kvm_pv_eoi(apic, vector);\n}"
  },
  {
    "function_name": "__kvm_migrate_apic_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2545-2556",
    "snippet": "void __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct hrtimer *timer;\n\n\tif (!lapic_in_kernel(vcpu) ||\n\t\tkvm_can_post_timer_interrupt(vcpu))\n\t\treturn;\n\n\ttimer = &vcpu->arch.apic->lapic_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_HARD);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start_expires",
          "args": [
            "timer",
            "HRTIMER_MODE_ABS_HARD"
          ],
          "line": 2555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "timer"
          ],
          "line": 2554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_can_post_timer_interrupt",
          "args": [
            "vcpu"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_can_post_timer_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "116-119",
          "snippet": "bool kvm_can_post_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn pi_inject_timer && kvm_vcpu_apicv_active(vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_can_post_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn pi_inject_timer && kvm_vcpu_apicv_active(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct hrtimer *timer;\n\n\tif (!lapic_in_kernel(vcpu) ||\n\t\tkvm_can_post_timer_interrupt(vcpu))\n\t\treturn;\n\n\ttimer = &vcpu->arch.apic->lapic_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_HARD);\n}"
  },
  {
    "function_name": "kvm_apic_set_state",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2502-2543",
    "snippet": "int kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint r;\n\n\tkvm_lapic_set_base(vcpu, vcpu->arch.apic_base);\n\t/* set SPIV separately to get count of SW disabled APICs right */\n\tapic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));\n\n\tr = kvm_apic_state_fixup(vcpu, s, true);\n\tif (r) {\n\t\tkvm_recalculate_apic_map(vcpu->kvm);\n\t\treturn r;\n\t}\n\tmemcpy(vcpu->arch.apic->regs, s->regs, sizeof(*s));\n\n\tkvm_recalculate_apic_map(vcpu->kvm);\n\tkvm_apic_set_version(vcpu);\n\n\tapic_update_ppr(apic);\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic_update_lvtt(apic);\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\tupdate_divide_count(apic);\n\tstart_apic_timer(apic);\n\tkvm_apic_update_apicv(vcpu);\n\tapic->highest_isr_cache = -1;\n\tif (vcpu->arch.apicv_active) {\n\t\tkvm_x86_ops.apicv_post_state_restore(vcpu);\n\t\tkvm_x86_ops.hwapic_irr_update(vcpu,\n\t\t\t\tapic_find_highest_irr(apic));\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu,\n\t\t\t\tapic_find_highest_isr(apic));\n\t}\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tif (ioapic_in_kernel(vcpu->kvm))\n\t\tkvm_rtc_eoi_tracking_restore_one(vcpu);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rtc_eoi_tracking_restore_one",
          "args": [
            "vcpu"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rtc_eoi_tracking_restore_one",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "140-147",
          "snippet": "void kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__rtc_irq_eoi_tracking_restore_one(vcpu);\n\tspin_unlock(&ioapic->lock);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__rtc_irq_eoi_tracking_restore_one(vcpu);\n\tspin_unlock(&ioapic->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioapic_in_kernel",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.h",
          "lines": "109-116",
          "snippet": "static inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.hwapic_isr_update",
          "args": [
            "vcpu",
            "apic_find_highest_isr(apic)"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_isr",
          "args": [
            "apic"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "apic_find_highest_isr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "504-521",
          "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.hwapic_irr_update",
          "args": [
            "vcpu",
            "apic_find_highest_irr(apic)"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_irr",
          "args": [
            "apic"
          ],
          "line": 2532
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "548-556",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.apicv_post_state_restore",
          "args": [
            "vcpu"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_update_apicv",
          "args": [
            "vcpu"
          ],
          "line": 2527
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_update_apicv",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2209-2221",
          "snippet": "void kvm_apic_update_apicv(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vcpu->arch.apicv_active) {\n\t\t/* irr_pending is always true when apicv is activated. */\n\t\tapic->irr_pending = true;\n\t\tapic->isr_count = 1;\n\t} else {\n\t\tapic->irr_pending = (apic_search_irr(apic) != -1);\n\t\tapic->isr_count = count_vectors(apic->regs + APIC_ISR);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_update_apicv(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vcpu->arch.apicv_active) {\n\t\t/* irr_pending is always true when apicv is activated. */\n\t\tapic->irr_pending = true;\n\t\tapic->isr_count = 1;\n\t} else {\n\t\tapic->irr_pending = (apic_search_irr(apic) != -1);\n\t\tapic->isr_count = count_vectors(apic->regs + APIC_ISR);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_apic_timer",
          "args": [
            "apic"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "start_apic_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1878-1887",
          "snippet": "static void start_apic_timer(struct kvm_lapic *apic)\n{\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif ((apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t    && !set_target_expiration(apic))\n\t\treturn;\n\n\trestart_apic_timer(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif ((apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t    && !set_target_expiration(apic))\n\t\treturn;\n\n\trestart_apic_timer(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_divide_count",
          "args": [
            "apic"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "update_divide_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1432-1440",
          "snippet": "static void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_manage_nmi_watchdog",
          "args": [
            "apic",
            "kvm_lapic_get_reg(apic, APIC_LVT0)"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "apic_manage_nmi_watchdog",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1889-1900",
          "snippet": "static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_LVT0"
          ],
          "line": 2524
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_lvtt",
          "args": [
            "apic"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_lvtt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1465-1485",
          "snippet": "static void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tif (apic_lvtt_tscdeadline(apic) != (timer_mode ==\n\t\t\t\tAPIC_LVT_TIMER_TSCDEADLINE)) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tpreempt_disable();\n\t\t\tif (apic->lapic_timer.hv_timer_in_use)\n\t\t\t\tcancel_hv_timer(apic);\n\t\t\tpreempt_enable();\n\t\t\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\t\t\tapic->lapic_timer.period = 0;\n\t\t\tapic->lapic_timer.tscdeadline = 0;\n\t\t}\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\tlimit_periodic_timer_frequency(apic);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tif (apic_lvtt_tscdeadline(apic) != (timer_mode ==\n\t\t\t\tAPIC_LVT_TIMER_TSCDEADLINE)) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tpreempt_disable();\n\t\t\tif (apic->lapic_timer.hv_timer_in_use)\n\t\t\t\tcancel_hv_timer(apic);\n\t\t\tpreempt_enable();\n\t\t\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\t\t\tapic->lapic_timer.period = 0;\n\t\t\tapic->lapic_timer.tscdeadline = 0;\n\t\t}\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\tlimit_periodic_timer_frequency(apic);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_update_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "716-719",
          "snippet": "void kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_version",
          "args": [
            "vcpu"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_version",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "337-358",
          "snippet": "void kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\t/*\n\t * KVM emulates 82093AA datasheet (with in-kernel IOAPIC implementation)\n\t * which doesn't have EOI register; Some buggy OSes (e.g. Windows with\n\t * Hyper-V role) disable EOI broadcast in lapic not checking for IOAPIC\n\t * version first and level-triggered interrupts never get EOIed in\n\t * IOAPIC.\n\t */\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))) &&\n\t    !ioapic_in_kernel(vcpu->kvm))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))"
          ],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\t/*\n\t * KVM emulates 82093AA datasheet (with in-kernel IOAPIC implementation)\n\t * which doesn't have EOI register; Some buggy OSes (e.g. Windows with\n\t * Hyper-V role) disable EOI broadcast in lapic not checking for IOAPIC\n\t * version first and level-triggered interrupts never get EOIed in\n\t * IOAPIC.\n\t */\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))) &&\n\t    !ioapic_in_kernel(vcpu->kvm))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_recalculate_apic_map",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_recalculate_apic_map",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "167-265",
          "snippet": "void kvm_recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tu32 max_id = 255; /* enough space for any xAPIC ID */\n\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/*\n\t\t * Read kvm->arch.apic_map_dirty before\n\t\t * kvm->arch.apic_map\n\t\t */\n\t\tsmp_rmb();\n\t\treturn;\n\t}\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/* Someone else has updated the map. */\n\t\tmutex_unlock(&kvm->arch.apic_map_lock);\n\t\treturn;\n\t}\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (kvm_apic_present(vcpu))\n\t\t\tmax_id = max(max_id, kvm_x2apic_id(vcpu->arch.apic));\n\n\tnew = kvzalloc(sizeof(struct kvm_apic_map) +\n\t                   sizeof(struct kvm_lapic *) * ((u64)max_id + 1),\n\t\t\t   GFP_KERNEL_ACCOUNT);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->max_apic_id = max_id;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tstruct kvm_lapic **cluster;\n\t\tu16 mask;\n\t\tu32 ldr;\n\t\tu8 xapic_id;\n\t\tu32 x2apic_id;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\txapic_id = kvm_xapic_id(apic);\n\t\tx2apic_id = kvm_x2apic_id(apic);\n\n\t\t/* Hotplug hack: see kvm_apic_match_physical_addr(), ... */\n\t\tif ((apic_x2apic_mode(apic) || x2apic_id > 0xff) &&\n\t\t\t\tx2apic_id <= new->max_apic_id)\n\t\t\tnew->phys_map[x2apic_id] = apic;\n\t\t/*\n\t\t * ... xAPIC ID of VCPUs with APIC ID > 0xff will wrap-around,\n\t\t * prevent them from masking VCPUs with APIC ID <= 0xff.\n\t\t */\n\t\tif (!apic_x2apic_mode(apic) && !new->phys_map[xapic_id])\n\t\t\tnew->phys_map[xapic_id] = apic;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tcontinue;\n\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))\n\t\t\tcontinue;\n\n\t\tif (mask)\n\t\t\tcluster[ffs(mask) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\t/*\n\t * Write kvm->arch.apic_map before\n\t * clearing apic->apic_map_dirty\n\t */\n\tsmp_wmb();\n\tkvm->arch.apic_map_dirty = false;\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tcall_rcu(&old->rcu, kvm_apic_map_free);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tu32 max_id = 255; /* enough space for any xAPIC ID */\n\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/*\n\t\t * Read kvm->arch.apic_map_dirty before\n\t\t * kvm->arch.apic_map\n\t\t */\n\t\tsmp_rmb();\n\t\treturn;\n\t}\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/* Someone else has updated the map. */\n\t\tmutex_unlock(&kvm->arch.apic_map_lock);\n\t\treturn;\n\t}\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (kvm_apic_present(vcpu))\n\t\t\tmax_id = max(max_id, kvm_x2apic_id(vcpu->arch.apic));\n\n\tnew = kvzalloc(sizeof(struct kvm_apic_map) +\n\t                   sizeof(struct kvm_lapic *) * ((u64)max_id + 1),\n\t\t\t   GFP_KERNEL_ACCOUNT);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->max_apic_id = max_id;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tstruct kvm_lapic **cluster;\n\t\tu16 mask;\n\t\tu32 ldr;\n\t\tu8 xapic_id;\n\t\tu32 x2apic_id;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\txapic_id = kvm_xapic_id(apic);\n\t\tx2apic_id = kvm_x2apic_id(apic);\n\n\t\t/* Hotplug hack: see kvm_apic_match_physical_addr(), ... */\n\t\tif ((apic_x2apic_mode(apic) || x2apic_id > 0xff) &&\n\t\t\t\tx2apic_id <= new->max_apic_id)\n\t\t\tnew->phys_map[x2apic_id] = apic;\n\t\t/*\n\t\t * ... xAPIC ID of VCPUs with APIC ID > 0xff will wrap-around,\n\t\t * prevent them from masking VCPUs with APIC ID <= 0xff.\n\t\t */\n\t\tif (!apic_x2apic_mode(apic) && !new->phys_map[xapic_id])\n\t\t\tnew->phys_map[xapic_id] = apic;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tcontinue;\n\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))\n\t\t\tcontinue;\n\n\t\tif (mask)\n\t\t\tcluster[ffs(mask) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\t/*\n\t * Write kvm->arch.apic_map before\n\t * clearing apic->apic_map_dirty\n\t */\n\tsmp_wmb();\n\tkvm->arch.apic_map_dirty = false;\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tcall_rcu(&old->rcu, kvm_apic_map_free);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "vcpu->arch.apic->regs",
            "s->regs",
            "sizeof(*s)"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_state_fixup",
          "args": [
            "vcpu",
            "s",
            "true"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_state_fixup",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2471-2494",
          "snippet": "static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s, bool set)\n{\n\tif (apic_x2apic_mode(vcpu->arch.apic)) {\n\t\tu32 *id = (u32 *)(s->regs + APIC_ID);\n\t\tu32 *ldr = (u32 *)(s->regs + APIC_LDR);\n\n\t\tif (vcpu->kvm->arch.x2apic_format) {\n\t\t\tif (*id != vcpu->vcpu_id)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (set)\n\t\t\t\t*id >>= 24;\n\t\t\telse\n\t\t\t\t*id <<= 24;\n\t\t}\n\n\t\t/* In x2APIC mode, the LDR is fixed and based on the id */\n\t\tif (set)\n\t\t\t*ldr = kvm_apic_calc_x2apic_ldr(*id);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s, bool set)\n{\n\tif (apic_x2apic_mode(vcpu->arch.apic)) {\n\t\tu32 *id = (u32 *)(s->regs + APIC_ID);\n\t\tu32 *ldr = (u32 *)(s->regs + APIC_LDR);\n\n\t\tif (vcpu->kvm->arch.x2apic_format) {\n\t\t\tif (*id != vcpu->vcpu_id)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (set)\n\t\t\t\t*id >>= 24;\n\t\t\telse\n\t\t\t\t*id <<= 24;\n\t\t}\n\n\t\t/* In x2APIC mode, the LDR is fixed and based on the id */\n\t\tif (set)\n\t\t\t*ldr = kvm_apic_calc_x2apic_ldr(*id);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_set_spiv",
          "args": [
            "apic",
            "*((u32 *)(s->regs + APIC_SPIV))"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "apic_set_spiv",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "267-282",
          "snippet": "static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\n\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_sw_disabled",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_sw_disabled;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\n\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_base",
          "args": [
            "vcpu",
            "vcpu->arch.apic_base"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_base",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2168-2207",
          "snippet": "void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic)\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\n\tvcpu->arch.apic_base = value;\n\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE)\n\t\tkvm_update_cpuid(vcpu);\n\n\tif (!apic)\n\t\treturn;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE) {\n\t\t\tkvm_apic_set_xapic_id(apic, vcpu->vcpu_id);\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\t} else {\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\t\tvcpu->kvm->arch.apic_map_dirty = true;\n\t\t}\n\t}\n\n\tif (((old_value ^ value) & X2APIC_ENABLE) && (value & X2APIC_ENABLE))\n\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\n\tif ((old_value ^ value) & (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE))\n\t\tkvm_x86_ops.set_virtual_apic_mode(vcpu);\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_hw_disabled",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_hw_disabled;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic)\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\n\tvcpu->arch.apic_base = value;\n\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE)\n\t\tkvm_update_cpuid(vcpu);\n\n\tif (!apic)\n\t\treturn;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE) {\n\t\t\tkvm_apic_set_xapic_id(apic, vcpu->vcpu_id);\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\t} else {\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\t\tvcpu->kvm->arch.apic_map_dirty = true;\n\t\t}\n\t}\n\n\tif (((old_value ^ value) & X2APIC_ENABLE) && (value & X2APIC_ENABLE))\n\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\n\tif ((old_value ^ value) & (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE))\n\t\tkvm_x86_ops.set_virtual_apic_mode(vcpu);\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_set_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint r;\n\n\tkvm_lapic_set_base(vcpu, vcpu->arch.apic_base);\n\t/* set SPIV separately to get count of SW disabled APICs right */\n\tapic_set_spiv(apic, *((u32 *)(s->regs + APIC_SPIV)));\n\n\tr = kvm_apic_state_fixup(vcpu, s, true);\n\tif (r) {\n\t\tkvm_recalculate_apic_map(vcpu->kvm);\n\t\treturn r;\n\t}\n\tmemcpy(vcpu->arch.apic->regs, s->regs, sizeof(*s));\n\n\tkvm_recalculate_apic_map(vcpu->kvm);\n\tkvm_apic_set_version(vcpu);\n\n\tapic_update_ppr(apic);\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic_update_lvtt(apic);\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\tupdate_divide_count(apic);\n\tstart_apic_timer(apic);\n\tkvm_apic_update_apicv(vcpu);\n\tapic->highest_isr_cache = -1;\n\tif (vcpu->arch.apicv_active) {\n\t\tkvm_x86_ops.apicv_post_state_restore(vcpu);\n\t\tkvm_x86_ops.hwapic_irr_update(vcpu,\n\t\t\t\tapic_find_highest_irr(apic));\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu,\n\t\t\t\tapic_find_highest_isr(apic));\n\t}\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\tif (ioapic_in_kernel(vcpu->kvm))\n\t\tkvm_rtc_eoi_tracking_restore_one(vcpu);\n\n\tvcpu->arch.apic_arb_prio = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_apic_get_state",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2496-2500",
    "snippet": "int kvm_apic_get_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)\n{\n\tmemcpy(s->regs, vcpu->arch.apic->regs, sizeof(*s));\n\treturn kvm_apic_state_fixup(vcpu, s, false);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_state_fixup",
          "args": [
            "vcpu",
            "s",
            "false"
          ],
          "line": 2499
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_state_fixup",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2471-2494",
          "snippet": "static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s, bool set)\n{\n\tif (apic_x2apic_mode(vcpu->arch.apic)) {\n\t\tu32 *id = (u32 *)(s->regs + APIC_ID);\n\t\tu32 *ldr = (u32 *)(s->regs + APIC_LDR);\n\n\t\tif (vcpu->kvm->arch.x2apic_format) {\n\t\t\tif (*id != vcpu->vcpu_id)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (set)\n\t\t\t\t*id >>= 24;\n\t\t\telse\n\t\t\t\t*id <<= 24;\n\t\t}\n\n\t\t/* In x2APIC mode, the LDR is fixed and based on the id */\n\t\tif (set)\n\t\t\t*ldr = kvm_apic_calc_x2apic_ldr(*id);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s, bool set)\n{\n\tif (apic_x2apic_mode(vcpu->arch.apic)) {\n\t\tu32 *id = (u32 *)(s->regs + APIC_ID);\n\t\tu32 *ldr = (u32 *)(s->regs + APIC_LDR);\n\n\t\tif (vcpu->kvm->arch.x2apic_format) {\n\t\t\tif (*id != vcpu->vcpu_id)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (set)\n\t\t\t\t*id >>= 24;\n\t\t\telse\n\t\t\t\t*id <<= 24;\n\t\t}\n\n\t\t/* In x2APIC mode, the LDR is fixed and based on the id */\n\t\tif (set)\n\t\t\t*ldr = kvm_apic_calc_x2apic_ldr(*id);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->regs",
            "vcpu->arch.apic->regs",
            "sizeof(*s)"
          ],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_get_state(struct kvm_vcpu *vcpu, struct kvm_lapic_state *s)\n{\n\tmemcpy(s->regs, vcpu->arch.apic->regs, sizeof(*s));\n\treturn kvm_apic_state_fixup(vcpu, s, false);\n}"
  },
  {
    "function_name": "kvm_apic_state_fixup",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2471-2494",
    "snippet": "static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s, bool set)\n{\n\tif (apic_x2apic_mode(vcpu->arch.apic)) {\n\t\tu32 *id = (u32 *)(s->regs + APIC_ID);\n\t\tu32 *ldr = (u32 *)(s->regs + APIC_LDR);\n\n\t\tif (vcpu->kvm->arch.x2apic_format) {\n\t\t\tif (*id != vcpu->vcpu_id)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (set)\n\t\t\t\t*id >>= 24;\n\t\t\telse\n\t\t\t\t*id <<= 24;\n\t\t}\n\n\t\t/* In x2APIC mode, the LDR is fixed and based on the id */\n\t\tif (set)\n\t\t\t*ldr = kvm_apic_calc_x2apic_ldr(*id);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_calc_x2apic_ldr",
          "args": [
            "*id"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_calc_x2apic_ldr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "296-299",
          "snippet": "static inline u32 kvm_apic_calc_x2apic_ldr(u32 id)\n{\n\treturn ((id >> 4) << 16) | (1 << (id & 0xf));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline u32 kvm_apic_calc_x2apic_ldr(u32 id)\n{\n\treturn ((id >> 4) << 16) | (1 << (id & 0xf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_lapic_state *s, bool set)\n{\n\tif (apic_x2apic_mode(vcpu->arch.apic)) {\n\t\tu32 *id = (u32 *)(s->regs + APIC_ID);\n\t\tu32 *ldr = (u32 *)(s->regs + APIC_LDR);\n\n\t\tif (vcpu->kvm->arch.x2apic_format) {\n\t\t\tif (*id != vcpu->vcpu_id)\n\t\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tif (set)\n\t\t\t\t*id >>= 24;\n\t\t\telse\n\t\t\t\t*id <<= 24;\n\t\t}\n\n\t\t/* In x2APIC mode, the LDR is fixed and based on the id */\n\t\tif (set)\n\t\t\t*ldr = kvm_apic_calc_x2apic_ldr(*id);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_get_apic_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2433-2469",
    "snippet": "int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)\n{\n\tint vector = kvm_apic_has_interrupt(vcpu);\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (vector == -1)\n\t\treturn -1;\n\n\t/*\n\t * We get here even with APIC virtualization enabled, if doing\n\t * nested virtualization and L1 runs with the \"acknowledge interrupt\n\t * on exit\" mode.  Then we cannot inject the interrupt via RVI,\n\t * because the process would deliver it through the IDT.\n\t */\n\n\tapic_clear_irr(vector, apic);\n\tif (test_bit(vector, vcpu_to_synic(vcpu)->auto_eoi_bitmap)) {\n\t\t/*\n\t\t * For auto-EOI interrupts, there might be another pending\n\t\t * interrupt above PPR, so check whether to raise another\n\t\t * KVM_REQ_EVENT.\n\t\t */\n\t\tapic_update_ppr(apic);\n\t} else {\n\t\t/*\n\t\t * For normal interrupts, PPR has been raised and there cannot\n\t\t * be a higher-priority pending interrupt---except if there was\n\t\t * a concurrent interrupt injection, but that would have\n\t\t * triggered KVM_REQ_EVENT already.\n\t\t */\n\t\tapic_set_isr(vector, apic);\n\t\t__apic_update_ppr(apic, &ppr);\n\t}\n\n\treturn vector;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__apic_update_ppr",
          "args": [
            "apic",
            "&ppr"
          ],
          "line": 2465
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_update_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "685-705",
          "snippet": "static bool __apic_update_ppr(struct kvm_lapic *apic, u32 *new_ppr)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\t*new_ppr = ppr;\n\tif (old_ppr != ppr)\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\n\treturn ppr < old_ppr;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool __apic_update_ppr(struct kvm_lapic *apic, u32 *new_ppr)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\t*new_ppr = ppr;\n\tif (old_ppr != ppr)\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\n\treturn ppr < old_ppr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_set_isr",
          "args": [
            "vector",
            "apic"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "apic_set_isr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "476-502",
          "snippet": "static inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tif (__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * With APIC virtualization enabled, all caching is disabled\n\t * because the processor can modify ISR under the hood.  Instead\n\t * just set SVI.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu, vec);\n\telse {\n\t\t++apic->isr_count;\n\t\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t\t/*\n\t\t * ISR (in service register) bit is set when injecting an interrupt.\n\t\t * The highest vector is injected. Thus the latest bit set matches\n\t\t * the highest bit in ISR.\n\t\t */\n\t\tapic->highest_isr_cache = vec;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_APIC_VECTOR\t\t\t256"
          ],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tif (__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * With APIC virtualization enabled, all caching is disabled\n\t * because the processor can modify ISR under the hood.  Instead\n\t * just set SVI.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu, vec);\n\telse {\n\t\t++apic->isr_count;\n\t\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t\t/*\n\t\t * ISR (in service register) bit is set when injecting an interrupt.\n\t\t * The highest vector is injected. Thus the latest bit set matches\n\t\t * the highest bit in ISR.\n\t\t */\n\t\tapic->highest_isr_cache = vec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_update_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "716-719",
          "snippet": "void kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vector",
            "vcpu_to_synic(vcpu)->auto_eoi_bitmap"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "39-42",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_clear_irr",
          "args": [
            "vector",
            "apic"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "apic_clear_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "457-474",
          "snippet": "static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tvcpu = apic->vcpu;\n\n\tif (unlikely(vcpu->arch.apicv_active)) {\n\t\t/* need to update RVI */\n\t\tkvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tkvm_x86_ops.hwapic_irr_update(vcpu,\n\t\t\t\tapic_find_highest_irr(apic));\n\t} else {\n\t\tapic->irr_pending = false;\n\t\tkvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tif (apic_search_irr(apic) != -1)\n\t\t\tapic->irr_pending = true;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tvcpu = apic->vcpu;\n\n\tif (unlikely(vcpu->arch.apicv_active)) {\n\t\t/* need to update RVI */\n\t\tkvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tkvm_x86_ops.hwapic_irr_update(vcpu,\n\t\t\t\tapic_find_highest_irr(apic));\n\t} else {\n\t\tapic->irr_pending = false;\n\t\tkvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tif (apic_search_irr(apic) != -1)\n\t\t\tapic->irr_pending = true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_has_interrupt",
          "args": [
            "vcpu"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_has_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2399-2409",
          "snippet": "int kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (!kvm_apic_hw_enabled(apic))\n\t\treturn -1;\n\n\t__apic_update_ppr(apic, &ppr);\n\treturn apic_has_interrupt_for_ppr(apic, ppr);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (!kvm_apic_hw_enabled(apic))\n\t\treturn -1;\n\n\t__apic_update_ppr(apic, &ppr);\n\treturn apic_has_interrupt_for_ppr(apic, ppr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)\n{\n\tint vector = kvm_apic_has_interrupt(vcpu);\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (vector == -1)\n\t\treturn -1;\n\n\t/*\n\t * We get here even with APIC virtualization enabled, if doing\n\t * nested virtualization and L1 runs with the \"acknowledge interrupt\n\t * on exit\" mode.  Then we cannot inject the interrupt via RVI,\n\t * because the process would deliver it through the IDT.\n\t */\n\n\tapic_clear_irr(vector, apic);\n\tif (test_bit(vector, vcpu_to_synic(vcpu)->auto_eoi_bitmap)) {\n\t\t/*\n\t\t * For auto-EOI interrupts, there might be another pending\n\t\t * interrupt above PPR, so check whether to raise another\n\t\t * KVM_REQ_EVENT.\n\t\t */\n\t\tapic_update_ppr(apic);\n\t} else {\n\t\t/*\n\t\t * For normal interrupts, PPR has been raised and there cannot\n\t\t * be a higher-priority pending interrupt---except if there was\n\t\t * a concurrent interrupt injection, but that would have\n\t\t * triggered KVM_REQ_EVENT already.\n\t\t */\n\t\tapic_set_isr(vector, apic);\n\t\t__apic_update_ppr(apic, &ppr);\n\t}\n\n\treturn vector;\n}"
  },
  {
    "function_name": "kvm_inject_apic_timer_irqs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2423-2431",
    "snippet": "void kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (atomic_read(&apic->lapic_timer.pending) > 0) {\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&apic->lapic_timer.pending",
            "0"
          ],
          "line": 2429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_inject_pending_timer_irqs",
          "args": [
            "apic"
          ],
          "line": 2428
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_inject_pending_timer_irqs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1586-1597",
          "snippet": "static void kvm_apic_inject_pending_timer_irqs(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\tif (apic_lvtt_tscdeadline(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t} else if (apic_lvtt_oneshot(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t\tktimer->target_expiration = 0;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void kvm_apic_inject_pending_timer_irqs(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\tif (apic_lvtt_tscdeadline(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t} else if (apic_lvtt_oneshot(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t\tktimer->target_expiration = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&apic->lapic_timer.pending"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (atomic_read(&apic->lapic_timer.pending) > 0) {\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\t}\n}"
  },
  {
    "function_name": "kvm_apic_accept_pic_intr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2411-2421",
    "snippet": "int kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GET_APIC_DELIVERY_MODE",
          "args": [
            "lvt0"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "177-182",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "vcpu->arch.apic",
            "APIC_LVT0"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_apic_has_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2399-2409",
    "snippet": "int kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (!kvm_apic_hw_enabled(apic))\n\t\treturn -1;\n\n\t__apic_update_ppr(apic, &ppr);\n\treturn apic_has_interrupt_for_ppr(apic, ppr);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_has_interrupt_for_ppr",
          "args": [
            "apic",
            "ppr"
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "apic_has_interrupt_for_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "673-683",
          "snippet": "static int apic_has_interrupt_for_ppr(struct kvm_lapic *apic, u32 ppr)\n{\n\tint highest_irr;\n\tif (apic->vcpu->arch.apicv_active)\n\t\thighest_irr = kvm_x86_ops.sync_pir_to_irr(apic->vcpu);\n\telse\n\t\thighest_irr = apic_find_highest_irr(apic);\n\tif (highest_irr == -1 || (highest_irr & 0xF0) <= ppr)\n\t\treturn -1;\n\treturn highest_irr;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int apic_has_interrupt_for_ppr(struct kvm_lapic *apic, u32 ppr)\n{\n\tint highest_irr;\n\tif (apic->vcpu->arch.apicv_active)\n\t\thighest_irr = kvm_x86_ops.sync_pir_to_irr(apic->vcpu);\n\telse\n\t\thighest_irr = apic_find_highest_irr(apic);\n\tif (highest_irr == -1 || (highest_irr & 0xF0) <= ppr)\n\t\treturn -1;\n\treturn highest_irr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__apic_update_ppr",
          "args": [
            "apic",
            "&ppr"
          ],
          "line": 2407
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_update_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "685-705",
          "snippet": "static bool __apic_update_ppr(struct kvm_lapic *apic, u32 *new_ppr)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\t*new_ppr = ppr;\n\tif (old_ppr != ppr)\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\n\treturn ppr < old_ppr;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool __apic_update_ppr(struct kvm_lapic *apic, u32 *new_ppr)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\t*new_ppr = ppr;\n\tif (old_ppr != ppr)\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\n\treturn ppr < old_ppr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "apic"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "177-182",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (!kvm_apic_hw_enabled(apic))\n\t\treturn -1;\n\n\t__apic_update_ppr(apic, &ppr);\n\treturn apic_has_interrupt_for_ppr(apic, ppr);\n}"
  },
  {
    "function_name": "kvm_create_lapic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2352-2397",
    "snippet": "int kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)\n{\n\tstruct kvm_lapic *apic;\n\n\tASSERT(vcpu != NULL);\n\n\tapic = kzalloc(sizeof(*apic), GFP_KERNEL_ACCOUNT);\n\tif (!apic)\n\t\tgoto nomem;\n\n\tvcpu->arch.apic = apic;\n\n\tapic->regs = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT);\n\tif (!apic->regs) {\n\t\tprintk(KERN_ERR \"malloc apic regs error for vcpu %x\\n\",\n\t\t       vcpu->vcpu_id);\n\t\tgoto nomem_free_apic;\n\t}\n\tapic->vcpu = vcpu;\n\n\thrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS_HARD);\n\tapic->lapic_timer.timer.function = apic_timer_fn;\n\tif (timer_advance_ns == -1) {\n\t\tapic->lapic_timer.timer_advance_ns = LAPIC_TIMER_ADVANCE_NS_INIT;\n\t\tlapic_timer_advance_dynamic = true;\n\t} else {\n\t\tapic->lapic_timer.timer_advance_ns = timer_advance_ns;\n\t\tlapic_timer_advance_dynamic = false;\n\t}\n\n\t/*\n\t * APIC is created enabled. This will prevent kvm_lapic_set_base from\n\t * thinking that APIC state has changed.\n\t */\n\tvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\n\tstatic_key_slow_inc(&apic_sw_disabled.key); /* sw disabled at reset */\n\tkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\n\n\treturn 0;\nnomem_free_apic:\n\tkfree(apic);\n\tvcpu->arch.apic = NULL;\nnomem:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define LAPIC_TIMER_ADVANCE_NS_INIT\t1000"
    ],
    "globals_used": [
      "static bool lapic_timer_advance_dynamic",
      "struct static_key_deferred apic_sw_disabled",
      "static void cancel_hv_timer(struct kvm_lapic *apic);",
      "static const struct kvm_io_device_ops apic_mmio_ops = {\n\t.read     = apic_mmio_read,\n\t.write    = apic_mmio_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "apic"
          ],
          "line": 2393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&apic->dev",
            "&apic_mmio_ops"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_slow_inc",
          "args": [
            "&apic_sw_disabled.key"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&apic->lapic_timer.timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS_HARD"
          ],
          "line": 2372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"malloc apic regs error for vcpu %x\\n\"",
            "vcpu->vcpu_id"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*apic)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "vcpu != NULL"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_TIMER_ADVANCE_NS_INIT\t1000\n\nstatic bool lapic_timer_advance_dynamic;\nstruct static_key_deferred apic_sw_disabled;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\nstatic const struct kvm_io_device_ops apic_mmio_ops = {\n\t.read     = apic_mmio_read,\n\t.write    = apic_mmio_write,\n};\n\nint kvm_create_lapic(struct kvm_vcpu *vcpu, int timer_advance_ns)\n{\n\tstruct kvm_lapic *apic;\n\n\tASSERT(vcpu != NULL);\n\n\tapic = kzalloc(sizeof(*apic), GFP_KERNEL_ACCOUNT);\n\tif (!apic)\n\t\tgoto nomem;\n\n\tvcpu->arch.apic = apic;\n\n\tapic->regs = (void *)get_zeroed_page(GFP_KERNEL_ACCOUNT);\n\tif (!apic->regs) {\n\t\tprintk(KERN_ERR \"malloc apic regs error for vcpu %x\\n\",\n\t\t       vcpu->vcpu_id);\n\t\tgoto nomem_free_apic;\n\t}\n\tapic->vcpu = vcpu;\n\n\thrtimer_init(&apic->lapic_timer.timer, CLOCK_MONOTONIC,\n\t\t     HRTIMER_MODE_ABS_HARD);\n\tapic->lapic_timer.timer.function = apic_timer_fn;\n\tif (timer_advance_ns == -1) {\n\t\tapic->lapic_timer.timer_advance_ns = LAPIC_TIMER_ADVANCE_NS_INIT;\n\t\tlapic_timer_advance_dynamic = true;\n\t} else {\n\t\tapic->lapic_timer.timer_advance_ns = timer_advance_ns;\n\t\tlapic_timer_advance_dynamic = false;\n\t}\n\n\t/*\n\t * APIC is created enabled. This will prevent kvm_lapic_set_base from\n\t * thinking that APIC state has changed.\n\t */\n\tvcpu->arch.apic_base = MSR_IA32_APICBASE_ENABLE;\n\tstatic_key_slow_inc(&apic_sw_disabled.key); /* sw disabled at reset */\n\tkvm_iodevice_init(&apic->dev, &apic_mmio_ops);\n\n\treturn 0;\nnomem_free_apic:\n\tkfree(apic);\n\tvcpu->arch.apic = NULL;\nnomem:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "apic_timer_fn",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2337-2350",
    "snippet": "static enum hrtimer_restart apic_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);\n\tstruct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);\n\n\tapic_timer_expired(apic);\n\n\tif (lapic_is_periodic(apic)) {\n\t\tadvance_periodic_target_expiration(apic);\n\t\thrtimer_add_expires_ns(&ktimer->timer, ktimer->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_add_expires_ns",
          "args": [
            "&ktimer->timer",
            "ktimer->period"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "advance_periodic_target_expiration",
          "args": [
            "apic"
          ],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "advance_periodic_target_expiration",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1701-1720",
          "snippet": "static void advance_periodic_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now = ktime_get();\n\tu64 tscl = rdtsc();\n\tktime_t delta;\n\n\t/*\n\t * Synchronize both deadlines to the same time source or\n\t * differences in the periods (caused by differences in the\n\t * underlying clocks or numerical approximation errors) will\n\t * cause the two to drift apart over time as the errors\n\t * accumulate.\n\t */\n\tapic->lapic_timer.target_expiration =\n\t\tktime_add_ns(apic->lapic_timer.target_expiration,\n\t\t\t\tapic->lapic_timer.period);\n\tdelta = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, delta);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void advance_periodic_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now = ktime_get();\n\tu64 tscl = rdtsc();\n\tktime_t delta;\n\n\t/*\n\t * Synchronize both deadlines to the same time source or\n\t * differences in the periods (caused by differences in the\n\t * underlying clocks or numerical approximation errors) will\n\t * cause the two to drift apart over time as the errors\n\t * accumulate.\n\t */\n\tapic->lapic_timer.target_expiration =\n\t\tktime_add_ns(apic->lapic_timer.target_expiration,\n\t\t\t\tapic->lapic_timer.period);\n\tdelta = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_is_periodic",
          "args": [
            "apic"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_is_periodic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2294-2297",
          "snippet": "static bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_timer_expired",
          "args": [
            "apic"
          ],
          "line": 2342
        },
        "resolved": true,
        "details": {
          "function_name": "apic_timer_expired",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1599-1619",
          "snippet": "static void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ktimer",
            "structkvm_lapic",
            "lapic_timer"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "data",
            "structkvm_timer",
            "timer"
          ],
          "line": 2339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic enum hrtimer_restart apic_timer_fn(struct hrtimer *data)\n{\n\tstruct kvm_timer *ktimer = container_of(data, struct kvm_timer, timer);\n\tstruct kvm_lapic *apic = container_of(ktimer, struct kvm_lapic, lapic_timer);\n\n\tapic_timer_expired(apic);\n\n\tif (lapic_is_periodic(apic)) {\n\t\tadvance_periodic_target_expiration(apic);\n\t\thrtimer_add_expires_ns(&ktimer->timer, ktimer->period);\n\t\treturn HRTIMER_RESTART;\n\t} else\n\t\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "kvm_apic_nmi_wd_deliver",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2324-2330",
    "snippet": "void kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic)\n\t\tkvm_apic_local_deliver(apic, APIC_LVT0);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_local_deliver",
          "args": [
            "apic",
            "APIC_LVT0"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_local_deliver",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2309-2322",
          "snippet": "int kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_nmi_wd_deliver(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic)\n\t\tkvm_apic_local_deliver(apic, APIC_LVT0);\n}"
  },
  {
    "function_name": "kvm_apic_local_deliver",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2309-2322",
    "snippet": "int kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__apic_accept_irq",
          "args": [
            "apic",
            "mode",
            "vector",
            "1",
            "trig_mode",
            "NULL"
          ],
          "line": 2318
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_accept_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1029-1126",
          "snippet": "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\t\t/* fall through */\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector,\n\t\t\t\t\t\t     apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tkvm_lapic_clear_vector(vector,\n\t\t\t\t\t\t       apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (kvm_x86_ops.deliver_posted_interrupt(vcpu, vector)) {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\t\t/* fall through */\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector,\n\t\t\t\t\t\t     apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tkvm_lapic_clear_vector(vector,\n\t\t\t\t\t\t       apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (kvm_x86_ops.deliver_posted_interrupt(vcpu, vector)) {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "apic"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "177-182",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "lvt_type"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "apic_has_pending_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2299-2307",
    "snippet": "int apic_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic_enabled(apic) && apic_lvt_enabled(apic, APIC_LVTT))\n\t\treturn atomic_read(&apic->lapic_timer.pending);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&apic->lapic_timer.pending"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvt_enabled",
          "args": [
            "apic",
            "APIC_LVTT"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvt_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "312-315",
          "snippet": "static inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_lapic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_lapic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_enabled",
          "args": [
            "apic"
          ],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "apic_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "99-102",
          "snippet": "static inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint apic_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic_enabled(apic) && apic_lvt_enabled(apic, APIC_LVTT))\n\t\treturn atomic_read(&apic->lapic_timer.pending);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lapic_is_periodic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2294-2297",
    "snippet": "static bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 2296
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "322-325",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool lapic_is_periodic(struct kvm_lapic *apic)\n{\n\treturn apic_lvtt_period(apic);\n}"
  },
  {
    "function_name": "kvm_lapic_reset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2224-2286",
    "snippet": "void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint i;\n\n\tif (!apic)\n\t\treturn;\n\n\tvcpu->kvm->arch.apic_map_dirty = false;\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!init_event) {\n\t\tkvm_lapic_set_base(vcpu, APIC_DEFAULT_PHYS_BASE |\n\t\t                         MSR_IA32_APICBASE_ENABLE);\n\t\tkvm_apic_set_xapic_id(apic, vcpu->vcpu_id);\n\t}\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++)\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_update_lvtt(apic);\n\tif (kvm_vcpu_is_reset_bsp(vcpu) &&\n\t    kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_LINT0_REENABLED))\n\t\tkvm_lapic_set_reg(apic, APIC_LVT0,\n\t\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\n\tkvm_lapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, 0);\n\tif (!apic_x2apic_mode(apic))\n\t\tkvm_apic_set_ldr(apic, 0);\n\tkvm_lapic_set_reg(apic, APIC_ESR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR2, 0);\n\tkvm_lapic_set_reg(apic, APIC_TDCR, 0);\n\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tkvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tkvm_apic_update_apicv(vcpu);\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\tif (vcpu->arch.apicv_active) {\n\t\tkvm_x86_ops.apicv_post_state_restore(vcpu);\n\t\tkvm_x86_ops.hwapic_irr_update(vcpu, -1);\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu, -1);\n\t}\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tkvm_recalculate_apic_map(vcpu->kvm);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_recalculate_apic_map",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_recalculate_apic_map",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "167-265",
          "snippet": "void kvm_recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tu32 max_id = 255; /* enough space for any xAPIC ID */\n\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/*\n\t\t * Read kvm->arch.apic_map_dirty before\n\t\t * kvm->arch.apic_map\n\t\t */\n\t\tsmp_rmb();\n\t\treturn;\n\t}\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/* Someone else has updated the map. */\n\t\tmutex_unlock(&kvm->arch.apic_map_lock);\n\t\treturn;\n\t}\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (kvm_apic_present(vcpu))\n\t\t\tmax_id = max(max_id, kvm_x2apic_id(vcpu->arch.apic));\n\n\tnew = kvzalloc(sizeof(struct kvm_apic_map) +\n\t                   sizeof(struct kvm_lapic *) * ((u64)max_id + 1),\n\t\t\t   GFP_KERNEL_ACCOUNT);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->max_apic_id = max_id;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tstruct kvm_lapic **cluster;\n\t\tu16 mask;\n\t\tu32 ldr;\n\t\tu8 xapic_id;\n\t\tu32 x2apic_id;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\txapic_id = kvm_xapic_id(apic);\n\t\tx2apic_id = kvm_x2apic_id(apic);\n\n\t\t/* Hotplug hack: see kvm_apic_match_physical_addr(), ... */\n\t\tif ((apic_x2apic_mode(apic) || x2apic_id > 0xff) &&\n\t\t\t\tx2apic_id <= new->max_apic_id)\n\t\t\tnew->phys_map[x2apic_id] = apic;\n\t\t/*\n\t\t * ... xAPIC ID of VCPUs with APIC ID > 0xff will wrap-around,\n\t\t * prevent them from masking VCPUs with APIC ID <= 0xff.\n\t\t */\n\t\tif (!apic_x2apic_mode(apic) && !new->phys_map[xapic_id])\n\t\t\tnew->phys_map[xapic_id] = apic;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tcontinue;\n\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))\n\t\t\tcontinue;\n\n\t\tif (mask)\n\t\t\tcluster[ffs(mask) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\t/*\n\t * Write kvm->arch.apic_map before\n\t * clearing apic->apic_map_dirty\n\t */\n\tsmp_wmb();\n\tkvm->arch.apic_map_dirty = false;\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tcall_rcu(&old->rcu, kvm_apic_map_free);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tu32 max_id = 255; /* enough space for any xAPIC ID */\n\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/*\n\t\t * Read kvm->arch.apic_map_dirty before\n\t\t * kvm->arch.apic_map\n\t\t */\n\t\tsmp_rmb();\n\t\treturn;\n\t}\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/* Someone else has updated the map. */\n\t\tmutex_unlock(&kvm->arch.apic_map_lock);\n\t\treturn;\n\t}\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (kvm_apic_present(vcpu))\n\t\t\tmax_id = max(max_id, kvm_x2apic_id(vcpu->arch.apic));\n\n\tnew = kvzalloc(sizeof(struct kvm_apic_map) +\n\t                   sizeof(struct kvm_lapic *) * ((u64)max_id + 1),\n\t\t\t   GFP_KERNEL_ACCOUNT);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->max_apic_id = max_id;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tstruct kvm_lapic **cluster;\n\t\tu16 mask;\n\t\tu32 ldr;\n\t\tu8 xapic_id;\n\t\tu32 x2apic_id;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\txapic_id = kvm_xapic_id(apic);\n\t\tx2apic_id = kvm_x2apic_id(apic);\n\n\t\t/* Hotplug hack: see kvm_apic_match_physical_addr(), ... */\n\t\tif ((apic_x2apic_mode(apic) || x2apic_id > 0xff) &&\n\t\t\t\tx2apic_id <= new->max_apic_id)\n\t\t\tnew->phys_map[x2apic_id] = apic;\n\t\t/*\n\t\t * ... xAPIC ID of VCPUs with APIC ID > 0xff will wrap-around,\n\t\t * prevent them from masking VCPUs with APIC ID <= 0xff.\n\t\t */\n\t\tif (!apic_x2apic_mode(apic) && !new->phys_map[xapic_id])\n\t\t\tnew->phys_map[xapic_id] = apic;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tcontinue;\n\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))\n\t\t\tcontinue;\n\n\t\tif (mask)\n\t\t\tcluster[ffs(mask) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\t/*\n\t * Write kvm->arch.apic_map before\n\t * clearing apic->apic_map_dirty\n\t */\n\tsmp_wmb();\n\tkvm->arch.apic_map_dirty = false;\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tcall_rcu(&old->rcu, kvm_apic_map_free);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.hwapic_isr_update",
          "args": [
            "vcpu",
            "-1"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.hwapic_irr_update",
          "args": [
            "vcpu",
            "-1"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.apicv_post_state_restore",
          "args": [
            "vcpu"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_update_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "716-719",
          "snippet": "void kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_base",
          "args": [
            "vcpu",
            "vcpu->arch.apic_base | MSR_IA32_APICBASE_BSP"
          ],
          "line": 2272
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_base",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2168-2207",
          "snippet": "void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic)\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\n\tvcpu->arch.apic_base = value;\n\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE)\n\t\tkvm_update_cpuid(vcpu);\n\n\tif (!apic)\n\t\treturn;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE) {\n\t\t\tkvm_apic_set_xapic_id(apic, vcpu->vcpu_id);\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\t} else {\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\t\tvcpu->kvm->arch.apic_map_dirty = true;\n\t\t}\n\t}\n\n\tif (((old_value ^ value) & X2APIC_ENABLE) && (value & X2APIC_ENABLE))\n\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\n\tif ((old_value ^ value) & (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE))\n\t\tkvm_x86_ops.set_virtual_apic_mode(vcpu);\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_hw_disabled",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_hw_disabled;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic)\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\n\tvcpu->arch.apic_base = value;\n\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE)\n\t\tkvm_update_cpuid(vcpu);\n\n\tif (!apic)\n\t\treturn;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE) {\n\t\t\tkvm_apic_set_xapic_id(apic, vcpu->vcpu_id);\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\t} else {\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\t\tvcpu->kvm->arch.apic_map_dirty = true;\n\t\t}\n\t}\n\n\tif (((old_value ^ value) & X2APIC_ENABLE) && (value & X2APIC_ENABLE))\n\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\n\tif ((old_value ^ value) & (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE))\n\t\tkvm_x86_ops.set_virtual_apic_mode(vcpu);\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_is_bsp",
          "args": [
            "vcpu"
          ],
          "line": 2271
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_is_bsp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9694-9697",
          "snippet": "bool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn (vcpu->arch.apic_base & MSR_IA32_APICBASE_BSP) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&apic->lapic_timer.pending",
            "0"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_divide_count",
          "args": [
            "apic"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "update_divide_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1432-1440",
          "snippet": "static void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_update_apicv",
          "args": [
            "vcpu"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_update_apicv",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2209-2221",
          "snippet": "void kvm_apic_update_apicv(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vcpu->arch.apicv_active) {\n\t\t/* irr_pending is always true when apicv is activated. */\n\t\tapic->irr_pending = true;\n\t\tapic->isr_count = 1;\n\t} else {\n\t\tapic->irr_pending = (apic_search_irr(apic) != -1);\n\t\tapic->isr_count = count_vectors(apic->regs + APIC_ISR);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_update_apicv(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vcpu->arch.apicv_active) {\n\t\t/* irr_pending is always true when apicv is activated. */\n\t\tapic->irr_pending = true;\n\t\tapic->isr_count = 1;\n\t} else {\n\t\tapic->irr_pending = (apic_search_irr(apic) != -1);\n\t\tapic->isr_count = count_vectors(apic->regs + APIC_ISR);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_TMR + 0x10 * i",
            "0"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "161-164",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_ldr",
          "args": [
            "apic",
            "0"
          ],
          "line": 2256
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_ldr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "290-294",
          "snippet": "static inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_set_spiv",
          "args": [
            "apic",
            "0xff"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "apic_set_spiv",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "267-282",
          "snippet": "static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\n\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_sw_disabled",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_sw_disabled;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\n\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_manage_nmi_watchdog",
          "args": [
            "apic",
            "kvm_lapic_get_reg(apic, APIC_LVT0)"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "apic_manage_nmi_watchdog",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1889-1900",
          "snippet": "static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_LVT0"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "SET_APIC_DELIVERY_MODE",
          "args": [
            "0",
            "APIC_MODE_EXTINT"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_has_quirk",
          "args": [
            "vcpu->kvm",
            "KVM_X86_QUIRK_LINT0_REENABLED"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_check_has_quirk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "233-236",
          "snippet": "static inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_is_reset_bsp",
          "args": [
            "vcpu"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_is_reset_bsp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9688-9691",
          "snippet": "bool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_lvtt",
          "args": [
            "apic"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_lvtt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1465-1485",
          "snippet": "static void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tif (apic_lvtt_tscdeadline(apic) != (timer_mode ==\n\t\t\t\tAPIC_LVT_TIMER_TSCDEADLINE)) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tpreempt_disable();\n\t\t\tif (apic->lapic_timer.hv_timer_in_use)\n\t\t\t\tcancel_hv_timer(apic);\n\t\t\tpreempt_enable();\n\t\t\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\t\t\tapic->lapic_timer.period = 0;\n\t\t\tapic->lapic_timer.tscdeadline = 0;\n\t\t}\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\tlimit_periodic_timer_frequency(apic);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tif (apic_lvtt_tscdeadline(apic) != (timer_mode ==\n\t\t\t\tAPIC_LVT_TIMER_TSCDEADLINE)) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tpreempt_disable();\n\t\t\tif (apic->lapic_timer.hv_timer_in_use)\n\t\t\t\tcancel_hv_timer(apic);\n\t\t\tpreempt_enable();\n\t\t\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\t\t\tapic->lapic_timer.period = 0;\n\t\t\tapic->lapic_timer.tscdeadline = 0;\n\t\t}\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\tlimit_periodic_timer_frequency(apic);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_version",
          "args": [
            "apic->vcpu"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_version",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "337-358",
          "snippet": "void kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\t/*\n\t * KVM emulates 82093AA datasheet (with in-kernel IOAPIC implementation)\n\t * which doesn't have EOI register; Some buggy OSes (e.g. Windows with\n\t * Hyper-V role) disable EOI broadcast in lapic not checking for IOAPIC\n\t * version first and level-triggered interrupts never get EOIed in\n\t * IOAPIC.\n\t */\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))) &&\n\t    !ioapic_in_kernel(vcpu->kvm))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))"
          ],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\t/*\n\t * KVM emulates 82093AA datasheet (with in-kernel IOAPIC implementation)\n\t * which doesn't have EOI register; Some buggy OSes (e.g. Windows with\n\t * Hyper-V role) disable EOI broadcast in lapic not checking for IOAPIC\n\t * version first and level-triggered interrupts never get EOIed in\n\t * IOAPIC.\n\t */\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))) &&\n\t    !ioapic_in_kernel(vcpu->kvm))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_xapic_id",
          "args": [
            "apic",
            "vcpu->vcpu_id"
          ],
          "line": 2239
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_xapic_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "284-288",
          "snippet": "static inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tint i;\n\n\tif (!apic)\n\t\treturn;\n\n\tvcpu->kvm->arch.apic_map_dirty = false;\n\t/* Stop the timer in case it's a reset to an active apic */\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!init_event) {\n\t\tkvm_lapic_set_base(vcpu, APIC_DEFAULT_PHYS_BASE |\n\t\t                         MSR_IA32_APICBASE_ENABLE);\n\t\tkvm_apic_set_xapic_id(apic, vcpu->vcpu_id);\n\t}\n\tkvm_apic_set_version(apic->vcpu);\n\n\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++)\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i, APIC_LVT_MASKED);\n\tapic_update_lvtt(apic);\n\tif (kvm_vcpu_is_reset_bsp(vcpu) &&\n\t    kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_LINT0_REENABLED))\n\t\tkvm_lapic_set_reg(apic, APIC_LVT0,\n\t\t\t     SET_APIC_DELIVERY_MODE(0, APIC_MODE_EXTINT));\n\tapic_manage_nmi_watchdog(apic, kvm_lapic_get_reg(apic, APIC_LVT0));\n\n\tkvm_lapic_set_reg(apic, APIC_DFR, 0xffffffffU);\n\tapic_set_spiv(apic, 0xff);\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, 0);\n\tif (!apic_x2apic_mode(apic))\n\t\tkvm_apic_set_ldr(apic, 0);\n\tkvm_lapic_set_reg(apic, APIC_ESR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR, 0);\n\tkvm_lapic_set_reg(apic, APIC_ICR2, 0);\n\tkvm_lapic_set_reg(apic, APIC_TDCR, 0);\n\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\tfor (i = 0; i < 8; i++) {\n\t\tkvm_lapic_set_reg(apic, APIC_IRR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_ISR + 0x10 * i, 0);\n\t\tkvm_lapic_set_reg(apic, APIC_TMR + 0x10 * i, 0);\n\t}\n\tkvm_apic_update_apicv(vcpu);\n\tapic->highest_isr_cache = -1;\n\tupdate_divide_count(apic);\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\tif (kvm_vcpu_is_bsp(vcpu))\n\t\tkvm_lapic_set_base(vcpu,\n\t\t\t\tvcpu->arch.apic_base | MSR_IA32_APICBASE_BSP);\n\tvcpu->arch.pv_eoi.msr_val = 0;\n\tapic_update_ppr(apic);\n\tif (vcpu->arch.apicv_active) {\n\t\tkvm_x86_ops.apicv_post_state_restore(vcpu);\n\t\tkvm_x86_ops.hwapic_irr_update(vcpu, -1);\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu, -1);\n\t}\n\n\tvcpu->arch.apic_arb_prio = 0;\n\tvcpu->arch.apic_attention = 0;\n\n\tkvm_recalculate_apic_map(vcpu->kvm);\n}"
  },
  {
    "function_name": "kvm_apic_update_apicv",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2209-2221",
    "snippet": "void kvm_apic_update_apicv(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vcpu->arch.apicv_active) {\n\t\t/* irr_pending is always true when apicv is activated. */\n\t\tapic->irr_pending = true;\n\t\tapic->isr_count = 1;\n\t} else {\n\t\tapic->irr_pending = (apic_search_irr(apic) != -1);\n\t\tapic->isr_count = count_vectors(apic->regs + APIC_ISR);\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_vectors",
          "args": [
            "apic->regs + APIC_ISR"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "count_vectors",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "383-395",
          "snippet": "static u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VECTORS_PER_REG\t\t32",
            "#define MAX_APIC_VECTOR\t\t\t256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VECTORS_PER_REG\t\t32\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_search_irr",
          "args": [
            "apic"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "apic_search_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "435-438",
          "snippet": "static inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_update_apicv(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (vcpu->arch.apicv_active) {\n\t\t/* irr_pending is always true when apicv is activated. */\n\t\tapic->irr_pending = true;\n\t\tapic->isr_count = 1;\n\t} else {\n\t\tapic->irr_pending = (apic_search_irr(apic) != -1);\n\t\tapic->isr_count = count_vectors(apic->regs + APIC_ISR);\n\t}\n}"
  },
  {
    "function_name": "kvm_lapic_set_base",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2168-2207",
    "snippet": "void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic)\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\n\tvcpu->arch.apic_base = value;\n\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE)\n\t\tkvm_update_cpuid(vcpu);\n\n\tif (!apic)\n\t\treturn;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE) {\n\t\t\tkvm_apic_set_xapic_id(apic, vcpu->vcpu_id);\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\t} else {\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\t\tvcpu->kvm->arch.apic_map_dirty = true;\n\t\t}\n\t}\n\n\tif (((old_value ^ value) & X2APIC_ENABLE) && (value & X2APIC_ENABLE))\n\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\n\tif ((old_value ^ value) & (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE))\n\t\tkvm_x86_ops.set_virtual_apic_mode(vcpu);\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct static_key_deferred apic_hw_disabled",
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"APIC base relocation is unsupported by KVM\""
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.set_virtual_apic_mode",
          "args": [
            "vcpu"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_x2apic_id",
          "args": [
            "apic",
            "vcpu->vcpu_id"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_x2apic_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "301-310",
          "snippet": "static inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u32 id)\n{\n\tu32 ldr = kvm_apic_calc_x2apic_ldr(id);\n\n\tWARN_ON_ONCE(id != apic->vcpu->vcpu_id);\n\n\tkvm_lapic_set_reg(apic, APIC_ID, id);\n\tkvm_lapic_set_reg(apic, APIC_LDR, ldr);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u32 id)\n{\n\tu32 ldr = kvm_apic_calc_x2apic_ldr(id);\n\n\tWARN_ON_ONCE(id != apic->vcpu->vcpu_id);\n\n\tkvm_lapic_set_reg(apic, APIC_ID, id);\n\tkvm_lapic_set_reg(apic, APIC_LDR, ldr);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_slow_inc",
          "args": [
            "&apic_hw_disabled.key"
          ],
          "line": 2190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_slow_dec_deferred",
          "args": [
            "&apic_hw_disabled"
          ],
          "line": 2188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_xapic_id",
          "args": [
            "apic",
            "vcpu->vcpu_id"
          ],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_xapic_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "284-288",
          "snippet": "static inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_update_cpuid",
          "args": [
            "vcpu"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_update_cpuid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.c",
          "lines": "57-133",
          "snippet": "int kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (boot_cpu_has(X86_FEATURE_XSAVE) && best->function == 0x1)\n\t\tcpuid_entry_change(best, X86_FEATURE_OSXSAVE,\n\t\t\t\t   kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE));\n\n\tcpuid_entry_change(best, X86_FEATURE_APIC,\n\t\t\t   vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE);\n\n\tif (apic) {\n\t\tif (cpuid_entry_has(best, X86_FEATURE_TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best && boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7)\n\t\tcpuid_entry_change(best, X86_FEATURE_OSPKE,\n\t\t\t\t   kvm_read_cr4_bits(vcpu, X86_CR4_PKE));\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) & supported_xcr0;\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (cpuid_entry_has(best, X86_FEATURE_XSAVES) ||\n\t\t     cpuid_entry_has(best, X86_FEATURE_XSAVEC)))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit or 57-bit in the\n\t * canonical address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best) {\n\t\tint vaddr_bits = (best->eax & 0xff00) >> 8;\n\n\t\tif (vaddr_bits != 48 && vaddr_bits != 57 && vaddr_bits != 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, KVM_CPUID_FEATURES, 0);\n\tif (kvm_hlt_in_guest(vcpu->kvm) && best &&\n\t\t(best->eax & (1 << KVM_FEATURE_PV_UNHALT)))\n\t\tbest->eax &= ~(1 << KVM_FEATURE_PV_UNHALT);\n\n\tif (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT)) {\n\t\tbest = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\t\tif (best)\n\t\t\tcpuid_entry_change(best, X86_FEATURE_MWAIT,\n\t\t\t\t\t   vcpu->arch.ia32_misc_enable_msr &\n\t\t\t\t\t   MSR_IA32_MISC_ENABLE_MWAIT);\n\t}\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\tkvm_mmu_reset_context(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/processor.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/processor.h>\n#include <linux/sched/stat.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/kvm_host.h>\n\nint kvm_update_cpuid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 1, 0);\n\tif (!best)\n\t\treturn 0;\n\n\t/* Update OSXSAVE bit */\n\tif (boot_cpu_has(X86_FEATURE_XSAVE) && best->function == 0x1)\n\t\tcpuid_entry_change(best, X86_FEATURE_OSXSAVE,\n\t\t\t\t   kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE));\n\n\tcpuid_entry_change(best, X86_FEATURE_APIC,\n\t\t\t   vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE);\n\n\tif (apic) {\n\t\tif (cpuid_entry_has(best, X86_FEATURE_TSC_DEADLINE_TIMER))\n\t\t\tapic->lapic_timer.timer_mode_mask = 3 << 17;\n\t\telse\n\t\t\tapic->lapic_timer.timer_mode_mask = 1 << 17;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (best && boot_cpu_has(X86_FEATURE_PKU) && best->function == 0x7)\n\t\tcpuid_entry_change(best, X86_FEATURE_OSPKE,\n\t\t\t\t   kvm_read_cr4_bits(vcpu, X86_CR4_PKE));\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 0);\n\tif (!best) {\n\t\tvcpu->arch.guest_supported_xcr0 = 0;\n\t\tvcpu->arch.guest_xstate_size = XSAVE_HDR_SIZE + XSAVE_HDR_OFFSET;\n\t} else {\n\t\tvcpu->arch.guest_supported_xcr0 =\n\t\t\t(best->eax | ((u64)best->edx << 32)) & supported_xcr0;\n\t\tvcpu->arch.guest_xstate_size = best->ebx =\n\t\t\txstate_required_size(vcpu->arch.xcr0, false);\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0xD, 1);\n\tif (best && (cpuid_entry_has(best, X86_FEATURE_XSAVES) ||\n\t\t     cpuid_entry_has(best, X86_FEATURE_XSAVEC)))\n\t\tbest->ebx = xstate_required_size(vcpu->arch.xcr0, true);\n\n\t/*\n\t * The existing code assumes virtual address is 48-bit or 57-bit in the\n\t * canonical address checks; exit if it is ever changed.\n\t */\n\tbest = kvm_find_cpuid_entry(vcpu, 0x80000008, 0);\n\tif (best) {\n\t\tint vaddr_bits = (best->eax & 0xff00) >> 8;\n\n\t\tif (vaddr_bits != 48 && vaddr_bits != 57 && vaddr_bits != 0)\n\t\t\treturn -EINVAL;\n\t}\n\n\tbest = kvm_find_cpuid_entry(vcpu, KVM_CPUID_FEATURES, 0);\n\tif (kvm_hlt_in_guest(vcpu->kvm) && best &&\n\t\t(best->eax & (1 << KVM_FEATURE_PV_UNHALT)))\n\t\tbest->eax &= ~(1 << KVM_FEATURE_PV_UNHALT);\n\n\tif (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT)) {\n\t\tbest = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\t\tif (best)\n\t\t\tcpuid_entry_change(best, X86_FEATURE_MWAIT,\n\t\t\t\t\t   vcpu->arch.ia32_misc_enable_msr &\n\t\t\t\t\t   MSR_IA32_MISC_ENABLE_MWAIT);\n\t}\n\n\t/* Update physical-address width */\n\tvcpu->arch.maxphyaddr = cpuid_query_maxphyaddr(vcpu);\n\tkvm_mmu_reset_context(vcpu);\n\n\tkvm_pmu_refresh(vcpu);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_hw_disabled;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)\n{\n\tu64 old_value = vcpu->arch.apic_base;\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!apic)\n\t\tvalue |= MSR_IA32_APICBASE_BSP;\n\n\tvcpu->arch.apic_base = value;\n\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE)\n\t\tkvm_update_cpuid(vcpu);\n\n\tif (!apic)\n\t\treturn;\n\n\t/* update jump label if enable bit changes */\n\tif ((old_value ^ value) & MSR_IA32_APICBASE_ENABLE) {\n\t\tif (value & MSR_IA32_APICBASE_ENABLE) {\n\t\t\tkvm_apic_set_xapic_id(apic, vcpu->vcpu_id);\n\t\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\t\t} else {\n\t\t\tstatic_key_slow_inc(&apic_hw_disabled.key);\n\t\t\tvcpu->kvm->arch.apic_map_dirty = true;\n\t\t}\n\t}\n\n\tif (((old_value ^ value) & X2APIC_ENABLE) && (value & X2APIC_ENABLE))\n\t\tkvm_apic_set_x2apic_id(apic, vcpu->vcpu_id);\n\n\tif ((old_value ^ value) & (MSR_IA32_APICBASE_ENABLE | X2APIC_ENABLE))\n\t\tkvm_x86_ops.set_virtual_apic_mode(vcpu);\n\n\tapic->base_address = apic->vcpu->arch.apic_base &\n\t\t\t     MSR_IA32_APICBASE_BASE;\n\n\tif ((value & MSR_IA32_APICBASE_ENABLE) &&\n\t     apic->base_address != APIC_DEFAULT_PHYS_BASE)\n\t\tpr_warn_once(\"APIC base relocation is unsupported by KVM\");\n}"
  },
  {
    "function_name": "kvm_lapic_get_cr8",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2159-2166",
    "snippet": "u64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\ttpr = (u64) kvm_lapic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "vcpu->arch.apic",
            "APIC_TASKPRI"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nu64 kvm_lapic_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tu64 tpr;\n\n\ttpr = (u64) kvm_lapic_get_reg(vcpu->arch.apic, APIC_TASKPRI);\n\n\treturn (tpr & 0xf0) >> 4;\n}"
  },
  {
    "function_name": "kvm_lapic_set_tpr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2151-2157",
    "snippet": "void kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_set_tpr",
          "args": [
            "apic",
            "((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4)"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_tpr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2151-2157",
          "snippet": "void kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TASKPRI"
          ],
          "line": 2156
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}"
  },
  {
    "function_name": "kvm_set_lapic_tscdeadline_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2138-2149",
    "snippet": "void kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic->lapic_timer.tscdeadline = data;\n\tstart_apic_timer(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_apic_timer",
          "args": [
            "apic"
          ],
          "line": 2148
        },
        "resolved": true,
        "details": {
          "function_name": "start_apic_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1878-1887",
          "snippet": "static void start_apic_timer(struct kvm_lapic *apic)\n{\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif ((apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t    && !set_target_expiration(apic))\n\t\treturn;\n\n\trestart_apic_timer(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif ((apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t    && !set_target_expiration(apic))\n\t\treturn;\n\n\trestart_apic_timer(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 2143
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "322-325",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_oneshot",
          "args": [
            "apic"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_oneshot",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "317-320",
          "snippet": "static inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2142
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_set_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) || apic_lvtt_oneshot(apic) ||\n\t\t\tapic_lvtt_period(apic))\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\tapic->lapic_timer.tscdeadline = data;\n\tstart_apic_timer(apic);\n}"
  },
  {
    "function_name": "kvm_get_lapic_tscdeadline_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2127-2136",
    "snippet": "u64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) ||\n\t\t!apic_lvtt_tscdeadline(apic))\n\t\treturn 0;\n\n\treturn apic->lapic_timer.tscdeadline;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "327-330",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nu64 kvm_get_lapic_tscdeadline_msr(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu) ||\n\t\t!apic_lvtt_tscdeadline(apic))\n\t\treturn 0;\n\n\treturn apic->lapic_timer.tscdeadline;\n}"
  },
  {
    "function_name": "kvm_free_lapic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2101-2120",
    "snippet": "void kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!apic->sw_enabled)\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct static_key_deferred apic_hw_disabled",
      "struct static_key_deferred apic_sw_disabled",
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "apic"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)apic->regs"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2066-2075",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_slow_dec_deferred",
          "args": [
            "&apic_sw_disabled"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_slow_dec_deferred",
          "args": [
            "&apic_hw_disabled"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 2108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_hw_disabled;\nstruct static_key_deferred apic_sw_disabled;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_free_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!vcpu->arch.apic)\n\t\treturn;\n\n\thrtimer_cancel(&apic->lapic_timer.timer);\n\n\tif (!(vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE))\n\t\tstatic_key_slow_dec_deferred(&apic_hw_disabled);\n\n\tif (!apic->sw_enabled)\n\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\n\tif (apic->regs)\n\t\tfree_page((unsigned long)apic->regs);\n\n\tkfree(apic);\n}"
  },
  {
    "function_name": "kvm_apic_write_nodecode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2087-2098",
    "snippet": "void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)\n{\n\tu32 val = 0;\n\n\t/* hw has done the conditional check and inst decode */\n\toffset &= 0xff0;\n\n\tkvm_lapic_reg_read(vcpu->arch.apic, offset, 4, &val);\n\n\t/* TODO: optimize to just emulate side effect w/o one more write */\n\tkvm_lapic_reg_write(vcpu->arch.apic, offset, val);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "vcpu->arch.apic",
            "offset",
            "val"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1902-2044",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_reg_read",
          "args": [
            "vcpu->arch.apic",
            "offset",
            "4",
            "&val"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1347-1400",
          "snippet": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tu64 valid_reg_mask =\n\t\tAPIC_REG_MASK(APIC_ID) |\n\t\tAPIC_REG_MASK(APIC_LVR) |\n\t\tAPIC_REG_MASK(APIC_TASKPRI) |\n\t\tAPIC_REG_MASK(APIC_PROCPRI) |\n\t\tAPIC_REG_MASK(APIC_LDR) |\n\t\tAPIC_REG_MASK(APIC_DFR) |\n\t\tAPIC_REG_MASK(APIC_SPIV) |\n\t\tAPIC_REGS_MASK(APIC_ISR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_TMR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_IRR, APIC_ISR_NR) |\n\t\tAPIC_REG_MASK(APIC_ESR) |\n\t\tAPIC_REG_MASK(APIC_ICR) |\n\t\tAPIC_REG_MASK(APIC_ICR2) |\n\t\tAPIC_REG_MASK(APIC_LVTT) |\n\t\tAPIC_REG_MASK(APIC_LVTTHMR) |\n\t\tAPIC_REG_MASK(APIC_LVTPC) |\n\t\tAPIC_REG_MASK(APIC_LVT0) |\n\t\tAPIC_REG_MASK(APIC_LVT1) |\n\t\tAPIC_REG_MASK(APIC_LVTERR) |\n\t\tAPIC_REG_MASK(APIC_TMICT) |\n\t\tAPIC_REG_MASK(APIC_TMCCT) |\n\t\tAPIC_REG_MASK(APIC_TDCR);\n\n\t/* ARBPRI is not valid on x2APIC */\n\tif (!apic_x2apic_mode(apic))\n\t\tvalid_reg_mask |= APIC_REG_MASK(APIC_ARBPRI);\n\n\tif (offset > 0x3f0 || !(valid_reg_mask & APIC_REG_MASK(offset)))\n\t\treturn 1;\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tu64 valid_reg_mask =\n\t\tAPIC_REG_MASK(APIC_ID) |\n\t\tAPIC_REG_MASK(APIC_LVR) |\n\t\tAPIC_REG_MASK(APIC_TASKPRI) |\n\t\tAPIC_REG_MASK(APIC_PROCPRI) |\n\t\tAPIC_REG_MASK(APIC_LDR) |\n\t\tAPIC_REG_MASK(APIC_DFR) |\n\t\tAPIC_REG_MASK(APIC_SPIV) |\n\t\tAPIC_REGS_MASK(APIC_ISR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_TMR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_IRR, APIC_ISR_NR) |\n\t\tAPIC_REG_MASK(APIC_ESR) |\n\t\tAPIC_REG_MASK(APIC_ICR) |\n\t\tAPIC_REG_MASK(APIC_ICR2) |\n\t\tAPIC_REG_MASK(APIC_LVTT) |\n\t\tAPIC_REG_MASK(APIC_LVTTHMR) |\n\t\tAPIC_REG_MASK(APIC_LVTPC) |\n\t\tAPIC_REG_MASK(APIC_LVT0) |\n\t\tAPIC_REG_MASK(APIC_LVT1) |\n\t\tAPIC_REG_MASK(APIC_LVTERR) |\n\t\tAPIC_REG_MASK(APIC_TMICT) |\n\t\tAPIC_REG_MASK(APIC_TMCCT) |\n\t\tAPIC_REG_MASK(APIC_TDCR);\n\n\t/* ARBPRI is not valid on x2APIC */\n\tif (!apic_x2apic_mode(apic))\n\t\tvalid_reg_mask |= APIC_REG_MASK(APIC_ARBPRI);\n\n\tif (offset > 0x3f0 || !(valid_reg_mask & APIC_REG_MASK(offset)))\n\t\treturn 1;\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)\n{\n\tu32 val = 0;\n\n\t/* hw has done the conditional check and inst decode */\n\toffset &= 0xff0;\n\n\tkvm_lapic_reg_read(vcpu->arch.apic, offset, 4, &val);\n\n\t/* TODO: optimize to just emulate side effect w/o one more write */\n\tkvm_lapic_reg_write(vcpu->arch.apic, offset, val);\n}"
  },
  {
    "function_name": "kvm_lapic_set_eoi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2080-2083",
    "snippet": "void kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "vcpu->arch.apic",
            "APIC_EOI",
            "0"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1902-2044",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}"
  },
  {
    "function_name": "apic_mmio_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "2047-2078",
    "snippet": "static int apic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t    gpa_t address, int len, const void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tunsigned int offset = address - apic->base_address;\n\tu32 val;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {\n\t\tif (!kvm_check_has_quirk(vcpu->kvm,\n\t\t\t\t\t KVM_X86_QUIRK_LAPIC_MMIO_HOLE))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * APIC register must be aligned on 128-bits boundary.\n\t * 32/64/128 bits registers must be accessed thru 32 bits.\n\t * Refer SDM 8.4.1\n\t */\n\tif (len != 4 || (offset & 0xf))\n\t\treturn 0;\n\n\tval = *(u32*)data;\n\n\tkvm_lapic_reg_write(apic, offset & 0xff0, val);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "offset & 0xff0",
            "val"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1902-2044",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_has_quirk",
          "args": [
            "vcpu->kvm",
            "KVM_X86_QUIRK_LAPIC_MMIO_HOLE"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_check_has_quirk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "233-236",
          "snippet": "static inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "apic"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "177-182",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_mmio_in_range",
          "args": [
            "apic",
            "address"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "apic_mmio_in_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1403-1407",
          "snippet": "static int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn addr >= apic->base_address &&\n\t\taddr < apic->base_address + LAPIC_MMIO_LENGTH;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define LAPIC_MMIO_LENGTH\t\t(1 << 12)"
          ],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn addr >= apic->base_address &&\n\t\taddr < apic->base_address + LAPIC_MMIO_LENGTH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_lapic",
          "args": [
            "this"
          ],
          "line": 2050
        },
        "resolved": true,
        "details": {
          "function_name": "to_lapic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1338-1341",
          "snippet": "static inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int apic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t    gpa_t address, int len, const void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tunsigned int offset = address - apic->base_address;\n\tu32 val;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {\n\t\tif (!kvm_check_has_quirk(vcpu->kvm,\n\t\t\t\t\t KVM_X86_QUIRK_LAPIC_MMIO_HOLE))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * APIC register must be aligned on 128-bits boundary.\n\t * 32/64/128 bits registers must be accessed thru 32 bits.\n\t * Refer SDM 8.4.1\n\t */\n\tif (len != 4 || (offset & 0xf))\n\t\treturn 0;\n\n\tval = *(u32*)data;\n\n\tkvm_lapic_reg_write(apic, offset & 0xff0, val);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_lapic_reg_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1902-2044",
    "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};",
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_recalculate_apic_map",
          "args": [
            "apic->vcpu->kvm"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_recalculate_apic_map",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "167-265",
          "snippet": "void kvm_recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tu32 max_id = 255; /* enough space for any xAPIC ID */\n\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/*\n\t\t * Read kvm->arch.apic_map_dirty before\n\t\t * kvm->arch.apic_map\n\t\t */\n\t\tsmp_rmb();\n\t\treturn;\n\t}\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/* Someone else has updated the map. */\n\t\tmutex_unlock(&kvm->arch.apic_map_lock);\n\t\treturn;\n\t}\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (kvm_apic_present(vcpu))\n\t\t\tmax_id = max(max_id, kvm_x2apic_id(vcpu->arch.apic));\n\n\tnew = kvzalloc(sizeof(struct kvm_apic_map) +\n\t                   sizeof(struct kvm_lapic *) * ((u64)max_id + 1),\n\t\t\t   GFP_KERNEL_ACCOUNT);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->max_apic_id = max_id;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tstruct kvm_lapic **cluster;\n\t\tu16 mask;\n\t\tu32 ldr;\n\t\tu8 xapic_id;\n\t\tu32 x2apic_id;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\txapic_id = kvm_xapic_id(apic);\n\t\tx2apic_id = kvm_x2apic_id(apic);\n\n\t\t/* Hotplug hack: see kvm_apic_match_physical_addr(), ... */\n\t\tif ((apic_x2apic_mode(apic) || x2apic_id > 0xff) &&\n\t\t\t\tx2apic_id <= new->max_apic_id)\n\t\t\tnew->phys_map[x2apic_id] = apic;\n\t\t/*\n\t\t * ... xAPIC ID of VCPUs with APIC ID > 0xff will wrap-around,\n\t\t * prevent them from masking VCPUs with APIC ID <= 0xff.\n\t\t */\n\t\tif (!apic_x2apic_mode(apic) && !new->phys_map[xapic_id])\n\t\t\tnew->phys_map[xapic_id] = apic;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tcontinue;\n\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))\n\t\t\tcontinue;\n\n\t\tif (mask)\n\t\t\tcluster[ffs(mask) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\t/*\n\t * Write kvm->arch.apic_map before\n\t * clearing apic->apic_map_dirty\n\t */\n\tsmp_wmb();\n\tkvm->arch.apic_map_dirty = false;\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tcall_rcu(&old->rcu, kvm_apic_map_free);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tu32 max_id = 255; /* enough space for any xAPIC ID */\n\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/*\n\t\t * Read kvm->arch.apic_map_dirty before\n\t\t * kvm->arch.apic_map\n\t\t */\n\t\tsmp_rmb();\n\t\treturn;\n\t}\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/* Someone else has updated the map. */\n\t\tmutex_unlock(&kvm->arch.apic_map_lock);\n\t\treturn;\n\t}\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (kvm_apic_present(vcpu))\n\t\t\tmax_id = max(max_id, kvm_x2apic_id(vcpu->arch.apic));\n\n\tnew = kvzalloc(sizeof(struct kvm_apic_map) +\n\t                   sizeof(struct kvm_lapic *) * ((u64)max_id + 1),\n\t\t\t   GFP_KERNEL_ACCOUNT);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->max_apic_id = max_id;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tstruct kvm_lapic **cluster;\n\t\tu16 mask;\n\t\tu32 ldr;\n\t\tu8 xapic_id;\n\t\tu32 x2apic_id;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\txapic_id = kvm_xapic_id(apic);\n\t\tx2apic_id = kvm_x2apic_id(apic);\n\n\t\t/* Hotplug hack: see kvm_apic_match_physical_addr(), ... */\n\t\tif ((apic_x2apic_mode(apic) || x2apic_id > 0xff) &&\n\t\t\t\tx2apic_id <= new->max_apic_id)\n\t\t\tnew->phys_map[x2apic_id] = apic;\n\t\t/*\n\t\t * ... xAPIC ID of VCPUs with APIC ID > 0xff will wrap-around,\n\t\t * prevent them from masking VCPUs with APIC ID <= 0xff.\n\t\t */\n\t\tif (!apic_x2apic_mode(apic) && !new->phys_map[xapic_id])\n\t\t\tnew->phys_map[xapic_id] = apic;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tcontinue;\n\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))\n\t\t\tcontinue;\n\n\t\tif (mask)\n\t\t\tcluster[ffs(mask) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\t/*\n\t * Write kvm->arch.apic_map before\n\t * clearing apic->apic_map_dirty\n\t */\n\tsmp_wmb();\n\tkvm->arch.apic_map_dirty = false;\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tcall_rcu(&old->rcu, kvm_apic_map_free);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "APIC_ICR",
            "0x40000 | (val & 0xff)"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1902-2044",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "restart_apic_timer",
          "args": [
            "apic"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "restart_apic_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1818-1829",
          "snippet": "static void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_target_expiration",
          "args": [
            "apic",
            "old_divisor"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "update_target_expiration",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1654-1676",
          "snippet": "static void update_target_expiration(struct kvm_lapic *apic, uint32_t old_divisor)\n{\n\tktime_t now, remaining;\n\tu64 ns_remaining_old, ns_remaining_new;\n\n\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t* APIC_BUS_CYCLE_NS * apic->divide_count;\n\tlimit_periodic_timer_frequency(apic);\n\n\tnow = ktime_get();\n\tremaining = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = 0;\n\n\tns_remaining_old = ktime_to_ns(remaining);\n\tns_remaining_new = mul_u64_u32_div(ns_remaining_old,\n\t                                   apic->divide_count, old_divisor);\n\n\tapic->lapic_timer.tscdeadline +=\n\t\tnsec_to_cycles(apic->vcpu, ns_remaining_new) -\n\t\tnsec_to_cycles(apic->vcpu, ns_remaining_old);\n\tapic->lapic_timer.target_expiration = ktime_add_ns(now, ns_remaining_new);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void update_target_expiration(struct kvm_lapic *apic, uint32_t old_divisor)\n{\n\tktime_t now, remaining;\n\tu64 ns_remaining_old, ns_remaining_new;\n\n\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t* APIC_BUS_CYCLE_NS * apic->divide_count;\n\tlimit_periodic_timer_frequency(apic);\n\n\tnow = ktime_get();\n\tremaining = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = 0;\n\n\tns_remaining_old = ktime_to_ns(remaining);\n\tns_remaining_new = mul_u64_u32_div(ns_remaining_old,\n\t                                   apic->divide_count, old_divisor);\n\n\tapic->lapic_timer.tscdeadline +=\n\t\tnsec_to_cycles(apic->vcpu, ns_remaining_new) -\n\t\tnsec_to_cycles(apic->vcpu, ns_remaining_old);\n\tapic->lapic_timer.target_expiration = ktime_add_ns(now, ns_remaining_new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_divide_count",
          "args": [
            "apic"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "update_divide_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1432-1440",
          "snippet": "static void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_TDCR",
            "val"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "161-164",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_apic_timer",
          "args": [
            "apic"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "start_apic_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1878-1887",
          "snippet": "static void start_apic_timer(struct kvm_lapic *apic)\n{\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif ((apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t    && !set_target_expiration(apic))\n\t\treturn;\n\n\trestart_apic_timer(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif ((apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t    && !set_target_expiration(apic))\n\t\treturn;\n\n\trestart_apic_timer(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "327-330",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_lvtt",
          "args": [
            "apic"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "apic_update_lvtt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1465-1485",
          "snippet": "static void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tif (apic_lvtt_tscdeadline(apic) != (timer_mode ==\n\t\t\t\tAPIC_LVT_TIMER_TSCDEADLINE)) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tpreempt_disable();\n\t\t\tif (apic->lapic_timer.hv_timer_in_use)\n\t\t\t\tcancel_hv_timer(apic);\n\t\t\tpreempt_enable();\n\t\t\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\t\t\tapic->lapic_timer.period = 0;\n\t\t\tapic->lapic_timer.tscdeadline = 0;\n\t\t}\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\tlimit_periodic_timer_frequency(apic);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tif (apic_lvtt_tscdeadline(apic) != (timer_mode ==\n\t\t\t\tAPIC_LVT_TIMER_TSCDEADLINE)) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tpreempt_disable();\n\t\t\tif (apic->lapic_timer.hv_timer_in_use)\n\t\t\t\tcancel_hv_timer(apic);\n\t\t\tpreempt_enable();\n\t\t\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\t\t\tapic->lapic_timer.period = 0;\n\t\t\tapic->lapic_timer.tscdeadline = 0;\n\t\t}\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\tlimit_periodic_timer_frequency(apic);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_sw_enabled",
          "args": [
            "apic"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_sw_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "186-191",
          "snippet": "static inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "(reg - APIC_LVTT) >> 4",
            "size"
          ],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "apic_lvt_mask"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_manage_nmi_watchdog",
          "args": [
            "apic",
            "val"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "apic_manage_nmi_watchdog",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1889-1900",
          "snippet": "static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_send_ipi",
          "args": [
            "apic",
            "val",
            "kvm_lapic_get_reg(apic, APIC_ICR2)"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_send_ipi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1244-1263",
          "snippet": "void kvm_apic_send_ipi(struct kvm_lapic *apic, u32 icr_low, u32 icr_high)\n{\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = (icr_low & APIC_INT_ASSERT) != 0;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tirq.msi_redir_hint = false;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_send_ipi(struct kvm_lapic *apic, u32 icr_low, u32 icr_high)\n{\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = (icr_low & APIC_INT_ASSERT) != 0;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tirq.msi_redir_hint = false;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_ICR2"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&apic->lapic_timer.pending",
            "0"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_set_spiv",
          "args": [
            "apic",
            "val & mask"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "apic_set_spiv",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "267-282",
          "snippet": "static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\n\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct static_key_deferred apic_sw_disabled",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_sw_disabled;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\n\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_ldr",
          "args": [
            "apic",
            "val & APIC_LDR_MASK"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_ldr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "290-294",
          "snippet": "static inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_set_eoi",
          "args": [
            "apic"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2080-2083",
          "snippet": "void kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_set_tpr",
          "args": [
            "apic",
            "val & 0xff"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_tpr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2151-2157",
          "snippet": "void kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_set_tpr(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tapic_set_tpr(apic, ((cr8 & 0x0f) << 4)\n\t\t     | (kvm_lapic_get_reg(apic, APIC_TASKPRI) & 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_tpr_access",
          "args": [
            "apic",
            "true"
          ],
          "line": 1917
        },
        "resolved": true,
        "details": {
          "function_name": "report_tpr_access",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1300-1304",
          "snippet": "static inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_xapic_id",
          "args": [
            "apic",
            "val >> 24"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_xapic_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "284-288",
          "snippet": "static inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_apic_write",
          "args": [
            "reg",
            "val"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "apic_manage_nmi_watchdog",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1889-1900",
    "snippet": "static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&apic->vcpu->kvm->arch.vapics_in_nmi_mode"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&apic->vcpu->kvm->arch.vapics_in_nmi_mode"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvt_nmi_mode",
          "args": [
            "lvt0_val"
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvt_nmi_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "332-335",
          "snippet": "static inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)\n{\n\tbool lvt0_in_nmi_mode = apic_lvt_nmi_mode(lvt0_val);\n\n\tif (apic->lvt0_in_nmi_mode != lvt0_in_nmi_mode) {\n\t\tapic->lvt0_in_nmi_mode = lvt0_in_nmi_mode;\n\t\tif (lvt0_in_nmi_mode) {\n\t\t\tatomic_inc(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t\t} else\n\t\t\tatomic_dec(&apic->vcpu->kvm->arch.vapics_in_nmi_mode);\n\t}\n}"
  },
  {
    "function_name": "start_apic_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1878-1887",
    "snippet": "static void start_apic_timer(struct kvm_lapic *apic)\n{\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif ((apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t    && !set_target_expiration(apic))\n\t\treturn;\n\n\trestart_apic_timer(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "restart_apic_timer",
          "args": [
            "apic"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "restart_apic_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1818-1829",
          "snippet": "static void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_target_expiration",
          "args": [
            "apic"
          ],
          "line": 1883
        },
        "resolved": true,
        "details": {
          "function_name": "set_target_expiration",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1678-1699",
          "snippet": "static bool set_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\tu64 tscl = rdtsc();\n\n\tnow = ktime_get();\n\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t* APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\tif (!apic->lapic_timer.period) {\n\t\tapic->lapic_timer.tscdeadline = 0;\n\t\treturn false;\n\t}\n\n\tlimit_periodic_timer_frequency(apic);\n\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, apic->lapic_timer.period);\n\tapic->lapic_timer.target_expiration = ktime_add_ns(now, apic->lapic_timer.period);\n\n\treturn true;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool set_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\tu64 tscl = rdtsc();\n\n\tnow = ktime_get();\n\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t* APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\tif (!apic->lapic_timer.period) {\n\t\tapic->lapic_timer.tscdeadline = 0;\n\t\treturn false;\n\t}\n\n\tlimit_periodic_timer_frequency(apic);\n\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, apic->lapic_timer.period);\n\tapic->lapic_timer.target_expiration = ktime_add_ns(now, apic->lapic_timer.period);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_oneshot",
          "args": [
            "apic"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_oneshot",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "317-320",
          "snippet": "static inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "322-325",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&apic->lapic_timer.pending",
            "0"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void start_apic_timer(struct kvm_lapic *apic)\n{\n\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\tif ((apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t    && !set_target_expiration(apic))\n\t\treturn;\n\n\trestart_apic_timer(apic);\n}"
  },
  {
    "function_name": "kvm_lapic_restart_hv_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1870-1876",
    "snippet": "void kvm_lapic_restart_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\trestart_apic_timer(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "restart_apic_timer",
          "args": [
            "apic"
          ],
          "line": 1875
        },
        "resolved": true,
        "details": {
          "function_name": "restart_apic_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1818-1829",
          "snippet": "static void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!apic->lapic_timer.hv_timer_in_use"
          ],
          "line": 1874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_restart_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\trestart_apic_timer(apic);\n}"
  },
  {
    "function_name": "kvm_lapic_switch_to_sw_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1858-1867",
    "snippet": "void kvm_lapic_switch_to_sw_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tpreempt_disable();\n\t/* Possibly the TSC deadline timer is not enabled yet */\n\tif (apic->lapic_timer.hv_timer_in_use)\n\t\tstart_sw_timer(apic);\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_sw_timer",
          "args": [
            "apic"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "start_sw_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1801-1816",
          "snippet": "static void start_sw_timer(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tWARN_ON(preemptible());\n\tif (apic->lapic_timer.hv_timer_in_use)\n\t\tcancel_hv_timer(apic);\n\tif (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending))\n\t\treturn;\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t\tstart_sw_period(apic);\n\telse if (apic_lvtt_tscdeadline(apic))\n\t\tstart_sw_tscdeadline(apic);\n\ttrace_kvm_hv_timer_state(apic->vcpu->vcpu_id, false);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void start_sw_timer(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tWARN_ON(preemptible());\n\tif (apic->lapic_timer.hv_timer_in_use)\n\t\tcancel_hv_timer(apic);\n\tif (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending))\n\t\treturn;\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t\tstart_sw_period(apic);\n\telse if (apic_lvtt_tscdeadline(apic))\n\t\tstart_sw_tscdeadline(apic);\n\ttrace_kvm_hv_timer_state(apic->vcpu->vcpu_id, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_switch_to_sw_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tpreempt_disable();\n\t/* Possibly the TSC deadline timer is not enabled yet */\n\tif (apic->lapic_timer.hv_timer_in_use)\n\t\tstart_sw_timer(apic);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "kvm_lapic_switch_to_hv_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1852-1855",
    "snippet": "void kvm_lapic_switch_to_hv_timer(struct kvm_vcpu *vcpu)\n{\n\trestart_apic_timer(vcpu->arch.apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "restart_apic_timer",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "restart_apic_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1818-1829",
          "snippet": "static void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_switch_to_hv_timer(struct kvm_vcpu *vcpu)\n{\n\trestart_apic_timer(vcpu->arch.apic);\n}"
  },
  {
    "function_name": "kvm_lapic_expired_hv_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1831-1849",
    "snippet": "void kvm_lapic_expired_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tpreempt_disable();\n\t/* If the preempt notifier has already run, it also called apic_timer_expired */\n\tif (!apic->lapic_timer.hv_timer_in_use)\n\t\tgoto out;\n\tWARN_ON(swait_active(&vcpu->wq));\n\tcancel_hv_timer(apic);\n\tapic_timer_expired(apic);\n\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\tadvance_periodic_target_expiration(apic);\n\t\trestart_apic_timer(apic);\n\t}\nout:\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restart_apic_timer",
          "args": [
            "apic"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "restart_apic_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1818-1829",
          "snippet": "static void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "advance_periodic_target_expiration",
          "args": [
            "apic"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "advance_periodic_target_expiration",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1701-1720",
          "snippet": "static void advance_periodic_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now = ktime_get();\n\tu64 tscl = rdtsc();\n\tktime_t delta;\n\n\t/*\n\t * Synchronize both deadlines to the same time source or\n\t * differences in the periods (caused by differences in the\n\t * underlying clocks or numerical approximation errors) will\n\t * cause the two to drift apart over time as the errors\n\t * accumulate.\n\t */\n\tapic->lapic_timer.target_expiration =\n\t\tktime_add_ns(apic->lapic_timer.target_expiration,\n\t\t\t\tapic->lapic_timer.period);\n\tdelta = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, delta);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void advance_periodic_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now = ktime_get();\n\tu64 tscl = rdtsc();\n\tktime_t delta;\n\n\t/*\n\t * Synchronize both deadlines to the same time source or\n\t * differences in the periods (caused by differences in the\n\t * underlying clocks or numerical approximation errors) will\n\t * cause the two to drift apart over time as the errors\n\t * accumulate.\n\t */\n\tapic->lapic_timer.target_expiration =\n\t\tktime_add_ns(apic->lapic_timer.target_expiration,\n\t\t\t\tapic->lapic_timer.period);\n\tdelta = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "322-325",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_timer_expired",
          "args": [
            "apic"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "apic_timer_expired",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1599-1619",
          "snippet": "static void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_hv_timer",
          "args": [
            "apic"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_hv_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1751-1757",
          "snippet": "static void cancel_hv_timer(struct kvm_lapic *apic)\n{\n\tWARN_ON(preemptible());\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\tkvm_x86_ops.cancel_hv_timer(apic->vcpu);\n\tapic->lapic_timer.hv_timer_in_use = false;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic)\n{\n\tWARN_ON(preemptible());\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\tkvm_x86_ops.cancel_hv_timer(apic->vcpu);\n\tapic->lapic_timer.hv_timer_in_use = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "swait_active(&vcpu->wq)"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "swait_active",
          "args": [
            "&vcpu->wq"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_expired_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tpreempt_disable();\n\t/* If the preempt notifier has already run, it also called apic_timer_expired */\n\tif (!apic->lapic_timer.hv_timer_in_use)\n\t\tgoto out;\n\tWARN_ON(swait_active(&vcpu->wq));\n\tcancel_hv_timer(apic);\n\tapic_timer_expired(apic);\n\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\tadvance_periodic_target_expiration(apic);\n\t\trestart_apic_timer(apic);\n\t}\nout:\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "restart_apic_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1818-1829",
    "snippet": "static void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_sw_timer",
          "args": [
            "apic"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "start_sw_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1801-1816",
          "snippet": "static void start_sw_timer(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tWARN_ON(preemptible());\n\tif (apic->lapic_timer.hv_timer_in_use)\n\t\tcancel_hv_timer(apic);\n\tif (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending))\n\t\treturn;\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t\tstart_sw_period(apic);\n\telse if (apic_lvtt_tscdeadline(apic))\n\t\tstart_sw_tscdeadline(apic);\n\ttrace_kvm_hv_timer_state(apic->vcpu->vcpu_id, false);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void start_sw_timer(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tWARN_ON(preemptible());\n\tif (apic->lapic_timer.hv_timer_in_use)\n\t\tcancel_hv_timer(apic);\n\tif (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending))\n\t\treturn;\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t\tstart_sw_period(apic);\n\telse if (apic_lvtt_tscdeadline(apic))\n\t\tstart_sw_tscdeadline(apic);\n\ttrace_kvm_hv_timer_state(apic->vcpu->vcpu_id, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_hv_timer",
          "args": [
            "apic"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_restart_hv_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1870-1876",
          "snippet": "void kvm_lapic_restart_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\trestart_apic_timer(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_restart_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\trestart_apic_timer(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&apic->lapic_timer.pending"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 1822
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "322-325",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void restart_apic_timer(struct kvm_lapic *apic)\n{\n\tpreempt_disable();\n\n\tif (!apic_lvtt_period(apic) && atomic_read(&apic->lapic_timer.pending))\n\t\tgoto out;\n\n\tif (!start_hv_timer(apic))\n\t\tstart_sw_timer(apic);\nout:\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "start_sw_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1801-1816",
    "snippet": "static void start_sw_timer(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tWARN_ON(preemptible());\n\tif (apic->lapic_timer.hv_timer_in_use)\n\t\tcancel_hv_timer(apic);\n\tif (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending))\n\t\treturn;\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t\tstart_sw_period(apic);\n\telse if (apic_lvtt_tscdeadline(apic))\n\t\tstart_sw_tscdeadline(apic);\n\ttrace_kvm_hv_timer_state(apic->vcpu->vcpu_id, false);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_hv_timer_state",
          "args": [
            "apic->vcpu->vcpu_id",
            "false"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_sw_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "start_sw_tscdeadline",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1621-1652",
          "snippet": "static void start_sw_tscdeadline(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\tu64 guest_tsc, tscdeadline = ktimer->tscdeadline;\n\tu64 ns = 0;\n\tktime_t expire;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\tunsigned long flags;\n\tktime_t now;\n\n\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tnow = ktime_get();\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\n\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\tdo_div(ns, this_tsc_khz);\n\n\tif (likely(tscdeadline > guest_tsc) &&\n\t    likely(ns > apic->lapic_timer.timer_advance_ns)) {\n\t\texpire = ktime_add_ns(now, ns);\n\t\texpire = ktime_sub_ns(expire, ktimer->timer_advance_ns);\n\t\thrtimer_start(&ktimer->timer, expire, HRTIMER_MODE_ABS_HARD);\n\t} else\n\t\tapic_timer_expired(apic);\n\n\tlocal_irq_restore(flags);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void start_sw_tscdeadline(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\tu64 guest_tsc, tscdeadline = ktimer->tscdeadline;\n\tu64 ns = 0;\n\tktime_t expire;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\tunsigned long flags;\n\tktime_t now;\n\n\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tnow = ktime_get();\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\n\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\tdo_div(ns, this_tsc_khz);\n\n\tif (likely(tscdeadline > guest_tsc) &&\n\t    likely(ns > apic->lapic_timer.timer_advance_ns)) {\n\t\texpire = ktime_add_ns(now, ns);\n\t\texpire = ktime_sub_ns(expire, ktimer->timer_advance_ns);\n\t\thrtimer_start(&ktimer->timer, expire, HRTIMER_MODE_ABS_HARD);\n\t} else\n\t\tapic_timer_expired(apic);\n\n\tlocal_irq_restore(flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "327-330",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_sw_period",
          "args": [
            "apic"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "start_sw_period",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1722-1740",
          "snippet": "static void start_sw_period(struct kvm_lapic *apic)\n{\n\tif (!apic->lapic_timer.period)\n\t\treturn;\n\n\tif (ktime_after(ktime_get(),\n\t\t\tapic->lapic_timer.target_expiration)) {\n\t\tapic_timer_expired(apic);\n\n\t\tif (apic_lvtt_oneshot(apic))\n\t\t\treturn;\n\n\t\tadvance_periodic_target_expiration(apic);\n\t}\n\n\thrtimer_start(&apic->lapic_timer.timer,\n\t\tapic->lapic_timer.target_expiration,\n\t\tHRTIMER_MODE_ABS_HARD);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void start_sw_period(struct kvm_lapic *apic)\n{\n\tif (!apic->lapic_timer.period)\n\t\treturn;\n\n\tif (ktime_after(ktime_get(),\n\t\t\tapic->lapic_timer.target_expiration)) {\n\t\tapic_timer_expired(apic);\n\n\t\tif (apic_lvtt_oneshot(apic))\n\t\t\treturn;\n\n\t\tadvance_periodic_target_expiration(apic);\n\t}\n\n\thrtimer_start(&apic->lapic_timer.timer,\n\t\tapic->lapic_timer.target_expiration,\n\t\tHRTIMER_MODE_ABS_HARD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_oneshot",
          "args": [
            "apic"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_oneshot",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "317-320",
          "snippet": "static inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "322-325",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ktimer->pending"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_hv_timer",
          "args": [
            "apic"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_hv_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1751-1757",
          "snippet": "static void cancel_hv_timer(struct kvm_lapic *apic)\n{\n\tWARN_ON(preemptible());\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\tkvm_x86_ops.cancel_hv_timer(apic->vcpu);\n\tapic->lapic_timer.hv_timer_in_use = false;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic)\n{\n\tWARN_ON(preemptible());\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\tkvm_x86_ops.cancel_hv_timer(apic->vcpu);\n\tapic->lapic_timer.hv_timer_in_use = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "preemptible()"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void start_sw_timer(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tWARN_ON(preemptible());\n\tif (apic->lapic_timer.hv_timer_in_use)\n\t\tcancel_hv_timer(apic);\n\tif (!apic_lvtt_period(apic) && atomic_read(&ktimer->pending))\n\t\treturn;\n\n\tif (apic_lvtt_period(apic) || apic_lvtt_oneshot(apic))\n\t\tstart_sw_period(apic);\n\telse if (apic_lvtt_tscdeadline(apic))\n\t\tstart_sw_tscdeadline(apic);\n\ttrace_kvm_hv_timer_state(apic->vcpu->vcpu_id, false);\n}"
  },
  {
    "function_name": "start_hv_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1759-1799",
    "snippet": "static bool start_hv_timer(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tbool expired;\n\n\tWARN_ON(preemptible());\n\tif (!kvm_x86_ops.set_hv_timer)\n\t\treturn false;\n\n\tif (!ktimer->tscdeadline)\n\t\treturn false;\n\n\tif (kvm_x86_ops.set_hv_timer(vcpu, ktimer->tscdeadline, &expired))\n\t\treturn false;\n\n\tktimer->hv_timer_in_use = true;\n\thrtimer_cancel(&ktimer->timer);\n\n\t/*\n\t * To simplify handling the periodic timer, leave the hv timer running\n\t * even if the deadline timer has expired, i.e. rely on the resulting\n\t * VM-Exit to recompute the periodic timer's target expiration.\n\t */\n\tif (!apic_lvtt_period(apic)) {\n\t\t/*\n\t\t * Cancel the hv timer if the sw timer fired while the hv timer\n\t\t * was being programmed, or if the hv timer itself expired.\n\t\t */\n\t\tif (atomic_read(&ktimer->pending)) {\n\t\t\tcancel_hv_timer(apic);\n\t\t} else if (expired) {\n\t\t\tapic_timer_expired(apic);\n\t\t\tcancel_hv_timer(apic);\n\t\t}\n\t}\n\n\ttrace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);\n\n\treturn true;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_hv_timer_state",
          "args": [
            "vcpu->vcpu_id",
            "ktimer->hv_timer_in_use"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_hv_timer",
          "args": [
            "apic"
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_hv_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1751-1757",
          "snippet": "static void cancel_hv_timer(struct kvm_lapic *apic)\n{\n\tWARN_ON(preemptible());\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\tkvm_x86_ops.cancel_hv_timer(apic->vcpu);\n\tapic->lapic_timer.hv_timer_in_use = false;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic)\n{\n\tWARN_ON(preemptible());\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\tkvm_x86_ops.cancel_hv_timer(apic->vcpu);\n\tapic->lapic_timer.hv_timer_in_use = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_timer_expired",
          "args": [
            "apic"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "apic_timer_expired",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1599-1619",
          "snippet": "static void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ktimer->pending"
          ],
          "line": 1788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "322-325",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&ktimer->timer"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.set_hv_timer",
          "args": [
            "vcpu",
            "ktimer->tscdeadline",
            "&expired"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "preemptible()"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool start_hv_timer(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tbool expired;\n\n\tWARN_ON(preemptible());\n\tif (!kvm_x86_ops.set_hv_timer)\n\t\treturn false;\n\n\tif (!ktimer->tscdeadline)\n\t\treturn false;\n\n\tif (kvm_x86_ops.set_hv_timer(vcpu, ktimer->tscdeadline, &expired))\n\t\treturn false;\n\n\tktimer->hv_timer_in_use = true;\n\thrtimer_cancel(&ktimer->timer);\n\n\t/*\n\t * To simplify handling the periodic timer, leave the hv timer running\n\t * even if the deadline timer has expired, i.e. rely on the resulting\n\t * VM-Exit to recompute the periodic timer's target expiration.\n\t */\n\tif (!apic_lvtt_period(apic)) {\n\t\t/*\n\t\t * Cancel the hv timer if the sw timer fired while the hv timer\n\t\t * was being programmed, or if the hv timer itself expired.\n\t\t */\n\t\tif (atomic_read(&ktimer->pending)) {\n\t\t\tcancel_hv_timer(apic);\n\t\t} else if (expired) {\n\t\t\tapic_timer_expired(apic);\n\t\t\tcancel_hv_timer(apic);\n\t\t}\n\t}\n\n\ttrace_kvm_hv_timer_state(vcpu->vcpu_id, ktimer->hv_timer_in_use);\n\n\treturn true;\n}"
  },
  {
    "function_name": "cancel_hv_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1751-1757",
    "snippet": "static void cancel_hv_timer(struct kvm_lapic *apic)\n{\n\tWARN_ON(preemptible());\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\tkvm_x86_ops.cancel_hv_timer(apic->vcpu);\n\tapic->lapic_timer.hv_timer_in_use = false;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops.cancel_hv_timer",
          "args": [
            "apic->vcpu"
          ],
          "line": 1755
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_hv_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1751-1757",
          "snippet": "static void cancel_hv_timer(struct kvm_lapic *apic)\n{\n\tWARN_ON(preemptible());\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\tkvm_x86_ops.cancel_hv_timer(apic->vcpu);\n\tapic->lapic_timer.hv_timer_in_use = false;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!apic->lapic_timer.hv_timer_in_use"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "preemptible()"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preemptible",
          "args": [],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic)\n{\n\tWARN_ON(preemptible());\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\tkvm_x86_ops.cancel_hv_timer(apic->vcpu);\n\tapic->lapic_timer.hv_timer_in_use = false;\n}"
  },
  {
    "function_name": "kvm_lapic_hv_timer_in_use",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1742-1748",
    "snippet": "bool kvm_lapic_hv_timer_in_use(struct kvm_vcpu *vcpu)\n{\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn false;\n\n\treturn vcpu->arch.apic->lapic_timer.hv_timer_in_use;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_lapic_hv_timer_in_use(struct kvm_vcpu *vcpu)\n{\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn false;\n\n\treturn vcpu->arch.apic->lapic_timer.hv_timer_in_use;\n}"
  },
  {
    "function_name": "start_sw_period",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1722-1740",
    "snippet": "static void start_sw_period(struct kvm_lapic *apic)\n{\n\tif (!apic->lapic_timer.period)\n\t\treturn;\n\n\tif (ktime_after(ktime_get(),\n\t\t\tapic->lapic_timer.target_expiration)) {\n\t\tapic_timer_expired(apic);\n\n\t\tif (apic_lvtt_oneshot(apic))\n\t\t\treturn;\n\n\t\tadvance_periodic_target_expiration(apic);\n\t}\n\n\thrtimer_start(&apic->lapic_timer.timer,\n\t\tapic->lapic_timer.target_expiration,\n\t\tHRTIMER_MODE_ABS_HARD);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&apic->lapic_timer.timer",
            "apic->lapic_timer.target_expiration",
            "HRTIMER_MODE_ABS_HARD"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "advance_periodic_target_expiration",
          "args": [
            "apic"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "advance_periodic_target_expiration",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1701-1720",
          "snippet": "static void advance_periodic_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now = ktime_get();\n\tu64 tscl = rdtsc();\n\tktime_t delta;\n\n\t/*\n\t * Synchronize both deadlines to the same time source or\n\t * differences in the periods (caused by differences in the\n\t * underlying clocks or numerical approximation errors) will\n\t * cause the two to drift apart over time as the errors\n\t * accumulate.\n\t */\n\tapic->lapic_timer.target_expiration =\n\t\tktime_add_ns(apic->lapic_timer.target_expiration,\n\t\t\t\tapic->lapic_timer.period);\n\tdelta = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, delta);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void advance_periodic_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now = ktime_get();\n\tu64 tscl = rdtsc();\n\tktime_t delta;\n\n\t/*\n\t * Synchronize both deadlines to the same time source or\n\t * differences in the periods (caused by differences in the\n\t * underlying clocks or numerical approximation errors) will\n\t * cause the two to drift apart over time as the errors\n\t * accumulate.\n\t */\n\tapic->lapic_timer.target_expiration =\n\t\tktime_add_ns(apic->lapic_timer.target_expiration,\n\t\t\t\tapic->lapic_timer.period);\n\tdelta = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_oneshot",
          "args": [
            "apic"
          ],
          "line": 1731
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_oneshot",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "317-320",
          "snippet": "static inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_timer_expired",
          "args": [
            "apic"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "apic_timer_expired",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1599-1619",
          "snippet": "static void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_after",
          "args": [
            "ktime_get()",
            "apic->lapic_timer.target_expiration"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void start_sw_period(struct kvm_lapic *apic)\n{\n\tif (!apic->lapic_timer.period)\n\t\treturn;\n\n\tif (ktime_after(ktime_get(),\n\t\t\tapic->lapic_timer.target_expiration)) {\n\t\tapic_timer_expired(apic);\n\n\t\tif (apic_lvtt_oneshot(apic))\n\t\t\treturn;\n\n\t\tadvance_periodic_target_expiration(apic);\n\t}\n\n\thrtimer_start(&apic->lapic_timer.timer,\n\t\tapic->lapic_timer.target_expiration,\n\t\tHRTIMER_MODE_ABS_HARD);\n}"
  },
  {
    "function_name": "advance_periodic_target_expiration",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1701-1720",
    "snippet": "static void advance_periodic_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now = ktime_get();\n\tu64 tscl = rdtsc();\n\tktime_t delta;\n\n\t/*\n\t * Synchronize both deadlines to the same time source or\n\t * differences in the periods (caused by differences in the\n\t * underlying clocks or numerical approximation errors) will\n\t * cause the two to drift apart over time as the errors\n\t * accumulate.\n\t */\n\tapic->lapic_timer.target_expiration =\n\t\tktime_add_ns(apic->lapic_timer.target_expiration,\n\t\t\t\tapic->lapic_timer.period);\n\tdelta = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, delta);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nsec_to_cycles",
          "args": [
            "apic->vcpu",
            "delta"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_to_cycles",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "291-295",
          "snippet": "static inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_l1_tsc",
          "args": [
            "apic->vcpu",
            "tscl"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_l1_tsc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1951-1956",
          "snippet": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "apic->lapic_timer.target_expiration",
            "now"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "apic->lapic_timer.target_expiration",
            "apic->lapic_timer.period"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_rdtscp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "149-153",
          "snippet": "static inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void advance_periodic_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now = ktime_get();\n\tu64 tscl = rdtsc();\n\tktime_t delta;\n\n\t/*\n\t * Synchronize both deadlines to the same time source or\n\t * differences in the periods (caused by differences in the\n\t * underlying clocks or numerical approximation errors) will\n\t * cause the two to drift apart over time as the errors\n\t * accumulate.\n\t */\n\tapic->lapic_timer.target_expiration =\n\t\tktime_add_ns(apic->lapic_timer.target_expiration,\n\t\t\t\tapic->lapic_timer.period);\n\tdelta = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, delta);\n}"
  },
  {
    "function_name": "set_target_expiration",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1678-1699",
    "snippet": "static bool set_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\tu64 tscl = rdtsc();\n\n\tnow = ktime_get();\n\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t* APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\tif (!apic->lapic_timer.period) {\n\t\tapic->lapic_timer.tscdeadline = 0;\n\t\treturn false;\n\t}\n\n\tlimit_periodic_timer_frequency(apic);\n\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, apic->lapic_timer.period);\n\tapic->lapic_timer.target_expiration = ktime_add_ns(now, apic->lapic_timer.period);\n\n\treturn true;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "now",
            "apic->lapic_timer.period"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsec_to_cycles",
          "args": [
            "apic->vcpu",
            "apic->lapic_timer.period"
          ],
          "line": 1695
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_to_cycles",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "291-295",
          "snippet": "static inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_l1_tsc",
          "args": [
            "apic->vcpu",
            "tscl"
          ],
          "line": 1694
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_l1_tsc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1951-1956",
          "snippet": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "limit_periodic_timer_frequency",
          "args": [
            "apic"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "limit_periodic_timer_frequency",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1442-1461",
          "snippet": "static void limit_periodic_timer_frequency(struct kvm_lapic *apic)\n{\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\tapic->lapic_timer.period = min_period;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void limit_periodic_timer_frequency(struct kvm_lapic *apic)\n{\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\tapic->lapic_timer.period = min_period;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TMICT"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_rdtscp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "149-153",
          "snippet": "static inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool set_target_expiration(struct kvm_lapic *apic)\n{\n\tktime_t now;\n\tu64 tscl = rdtsc();\n\n\tnow = ktime_get();\n\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t* APIC_BUS_CYCLE_NS * apic->divide_count;\n\n\tif (!apic->lapic_timer.period) {\n\t\tapic->lapic_timer.tscdeadline = 0;\n\t\treturn false;\n\t}\n\n\tlimit_periodic_timer_frequency(apic);\n\n\tapic->lapic_timer.tscdeadline = kvm_read_l1_tsc(apic->vcpu, tscl) +\n\t\tnsec_to_cycles(apic->vcpu, apic->lapic_timer.period);\n\tapic->lapic_timer.target_expiration = ktime_add_ns(now, apic->lapic_timer.period);\n\n\treturn true;\n}"
  },
  {
    "function_name": "update_target_expiration",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1654-1676",
    "snippet": "static void update_target_expiration(struct kvm_lapic *apic, uint32_t old_divisor)\n{\n\tktime_t now, remaining;\n\tu64 ns_remaining_old, ns_remaining_new;\n\n\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t* APIC_BUS_CYCLE_NS * apic->divide_count;\n\tlimit_periodic_timer_frequency(apic);\n\n\tnow = ktime_get();\n\tremaining = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = 0;\n\n\tns_remaining_old = ktime_to_ns(remaining);\n\tns_remaining_new = mul_u64_u32_div(ns_remaining_old,\n\t                                   apic->divide_count, old_divisor);\n\n\tapic->lapic_timer.tscdeadline +=\n\t\tnsec_to_cycles(apic->vcpu, ns_remaining_new) -\n\t\tnsec_to_cycles(apic->vcpu, ns_remaining_old);\n\tapic->lapic_timer.target_expiration = ktime_add_ns(now, ns_remaining_new);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "now",
            "ns_remaining_new"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsec_to_cycles",
          "args": [
            "apic->vcpu",
            "ns_remaining_old"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_to_cycles",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "291-295",
          "snippet": "static inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mul_u64_u32_div",
          "args": [
            "ns_remaining_old",
            "apic->divide_count",
            "old_divisor"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "remaining"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "remaining"
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "apic->lapic_timer.target_expiration",
            "now"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "limit_periodic_timer_frequency",
          "args": [
            "apic"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "limit_periodic_timer_frequency",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1442-1461",
          "snippet": "static void limit_periodic_timer_frequency(struct kvm_lapic *apic)\n{\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\tapic->lapic_timer.period = min_period;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void limit_periodic_timer_frequency(struct kvm_lapic *apic)\n{\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\tapic->lapic_timer.period = min_period;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TMICT"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void update_target_expiration(struct kvm_lapic *apic, uint32_t old_divisor)\n{\n\tktime_t now, remaining;\n\tu64 ns_remaining_old, ns_remaining_new;\n\n\tapic->lapic_timer.period = (u64)kvm_lapic_get_reg(apic, APIC_TMICT)\n\t\t* APIC_BUS_CYCLE_NS * apic->divide_count;\n\tlimit_periodic_timer_frequency(apic);\n\n\tnow = ktime_get();\n\tremaining = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = 0;\n\n\tns_remaining_old = ktime_to_ns(remaining);\n\tns_remaining_new = mul_u64_u32_div(ns_remaining_old,\n\t                                   apic->divide_count, old_divisor);\n\n\tapic->lapic_timer.tscdeadline +=\n\t\tnsec_to_cycles(apic->vcpu, ns_remaining_new) -\n\t\tnsec_to_cycles(apic->vcpu, ns_remaining_old);\n\tapic->lapic_timer.target_expiration = ktime_add_ns(now, ns_remaining_new);\n}"
  },
  {
    "function_name": "start_sw_tscdeadline",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1621-1652",
    "snippet": "static void start_sw_tscdeadline(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\tu64 guest_tsc, tscdeadline = ktimer->tscdeadline;\n\tu64 ns = 0;\n\tktime_t expire;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\tunsigned long flags;\n\tktime_t now;\n\n\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tnow = ktime_get();\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\n\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\tdo_div(ns, this_tsc_khz);\n\n\tif (likely(tscdeadline > guest_tsc) &&\n\t    likely(ns > apic->lapic_timer.timer_advance_ns)) {\n\t\texpire = ktime_add_ns(now, ns);\n\t\texpire = ktime_sub_ns(expire, ktimer->timer_advance_ns);\n\t\thrtimer_start(&ktimer->timer, expire, HRTIMER_MODE_ABS_HARD);\n\t} else\n\t\tapic_timer_expired(apic);\n\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_timer_expired",
          "args": [
            "apic"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "apic_timer_expired",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1599-1619",
          "snippet": "static void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&ktimer->timer",
            "expire",
            "HRTIMER_MODE_ABS_HARD"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub_ns",
          "args": [
            "expire",
            "ktimer->timer_advance_ns"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "now",
            "ns"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "ns > apic->lapic_timer.timer_advance_ns"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "tscdeadline > guest_tsc"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ns",
            "this_tsc_khz"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_l1_tsc",
          "args": [
            "vcpu",
            "rdtsc()"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_l1_tsc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1951-1956",
          "snippet": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_rdtscp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "149-153",
          "snippet": "static inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!tscdeadline || !this_tsc_khz"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void start_sw_tscdeadline(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\tu64 guest_tsc, tscdeadline = ktimer->tscdeadline;\n\tu64 ns = 0;\n\tktime_t expire;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tunsigned long this_tsc_khz = vcpu->arch.virtual_tsc_khz;\n\tunsigned long flags;\n\tktime_t now;\n\n\tif (unlikely(!tscdeadline || !this_tsc_khz))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\tnow = ktime_get();\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\n\tns = (tscdeadline - guest_tsc) * 1000000ULL;\n\tdo_div(ns, this_tsc_khz);\n\n\tif (likely(tscdeadline > guest_tsc) &&\n\t    likely(ns > apic->lapic_timer.timer_advance_ns)) {\n\t\texpire = ktime_add_ns(now, ns);\n\t\texpire = ktime_sub_ns(expire, ktimer->timer_advance_ns);\n\t\thrtimer_start(&ktimer->timer, expire, HRTIMER_MODE_ABS_HARD);\n\t} else\n\t\tapic_timer_expired(apic);\n\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "apic_timer_expired",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1599-1619",
    "snippet": "static void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_pending_timer",
          "args": [
            "vcpu"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_pending_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1705-1709",
          "snippet": "void kvm_set_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);\n\tkvm_vcpu_kick(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_set_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tkvm_make_request(KVM_REQ_PENDING_TIMER, vcpu);\n\tkvm_vcpu_kick(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&apic->lapic_timer.pending"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_inject_pending_timer_irqs",
          "args": [
            "apic"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_inject_pending_timer_irqs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1586-1597",
          "snippet": "static void kvm_apic_inject_pending_timer_irqs(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\tif (apic_lvtt_tscdeadline(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t} else if (apic_lvtt_oneshot(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t\tktimer->target_expiration = 0;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void kvm_apic_inject_pending_timer_irqs(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\tif (apic_lvtt_tscdeadline(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t} else if (apic_lvtt_oneshot(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t\tktimer->target_expiration = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kvm_wait_lapic_expire",
          "args": [
            "vcpu"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_wait_lapic_expire",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1559-1577",
          "snippet": "static void __kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu64 guest_tsc, tsc_deadline;\n\n\tif (apic->lapic_timer.expired_tscdeadline == 0)\n\t\treturn;\n\n\ttsc_deadline = apic->lapic_timer.expired_tscdeadline;\n\tapic->lapic_timer.expired_tscdeadline = 0;\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\tapic->lapic_timer.advance_expire_delta = guest_tsc - tsc_deadline;\n\n\tif (guest_tsc < tsc_deadline)\n\t\t__wait_lapic_expire(vcpu, tsc_deadline - guest_tsc);\n\n\tif (lapic_timer_advance_dynamic)\n\t\tadjust_lapic_timer_advance(vcpu, apic->lapic_timer.advance_expire_delta);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lapic_timer_advance_dynamic",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool lapic_timer_advance_dynamic;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void __kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu64 guest_tsc, tsc_deadline;\n\n\tif (apic->lapic_timer.expired_tscdeadline == 0)\n\t\treturn;\n\n\ttsc_deadline = apic->lapic_timer.expired_tscdeadline;\n\tapic->lapic_timer.expired_tscdeadline = 0;\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\tapic->lapic_timer.advance_expire_delta = guest_tsc - tsc_deadline;\n\n\tif (guest_tsc < tsc_deadline)\n\t\t__wait_lapic_expire(vcpu, tsc_deadline - guest_tsc);\n\n\tif (lapic_timer_advance_dynamic)\n\t\tadjust_lapic_timer_advance(vcpu, apic->lapic_timer.advance_expire_delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_use_posted_timer_interrupt",
          "args": [
            "apic->vcpu"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_use_posted_timer_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "122-125",
          "snippet": "static bool kvm_use_posted_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_can_post_timer_interrupt(vcpu) && vcpu->mode == IN_GUEST_MODE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_use_posted_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_can_post_timer_interrupt(vcpu) && vcpu->mode == IN_GUEST_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "327-330",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&apic->lapic_timer.pending"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_timer_expired(struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tif (atomic_read(&apic->lapic_timer.pending))\n\t\treturn;\n\n\tif (apic_lvtt_tscdeadline(apic) || ktimer->hv_timer_in_use)\n\t\tktimer->expired_tscdeadline = ktimer->tscdeadline;\n\n\tif (kvm_use_posted_timer_interrupt(apic->vcpu)) {\n\t\tif (apic->lapic_timer.timer_advance_ns)\n\t\t\t__kvm_wait_lapic_expire(vcpu);\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\treturn;\n\t}\n\n\tatomic_inc(&apic->lapic_timer.pending);\n\tkvm_set_pending_timer(vcpu);\n}"
  },
  {
    "function_name": "kvm_apic_inject_pending_timer_irqs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1586-1597",
    "snippet": "static void kvm_apic_inject_pending_timer_irqs(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\tif (apic_lvtt_tscdeadline(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t} else if (apic_lvtt_oneshot(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t\tktimer->target_expiration = 0;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_lvtt_oneshot",
          "args": [
            "apic"
          ],
          "line": 1593
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_oneshot",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "317-320",
          "snippet": "static inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "327-330",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_local_deliver",
          "args": [
            "apic",
            "APIC_LVTT"
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_local_deliver",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2309-2322",
          "snippet": "int kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_local_deliver(struct kvm_lapic *apic, int lvt_type)\n{\n\tu32 reg = kvm_lapic_get_reg(apic, lvt_type);\n\tint vector, mode, trig_mode;\n\n\tif (kvm_apic_hw_enabled(apic) && !(reg & APIC_LVT_MASKED)) {\n\t\tvector = reg & APIC_VECTOR_MASK;\n\t\tmode = reg & APIC_MODE_MASK;\n\t\ttrig_mode = reg & APIC_LVT_LEVEL_TRIGGER;\n\t\treturn __apic_accept_irq(apic, mode, vector, 1, trig_mode,\n\t\t\t\t\tNULL);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void kvm_apic_inject_pending_timer_irqs(struct kvm_lapic *apic)\n{\n\tstruct kvm_timer *ktimer = &apic->lapic_timer;\n\n\tkvm_apic_local_deliver(apic, APIC_LVTT);\n\tif (apic_lvtt_tscdeadline(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t} else if (apic_lvtt_oneshot(apic)) {\n\t\tktimer->tscdeadline = 0;\n\t\tktimer->target_expiration = 0;\n\t}\n}"
  },
  {
    "function_name": "kvm_wait_lapic_expire",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1579-1583",
    "snippet": "void kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_timer_int_injected(vcpu))\n\t\t__kvm_wait_lapic_expire(vcpu);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kvm_wait_lapic_expire",
          "args": [
            "vcpu"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_wait_lapic_expire",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1559-1577",
          "snippet": "static void __kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu64 guest_tsc, tsc_deadline;\n\n\tif (apic->lapic_timer.expired_tscdeadline == 0)\n\t\treturn;\n\n\ttsc_deadline = apic->lapic_timer.expired_tscdeadline;\n\tapic->lapic_timer.expired_tscdeadline = 0;\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\tapic->lapic_timer.advance_expire_delta = guest_tsc - tsc_deadline;\n\n\tif (guest_tsc < tsc_deadline)\n\t\t__wait_lapic_expire(vcpu, tsc_deadline - guest_tsc);\n\n\tif (lapic_timer_advance_dynamic)\n\t\tadjust_lapic_timer_advance(vcpu, apic->lapic_timer.advance_expire_delta);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool lapic_timer_advance_dynamic",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool lapic_timer_advance_dynamic;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void __kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu64 guest_tsc, tsc_deadline;\n\n\tif (apic->lapic_timer.expired_tscdeadline == 0)\n\t\treturn;\n\n\ttsc_deadline = apic->lapic_timer.expired_tscdeadline;\n\tapic->lapic_timer.expired_tscdeadline = 0;\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\tapic->lapic_timer.advance_expire_delta = guest_tsc - tsc_deadline;\n\n\tif (guest_tsc < tsc_deadline)\n\t\t__wait_lapic_expire(vcpu, tsc_deadline - guest_tsc);\n\n\tif (lapic_timer_advance_dynamic)\n\t\tadjust_lapic_timer_advance(vcpu, apic->lapic_timer.advance_expire_delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_timer_int_injected",
          "args": [
            "vcpu"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_timer_int_injected",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1492-1508",
          "snippet": "static bool lapic_timer_int_injected(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = kvm_lapic_get_reg(apic, APIC_LVTT);\n\n\tif (kvm_apic_hw_enabled(apic)) {\n\t\tint vec = reg & APIC_VECTOR_MASK;\n\t\tvoid *bitmap = apic->regs + APIC_ISR;\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tbitmap = apic->regs + APIC_IRR;\n\n\t\tif (apic_test_vector(vec, bitmap))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool lapic_timer_int_injected(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = kvm_lapic_get_reg(apic, APIC_LVTT);\n\n\tif (kvm_apic_hw_enabled(apic)) {\n\t\tint vec = reg & APIC_VECTOR_MASK;\n\t\tvoid *bitmap = apic->regs + APIC_ISR;\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tbitmap = apic->regs + APIC_IRR;\n\n\t\tif (apic_test_vector(vec, bitmap))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_timer_int_injected(vcpu))\n\t\t__kvm_wait_lapic_expire(vcpu);\n}"
  },
  {
    "function_name": "__kvm_wait_lapic_expire",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1559-1577",
    "snippet": "static void __kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu64 guest_tsc, tsc_deadline;\n\n\tif (apic->lapic_timer.expired_tscdeadline == 0)\n\t\treturn;\n\n\ttsc_deadline = apic->lapic_timer.expired_tscdeadline;\n\tapic->lapic_timer.expired_tscdeadline = 0;\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\tapic->lapic_timer.advance_expire_delta = guest_tsc - tsc_deadline;\n\n\tif (guest_tsc < tsc_deadline)\n\t\t__wait_lapic_expire(vcpu, tsc_deadline - guest_tsc);\n\n\tif (lapic_timer_advance_dynamic)\n\t\tadjust_lapic_timer_advance(vcpu, apic->lapic_timer.advance_expire_delta);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool lapic_timer_advance_dynamic",
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "adjust_lapic_timer_advance",
          "args": [
            "vcpu",
            "apic->lapic_timer.advance_expire_delta"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "adjust_lapic_timer_advance",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1530-1557",
          "snippet": "static inline void adjust_lapic_timer_advance(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      s64 advance_expire_delta)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 timer_advance_ns = apic->lapic_timer.timer_advance_ns;\n\tu64 ns;\n\n\t/* Do not adjust for tiny fluctuations or large random spikes. */\n\tif (abs(advance_expire_delta) > LAPIC_TIMER_ADVANCE_ADJUST_MAX ||\n\t    abs(advance_expire_delta) < LAPIC_TIMER_ADVANCE_ADJUST_MIN)\n\t\treturn;\n\n\t/* too early */\n\tif (advance_expire_delta < 0) {\n\t\tns = -advance_expire_delta * 1000000ULL;\n\t\tdo_div(ns, vcpu->arch.virtual_tsc_khz);\n\t\ttimer_advance_ns -= ns/LAPIC_TIMER_ADVANCE_ADJUST_STEP;\n\t} else {\n\t/* too late */\n\t\tns = advance_expire_delta * 1000000ULL;\n\t\tdo_div(ns, vcpu->arch.virtual_tsc_khz);\n\t\ttimer_advance_ns += ns/LAPIC_TIMER_ADVANCE_ADJUST_STEP;\n\t}\n\n\tif (unlikely(timer_advance_ns > LAPIC_TIMER_ADVANCE_NS_MAX))\n\t\ttimer_advance_ns = LAPIC_TIMER_ADVANCE_NS_INIT;\n\tapic->lapic_timer.timer_advance_ns = timer_advance_ns;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define LAPIC_TIMER_ADVANCE_ADJUST_STEP 8",
            "#define LAPIC_TIMER_ADVANCE_NS_MAX     5000",
            "#define LAPIC_TIMER_ADVANCE_NS_INIT\t1000",
            "#define LAPIC_TIMER_ADVANCE_ADJUST_MAX\t10000\t/* clock cycles */",
            "#define LAPIC_TIMER_ADVANCE_ADJUST_MIN\t100\t/* clock cycles */"
          ],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_TIMER_ADVANCE_ADJUST_STEP 8\n#define LAPIC_TIMER_ADVANCE_NS_MAX     5000\n#define LAPIC_TIMER_ADVANCE_NS_INIT\t1000\n#define LAPIC_TIMER_ADVANCE_ADJUST_MAX\t10000\t/* clock cycles */\n#define LAPIC_TIMER_ADVANCE_ADJUST_MIN\t100\t/* clock cycles */\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void adjust_lapic_timer_advance(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      s64 advance_expire_delta)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 timer_advance_ns = apic->lapic_timer.timer_advance_ns;\n\tu64 ns;\n\n\t/* Do not adjust for tiny fluctuations or large random spikes. */\n\tif (abs(advance_expire_delta) > LAPIC_TIMER_ADVANCE_ADJUST_MAX ||\n\t    abs(advance_expire_delta) < LAPIC_TIMER_ADVANCE_ADJUST_MIN)\n\t\treturn;\n\n\t/* too early */\n\tif (advance_expire_delta < 0) {\n\t\tns = -advance_expire_delta * 1000000ULL;\n\t\tdo_div(ns, vcpu->arch.virtual_tsc_khz);\n\t\ttimer_advance_ns -= ns/LAPIC_TIMER_ADVANCE_ADJUST_STEP;\n\t} else {\n\t/* too late */\n\t\tns = advance_expire_delta * 1000000ULL;\n\t\tdo_div(ns, vcpu->arch.virtual_tsc_khz);\n\t\ttimer_advance_ns += ns/LAPIC_TIMER_ADVANCE_ADJUST_STEP;\n\t}\n\n\tif (unlikely(timer_advance_ns > LAPIC_TIMER_ADVANCE_NS_MAX))\n\t\ttimer_advance_ns = LAPIC_TIMER_ADVANCE_NS_INIT;\n\tapic->lapic_timer.timer_advance_ns = timer_advance_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wait_lapic_expire",
          "args": [
            "vcpu",
            "tsc_deadline - guest_tsc"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_lapic_expire",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1510-1528",
          "snippet": "static inline void __wait_lapic_expire(struct kvm_vcpu *vcpu, u64 guest_cycles)\n{\n\tu64 timer_advance_ns = vcpu->arch.apic->lapic_timer.timer_advance_ns;\n\n\t/*\n\t * If the guest TSC is running at a different ratio than the host, then\n\t * convert the delay to nanoseconds to achieve an accurate delay.  Note\n\t * that __delay() uses delay_tsc whenever the hardware has TSC, thus\n\t * always for VMX enabled hardware.\n\t */\n\tif (vcpu->arch.tsc_scaling_ratio == kvm_default_tsc_scaling_ratio) {\n\t\t__delay(min(guest_cycles,\n\t\t\tnsec_to_cycles(vcpu, timer_advance_ns)));\n\t} else {\n\t\tu64 delay_ns = guest_cycles * 1000000ULL;\n\t\tdo_div(delay_ns, vcpu->arch.virtual_tsc_khz);\n\t\tndelay(min_t(u32, delay_ns, timer_advance_ns));\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void __wait_lapic_expire(struct kvm_vcpu *vcpu, u64 guest_cycles)\n{\n\tu64 timer_advance_ns = vcpu->arch.apic->lapic_timer.timer_advance_ns;\n\n\t/*\n\t * If the guest TSC is running at a different ratio than the host, then\n\t * convert the delay to nanoseconds to achieve an accurate delay.  Note\n\t * that __delay() uses delay_tsc whenever the hardware has TSC, thus\n\t * always for VMX enabled hardware.\n\t */\n\tif (vcpu->arch.tsc_scaling_ratio == kvm_default_tsc_scaling_ratio) {\n\t\t__delay(min(guest_cycles,\n\t\t\tnsec_to_cycles(vcpu, timer_advance_ns)));\n\t} else {\n\t\tu64 delay_ns = guest_cycles * 1000000ULL;\n\t\tdo_div(delay_ns, vcpu->arch.virtual_tsc_khz);\n\t\tndelay(min_t(u32, delay_ns, timer_advance_ns));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_l1_tsc",
          "args": [
            "vcpu",
            "rdtsc()"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_l1_tsc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1951-1956",
          "snippet": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_rdtscp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "149-153",
          "snippet": "static inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool lapic_timer_advance_dynamic;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void __kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu64 guest_tsc, tsc_deadline;\n\n\tif (apic->lapic_timer.expired_tscdeadline == 0)\n\t\treturn;\n\n\ttsc_deadline = apic->lapic_timer.expired_tscdeadline;\n\tapic->lapic_timer.expired_tscdeadline = 0;\n\tguest_tsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\tapic->lapic_timer.advance_expire_delta = guest_tsc - tsc_deadline;\n\n\tif (guest_tsc < tsc_deadline)\n\t\t__wait_lapic_expire(vcpu, tsc_deadline - guest_tsc);\n\n\tif (lapic_timer_advance_dynamic)\n\t\tadjust_lapic_timer_advance(vcpu, apic->lapic_timer.advance_expire_delta);\n}"
  },
  {
    "function_name": "adjust_lapic_timer_advance",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1530-1557",
    "snippet": "static inline void adjust_lapic_timer_advance(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      s64 advance_expire_delta)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 timer_advance_ns = apic->lapic_timer.timer_advance_ns;\n\tu64 ns;\n\n\t/* Do not adjust for tiny fluctuations or large random spikes. */\n\tif (abs(advance_expire_delta) > LAPIC_TIMER_ADVANCE_ADJUST_MAX ||\n\t    abs(advance_expire_delta) < LAPIC_TIMER_ADVANCE_ADJUST_MIN)\n\t\treturn;\n\n\t/* too early */\n\tif (advance_expire_delta < 0) {\n\t\tns = -advance_expire_delta * 1000000ULL;\n\t\tdo_div(ns, vcpu->arch.virtual_tsc_khz);\n\t\ttimer_advance_ns -= ns/LAPIC_TIMER_ADVANCE_ADJUST_STEP;\n\t} else {\n\t/* too late */\n\t\tns = advance_expire_delta * 1000000ULL;\n\t\tdo_div(ns, vcpu->arch.virtual_tsc_khz);\n\t\ttimer_advance_ns += ns/LAPIC_TIMER_ADVANCE_ADJUST_STEP;\n\t}\n\n\tif (unlikely(timer_advance_ns > LAPIC_TIMER_ADVANCE_NS_MAX))\n\t\ttimer_advance_ns = LAPIC_TIMER_ADVANCE_NS_INIT;\n\tapic->lapic_timer.timer_advance_ns = timer_advance_ns;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define LAPIC_TIMER_ADVANCE_ADJUST_STEP 8",
      "#define LAPIC_TIMER_ADVANCE_NS_MAX     5000",
      "#define LAPIC_TIMER_ADVANCE_NS_INIT\t1000",
      "#define LAPIC_TIMER_ADVANCE_ADJUST_MAX\t10000\t/* clock cycles */",
      "#define LAPIC_TIMER_ADVANCE_ADJUST_MIN\t100\t/* clock cycles */"
    ],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "timer_advance_ns > LAPIC_TIMER_ADVANCE_NS_MAX"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ns",
            "vcpu->arch.virtual_tsc_khz"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ns",
            "vcpu->arch.virtual_tsc_khz"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "advance_expire_delta"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "em_call_near_abs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/emulate.c",
          "lines": "2254-2266",
          "snippet": "static int em_call_near_abs(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tlong int old_eip;\n\n\told_eip = ctxt->_eip;\n\trc = assign_eip_near(ctxt, ctxt->src.val);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->src.val = old_eip;\n\trc = em_push(ctxt);\n\treturn rc;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"mmu.h\"",
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/nospec-branch.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/fpu/api.h>",
            "#include <linux/stringify.h>",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"mmu.h\"\n#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/nospec-branch.h>\n#include <asm/debugreg.h>\n#include <asm/fpu/api.h>\n#include <linux/stringify.h>\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic int em_call_near_abs(struct x86_emulate_ctxt *ctxt)\n{\n\tint rc;\n\tlong int old_eip;\n\n\told_eip = ctxt->_eip;\n\trc = assign_eip_near(ctxt, ctxt->src.val);\n\tif (rc != X86EMUL_CONTINUE)\n\t\treturn rc;\n\tctxt->src.val = old_eip;\n\trc = em_push(ctxt);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_TIMER_ADVANCE_ADJUST_STEP 8\n#define LAPIC_TIMER_ADVANCE_NS_MAX     5000\n#define LAPIC_TIMER_ADVANCE_NS_INIT\t1000\n#define LAPIC_TIMER_ADVANCE_ADJUST_MAX\t10000\t/* clock cycles */\n#define LAPIC_TIMER_ADVANCE_ADJUST_MIN\t100\t/* clock cycles */\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void adjust_lapic_timer_advance(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      s64 advance_expire_delta)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 timer_advance_ns = apic->lapic_timer.timer_advance_ns;\n\tu64 ns;\n\n\t/* Do not adjust for tiny fluctuations or large random spikes. */\n\tif (abs(advance_expire_delta) > LAPIC_TIMER_ADVANCE_ADJUST_MAX ||\n\t    abs(advance_expire_delta) < LAPIC_TIMER_ADVANCE_ADJUST_MIN)\n\t\treturn;\n\n\t/* too early */\n\tif (advance_expire_delta < 0) {\n\t\tns = -advance_expire_delta * 1000000ULL;\n\t\tdo_div(ns, vcpu->arch.virtual_tsc_khz);\n\t\ttimer_advance_ns -= ns/LAPIC_TIMER_ADVANCE_ADJUST_STEP;\n\t} else {\n\t/* too late */\n\t\tns = advance_expire_delta * 1000000ULL;\n\t\tdo_div(ns, vcpu->arch.virtual_tsc_khz);\n\t\ttimer_advance_ns += ns/LAPIC_TIMER_ADVANCE_ADJUST_STEP;\n\t}\n\n\tif (unlikely(timer_advance_ns > LAPIC_TIMER_ADVANCE_NS_MAX))\n\t\ttimer_advance_ns = LAPIC_TIMER_ADVANCE_NS_INIT;\n\tapic->lapic_timer.timer_advance_ns = timer_advance_ns;\n}"
  },
  {
    "function_name": "__wait_lapic_expire",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1510-1528",
    "snippet": "static inline void __wait_lapic_expire(struct kvm_vcpu *vcpu, u64 guest_cycles)\n{\n\tu64 timer_advance_ns = vcpu->arch.apic->lapic_timer.timer_advance_ns;\n\n\t/*\n\t * If the guest TSC is running at a different ratio than the host, then\n\t * convert the delay to nanoseconds to achieve an accurate delay.  Note\n\t * that __delay() uses delay_tsc whenever the hardware has TSC, thus\n\t * always for VMX enabled hardware.\n\t */\n\tif (vcpu->arch.tsc_scaling_ratio == kvm_default_tsc_scaling_ratio) {\n\t\t__delay(min(guest_cycles,\n\t\t\tnsec_to_cycles(vcpu, timer_advance_ns)));\n\t} else {\n\t\tu64 delay_ns = guest_cycles * 1000000ULL;\n\t\tdo_div(delay_ns, vcpu->arch.virtual_tsc_khz);\n\t\tndelay(min_t(u32, delay_ns, timer_advance_ns));\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ndelay",
          "args": [
            "min_t(u32, delay_ns, timer_advance_ns)"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "delay_ns",
            "timer_advance_ns"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "delay_ns",
            "vcpu->arch.virtual_tsc_khz"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__delay",
          "args": [
            "min(guest_cycles,\n\t\t\tnsec_to_cycles(vcpu, timer_advance_ns))"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "guest_cycles",
            "nsec_to_cycles(vcpu, timer_advance_ns)"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsec_to_cycles",
          "args": [
            "vcpu",
            "timer_advance_ns"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_to_cycles",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "291-295",
          "snippet": "static inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void __wait_lapic_expire(struct kvm_vcpu *vcpu, u64 guest_cycles)\n{\n\tu64 timer_advance_ns = vcpu->arch.apic->lapic_timer.timer_advance_ns;\n\n\t/*\n\t * If the guest TSC is running at a different ratio than the host, then\n\t * convert the delay to nanoseconds to achieve an accurate delay.  Note\n\t * that __delay() uses delay_tsc whenever the hardware has TSC, thus\n\t * always for VMX enabled hardware.\n\t */\n\tif (vcpu->arch.tsc_scaling_ratio == kvm_default_tsc_scaling_ratio) {\n\t\t__delay(min(guest_cycles,\n\t\t\tnsec_to_cycles(vcpu, timer_advance_ns)));\n\t} else {\n\t\tu64 delay_ns = guest_cycles * 1000000ULL;\n\t\tdo_div(delay_ns, vcpu->arch.virtual_tsc_khz);\n\t\tndelay(min_t(u32, delay_ns, timer_advance_ns));\n\t}\n}"
  },
  {
    "function_name": "lapic_timer_int_injected",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1492-1508",
    "snippet": "static bool lapic_timer_int_injected(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = kvm_lapic_get_reg(apic, APIC_LVTT);\n\n\tif (kvm_apic_hw_enabled(apic)) {\n\t\tint vec = reg & APIC_VECTOR_MASK;\n\t\tvoid *bitmap = apic->regs + APIC_ISR;\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tbitmap = apic->regs + APIC_IRR;\n\n\t\tif (apic_test_vector(vec, bitmap))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_test_vector",
          "args": [
            "vec",
            "bitmap"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "apic_test_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "73-76",
          "snippet": "static inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "apic"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "177-182",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_LVTT"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool lapic_timer_int_injected(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 reg = kvm_lapic_get_reg(apic, APIC_LVTT);\n\n\tif (kvm_apic_hw_enabled(apic)) {\n\t\tint vec = reg & APIC_VECTOR_MASK;\n\t\tvoid *bitmap = apic->regs + APIC_ISR;\n\n\t\tif (vcpu->arch.apicv_active)\n\t\t\tbitmap = apic->regs + APIC_IRR;\n\n\t\tif (apic_test_vector(vec, bitmap))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "apic_update_lvtt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1465-1485",
    "snippet": "static void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tif (apic_lvtt_tscdeadline(apic) != (timer_mode ==\n\t\t\t\tAPIC_LVT_TIMER_TSCDEADLINE)) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tpreempt_disable();\n\t\t\tif (apic->lapic_timer.hv_timer_in_use)\n\t\t\t\tcancel_hv_timer(apic);\n\t\t\tpreempt_enable();\n\t\t\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\t\t\tapic->lapic_timer.period = 0;\n\t\t\tapic->lapic_timer.tscdeadline = 0;\n\t\t}\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\tlimit_periodic_timer_frequency(apic);\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "limit_periodic_timer_frequency",
          "args": [
            "apic"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "limit_periodic_timer_frequency",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1442-1461",
          "snippet": "static void limit_periodic_timer_frequency(struct kvm_lapic *apic)\n{\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\tapic->lapic_timer.period = min_period;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void limit_periodic_timer_frequency(struct kvm_lapic *apic)\n{\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\tapic->lapic_timer.period = min_period;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_TMICT",
            "0"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "161-164",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_hv_timer",
          "args": [
            "apic"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "cancel_hv_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1751-1757",
          "snippet": "static void cancel_hv_timer(struct kvm_lapic *apic)\n{\n\tWARN_ON(preemptible());\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\tkvm_x86_ops.cancel_hv_timer(apic->vcpu);\n\tapic->lapic_timer.hv_timer_in_use = false;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic)\n{\n\tWARN_ON(preemptible());\n\tWARN_ON(!apic->lapic_timer.hv_timer_in_use);\n\tkvm_x86_ops.cancel_hv_timer(apic->vcpu);\n\tapic->lapic_timer.hv_timer_in_use = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&apic->lapic_timer.timer"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "327-330",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_LVTT"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_update_lvtt(struct kvm_lapic *apic)\n{\n\tu32 timer_mode = kvm_lapic_get_reg(apic, APIC_LVTT) &\n\t\t\tapic->lapic_timer.timer_mode_mask;\n\n\tif (apic->lapic_timer.timer_mode != timer_mode) {\n\t\tif (apic_lvtt_tscdeadline(apic) != (timer_mode ==\n\t\t\t\tAPIC_LVT_TIMER_TSCDEADLINE)) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tpreempt_disable();\n\t\t\tif (apic->lapic_timer.hv_timer_in_use)\n\t\t\t\tcancel_hv_timer(apic);\n\t\t\tpreempt_enable();\n\t\t\tkvm_lapic_set_reg(apic, APIC_TMICT, 0);\n\t\t\tapic->lapic_timer.period = 0;\n\t\t\tapic->lapic_timer.tscdeadline = 0;\n\t\t}\n\t\tapic->lapic_timer.timer_mode = timer_mode;\n\t\tlimit_periodic_timer_frequency(apic);\n\t}\n}"
  },
  {
    "function_name": "limit_periodic_timer_frequency",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1442-1461",
    "snippet": "static void limit_periodic_timer_frequency(struct kvm_lapic *apic)\n{\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\tapic->lapic_timer.period = min_period;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info_ratelimited",
          "args": [
            "\"kvm: vcpu %i: requested %lld ns \"\n\t\t\t    \"lapic timer period limited to %lld ns\\n\"",
            "apic->vcpu->vcpu_id",
            "apic->lapic_timer.period",
            "min_period"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_lvtt_period",
          "args": [
            "apic"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_period",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "322-325",
          "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void limit_periodic_timer_frequency(struct kvm_lapic *apic)\n{\n\t/*\n\t * Do not allow the guest to program periodic timers with small\n\t * interval, since the hrtimers are not throttled by the host\n\t * scheduler.\n\t */\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\ts64 min_period = min_timer_period_us * 1000LL;\n\n\t\tif (apic->lapic_timer.period < min_period) {\n\t\t\tpr_info_ratelimited(\n\t\t\t    \"kvm: vcpu %i: requested %lld ns \"\n\t\t\t    \"lapic timer period limited to %lld ns\\n\",\n\t\t\t    apic->vcpu->vcpu_id,\n\t\t\t    apic->lapic_timer.period, min_period);\n\t\t\tapic->lapic_timer.period = min_period;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "update_divide_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1432-1440",
    "snippet": "static void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TDCR"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void update_divide_count(struct kvm_lapic *apic)\n{\n\tu32 tmp1, tmp2, tdcr;\n\n\ttdcr = kvm_lapic_get_reg(apic, APIC_TDCR);\n\ttmp1 = tdcr & 0xf;\n\ttmp2 = ((tmp1 & 0x3) | ((tmp1 & 0x8) >> 1)) + 1;\n\tapic->divide_count = 0x1 << (tmp2 & 0x7);\n}"
  },
  {
    "function_name": "apic_mmio_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1409-1430",
    "snippet": "static int apic_mmio_read(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t   gpa_t address, int len, void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tu32 offset = address - apic->base_address;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {\n\t\tif (!kvm_check_has_quirk(vcpu->kvm,\n\t\t\t\t\t KVM_X86_QUIRK_LAPIC_MMIO_HOLE))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmemset(data, 0xff, len);\n\t\treturn 0;\n\t}\n\n\tkvm_lapic_reg_read(apic, offset, len, data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_read",
          "args": [
            "apic",
            "offset",
            "len",
            "data"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1347-1400",
          "snippet": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tu64 valid_reg_mask =\n\t\tAPIC_REG_MASK(APIC_ID) |\n\t\tAPIC_REG_MASK(APIC_LVR) |\n\t\tAPIC_REG_MASK(APIC_TASKPRI) |\n\t\tAPIC_REG_MASK(APIC_PROCPRI) |\n\t\tAPIC_REG_MASK(APIC_LDR) |\n\t\tAPIC_REG_MASK(APIC_DFR) |\n\t\tAPIC_REG_MASK(APIC_SPIV) |\n\t\tAPIC_REGS_MASK(APIC_ISR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_TMR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_IRR, APIC_ISR_NR) |\n\t\tAPIC_REG_MASK(APIC_ESR) |\n\t\tAPIC_REG_MASK(APIC_ICR) |\n\t\tAPIC_REG_MASK(APIC_ICR2) |\n\t\tAPIC_REG_MASK(APIC_LVTT) |\n\t\tAPIC_REG_MASK(APIC_LVTTHMR) |\n\t\tAPIC_REG_MASK(APIC_LVTPC) |\n\t\tAPIC_REG_MASK(APIC_LVT0) |\n\t\tAPIC_REG_MASK(APIC_LVT1) |\n\t\tAPIC_REG_MASK(APIC_LVTERR) |\n\t\tAPIC_REG_MASK(APIC_TMICT) |\n\t\tAPIC_REG_MASK(APIC_TMCCT) |\n\t\tAPIC_REG_MASK(APIC_TDCR);\n\n\t/* ARBPRI is not valid on x2APIC */\n\tif (!apic_x2apic_mode(apic))\n\t\tvalid_reg_mask |= APIC_REG_MASK(APIC_ARBPRI);\n\n\tif (offset > 0x3f0 || !(valid_reg_mask & APIC_REG_MASK(offset)))\n\t\treturn 1;\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tu64 valid_reg_mask =\n\t\tAPIC_REG_MASK(APIC_ID) |\n\t\tAPIC_REG_MASK(APIC_LVR) |\n\t\tAPIC_REG_MASK(APIC_TASKPRI) |\n\t\tAPIC_REG_MASK(APIC_PROCPRI) |\n\t\tAPIC_REG_MASK(APIC_LDR) |\n\t\tAPIC_REG_MASK(APIC_DFR) |\n\t\tAPIC_REG_MASK(APIC_SPIV) |\n\t\tAPIC_REGS_MASK(APIC_ISR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_TMR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_IRR, APIC_ISR_NR) |\n\t\tAPIC_REG_MASK(APIC_ESR) |\n\t\tAPIC_REG_MASK(APIC_ICR) |\n\t\tAPIC_REG_MASK(APIC_ICR2) |\n\t\tAPIC_REG_MASK(APIC_LVTT) |\n\t\tAPIC_REG_MASK(APIC_LVTTHMR) |\n\t\tAPIC_REG_MASK(APIC_LVTPC) |\n\t\tAPIC_REG_MASK(APIC_LVT0) |\n\t\tAPIC_REG_MASK(APIC_LVT1) |\n\t\tAPIC_REG_MASK(APIC_LVTERR) |\n\t\tAPIC_REG_MASK(APIC_TMICT) |\n\t\tAPIC_REG_MASK(APIC_TMCCT) |\n\t\tAPIC_REG_MASK(APIC_TDCR);\n\n\t/* ARBPRI is not valid on x2APIC */\n\tif (!apic_x2apic_mode(apic))\n\t\tvalid_reg_mask |= APIC_REG_MASK(APIC_ARBPRI);\n\n\tif (offset > 0x3f0 || !(valid_reg_mask & APIC_REG_MASK(offset)))\n\t\treturn 1;\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0xff",
            "len"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_check_has_quirk",
          "args": [
            "vcpu->kvm",
            "KVM_X86_QUIRK_LAPIC_MMIO_HOLE"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_check_has_quirk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "233-236",
          "snippet": "static inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "apic"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "177-182",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_mmio_in_range",
          "args": [
            "apic",
            "address"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "apic_mmio_in_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1403-1407",
          "snippet": "static int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn addr >= apic->base_address &&\n\t\taddr < apic->base_address + LAPIC_MMIO_LENGTH;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define LAPIC_MMIO_LENGTH\t\t(1 << 12)"
          ],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn addr >= apic->base_address &&\n\t\taddr < apic->base_address + LAPIC_MMIO_LENGTH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_lapic",
          "args": [
            "this"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "to_lapic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1338-1341",
          "snippet": "static inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int apic_mmio_read(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t   gpa_t address, int len, void *data)\n{\n\tstruct kvm_lapic *apic = to_lapic(this);\n\tu32 offset = address - apic->base_address;\n\n\tif (!apic_mmio_in_range(apic, address))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!kvm_apic_hw_enabled(apic) || apic_x2apic_mode(apic)) {\n\t\tif (!kvm_check_has_quirk(vcpu->kvm,\n\t\t\t\t\t KVM_X86_QUIRK_LAPIC_MMIO_HOLE))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tmemset(data, 0xff, len);\n\t\treturn 0;\n\t}\n\n\tkvm_lapic_reg_read(apic, offset, len, data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "apic_mmio_in_range",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1403-1407",
    "snippet": "static int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn addr >= apic->base_address &&\n\t\taddr < apic->base_address + LAPIC_MMIO_LENGTH;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define LAPIC_MMIO_LENGTH\t\t(1 << 12)"
    ],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int apic_mmio_in_range(struct kvm_lapic *apic, gpa_t addr)\n{\n\treturn addr >= apic->base_address &&\n\t\taddr < apic->base_address + LAPIC_MMIO_LENGTH;\n}"
  },
  {
    "function_name": "kvm_lapic_reg_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1347-1400",
    "snippet": "int kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tu64 valid_reg_mask =\n\t\tAPIC_REG_MASK(APIC_ID) |\n\t\tAPIC_REG_MASK(APIC_LVR) |\n\t\tAPIC_REG_MASK(APIC_TASKPRI) |\n\t\tAPIC_REG_MASK(APIC_PROCPRI) |\n\t\tAPIC_REG_MASK(APIC_LDR) |\n\t\tAPIC_REG_MASK(APIC_DFR) |\n\t\tAPIC_REG_MASK(APIC_SPIV) |\n\t\tAPIC_REGS_MASK(APIC_ISR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_TMR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_IRR, APIC_ISR_NR) |\n\t\tAPIC_REG_MASK(APIC_ESR) |\n\t\tAPIC_REG_MASK(APIC_ICR) |\n\t\tAPIC_REG_MASK(APIC_ICR2) |\n\t\tAPIC_REG_MASK(APIC_LVTT) |\n\t\tAPIC_REG_MASK(APIC_LVTTHMR) |\n\t\tAPIC_REG_MASK(APIC_LVTPC) |\n\t\tAPIC_REG_MASK(APIC_LVT0) |\n\t\tAPIC_REG_MASK(APIC_LVT1) |\n\t\tAPIC_REG_MASK(APIC_LVTERR) |\n\t\tAPIC_REG_MASK(APIC_TMICT) |\n\t\tAPIC_REG_MASK(APIC_TMCCT) |\n\t\tAPIC_REG_MASK(APIC_TDCR);\n\n\t/* ARBPRI is not valid on x2APIC */\n\tif (!apic_x2apic_mode(apic))\n\t\tvalid_reg_mask |= APIC_REG_MASK(APIC_ARBPRI);\n\n\tif (offset > 0x3f0 || !(valid_reg_mask & APIC_REG_MASK(offset)))\n\t\treturn 1;\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\"",
            "len"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "(char *)&result + alignment",
            "len"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_apic_read",
          "args": [
            "offset",
            "result"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__apic_read",
          "args": [
            "apic",
            "offset & ~0xf"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1306-1336",
          "snippet": "static u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ARBPRI:\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define LAPIC_MMIO_LENGTH\t\t(1 << 12)"
          ],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ARBPRI:\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "offset"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_ARBPRI"
          ],
          "line": 1379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_TDCR"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_TMCCT"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_TMICT"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_LVTERR"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_LVT1"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_LVT0"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_LVTPC"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_LVTTHMR"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_LVTT"
          ],
          "line": 1367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_ICR2"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_ICR"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_ESR"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REGS_MASK",
          "args": [
            "APIC_IRR",
            "APIC_ISR_NR"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REGS_MASK",
          "args": [
            "APIC_TMR",
            "APIC_ISR_NR"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REGS_MASK",
          "args": [
            "APIC_ISR",
            "APIC_ISR_NR"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_SPIV"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_DFR"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_LDR"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_PROCPRI"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_TASKPRI"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_LVR"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "APIC_REG_MASK",
          "args": [
            "APIC_ID"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_read(struct kvm_lapic *apic, u32 offset, int len,\n\t\tvoid *data)\n{\n\tunsigned char alignment = offset & 0xf;\n\tu32 result;\n\t/* this bitmask has a bit cleared for each reserved register */\n\tu64 valid_reg_mask =\n\t\tAPIC_REG_MASK(APIC_ID) |\n\t\tAPIC_REG_MASK(APIC_LVR) |\n\t\tAPIC_REG_MASK(APIC_TASKPRI) |\n\t\tAPIC_REG_MASK(APIC_PROCPRI) |\n\t\tAPIC_REG_MASK(APIC_LDR) |\n\t\tAPIC_REG_MASK(APIC_DFR) |\n\t\tAPIC_REG_MASK(APIC_SPIV) |\n\t\tAPIC_REGS_MASK(APIC_ISR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_TMR, APIC_ISR_NR) |\n\t\tAPIC_REGS_MASK(APIC_IRR, APIC_ISR_NR) |\n\t\tAPIC_REG_MASK(APIC_ESR) |\n\t\tAPIC_REG_MASK(APIC_ICR) |\n\t\tAPIC_REG_MASK(APIC_ICR2) |\n\t\tAPIC_REG_MASK(APIC_LVTT) |\n\t\tAPIC_REG_MASK(APIC_LVTTHMR) |\n\t\tAPIC_REG_MASK(APIC_LVTPC) |\n\t\tAPIC_REG_MASK(APIC_LVT0) |\n\t\tAPIC_REG_MASK(APIC_LVT1) |\n\t\tAPIC_REG_MASK(APIC_LVTERR) |\n\t\tAPIC_REG_MASK(APIC_TMICT) |\n\t\tAPIC_REG_MASK(APIC_TMCCT) |\n\t\tAPIC_REG_MASK(APIC_TDCR);\n\n\t/* ARBPRI is not valid on x2APIC */\n\tif (!apic_x2apic_mode(apic))\n\t\tvalid_reg_mask |= APIC_REG_MASK(APIC_ARBPRI);\n\n\tif (offset > 0x3f0 || !(valid_reg_mask & APIC_REG_MASK(offset)))\n\t\treturn 1;\n\n\tresult = __apic_read(apic, offset & ~0xf);\n\n\ttrace_kvm_apic_read(offset, result);\n\n\tswitch (len) {\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(data, (char *)&result + alignment, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"Local APIC read with len = %x, \"\n\t\t       \"should be 1,2, or 4 instead\\n\", len);\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "to_lapic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1338-1341",
    "snippet": "static inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_lapic",
            "dev"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_lapic *to_lapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_lapic, dev);\n}"
  },
  {
    "function_name": "__apic_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1306-1336",
    "snippet": "static u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ARBPRI:\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define LAPIC_MMIO_LENGTH\t\t(1 << 12)"
    ],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "offset"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "report_tpr_access",
          "args": [
            "apic",
            "false"
          ],
          "line": 1328
        },
        "resolved": true,
        "details": {
          "function_name": "report_tpr_access",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1300-1304",
          "snippet": "static inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_update_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "716-719",
          "snippet": "void kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_get_tmcct",
          "args": [
            "apic"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "apic_get_tmcct",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1265-1288",
          "snippet": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining, now;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_lapic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tnow = ktime_get();\n\tremaining = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = 0;\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining, now;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_lapic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tnow = ktime_get();\n\tremaining = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = 0;\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_lvtt_tscdeadline",
          "args": [
            "apic"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "apic_lvtt_tscdeadline",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "327-330",
          "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define LAPIC_MMIO_LENGTH\t\t(1 << 12)\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic u32 __apic_read(struct kvm_lapic *apic, unsigned int offset)\n{\n\tu32 val = 0;\n\n\tif (offset >= LAPIC_MMIO_LENGTH)\n\t\treturn 0;\n\n\tswitch (offset) {\n\tcase APIC_ARBPRI:\n\t\tbreak;\n\n\tcase APIC_TMCCT:\t/* Timer CCR */\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\treturn 0;\n\n\t\tval = apic_get_tmcct(apic);\n\t\tbreak;\n\tcase APIC_PROCPRI:\n\t\tapic_update_ppr(apic);\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, false);\n\t\t/* fall thru */\n\tdefault:\n\t\tval = kvm_lapic_get_reg(apic, offset);\n\t\tbreak;\n\t}\n\n\treturn val;\n}"
  },
  {
    "function_name": "report_tpr_access",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1300-1304",
    "snippet": "static inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__report_tpr_access",
          "args": [
            "apic",
            "write"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "__report_tpr_access",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1290-1298",
          "snippet": "static void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tif (apic->vcpu->arch.tpr_access_reporting)\n\t\t__report_tpr_access(apic, write);\n}"
  },
  {
    "function_name": "__report_tpr_access",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1290-1298",
    "snippet": "static void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "86-89",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_REPORT_TPR_ACCESS",
            "vcpu"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void __report_tpr_access(struct kvm_lapic *apic, bool write)\n{\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\tstruct kvm_run *run = vcpu->run;\n\n\tkvm_make_request(KVM_REQ_REPORT_TPR_ACCESS, vcpu);\n\trun->tpr_access.rip = kvm_rip_read(vcpu);\n\trun->tpr_access.is_write = write;\n}"
  },
  {
    "function_name": "apic_get_tmcct",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1265-1288",
    "snippet": "static u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining, now;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_lapic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tnow = ktime_get();\n\tremaining = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = 0;\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_u64",
          "args": [
            "ns",
            "(APIC_BUS_CYCLE_NS * apic->divide_count)"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mod_64",
          "args": [
            "ktime_to_ns(remaining)",
            "apic->lapic_timer.period"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "remaining"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "remaining"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "apic->lapic_timer.target_expiration",
            "now"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TMICT"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "apic != NULL"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic u32 apic_get_tmcct(struct kvm_lapic *apic)\n{\n\tktime_t remaining, now;\n\ts64 ns;\n\tu32 tmcct;\n\n\tASSERT(apic != NULL);\n\n\t/* if initial count is 0, current count should also be 0 */\n\tif (kvm_lapic_get_reg(apic, APIC_TMICT) == 0 ||\n\t\tapic->lapic_timer.period == 0)\n\t\treturn 0;\n\n\tnow = ktime_get();\n\tremaining = ktime_sub(apic->lapic_timer.target_expiration, now);\n\tif (ktime_to_ns(remaining) < 0)\n\t\tremaining = 0;\n\n\tns = mod_64(ktime_to_ns(remaining), apic->lapic_timer.period);\n\ttmcct = div64_u64(ns,\n\t\t\t (APIC_BUS_CYCLE_NS * apic->divide_count));\n\n\treturn tmcct;\n}"
  },
  {
    "function_name": "kvm_apic_send_ipi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1244-1263",
    "snippet": "void kvm_apic_send_ipi(struct kvm_lapic *apic, u32 icr_low, u32 icr_high)\n{\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = (icr_low & APIC_INT_ASSERT) != 0;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tirq.msi_redir_hint = false;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic",
          "args": [
            "apic->vcpu->kvm",
            "apic",
            "&irq",
            "NULL"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "47-102",
          "snippet": "int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL &&\n\t    irq->dest_id == 0xff && kvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL &&\n\t    irq->dest_id == 0xff && kvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_apic_ipi",
          "args": [
            "icr_low",
            "irq.dest_id"
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_APIC_DEST_FIELD",
          "args": [
            "icr_high"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_send_ipi(struct kvm_lapic *apic, u32 icr_low, u32 icr_high)\n{\n\tstruct kvm_lapic_irq irq;\n\n\tirq.vector = icr_low & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr_low & APIC_MODE_MASK;\n\tirq.dest_mode = icr_low & APIC_DEST_MASK;\n\tirq.level = (icr_low & APIC_INT_ASSERT) != 0;\n\tirq.trig_mode = icr_low & APIC_INT_LEVELTRIG;\n\tirq.shorthand = icr_low & APIC_SHORT_MASK;\n\tirq.msi_redir_hint = false;\n\tif (apic_x2apic_mode(apic))\n\t\tirq.dest_id = icr_high;\n\telse\n\t\tirq.dest_id = GET_APIC_DEST_FIELD(icr_high);\n\n\ttrace_kvm_apic_ipi(icr_low, irq.dest_id);\n\n\tkvm_irq_delivery_to_apic(apic->vcpu->kvm, apic, &irq, NULL);\n}"
  },
  {
    "function_name": "kvm_apic_set_eoi_accelerated",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1233-1241",
    "snippet": "void kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\ttrace_kvm_eoi(apic, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "apic->vcpu"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_send_eoi",
          "args": [
            "apic",
            "vector"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_send_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1182-1203",
          "snippet": "static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_eoi",
          "args": [
            "apic",
            "vector"
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\ttrace_kvm_eoi(apic, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}"
  },
  {
    "function_name": "apic_set_eoi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1205-1227",
    "snippet": "static int apic_set_eoi(struct kvm_lapic *apic)\n{\n\tint vector = apic_find_highest_isr(apic);\n\n\ttrace_kvm_eoi(apic, vector);\n\n\t/*\n\t * Not every write EOI will has corresponding ISR,\n\t * one example is when Kernel check timer on setup_IO_APIC\n\t */\n\tif (vector == -1)\n\t\treturn vector;\n\n\tapic_clear_isr(vector, apic);\n\tapic_update_ppr(apic);\n\n\tif (test_bit(vector, vcpu_to_synic(apic->vcpu)->vec_bitmap))\n\t\tkvm_hv_synic_send_eoi(apic->vcpu, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\treturn vector;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "apic->vcpu"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_send_eoi",
          "args": [
            "apic",
            "vector"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_send_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1182-1203",
          "snippet": "static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_synic_send_eoi",
          "args": [
            "apic->vcpu",
            "vector"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_synic_send_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "340-350",
          "snippet": "void kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tint i;\n\n\ttrace_kvm_hv_synic_send_eoi(vcpu->vcpu_id, vector);\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tint i;\n\n\ttrace_kvm_hv_synic_send_eoi(vcpu->vcpu_id, vector);\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vector",
            "vcpu_to_synic(apic->vcpu)->vec_bitmap"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "apic->vcpu"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "39-42",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_update_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "716-719",
          "snippet": "void kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_clear_isr",
          "args": [
            "vector",
            "apic"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "apic_clear_isr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "523-546",
          "snippet": "static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tif (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * We do get here for APIC virtualization enabled if the guest\n\t * uses the Hyper-V APIC enlightenment.  In this case we may need\n\t * to trigger a new interrupt delivery by writing the SVI field;\n\t * on the other hand isr_count and highest_isr_cache are unused\n\t * and must be left alone.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu,\n\t\t\t\t\t       apic_find_highest_isr(apic));\n\telse {\n\t\t--apic->isr_count;\n\t\tBUG_ON(apic->isr_count < 0);\n\t\tapic->highest_isr_cache = -1;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tif (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * We do get here for APIC virtualization enabled if the guest\n\t * uses the Hyper-V APIC enlightenment.  In this case we may need\n\t * to trigger a new interrupt delivery by writing the SVI field;\n\t * on the other hand isr_count and highest_isr_cache are unused\n\t * and must be left alone.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu,\n\t\t\t\t\t       apic_find_highest_isr(apic));\n\telse {\n\t\t--apic->isr_count;\n\t\tBUG_ON(apic->isr_count < 0);\n\t\tapic->highest_isr_cache = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_eoi",
          "args": [
            "apic",
            "vector"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_isr",
          "args": [
            "apic"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "apic_find_highest_isr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "504-521",
          "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int apic_set_eoi(struct kvm_lapic *apic)\n{\n\tint vector = apic_find_highest_isr(apic);\n\n\ttrace_kvm_eoi(apic, vector);\n\n\t/*\n\t * Not every write EOI will has corresponding ISR,\n\t * one example is when Kernel check timer on setup_IO_APIC\n\t */\n\tif (vector == -1)\n\t\treturn vector;\n\n\tapic_clear_isr(vector, apic);\n\tapic_update_ppr(apic);\n\n\tif (test_bit(vector, vcpu_to_synic(apic->vcpu)->vec_bitmap))\n\t\tkvm_hv_synic_send_eoi(apic->vcpu, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n\treturn vector;\n}"
  },
  {
    "function_name": "kvm_ioapic_send_eoi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1182-1203",
    "snippet": "static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_ioapic_update_eoi",
          "args": [
            "apic->vcpu",
            "vector",
            "trigger_mode"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_update_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "553-568",
          "snippet": "void kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)\n{\n\tint i;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\trtc_irq_eoi(ioapic, vcpu, vector);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.vector != vector)\n\t\t\tcontinue;\n\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic, trigger_mode, i);\n\t}\n\tspin_unlock(&ioapic->lock);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)\n{\n\tint i;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\trtc_irq_eoi(ioapic, vcpu, vector);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.vector != vector)\n\t\t\tcontinue;\n\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic, trigger_mode, i);\n\t}\n\tspin_unlock(&ioapic->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_test_vector",
          "args": [
            "vector",
            "apic->regs + APIC_TMR"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "apic_test_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "73-76",
          "snippet": "static inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_IOAPIC_EOI_EXIT",
            "apic->vcpu"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqchip_split",
          "args": [
            "apic->vcpu->kvm"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_split",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.h",
          "lines": "78-85",
          "snippet": "static inline int irqchip_split(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_SPLIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_split(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_SPLIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_handles_vector",
          "args": [
            "apic",
            "vector"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_handles_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1177-1180",
          "snippet": "static bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n\tint trigger_mode;\n\n\t/* Eoi the ioapic only if the ioapic doesn't own the vector. */\n\tif (!kvm_ioapic_handles_vector(apic, vector))\n\t\treturn;\n\n\t/* Request a KVM exit to inform the userspace IOAPIC. */\n\tif (irqchip_split(apic->vcpu->kvm)) {\n\t\tapic->vcpu->arch.pending_ioapic_eoi = vector;\n\t\tkvm_make_request(KVM_REQ_IOAPIC_EOI_EXIT, apic->vcpu);\n\t\treturn;\n\t}\n\n\tif (apic_test_vector(vector, apic->regs + APIC_TMR))\n\t\ttrigger_mode = IOAPIC_LEVEL_TRIG;\n\telse\n\t\ttrigger_mode = IOAPIC_EDGE_TRIG;\n\n\tkvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n}"
  },
  {
    "function_name": "kvm_ioapic_handles_vector",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1177-1180",
    "snippet": "static bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vector",
            "apic->vcpu->arch.ioapic_handled_vectors"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool kvm_ioapic_handles_vector(struct kvm_lapic *apic, int vector)\n{\n\treturn test_bit(vector, apic->vcpu->arch.ioapic_handled_vectors);\n}"
  },
  {
    "function_name": "kvm_apic_compare_prio",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1172-1175",
    "snippet": "int kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}"
  },
  {
    "function_name": "kvm_bitmap_or_dest_vcpus",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1134-1170",
    "snippet": "void kvm_bitmap_or_dest_vcpus(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\t      unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_lapic **dest_vcpu = NULL;\n\tstruct kvm_lapic *src = NULL;\n\tstruct kvm_apic_map *map;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long bitmap;\n\tint i, vcpu_idx;\n\tbool ret;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dest_vcpu,\n\t\t\t\t\t  &bitmap);\n\tif (ret) {\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dest_vcpu[i])\n\t\t\t\tcontinue;\n\t\t\tvcpu_idx = dest_vcpu[i]->vcpu->vcpu_idx;\n\t\t\t__set_bit(vcpu_idx, vcpu_bitmap);\n\t\t}\n\t} else {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!kvm_apic_present(vcpu))\n\t\t\t\tcontinue;\n\t\t\tif (!kvm_apic_match_dest(vcpu, NULL,\n\t\t\t\t\t\t irq->shorthand,\n\t\t\t\t\t\t irq->dest_id,\n\t\t\t\t\t\t irq->dest_mode))\n\t\t\t\tcontinue;\n\t\t\t__set_bit(i, vcpu_bitmap);\n\t\t}\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "i",
            "vcpu_bitmap"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "NULL",
            "irq->shorthand",
            "irq->dest_id",
            "irq->dest_mode"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "808-830",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_present",
          "args": [
            "vcpu"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_present",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "193-196",
          "snippet": "static inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "vcpu_idx",
            "vcpu_bitmap"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "&bitmap",
            "16"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_map_get_dest_lapic",
          "args": [
            "kvm",
            "&src",
            "irq",
            "map",
            "&dest_vcpu",
            "&bitmap"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_map_get_dest_lapic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "884-948",
          "snippet": "static inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,\n\t\tstruct kvm_lapic **src, struct kvm_lapic_irq *irq,\n\t\tstruct kvm_apic_map *map, struct kvm_lapic ***dst,\n\t\tunsigned long *bitmap)\n{\n\tint i, lowest;\n\n\tif (irq->shorthand == APIC_DEST_SELF && src) {\n\t\t*dst = src;\n\t\t*bitmap = 1;\n\t\treturn true;\n\t} else if (irq->shorthand)\n\t\treturn false;\n\n\tif (!map || kvm_apic_is_broadcast_dest(kvm, src, irq, map))\n\t\treturn false;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id > map->max_apic_id) {\n\t\t\t*bitmap = 0;\n\t\t} else {\n\t\t\tu32 dest_id = array_index_nospec(irq->dest_id, map->max_apic_id + 1);\n\t\t\t*dst = &map->phys_map[dest_id];\n\t\t\t*bitmap = 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\t*bitmap = 0;\n\tif (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,\n\t\t\t\t(u16 *)bitmap))\n\t\treturn false;\n\n\tif (!kvm_lowest_prio_delivery(irq))\n\t\treturn true;\n\n\tif (!kvm_vector_hashing_enabled()) {\n\t\tlowest = -1;\n\t\tfor_each_set_bit(i, bitmap, 16) {\n\t\t\tif (!(*dst)[i])\n\t\t\t\tcontinue;\n\t\t\tif (lowest < 0)\n\t\t\t\tlowest = i;\n\t\t\telse if (kvm_apic_compare_prio((*dst)[i]->vcpu,\n\t\t\t\t\t\t(*dst)[lowest]->vcpu) < 0)\n\t\t\t\tlowest = i;\n\t\t}\n\t} else {\n\t\tif (!*bitmap)\n\t\t\treturn true;\n\n\t\tlowest = kvm_vector_to_index(irq->vector, hweight16(*bitmap),\n\t\t\t\tbitmap, 16);\n\n\t\tif (!(*dst)[lowest]) {\n\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t*bitmap = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t*bitmap = (lowest >= 0) ? 1 << lowest : 0;\n\n\treturn true;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,\n\t\tstruct kvm_lapic **src, struct kvm_lapic_irq *irq,\n\t\tstruct kvm_apic_map *map, struct kvm_lapic ***dst,\n\t\tunsigned long *bitmap)\n{\n\tint i, lowest;\n\n\tif (irq->shorthand == APIC_DEST_SELF && src) {\n\t\t*dst = src;\n\t\t*bitmap = 1;\n\t\treturn true;\n\t} else if (irq->shorthand)\n\t\treturn false;\n\n\tif (!map || kvm_apic_is_broadcast_dest(kvm, src, irq, map))\n\t\treturn false;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id > map->max_apic_id) {\n\t\t\t*bitmap = 0;\n\t\t} else {\n\t\t\tu32 dest_id = array_index_nospec(irq->dest_id, map->max_apic_id + 1);\n\t\t\t*dst = &map->phys_map[dest_id];\n\t\t\t*bitmap = 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\t*bitmap = 0;\n\tif (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,\n\t\t\t\t(u16 *)bitmap))\n\t\treturn false;\n\n\tif (!kvm_lowest_prio_delivery(irq))\n\t\treturn true;\n\n\tif (!kvm_vector_hashing_enabled()) {\n\t\tlowest = -1;\n\t\tfor_each_set_bit(i, bitmap, 16) {\n\t\t\tif (!(*dst)[i])\n\t\t\t\tcontinue;\n\t\t\tif (lowest < 0)\n\t\t\t\tlowest = i;\n\t\t\telse if (kvm_apic_compare_prio((*dst)[i]->vcpu,\n\t\t\t\t\t\t(*dst)[lowest]->vcpu) < 0)\n\t\t\t\tlowest = i;\n\t\t}\n\t} else {\n\t\tif (!*bitmap)\n\t\t\treturn true;\n\n\t\tlowest = kvm_vector_to_index(irq->vector, hweight16(*bitmap),\n\t\t\t\tbitmap, 16);\n\n\t\tif (!(*dst)[lowest]) {\n\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t*bitmap = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t*bitmap = (lowest >= 0) ? 1 << lowest : 0;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "kvm->arch.apic_map"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_bitmap_or_dest_vcpus(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\t      unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_lapic **dest_vcpu = NULL;\n\tstruct kvm_lapic *src = NULL;\n\tstruct kvm_apic_map *map;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long bitmap;\n\tint i, vcpu_idx;\n\tbool ret;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dest_vcpu,\n\t\t\t\t\t  &bitmap);\n\tif (ret) {\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dest_vcpu[i])\n\t\t\t\tcontinue;\n\t\t\tvcpu_idx = dest_vcpu[i]->vcpu->vcpu_idx;\n\t\t\t__set_bit(vcpu_idx, vcpu_bitmap);\n\t\t}\n\t} else {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!kvm_apic_present(vcpu))\n\t\t\t\tcontinue;\n\t\t\tif (!kvm_apic_match_dest(vcpu, NULL,\n\t\t\t\t\t\t irq->shorthand,\n\t\t\t\t\t\t irq->dest_id,\n\t\t\t\t\t\t irq->dest_mode))\n\t\t\t\tcontinue;\n\t\t\t__set_bit(i, vcpu_bitmap);\n\t\t}\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "__apic_accept_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "1029-1126",
    "snippet": "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\t\t/* fall through */\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector,\n\t\t\t\t\t\t     apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tkvm_lapic_clear_vector(vector,\n\t\t\t\t\t\t       apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (kvm_x86_ops.deliver_posted_interrupt(vcpu, vector)) {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);",
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"TODO: unsupported delivery mode %x\\n\"",
            "delivery_mode"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "KVM_APIC_SIPI",
            "&apic->pending_events"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "224-232",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_inject_nmi",
          "args": [
            "vcpu"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_inject_nmi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "624-628",
          "snippet": "void kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tatomic_inc(&vcpu->arch.nmi_queued);\n\tkvm_make_request(KVM_REQ_NMI, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_SMI",
            "vcpu"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_irr",
          "args": [
            "vector",
            "apic"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "146-154",
          "snippet": "static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tkvm_lapic_set_vector(vec, apic->regs + APIC_IRR);\n\t/*\n\t * irr_pending must be true if any interrupt is pending; set it after\n\t * APIC_IRR to avoid race with apic_clear_irr\n\t */\n\tapic->irr_pending = true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tkvm_lapic_set_vector(vec, apic->regs + APIC_IRR);\n\t/*\n\t * irr_pending must be true if any interrupt is pending; set it after\n\t * APIC_IRR to avoid race with apic_clear_irr\n\t */\n\tapic->irr_pending = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.deliver_posted_interrupt",
          "args": [
            "vcpu",
            "vector"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_clear_vector",
          "args": [
            "vector",
            "apic->regs + APIC_TMR"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_clear_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "136-139",
          "snippet": "static inline void kvm_lapic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_vector",
          "args": [
            "vector",
            "apic->regs + APIC_TMR"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "141-144",
          "snippet": "static inline void kvm_lapic_set_vector(int vec, void *bitmap)\n{\n\tset_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_vector(int vec, void *bitmap)\n{\n\tset_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_test_vector",
          "args": [
            "vector",
            "apic->regs + APIC_TMR"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "apic_test_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "73-76",
          "snippet": "static inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "vcpu->vcpu_id",
            "dest_map->map"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!apic_enabled(apic)"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_enabled",
          "args": [
            "apic"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "apic_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "99-102",
          "snippet": "static inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "trig_mode && !level"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_apic_accept_irq",
          "args": [
            "vcpu->vcpu_id",
            "delivery_mode",
            "trig_mode",
            "vector"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\t\t/* fall through */\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector,\n\t\t\t\t\t\t     apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tkvm_lapic_clear_vector(vector,\n\t\t\t\t\t\t       apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (kvm_x86_ops.deliver_posted_interrupt(vcpu, vector)) {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "kvm_intr_is_single_vcpu_fast",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "997-1023",
    "snippet": "bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tbool ret = false;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (kvm_apic_map_get_dest_lapic(kvm, NULL, irq, map, &dst, &bitmap) &&\n\t\t\thweight16(bitmap) == 1) {\n\t\tunsigned long i = find_first_bit(&bitmap, 16);\n\n\t\tif (dst[i]) {\n\t\t\t*dest_vcpu = dst[i]->vcpu;\n\t\t\tret = true;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "&bitmap",
            "16"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hweight16",
          "args": [
            "bitmap"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_map_get_dest_lapic",
          "args": [
            "kvm",
            "NULL",
            "irq",
            "map",
            "&dst",
            "&bitmap"
          ],
          "line": 1011
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_map_get_dest_lapic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "884-948",
          "snippet": "static inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,\n\t\tstruct kvm_lapic **src, struct kvm_lapic_irq *irq,\n\t\tstruct kvm_apic_map *map, struct kvm_lapic ***dst,\n\t\tunsigned long *bitmap)\n{\n\tint i, lowest;\n\n\tif (irq->shorthand == APIC_DEST_SELF && src) {\n\t\t*dst = src;\n\t\t*bitmap = 1;\n\t\treturn true;\n\t} else if (irq->shorthand)\n\t\treturn false;\n\n\tif (!map || kvm_apic_is_broadcast_dest(kvm, src, irq, map))\n\t\treturn false;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id > map->max_apic_id) {\n\t\t\t*bitmap = 0;\n\t\t} else {\n\t\t\tu32 dest_id = array_index_nospec(irq->dest_id, map->max_apic_id + 1);\n\t\t\t*dst = &map->phys_map[dest_id];\n\t\t\t*bitmap = 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\t*bitmap = 0;\n\tif (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,\n\t\t\t\t(u16 *)bitmap))\n\t\treturn false;\n\n\tif (!kvm_lowest_prio_delivery(irq))\n\t\treturn true;\n\n\tif (!kvm_vector_hashing_enabled()) {\n\t\tlowest = -1;\n\t\tfor_each_set_bit(i, bitmap, 16) {\n\t\t\tif (!(*dst)[i])\n\t\t\t\tcontinue;\n\t\t\tif (lowest < 0)\n\t\t\t\tlowest = i;\n\t\t\telse if (kvm_apic_compare_prio((*dst)[i]->vcpu,\n\t\t\t\t\t\t(*dst)[lowest]->vcpu) < 0)\n\t\t\t\tlowest = i;\n\t\t}\n\t} else {\n\t\tif (!*bitmap)\n\t\t\treturn true;\n\n\t\tlowest = kvm_vector_to_index(irq->vector, hweight16(*bitmap),\n\t\t\t\tbitmap, 16);\n\n\t\tif (!(*dst)[lowest]) {\n\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t*bitmap = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t*bitmap = (lowest >= 0) ? 1 << lowest : 0;\n\n\treturn true;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,\n\t\tstruct kvm_lapic **src, struct kvm_lapic_irq *irq,\n\t\tstruct kvm_apic_map *map, struct kvm_lapic ***dst,\n\t\tunsigned long *bitmap)\n{\n\tint i, lowest;\n\n\tif (irq->shorthand == APIC_DEST_SELF && src) {\n\t\t*dst = src;\n\t\t*bitmap = 1;\n\t\treturn true;\n\t} else if (irq->shorthand)\n\t\treturn false;\n\n\tif (!map || kvm_apic_is_broadcast_dest(kvm, src, irq, map))\n\t\treturn false;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id > map->max_apic_id) {\n\t\t\t*bitmap = 0;\n\t\t} else {\n\t\t\tu32 dest_id = array_index_nospec(irq->dest_id, map->max_apic_id + 1);\n\t\t\t*dst = &map->phys_map[dest_id];\n\t\t\t*bitmap = 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\t*bitmap = 0;\n\tif (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,\n\t\t\t\t(u16 *)bitmap))\n\t\treturn false;\n\n\tif (!kvm_lowest_prio_delivery(irq))\n\t\treturn true;\n\n\tif (!kvm_vector_hashing_enabled()) {\n\t\tlowest = -1;\n\t\tfor_each_set_bit(i, bitmap, 16) {\n\t\t\tif (!(*dst)[i])\n\t\t\t\tcontinue;\n\t\t\tif (lowest < 0)\n\t\t\t\tlowest = i;\n\t\t\telse if (kvm_apic_compare_prio((*dst)[i]->vcpu,\n\t\t\t\t\t\t(*dst)[lowest]->vcpu) < 0)\n\t\t\t\tlowest = i;\n\t\t}\n\t} else {\n\t\tif (!*bitmap)\n\t\t\treturn true;\n\n\t\tlowest = kvm_vector_to_index(irq->vector, hweight16(*bitmap),\n\t\t\t\tbitmap, 16);\n\n\t\tif (!(*dst)[lowest]) {\n\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t*bitmap = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t*bitmap = (lowest >= 0) ? 1 << lowest : 0;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "kvm->arch.apic_map"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tbool ret = false;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (kvm_apic_map_get_dest_lapic(kvm, NULL, irq, map, &dst, &bitmap) &&\n\t\t\thweight16(bitmap) == 1) {\n\t\tunsigned long i = find_first_bit(&bitmap, 16);\n\n\t\tif (dst[i]) {\n\t\t\t*dest_vcpu = dst[i]->vcpu;\n\t\t\tret = true;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_irq_delivery_to_apic_fast",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "950-981",
    "snippet": "bool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_set_irq",
          "args": [
            "dst[i]->vcpu",
            "irq",
            "dest_map"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "563-570",
          "snippet": "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "&bitmap",
            "16"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_map_get_dest_lapic",
          "args": [
            "kvm",
            "&src",
            "irq",
            "map",
            "&dst",
            "&bitmap"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_map_get_dest_lapic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "884-948",
          "snippet": "static inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,\n\t\tstruct kvm_lapic **src, struct kvm_lapic_irq *irq,\n\t\tstruct kvm_apic_map *map, struct kvm_lapic ***dst,\n\t\tunsigned long *bitmap)\n{\n\tint i, lowest;\n\n\tif (irq->shorthand == APIC_DEST_SELF && src) {\n\t\t*dst = src;\n\t\t*bitmap = 1;\n\t\treturn true;\n\t} else if (irq->shorthand)\n\t\treturn false;\n\n\tif (!map || kvm_apic_is_broadcast_dest(kvm, src, irq, map))\n\t\treturn false;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id > map->max_apic_id) {\n\t\t\t*bitmap = 0;\n\t\t} else {\n\t\t\tu32 dest_id = array_index_nospec(irq->dest_id, map->max_apic_id + 1);\n\t\t\t*dst = &map->phys_map[dest_id];\n\t\t\t*bitmap = 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\t*bitmap = 0;\n\tif (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,\n\t\t\t\t(u16 *)bitmap))\n\t\treturn false;\n\n\tif (!kvm_lowest_prio_delivery(irq))\n\t\treturn true;\n\n\tif (!kvm_vector_hashing_enabled()) {\n\t\tlowest = -1;\n\t\tfor_each_set_bit(i, bitmap, 16) {\n\t\t\tif (!(*dst)[i])\n\t\t\t\tcontinue;\n\t\t\tif (lowest < 0)\n\t\t\t\tlowest = i;\n\t\t\telse if (kvm_apic_compare_prio((*dst)[i]->vcpu,\n\t\t\t\t\t\t(*dst)[lowest]->vcpu) < 0)\n\t\t\t\tlowest = i;\n\t\t}\n\t} else {\n\t\tif (!*bitmap)\n\t\t\treturn true;\n\n\t\tlowest = kvm_vector_to_index(irq->vector, hweight16(*bitmap),\n\t\t\t\tbitmap, 16);\n\n\t\tif (!(*dst)[lowest]) {\n\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t*bitmap = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t*bitmap = (lowest >= 0) ? 1 << lowest : 0;\n\n\treturn true;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,\n\t\tstruct kvm_lapic **src, struct kvm_lapic_irq *irq,\n\t\tstruct kvm_apic_map *map, struct kvm_lapic ***dst,\n\t\tunsigned long *bitmap)\n{\n\tint i, lowest;\n\n\tif (irq->shorthand == APIC_DEST_SELF && src) {\n\t\t*dst = src;\n\t\t*bitmap = 1;\n\t\treturn true;\n\t} else if (irq->shorthand)\n\t\treturn false;\n\n\tif (!map || kvm_apic_is_broadcast_dest(kvm, src, irq, map))\n\t\treturn false;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id > map->max_apic_id) {\n\t\t\t*bitmap = 0;\n\t\t} else {\n\t\t\tu32 dest_id = array_index_nospec(irq->dest_id, map->max_apic_id + 1);\n\t\t\t*dst = &map->phys_map[dest_id];\n\t\t\t*bitmap = 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\t*bitmap = 0;\n\tif (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,\n\t\t\t\t(u16 *)bitmap))\n\t\treturn false;\n\n\tif (!kvm_lowest_prio_delivery(irq))\n\t\treturn true;\n\n\tif (!kvm_vector_hashing_enabled()) {\n\t\tlowest = -1;\n\t\tfor_each_set_bit(i, bitmap, 16) {\n\t\t\tif (!(*dst)[i])\n\t\t\t\tcontinue;\n\t\t\tif (lowest < 0)\n\t\t\t\tlowest = i;\n\t\t\telse if (kvm_apic_compare_prio((*dst)[i]->vcpu,\n\t\t\t\t\t\t(*dst)[lowest]->vcpu) < 0)\n\t\t\t\tlowest = i;\n\t\t}\n\t} else {\n\t\tif (!*bitmap)\n\t\t\treturn true;\n\n\t\tlowest = kvm_vector_to_index(irq->vector, hweight16(*bitmap),\n\t\t\t\tbitmap, 16);\n\n\t\tif (!(*dst)[lowest]) {\n\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t*bitmap = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t*bitmap = (lowest >= 0) ? 1 << lowest : 0;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "kvm->arch.apic_map"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\n\nbool kvm_irq_delivery_to_apic_fast(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, int *r, struct dest_map *dest_map)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tint i;\n\tbool ret;\n\n\t*r = -1;\n\n\tif (irq->shorthand == APIC_DEST_SELF) {\n\t\t*r = kvm_apic_set_irq(src->vcpu, irq, dest_map);\n\t\treturn true;\n\t}\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dst, &bitmap);\n\tif (ret) {\n\t\t*r = 0;\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dst[i])\n\t\t\t\tcontinue;\n\t\t\t*r += kvm_apic_set_irq(dst[i]->vcpu, irq, dest_map);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_apic_map_get_dest_lapic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "884-948",
    "snippet": "static inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,\n\t\tstruct kvm_lapic **src, struct kvm_lapic_irq *irq,\n\t\tstruct kvm_apic_map *map, struct kvm_lapic ***dst,\n\t\tunsigned long *bitmap)\n{\n\tint i, lowest;\n\n\tif (irq->shorthand == APIC_DEST_SELF && src) {\n\t\t*dst = src;\n\t\t*bitmap = 1;\n\t\treturn true;\n\t} else if (irq->shorthand)\n\t\treturn false;\n\n\tif (!map || kvm_apic_is_broadcast_dest(kvm, src, irq, map))\n\t\treturn false;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id > map->max_apic_id) {\n\t\t\t*bitmap = 0;\n\t\t} else {\n\t\t\tu32 dest_id = array_index_nospec(irq->dest_id, map->max_apic_id + 1);\n\t\t\t*dst = &map->phys_map[dest_id];\n\t\t\t*bitmap = 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\t*bitmap = 0;\n\tif (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,\n\t\t\t\t(u16 *)bitmap))\n\t\treturn false;\n\n\tif (!kvm_lowest_prio_delivery(irq))\n\t\treturn true;\n\n\tif (!kvm_vector_hashing_enabled()) {\n\t\tlowest = -1;\n\t\tfor_each_set_bit(i, bitmap, 16) {\n\t\t\tif (!(*dst)[i])\n\t\t\t\tcontinue;\n\t\t\tif (lowest < 0)\n\t\t\t\tlowest = i;\n\t\t\telse if (kvm_apic_compare_prio((*dst)[i]->vcpu,\n\t\t\t\t\t\t(*dst)[lowest]->vcpu) < 0)\n\t\t\t\tlowest = i;\n\t\t}\n\t} else {\n\t\tif (!*bitmap)\n\t\t\treturn true;\n\n\t\tlowest = kvm_vector_to_index(irq->vector, hweight16(*bitmap),\n\t\t\t\tbitmap, 16);\n\n\t\tif (!(*dst)[lowest]) {\n\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t*bitmap = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t*bitmap = (lowest >= 0) ? 1 << lowest : 0;\n\n\treturn true;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_disabled_lapic_found",
          "args": [
            "kvm"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_disabled_lapic_found",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "849-856",
          "snippet": "static void kvm_apic_disabled_lapic_found(struct kvm *kvm)\n{\n\tif (!kvm->arch.disabled_lapic_found) {\n\t\tkvm->arch.disabled_lapic_found = true;\n\t\tprintk(KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\");\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_apic_disabled_lapic_found(struct kvm *kvm)\n{\n\tif (!kvm->arch.disabled_lapic_found) {\n\t\tkvm->arch.disabled_lapic_found = true;\n\t\tprintk(KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vector_to_index",
          "args": [
            "irq->vector",
            "hweight16(*bitmap)",
            "bitmap",
            "16"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vector_to_index",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "833-847",
          "snippet": "int kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hweight16",
          "args": [
            "*bitmap"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_compare_prio",
          "args": [
            "(*dst)[i]->vcpu",
            "(*dst)[lowest]->vcpu"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_compare_prio",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1172-1175",
          "snippet": "int kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_apic_compare_prio(struct kvm_vcpu *vcpu1, struct kvm_vcpu *vcpu2)\n{\n\treturn vcpu1->arch.apic_arb_prio - vcpu2->arch.apic_arb_prio;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "bitmap",
            "16"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vector_hashing_enabled",
          "args": [],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vector_hashing_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10529-10532",
          "snippet": "bool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_vector_hashing_enabled(void)\n{\n\treturn vector_hashing;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lowest_prio_delivery",
          "args": [
            "irq"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lowest_prio_delivery",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "218-222",
          "snippet": "static inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)\n{\n\treturn (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\tirq->msi_redir_hint);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_lowest_prio_delivery(struct kvm_lapic_irq *irq)\n{\n\treturn (irq->delivery_mode == APIC_DM_LOWEST ||\n\t\t\tirq->msi_redir_hint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_map_get_logical_dest",
          "args": [
            "map",
            "irq->dest_id",
            "dst",
            "(u16 *)bitmap"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_map_get_logical_dest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "127-158",
          "snippet": "static inline bool kvm_apic_map_get_logical_dest(struct kvm_apic_map *map,\n\t\tu32 dest_id, struct kvm_lapic ***cluster, u16 *mask) {\n\tswitch (map->mode) {\n\tcase KVM_APIC_MODE_X2APIC: {\n\t\tu32 offset = (dest_id >> 16) * 16;\n\t\tu32 max_apic_id = map->max_apic_id;\n\n\t\tif (offset <= max_apic_id) {\n\t\t\tu8 cluster_size = min(max_apic_id - offset + 1, 16U);\n\n\t\t\toffset = array_index_nospec(offset, map->max_apic_id + 1);\n\t\t\t*cluster = &map->phys_map[offset];\n\t\t\t*mask = dest_id & (0xffff >> (16 - cluster_size));\n\t\t} else {\n\t\t\t*mask = 0;\n\t\t}\n\n\t\treturn true;\n\t\t}\n\tcase KVM_APIC_MODE_XAPIC_FLAT:\n\t\t*cluster = map->xapic_flat_map;\n\t\t*mask = dest_id & 0xff;\n\t\treturn true;\n\tcase KVM_APIC_MODE_XAPIC_CLUSTER:\n\t\t*cluster = map->xapic_cluster_map[(dest_id >> 4) & 0xf];\n\t\t*mask = dest_id & 0xf;\n\t\treturn true;\n\tdefault:\n\t\t/* Not optimized. */\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_apic_map_get_logical_dest(struct kvm_apic_map *map,\n\t\tu32 dest_id, struct kvm_lapic ***cluster, u16 *mask) {\n\tswitch (map->mode) {\n\tcase KVM_APIC_MODE_X2APIC: {\n\t\tu32 offset = (dest_id >> 16) * 16;\n\t\tu32 max_apic_id = map->max_apic_id;\n\n\t\tif (offset <= max_apic_id) {\n\t\t\tu8 cluster_size = min(max_apic_id - offset + 1, 16U);\n\n\t\t\toffset = array_index_nospec(offset, map->max_apic_id + 1);\n\t\t\t*cluster = &map->phys_map[offset];\n\t\t\t*mask = dest_id & (0xffff >> (16 - cluster_size));\n\t\t} else {\n\t\t\t*mask = 0;\n\t\t}\n\n\t\treturn true;\n\t\t}\n\tcase KVM_APIC_MODE_XAPIC_FLAT:\n\t\t*cluster = map->xapic_flat_map;\n\t\t*mask = dest_id & 0xff;\n\t\treturn true;\n\tcase KVM_APIC_MODE_XAPIC_CLUSTER:\n\t\t*cluster = map->xapic_cluster_map[(dest_id >> 4) & 0xf];\n\t\t*mask = dest_id & 0xf;\n\t\treturn true;\n\tdefault:\n\t\t/* Not optimized. */\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "irq->dest_id",
            "map->max_apic_id + 1"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_is_broadcast_dest",
          "args": [
            "kvm",
            "src",
            "irq",
            "map"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_is_broadcast_dest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "858-875",
          "snippet": "static bool kvm_apic_is_broadcast_dest(struct kvm *kvm, struct kvm_lapic **src,\n\t\tstruct kvm_lapic_irq *irq, struct kvm_apic_map *map)\n{\n\tif (kvm->arch.x2apic_broadcast_quirk_disabled) {\n\t\tif ((irq->dest_id == APIC_BROADCAST &&\n\t\t\t\tmap->mode != KVM_APIC_MODE_X2APIC))\n\t\t\treturn true;\n\t\tif (irq->dest_id == X2APIC_BROADCAST)\n\t\t\treturn true;\n\t} else {\n\t\tbool x2apic_ipi = src && *src && apic_x2apic_mode(*src);\n\t\tif (irq->dest_id == (x2apic_ipi ?\n\t\t                     X2APIC_BROADCAST : APIC_BROADCAST))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
            "#define APIC_BROADCAST\t\t\t0xFF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic bool kvm_apic_is_broadcast_dest(struct kvm *kvm, struct kvm_lapic **src,\n\t\tstruct kvm_lapic_irq *irq, struct kvm_apic_map *map)\n{\n\tif (kvm->arch.x2apic_broadcast_quirk_disabled) {\n\t\tif ((irq->dest_id == APIC_BROADCAST &&\n\t\t\t\tmap->mode != KVM_APIC_MODE_X2APIC))\n\t\t\treturn true;\n\t\tif (irq->dest_id == X2APIC_BROADCAST)\n\t\t\treturn true;\n\t} else {\n\t\tbool x2apic_ipi = src && *src && apic_x2apic_mode(*src);\n\t\tif (irq->dest_id == (x2apic_ipi ?\n\t\t                     X2APIC_BROADCAST : APIC_BROADCAST))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_apic_map_get_dest_lapic(struct kvm *kvm,\n\t\tstruct kvm_lapic **src, struct kvm_lapic_irq *irq,\n\t\tstruct kvm_apic_map *map, struct kvm_lapic ***dst,\n\t\tunsigned long *bitmap)\n{\n\tint i, lowest;\n\n\tif (irq->shorthand == APIC_DEST_SELF && src) {\n\t\t*dst = src;\n\t\t*bitmap = 1;\n\t\treturn true;\n\t} else if (irq->shorthand)\n\t\treturn false;\n\n\tif (!map || kvm_apic_is_broadcast_dest(kvm, src, irq, map))\n\t\treturn false;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL) {\n\t\tif (irq->dest_id > map->max_apic_id) {\n\t\t\t*bitmap = 0;\n\t\t} else {\n\t\t\tu32 dest_id = array_index_nospec(irq->dest_id, map->max_apic_id + 1);\n\t\t\t*dst = &map->phys_map[dest_id];\n\t\t\t*bitmap = 1;\n\t\t}\n\t\treturn true;\n\t}\n\n\t*bitmap = 0;\n\tif (!kvm_apic_map_get_logical_dest(map, irq->dest_id, dst,\n\t\t\t\t(u16 *)bitmap))\n\t\treturn false;\n\n\tif (!kvm_lowest_prio_delivery(irq))\n\t\treturn true;\n\n\tif (!kvm_vector_hashing_enabled()) {\n\t\tlowest = -1;\n\t\tfor_each_set_bit(i, bitmap, 16) {\n\t\t\tif (!(*dst)[i])\n\t\t\t\tcontinue;\n\t\t\tif (lowest < 0)\n\t\t\t\tlowest = i;\n\t\t\telse if (kvm_apic_compare_prio((*dst)[i]->vcpu,\n\t\t\t\t\t\t(*dst)[lowest]->vcpu) < 0)\n\t\t\t\tlowest = i;\n\t\t}\n\t} else {\n\t\tif (!*bitmap)\n\t\t\treturn true;\n\n\t\tlowest = kvm_vector_to_index(irq->vector, hweight16(*bitmap),\n\t\t\t\tbitmap, 16);\n\n\t\tif (!(*dst)[lowest]) {\n\t\t\tkvm_apic_disabled_lapic_found(kvm);\n\t\t\t*bitmap = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t*bitmap = (lowest >= 0) ? 1 << lowest : 0;\n\n\treturn true;\n}"
  },
  {
    "function_name": "kvm_apic_is_broadcast_dest",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "858-875",
    "snippet": "static bool kvm_apic_is_broadcast_dest(struct kvm *kvm, struct kvm_lapic **src,\n\t\tstruct kvm_lapic_irq *irq, struct kvm_apic_map *map)\n{\n\tif (kvm->arch.x2apic_broadcast_quirk_disabled) {\n\t\tif ((irq->dest_id == APIC_BROADCAST &&\n\t\t\t\tmap->mode != KVM_APIC_MODE_X2APIC))\n\t\t\treturn true;\n\t\tif (irq->dest_id == X2APIC_BROADCAST)\n\t\t\treturn true;\n\t} else {\n\t\tbool x2apic_ipi = src && *src && apic_x2apic_mode(*src);\n\t\tif (irq->dest_id == (x2apic_ipi ?\n\t\t                     X2APIC_BROADCAST : APIC_BROADCAST))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
      "#define APIC_BROADCAST\t\t\t0xFF"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "*src"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic bool kvm_apic_is_broadcast_dest(struct kvm *kvm, struct kvm_lapic **src,\n\t\tstruct kvm_lapic_irq *irq, struct kvm_apic_map *map)\n{\n\tif (kvm->arch.x2apic_broadcast_quirk_disabled) {\n\t\tif ((irq->dest_id == APIC_BROADCAST &&\n\t\t\t\tmap->mode != KVM_APIC_MODE_X2APIC))\n\t\t\treturn true;\n\t\tif (irq->dest_id == X2APIC_BROADCAST)\n\t\t\treturn true;\n\t} else {\n\t\tbool x2apic_ipi = src && *src && apic_x2apic_mode(*src);\n\t\tif (irq->dest_id == (x2apic_ipi ?\n\t\t                     X2APIC_BROADCAST : APIC_BROADCAST))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "kvm_apic_disabled_lapic_found",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "849-856",
    "snippet": "static void kvm_apic_disabled_lapic_found(struct kvm *kvm)\n{\n\tif (!kvm->arch.disabled_lapic_found) {\n\t\tkvm->arch.disabled_lapic_found = true;\n\t\tprintk(KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\");\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\""
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_apic_disabled_lapic_found(struct kvm *kvm)\n{\n\tif (!kvm->arch.disabled_lapic_found) {\n\t\tkvm->arch.disabled_lapic_found = true;\n\t\tprintk(KERN_INFO\n\t\t       \"Disabled LAPIC found during irq injection\\n\");\n\t}\n}"
  },
  {
    "function_name": "kvm_vector_to_index",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "833-847",
    "snippet": "int kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "idx == bitmap_size"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "bitmap",
            "bitmap_size",
            "idx + 1"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_vector_to_index(u32 vector, u32 dest_vcpus,\n\t\t       const unsigned long *bitmap, u32 bitmap_size)\n{\n\tu32 mod;\n\tint i, idx = -1;\n\n\tmod = vector % dest_vcpus;\n\n\tfor (i = 0; i <= mod; i++) {\n\t\tidx = find_next_bit(bitmap, bitmap_size, idx + 1);\n\t\tBUG_ON(idx == bitmap_size);\n\t}\n\n\treturn idx;\n}"
  },
  {
    "function_name": "kvm_apic_match_dest",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "808-830",
    "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_match_logical_addr",
          "args": [
            "target",
            "mda"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_logical_addr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "754-778",
          "snippet": "static bool kvm_apic_match_logical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tu32 logical_id;\n\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tlogical_id = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn ((logical_id >> 16) == (mda >> 16))\n\t\t       && (logical_id & mda & 0xffff) != 0;\n\n\tlogical_id = GET_APIC_LOGICAL_ID(logical_id);\n\n\tswitch (kvm_lapic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\treturn (logical_id & mda) != 0;\n\tcase APIC_DFR_CLUSTER:\n\t\treturn ((logical_id >> 4) == (mda >> 4))\n\t\t       && (logical_id & mda & 0xf) != 0;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool kvm_apic_match_logical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tu32 logical_id;\n\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tlogical_id = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn ((logical_id >> 16) == (mda >> 16))\n\t\t       && (logical_id & mda & 0xffff) != 0;\n\n\tlogical_id = GET_APIC_LOGICAL_ID(logical_id);\n\n\tswitch (kvm_lapic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\treturn (logical_id & mda) != 0;\n\tcase APIC_DFR_CLUSTER:\n\t\treturn ((logical_id >> 4) == (mda >> 4))\n\t\t       && (logical_id & mda & 0xf) != 0;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_physical_addr",
          "args": [
            "target",
            "mda"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_physical_addr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "734-752",
          "snippet": "static bool kvm_apic_match_physical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == kvm_x2apic_id(apic);\n\n\t/*\n\t * Hotplug hack: Make LAPIC in xAPIC mode also accept interrupts as if\n\t * it were in x2APIC mode.  Hotplugged VCPUs start in xAPIC mode and\n\t * this allows unique addressing of VCPUs with APIC ID over 0xff.\n\t * The 0xff condition is needed because writeable xAPIC ID.\n\t */\n\tif (kvm_x2apic_id(apic) > 0xff && mda == kvm_x2apic_id(apic))\n\t\treturn true;\n\n\treturn mda == kvm_xapic_id(apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool kvm_apic_match_physical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == kvm_x2apic_id(apic);\n\n\t/*\n\t * Hotplug hack: Make LAPIC in xAPIC mode also accept interrupts as if\n\t * it were in x2APIC mode.  Hotplugged VCPUs start in xAPIC mode and\n\t * this allows unique addressing of VCPUs with APIC ID over 0xff.\n\t * The 0xff condition is needed because writeable xAPIC ID.\n\t */\n\tif (kvm_x2apic_id(apic) > 0xff && mda == kvm_x2apic_id(apic))\n\t\treturn true;\n\n\treturn mda == kvm_xapic_id(apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "target"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_mda",
          "args": [
            "vcpu",
            "dest",
            "source",
            "target"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_mda",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "796-806",
          "snippet": "static u32 kvm_apic_mda(struct kvm_vcpu *vcpu, unsigned int dest_id,\n\t\tstruct kvm_lapic *source, struct kvm_lapic *target)\n{\n\tbool ipi = source != NULL;\n\n\tif (!vcpu->kvm->arch.x2apic_broadcast_quirk_disabled &&\n\t    !ipi && dest_id == APIC_BROADCAST && apic_x2apic_mode(target))\n\t\treturn X2APIC_BROADCAST;\n\n\treturn dest_id;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
            "#define APIC_BROADCAST\t\t\t0xFF"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic u32 kvm_apic_mda(struct kvm_vcpu *vcpu, unsigned int dest_id,\n\t\tstruct kvm_lapic *source, struct kvm_lapic *target)\n{\n\tbool ipi = source != NULL;\n\n\tif (!vcpu->kvm->arch.x2apic_broadcast_quirk_disabled &&\n\t    !ipi && dest_id == APIC_BROADCAST && apic_x2apic_mode(target))\n\t\treturn X2APIC_BROADCAST;\n\n\treturn dest_id;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "kvm_apic_mda",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "796-806",
    "snippet": "static u32 kvm_apic_mda(struct kvm_vcpu *vcpu, unsigned int dest_id,\n\t\tstruct kvm_lapic *source, struct kvm_lapic *target)\n{\n\tbool ipi = source != NULL;\n\n\tif (!vcpu->kvm->arch.x2apic_broadcast_quirk_disabled &&\n\t    !ipi && dest_id == APIC_BROADCAST && apic_x2apic_mode(target))\n\t\treturn X2APIC_BROADCAST;\n\n\treturn dest_id;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
      "#define APIC_BROADCAST\t\t\t0xFF"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "target"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic u32 kvm_apic_mda(struct kvm_vcpu *vcpu, unsigned int dest_id,\n\t\tstruct kvm_lapic *source, struct kvm_lapic *target)\n{\n\tbool ipi = source != NULL;\n\n\tif (!vcpu->kvm->arch.x2apic_broadcast_quirk_disabled &&\n\t    !ipi && dest_id == APIC_BROADCAST && apic_x2apic_mode(target))\n\t\treturn X2APIC_BROADCAST;\n\n\treturn dest_id;\n}"
  },
  {
    "function_name": "kvm_apic_match_logical_addr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "754-778",
    "snippet": "static bool kvm_apic_match_logical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tu32 logical_id;\n\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tlogical_id = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn ((logical_id >> 16) == (mda >> 16))\n\t\t       && (logical_id & mda & 0xffff) != 0;\n\n\tlogical_id = GET_APIC_LOGICAL_ID(logical_id);\n\n\tswitch (kvm_lapic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\treturn (logical_id & mda) != 0;\n\tcase APIC_DFR_CLUSTER:\n\t\treturn ((logical_id >> 4) == (mda >> 4))\n\t\t       && (logical_id & mda & 0xf) != 0;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_DFR"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_APIC_LOGICAL_ID",
          "args": [
            "logical_id"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_broadcast",
          "args": [
            "apic",
            "mda"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_broadcast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "728-732",
          "snippet": "static bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\treturn mda == (apic_x2apic_mode(apic) ?\n\t\t\tX2APIC_BROADCAST : APIC_BROADCAST);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
            "#define APIC_BROADCAST\t\t\t0xFF"
          ],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\treturn mda == (apic_x2apic_mode(apic) ?\n\t\t\tX2APIC_BROADCAST : APIC_BROADCAST);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool kvm_apic_match_logical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tu32 logical_id;\n\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tlogical_id = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn ((logical_id >> 16) == (mda >> 16))\n\t\t       && (logical_id & mda & 0xffff) != 0;\n\n\tlogical_id = GET_APIC_LOGICAL_ID(logical_id);\n\n\tswitch (kvm_lapic_get_reg(apic, APIC_DFR)) {\n\tcase APIC_DFR_FLAT:\n\t\treturn (logical_id & mda) != 0;\n\tcase APIC_DFR_CLUSTER:\n\t\treturn ((logical_id >> 4) == (mda >> 4))\n\t\t       && (logical_id & mda & 0xf) != 0;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "kvm_apic_match_physical_addr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "734-752",
    "snippet": "static bool kvm_apic_match_physical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == kvm_x2apic_id(apic);\n\n\t/*\n\t * Hotplug hack: Make LAPIC in xAPIC mode also accept interrupts as if\n\t * it were in x2APIC mode.  Hotplugged VCPUs start in xAPIC mode and\n\t * this allows unique addressing of VCPUs with APIC ID over 0xff.\n\t * The 0xff condition is needed because writeable xAPIC ID.\n\t */\n\tif (kvm_x2apic_id(apic) > 0xff && mda == kvm_x2apic_id(apic))\n\t\treturn true;\n\n\treturn mda == kvm_xapic_id(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_xapic_id",
          "args": [
            "apic"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_xapic_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "252-255",
          "snippet": "static inline u8 kvm_xapic_id(struct kvm_lapic *apic)\n{\n\treturn kvm_lapic_get_reg(apic, APIC_ID) >> 24;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u8 kvm_xapic_id(struct kvm_lapic *apic)\n{\n\treturn kvm_lapic_get_reg(apic, APIC_ID) >> 24;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x2apic_id",
          "args": [
            "apic"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_x2apic_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "111-114",
          "snippet": "static inline u32 kvm_x2apic_id(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->vcpu_id;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline u32 kvm_x2apic_id(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->vcpu_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_broadcast",
          "args": [
            "apic",
            "mda"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_broadcast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "728-732",
          "snippet": "static bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\treturn mda == (apic_x2apic_mode(apic) ?\n\t\t\tX2APIC_BROADCAST : APIC_BROADCAST);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
            "#define APIC_BROADCAST\t\t\t0xFF"
          ],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\treturn mda == (apic_x2apic_mode(apic) ?\n\t\t\tX2APIC_BROADCAST : APIC_BROADCAST);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool kvm_apic_match_physical_addr(struct kvm_lapic *apic, u32 mda)\n{\n\tif (kvm_apic_broadcast(apic, mda))\n\t\treturn true;\n\n\tif (apic_x2apic_mode(apic))\n\t\treturn mda == kvm_x2apic_id(apic);\n\n\t/*\n\t * Hotplug hack: Make LAPIC in xAPIC mode also accept interrupts as if\n\t * it were in x2APIC mode.  Hotplugged VCPUs start in xAPIC mode and\n\t * this allows unique addressing of VCPUs with APIC ID over 0xff.\n\t * The 0xff condition is needed because writeable xAPIC ID.\n\t */\n\tif (kvm_x2apic_id(apic) > 0xff && mda == kvm_x2apic_id(apic))\n\t\treturn true;\n\n\treturn mda == kvm_xapic_id(apic);\n}"
  },
  {
    "function_name": "kvm_apic_broadcast",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "728-732",
    "snippet": "static bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\treturn mda == (apic_x2apic_mode(apic) ?\n\t\t\tX2APIC_BROADCAST : APIC_BROADCAST);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define X2APIC_BROADCAST\t\t0xFFFFFFFFul",
      "#define APIC_BROADCAST\t\t\t0xFF"
    ],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define X2APIC_BROADCAST\t\t0xFFFFFFFFul\n#define APIC_BROADCAST\t\t\t0xFF\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool kvm_apic_broadcast(struct kvm_lapic *apic, u32 mda)\n{\n\treturn mda == (apic_x2apic_mode(apic) ?\n\t\t\tX2APIC_BROADCAST : APIC_BROADCAST);\n}"
  },
  {
    "function_name": "apic_set_tpr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "722-726",
    "snippet": "static void apic_set_tpr(struct kvm_lapic *apic, u32 tpr)\n{\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, tpr);\n\tapic_update_ppr(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "apic"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_update_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "716-719",
          "snippet": "void kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_TASKPRI",
            "tpr"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "161-164",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_set_tpr(struct kvm_lapic *apic, u32 tpr)\n{\n\tkvm_lapic_set_reg(apic, APIC_TASKPRI, tpr);\n\tapic_update_ppr(apic);\n}"
  },
  {
    "function_name": "kvm_apic_update_ppr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "716-719",
    "snippet": "void kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_update_ppr",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_update_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "716-719",
          "snippet": "void kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}"
  },
  {
    "function_name": "apic_update_ppr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "707-714",
    "snippet": "static void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 ppr;\n\n\tif (__apic_update_ppr(apic, &ppr) &&\n\t    apic_has_interrupt_for_ppr(apic, ppr) != -1)\n\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "apic->vcpu"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_has_interrupt_for_ppr",
          "args": [
            "apic",
            "ppr"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "apic_has_interrupt_for_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "673-683",
          "snippet": "static int apic_has_interrupt_for_ppr(struct kvm_lapic *apic, u32 ppr)\n{\n\tint highest_irr;\n\tif (apic->vcpu->arch.apicv_active)\n\t\thighest_irr = kvm_x86_ops.sync_pir_to_irr(apic->vcpu);\n\telse\n\t\thighest_irr = apic_find_highest_irr(apic);\n\tif (highest_irr == -1 || (highest_irr & 0xF0) <= ppr)\n\t\treturn -1;\n\treturn highest_irr;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int apic_has_interrupt_for_ppr(struct kvm_lapic *apic, u32 ppr)\n{\n\tint highest_irr;\n\tif (apic->vcpu->arch.apicv_active)\n\t\thighest_irr = kvm_x86_ops.sync_pir_to_irr(apic->vcpu);\n\telse\n\t\thighest_irr = apic_find_highest_irr(apic);\n\tif (highest_irr == -1 || (highest_irr & 0xF0) <= ppr)\n\t\treturn -1;\n\treturn highest_irr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__apic_update_ppr",
          "args": [
            "apic",
            "&ppr"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_update_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "685-705",
          "snippet": "static bool __apic_update_ppr(struct kvm_lapic *apic, u32 *new_ppr)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\t*new_ppr = ppr;\n\tif (old_ppr != ppr)\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\n\treturn ppr < old_ppr;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool __apic_update_ppr(struct kvm_lapic *apic, u32 *new_ppr)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\t*new_ppr = ppr;\n\tif (old_ppr != ppr)\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\n\treturn ppr < old_ppr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic void apic_update_ppr(struct kvm_lapic *apic)\n{\n\tu32 ppr;\n\n\tif (__apic_update_ppr(apic, &ppr) &&\n\t    apic_has_interrupt_for_ppr(apic, ppr) != -1)\n\t\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}"
  },
  {
    "function_name": "__apic_update_ppr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "685-705",
    "snippet": "static bool __apic_update_ppr(struct kvm_lapic *apic, u32 *new_ppr)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\t*new_ppr = ppr;\n\tif (old_ppr != ppr)\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\n\treturn ppr < old_ppr;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_PROCPRI",
            "ppr"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "161-164",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "apic_find_highest_isr",
          "args": [
            "apic"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "apic_find_highest_isr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "504-521",
          "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_TASKPRI"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic bool __apic_update_ppr(struct kvm_lapic *apic, u32 *new_ppr)\n{\n\tu32 tpr, isrv, ppr, old_ppr;\n\tint isr;\n\n\told_ppr = kvm_lapic_get_reg(apic, APIC_PROCPRI);\n\ttpr = kvm_lapic_get_reg(apic, APIC_TASKPRI);\n\tisr = apic_find_highest_isr(apic);\n\tisrv = (isr != -1) ? isr : 0;\n\n\tif ((tpr & 0xf0) >= (isrv & 0xf0))\n\t\tppr = tpr & 0xff;\n\telse\n\t\tppr = isrv & 0xf0;\n\n\t*new_ppr = ppr;\n\tif (old_ppr != ppr)\n\t\tkvm_lapic_set_reg(apic, APIC_PROCPRI, ppr);\n\n\treturn ppr < old_ppr;\n}"
  },
  {
    "function_name": "apic_has_interrupt_for_ppr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "673-683",
    "snippet": "static int apic_has_interrupt_for_ppr(struct kvm_lapic *apic, u32 ppr)\n{\n\tint highest_irr;\n\tif (apic->vcpu->arch.apicv_active)\n\t\thighest_irr = kvm_x86_ops.sync_pir_to_irr(apic->vcpu);\n\telse\n\t\thighest_irr = apic_find_highest_irr(apic);\n\tif (highest_irr == -1 || (highest_irr & 0xF0) <= ppr)\n\t\treturn -1;\n\treturn highest_irr;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_find_highest_irr",
          "args": [
            "apic"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "548-556",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.sync_pir_to_irr",
          "args": [
            "apic->vcpu"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int apic_has_interrupt_for_ppr(struct kvm_lapic *apic, u32 ppr)\n{\n\tint highest_irr;\n\tif (apic->vcpu->arch.apicv_active)\n\t\thighest_irr = kvm_x86_ops.sync_pir_to_irr(apic->vcpu);\n\telse\n\t\thighest_irr = apic_find_highest_irr(apic);\n\tif (highest_irr == -1 || (highest_irr & 0xF0) <= ppr)\n\t\treturn -1;\n\treturn highest_irr;\n}"
  },
  {
    "function_name": "pv_eoi_clr_pending",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "663-671",
    "snippet": "static void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tprintk(KERN_WARNING \"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "KVM_APIC_PV_EOI_PENDING",
            "&vcpu->arch.apic_attention"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Can't clear EOI MSR value: 0x%llx\\n\"",
            "(unsigned long long)vcpu->arch.pv_eoi.msr_val"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_eoi_put_user",
          "args": [
            "vcpu",
            "KVM_PV_EOI_DISABLED"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_put_user",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "623-628",
          "snippet": "static int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void pv_eoi_clr_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_DISABLED) < 0) {\n\t\tprintk(KERN_WARNING \"Can't clear EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__clear_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}"
  },
  {
    "function_name": "pv_eoi_set_pending",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "653-661",
    "snippet": "static void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tprintk(KERN_WARNING \"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "KVM_APIC_PV_EOI_PENDING",
            "&vcpu->arch.apic_attention"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Can't set EOI MSR value: 0x%llx\\n\"",
            "(unsigned long long)vcpu->arch.pv_eoi.msr_val"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_eoi_put_user",
          "args": [
            "vcpu",
            "KVM_PV_EOI_ENABLED"
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_put_user",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "623-628",
          "snippet": "static int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void pv_eoi_set_pending(struct kvm_vcpu *vcpu)\n{\n\tif (pv_eoi_put_user(vcpu, KVM_PV_EOI_ENABLED) < 0) {\n\t\tprintk(KERN_WARNING \"Can't set EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn;\n\t}\n\t__set_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention);\n}"
  },
  {
    "function_name": "pv_eoi_get_pending",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "642-651",
    "snippet": "static bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0) {\n\t\tprintk(KERN_WARNING \"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn false;\n\t}\n\treturn val & 0x1;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"Can't read EOI MSR value: 0x%llx\\n\"",
            "(unsigned long long)vcpu->arch.pv_eoi.msr_val"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pv_eoi_get_user",
          "args": [
            "vcpu",
            "&val"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "pv_eoi_get_user",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "630-635",
          "snippet": "static int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool pv_eoi_get_pending(struct kvm_vcpu *vcpu)\n{\n\tu8 val;\n\tif (pv_eoi_get_user(vcpu, &val) < 0) {\n\t\tprintk(KERN_WARNING \"Can't read EOI MSR value: 0x%llx\\n\",\n\t\t\t   (unsigned long long)vcpu->arch.pv_eoi.msr_val);\n\t\treturn false;\n\t}\n\treturn val & 0x1;\n}"
  },
  {
    "function_name": "pv_eoi_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "637-640",
    "snippet": "static inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool pv_eoi_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}"
  },
  {
    "function_name": "pv_eoi_get_user",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "630-635",
    "snippet": "static int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.pv_eoi.data",
            "val",
            "sizeof(*val)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int pv_eoi_get_user(struct kvm_vcpu *vcpu, u8 *val)\n{\n\n\treturn kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, val,\n\t\t\t\t      sizeof(*val));\n}"
  },
  {
    "function_name": "pv_eoi_put_user",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "623-628",
    "snippet": "static int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_write_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.pv_eoi.data",
            "&val",
            "sizeof(val)"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int pv_eoi_put_user(struct kvm_vcpu *vcpu, u8 val)\n{\n\n\treturn kvm_write_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data, &val,\n\t\t\t\t      sizeof(val));\n}"
  },
  {
    "function_name": "kvm_pv_send_ipi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "592-621",
    "snippet": "int kvm_pv_send_ipi(struct kvm *kvm, unsigned long ipi_bitmap_low,\n\t\t    unsigned long ipi_bitmap_high, u32 min,\n\t\t    unsigned long icr, int op_64_bit)\n{\n\tstruct kvm_apic_map *map;\n\tstruct kvm_lapic_irq irq = {0};\n\tint cluster_size = op_64_bit ? 64 : 32;\n\tint count;\n\n\tif (icr & (APIC_DEST_MASK | APIC_SHORT_MASK))\n\t\treturn -KVM_EINVAL;\n\n\tirq.vector = icr & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr & APIC_MODE_MASK;\n\tirq.level = (icr & APIC_INT_ASSERT) != 0;\n\tirq.trig_mode = icr & APIC_INT_LEVELTRIG;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tcount = -EOPNOTSUPP;\n\tif (likely(map)) {\n\t\tcount = __pv_send_ipi(&ipi_bitmap_low, map, &irq, min);\n\t\tmin += cluster_size;\n\t\tcount += __pv_send_ipi(&ipi_bitmap_high, map, &irq, min);\n\t}\n\n\trcu_read_unlock();\n\treturn count;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pv_send_ipi",
          "args": [
            "&ipi_bitmap_high",
            "map",
            "&irq",
            "min"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_send_ipi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "572-590",
          "snippet": "static int __pv_send_ipi(unsigned long *ipi_bitmap, struct kvm_apic_map *map,\n\t\t\t struct kvm_lapic_irq *irq, u32 min)\n{\n\tint i, count = 0;\n\tstruct kvm_vcpu *vcpu;\n\n\tif (min > map->max_apic_id)\n\t\treturn 0;\n\n\tfor_each_set_bit(i, ipi_bitmap,\n\t\tmin((u32)BITS_PER_LONG, (map->max_apic_id - min + 1))) {\n\t\tif (map->phys_map[min + i]) {\n\t\t\tvcpu = map->phys_map[min + i]->vcpu;\n\t\t\tcount += kvm_apic_set_irq(vcpu, irq, NULL);\n\t\t}\n\t}\n\n\treturn count;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __pv_send_ipi(unsigned long *ipi_bitmap, struct kvm_apic_map *map,\n\t\t\t struct kvm_lapic_irq *irq, u32 min)\n{\n\tint i, count = 0;\n\tstruct kvm_vcpu *vcpu;\n\n\tif (min > map->max_apic_id)\n\t\treturn 0;\n\n\tfor_each_set_bit(i, ipi_bitmap,\n\t\tmin((u32)BITS_PER_LONG, (map->max_apic_id - min + 1))) {\n\t\tif (map->phys_map[min + i]) {\n\t\t\tvcpu = map->phys_map[min + i]->vcpu;\n\t\t\tcount += kvm_apic_set_irq(vcpu, irq, NULL);\n\t\t}\n\t}\n\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "map"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "kvm->arch.apic_map"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_pv_send_ipi(struct kvm *kvm, unsigned long ipi_bitmap_low,\n\t\t    unsigned long ipi_bitmap_high, u32 min,\n\t\t    unsigned long icr, int op_64_bit)\n{\n\tstruct kvm_apic_map *map;\n\tstruct kvm_lapic_irq irq = {0};\n\tint cluster_size = op_64_bit ? 64 : 32;\n\tint count;\n\n\tif (icr & (APIC_DEST_MASK | APIC_SHORT_MASK))\n\t\treturn -KVM_EINVAL;\n\n\tirq.vector = icr & APIC_VECTOR_MASK;\n\tirq.delivery_mode = icr & APIC_MODE_MASK;\n\tirq.level = (icr & APIC_INT_ASSERT) != 0;\n\tirq.trig_mode = icr & APIC_INT_LEVELTRIG;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tcount = -EOPNOTSUPP;\n\tif (likely(map)) {\n\t\tcount = __pv_send_ipi(&ipi_bitmap_low, map, &irq, min);\n\t\tmin += cluster_size;\n\t\tcount += __pv_send_ipi(&ipi_bitmap_high, map, &irq, min);\n\t}\n\n\trcu_read_unlock();\n\treturn count;\n}"
  },
  {
    "function_name": "__pv_send_ipi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "572-590",
    "snippet": "static int __pv_send_ipi(unsigned long *ipi_bitmap, struct kvm_apic_map *map,\n\t\t\t struct kvm_lapic_irq *irq, u32 min)\n{\n\tint i, count = 0;\n\tstruct kvm_vcpu *vcpu;\n\n\tif (min > map->max_apic_id)\n\t\treturn 0;\n\n\tfor_each_set_bit(i, ipi_bitmap,\n\t\tmin((u32)BITS_PER_LONG, (map->max_apic_id - min + 1))) {\n\t\tif (map->phys_map[min + i]) {\n\t\t\tvcpu = map->phys_map[min + i]->vcpu;\n\t\t\tcount += kvm_apic_set_irq(vcpu, irq, NULL);\n\t\t}\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_set_irq",
          "args": [
            "vcpu",
            "irq",
            "NULL"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "563-570",
          "snippet": "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "ipi_bitmap",
            "min((u32)BITS_PER_LONG, (map->max_apic_id - min + 1))"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(u32)BITS_PER_LONG",
            "(map->max_apic_id - min + 1)"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __pv_send_ipi(unsigned long *ipi_bitmap, struct kvm_apic_map *map,\n\t\t\t struct kvm_lapic_irq *irq, u32 min)\n{\n\tint i, count = 0;\n\tstruct kvm_vcpu *vcpu;\n\n\tif (min > map->max_apic_id)\n\t\treturn 0;\n\n\tfor_each_set_bit(i, ipi_bitmap,\n\t\tmin((u32)BITS_PER_LONG, (map->max_apic_id - min + 1))) {\n\t\tif (map->phys_map[min + i]) {\n\t\t\tvcpu = map->phys_map[min + i]->vcpu;\n\t\t\tcount += kvm_apic_set_irq(vcpu, irq, NULL);\n\t\t}\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "kvm_apic_set_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "563-570",
    "snippet": "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);",
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__apic_accept_irq",
          "args": [
            "apic",
            "irq->delivery_mode",
            "irq->vector",
            "irq->level",
            "irq->trig_mode",
            "dest_map"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_accept_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1029-1126",
          "snippet": "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\t\t/* fall through */\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector,\n\t\t\t\t\t\t     apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tkvm_lapic_clear_vector(vector,\n\t\t\t\t\t\t       apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (kvm_x86_ops.deliver_posted_interrupt(vcpu, vector)) {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map)\n{\n\tint result = 0;\n\tstruct kvm_vcpu *vcpu = apic->vcpu;\n\n\ttrace_kvm_apic_accept_irq(vcpu->vcpu_id, delivery_mode,\n\t\t\t\t  trig_mode, vector);\n\tswitch (delivery_mode) {\n\tcase APIC_DM_LOWEST:\n\t\tvcpu->arch.apic_arb_prio++;\n\t\t/* fall through */\n\tcase APIC_DM_FIXED:\n\t\tif (unlikely(trig_mode && !level))\n\t\t\tbreak;\n\n\t\t/* FIXME add logic for vcpu on reset */\n\t\tif (unlikely(!apic_enabled(apic)))\n\t\t\tbreak;\n\n\t\tresult = 1;\n\n\t\tif (dest_map) {\n\t\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\t\tdest_map->vectors[vcpu->vcpu_id] = vector;\n\t\t}\n\n\t\tif (apic_test_vector(vector, apic->regs + APIC_TMR) != !!trig_mode) {\n\t\t\tif (trig_mode)\n\t\t\t\tkvm_lapic_set_vector(vector,\n\t\t\t\t\t\t     apic->regs + APIC_TMR);\n\t\t\telse\n\t\t\t\tkvm_lapic_clear_vector(vector,\n\t\t\t\t\t\t       apic->regs + APIC_TMR);\n\t\t}\n\n\t\tif (kvm_x86_ops.deliver_posted_interrupt(vcpu, vector)) {\n\t\t\tkvm_lapic_set_irr(vector, apic);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_REMRD:\n\t\tresult = 1;\n\t\tvcpu->arch.pv.pv_unhalted = 1;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_SMI:\n\t\tresult = 1;\n\t\tkvm_make_request(KVM_REQ_SMI, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_NMI:\n\t\tresult = 1;\n\t\tkvm_inject_nmi(vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_INIT:\n\t\tif (!trig_mode || level) {\n\t\t\tresult = 1;\n\t\t\t/* assumes that there are only KVM_APIC_INIT/SIPI */\n\t\t\tapic->pending_events = (1UL << KVM_APIC_INIT);\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\t}\n\t\tbreak;\n\n\tcase APIC_DM_STARTUP:\n\t\tresult = 1;\n\t\tapic->sipi_vector = vector;\n\t\t/* make sure sipi_vector is visible for the receiver */\n\t\tsmp_wmb();\n\t\tset_bit(KVM_APIC_SIPI, &apic->pending_events);\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\tkvm_vcpu_kick(vcpu);\n\t\tbreak;\n\n\tcase APIC_DM_EXTINT:\n\t\t/*\n\t\t * Should only be called by kvm_apic_local_deliver() with LVT0,\n\t\t * before NMI watchdog was enabled. Already handled by\n\t\t * kvm_apic_accept_pic_intr().\n\t\t */\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"TODO: unsupported delivery mode %x\\n\",\n\t\t       delivery_mode);\n\t\tbreak;\n\t}\n\treturn result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}"
  },
  {
    "function_name": "kvm_lapic_find_highest_irr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "548-556",
    "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_find_highest_irr",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "548-556",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
  },
  {
    "function_name": "apic_clear_isr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "523-546",
    "snippet": "static inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tif (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * We do get here for APIC virtualization enabled if the guest\n\t * uses the Hyper-V APIC enlightenment.  In this case we may need\n\t * to trigger a new interrupt delivery by writing the SVI field;\n\t * on the other hand isr_count and highest_isr_cache are unused\n\t * and must be left alone.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu,\n\t\t\t\t\t       apic_find_highest_isr(apic));\n\telse {\n\t\t--apic->isr_count;\n\t\tBUG_ON(apic->isr_count < 0);\n\t\tapic->highest_isr_cache = -1;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "apic->isr_count < 0"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.hwapic_isr_update",
          "args": [
            "vcpu",
            "apic_find_highest_isr(apic)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_isr",
          "args": [
            "apic"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "apic_find_highest_isr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "504-521",
          "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.apicv_active"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__apic_test_and_clear_vector",
          "args": [
            "vec",
            "apic->regs + APIC_ISR"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_test_and_clear_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "91-94",
          "snippet": "static inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void apic_clear_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tif (!__apic_test_and_clear_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * We do get here for APIC virtualization enabled if the guest\n\t * uses the Hyper-V APIC enlightenment.  In this case we may need\n\t * to trigger a new interrupt delivery by writing the SVI field;\n\t * on the other hand isr_count and highest_isr_cache are unused\n\t * and must be left alone.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu,\n\t\t\t\t\t       apic_find_highest_isr(apic));\n\telse {\n\t\t--apic->isr_count;\n\t\tBUG_ON(apic->isr_count < 0);\n\t\tapic->highest_isr_cache = -1;\n\t}\n}"
  },
  {
    "function_name": "apic_find_highest_isr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "504-521",
    "snippet": "static inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "result == -1 || result >= 16"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_highest_vector",
          "args": [
            "apic->regs + APIC_ISR"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "find_highest_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "368-381",
          "snippet": "static int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn __fls(*reg) + vec;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VECTORS_PER_REG\t\t32",
            "#define MAX_APIC_VECTOR\t\t\t256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VECTORS_PER_REG\t\t32\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn __fls(*reg) + vec;\n\t}\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "apic->highest_isr_cache != -1"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_find_highest_isr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that isr_count is always 1, and highest_isr_cache\n\t * is always -1, with APIC virtualization enabled.\n\t */\n\tif (!apic->isr_count)\n\t\treturn -1;\n\tif (likely(apic->highest_isr_cache != -1))\n\t\treturn apic->highest_isr_cache;\n\n\tresult = find_highest_vector(apic->regs + APIC_ISR);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
  },
  {
    "function_name": "apic_set_isr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "476-502",
    "snippet": "static inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tif (__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * With APIC virtualization enabled, all caching is disabled\n\t * because the processor can modify ISR under the hood.  Instead\n\t * just set SVI.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu, vec);\n\telse {\n\t\t++apic->isr_count;\n\t\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t\t/*\n\t\t * ISR (in service register) bit is set when injecting an interrupt.\n\t\t * The highest vector is injected. Thus the latest bit set matches\n\t\t * the highest bit in ISR.\n\t\t */\n\t\tapic->highest_isr_cache = vec;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MAX_APIC_VECTOR\t\t\t256"
    ],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "apic->isr_count > MAX_APIC_VECTOR"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.hwapic_isr_update",
          "args": [
            "vcpu",
            "vec"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.apicv_active"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__apic_test_and_set_vector",
          "args": [
            "vec",
            "apic->regs + APIC_ISR"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "__apic_test_and_set_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "86-89",
          "snippet": "static inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void apic_set_isr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tif (__apic_test_and_set_vector(vec, apic->regs + APIC_ISR))\n\t\treturn;\n\n\tvcpu = apic->vcpu;\n\n\t/*\n\t * With APIC virtualization enabled, all caching is disabled\n\t * because the processor can modify ISR under the hood.  Instead\n\t * just set SVI.\n\t */\n\tif (unlikely(vcpu->arch.apicv_active))\n\t\tkvm_x86_ops.hwapic_isr_update(vcpu, vec);\n\telse {\n\t\t++apic->isr_count;\n\t\tBUG_ON(apic->isr_count > MAX_APIC_VECTOR);\n\t\t/*\n\t\t * ISR (in service register) bit is set when injecting an interrupt.\n\t\t * The highest vector is injected. Thus the latest bit set matches\n\t\t * the highest bit in ISR.\n\t\t */\n\t\tapic->highest_isr_cache = vec;\n\t}\n}"
  },
  {
    "function_name": "apic_clear_irr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "457-474",
    "snippet": "static inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tvcpu = apic->vcpu;\n\n\tif (unlikely(vcpu->arch.apicv_active)) {\n\t\t/* need to update RVI */\n\t\tkvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tkvm_x86_ops.hwapic_irr_update(vcpu,\n\t\t\t\tapic_find_highest_irr(apic));\n\t} else {\n\t\tapic->irr_pending = false;\n\t\tkvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tif (apic_search_irr(apic) != -1)\n\t\t\tapic->irr_pending = true;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_search_irr",
          "args": [
            "apic"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "apic_search_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "435-438",
          "snippet": "static inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_clear_vector",
          "args": [
            "vec",
            "apic->regs + APIC_IRR"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_clear_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "136-139",
          "snippet": "static inline void kvm_lapic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_clear_vector(int vec, void *bitmap)\n{\n\tclear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.hwapic_irr_update",
          "args": [
            "vcpu",
            "apic_find_highest_irr(apic)"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_find_highest_irr",
          "args": [
            "apic"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "548-556",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vcpu->arch.apicv_active"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void apic_clear_irr(int vec, struct kvm_lapic *apic)\n{\n\tstruct kvm_vcpu *vcpu;\n\n\tvcpu = apic->vcpu;\n\n\tif (unlikely(vcpu->arch.apicv_active)) {\n\t\t/* need to update RVI */\n\t\tkvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tkvm_x86_ops.hwapic_irr_update(vcpu,\n\t\t\t\tapic_find_highest_irr(apic));\n\t} else {\n\t\tapic->irr_pending = false;\n\t\tkvm_lapic_clear_vector(vec, apic->regs + APIC_IRR);\n\t\tif (apic_search_irr(apic) != -1)\n\t\t\tapic->irr_pending = true;\n\t}\n}"
  },
  {
    "function_name": "apic_find_highest_irr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "440-455",
    "snippet": "static inline int apic_find_highest_irr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that irr_pending is just a hint. It will be always\n\t * true with virtual interrupt delivery enabled.\n\t */\n\tif (!apic->irr_pending)\n\t\treturn -1;\n\n\tresult = apic_search_irr(apic);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "result == -1 || result >= 16"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_search_irr",
          "args": [
            "apic"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "apic_search_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "435-438",
          "snippet": "static inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_find_highest_irr(struct kvm_lapic *apic)\n{\n\tint result;\n\n\t/*\n\t * Note that irr_pending is just a hint. It will be always\n\t * true with virtual interrupt delivery enabled.\n\t */\n\tif (!apic->irr_pending)\n\t\treturn -1;\n\n\tresult = apic_search_irr(apic);\n\tASSERT(result == -1 || result >= 16);\n\n\treturn result;\n}"
  },
  {
    "function_name": "apic_search_irr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "435-438",
    "snippet": "static inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_highest_vector",
          "args": [
            "apic->regs + APIC_IRR"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "find_highest_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "368-381",
          "snippet": "static int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn __fls(*reg) + vec;\n\t}\n\n\treturn -1;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define APIC_VECTORS_PER_REG\t\t32",
            "#define MAX_APIC_VECTOR\t\t\t256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VECTORS_PER_REG\t\t32\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn __fls(*reg) + vec;\n\t}\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_search_irr(struct kvm_lapic *apic)\n{\n\treturn find_highest_vector(apic->regs + APIC_IRR);\n}"
  },
  {
    "function_name": "kvm_apic_update_irr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "427-432",
    "snippet": "bool kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir, int *max_irr)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __kvm_apic_update_irr(pir, apic->regs, max_irr);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kvm_apic_update_irr",
          "args": [
            "pir",
            "apic->regs",
            "max_irr"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_apic_update_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "397-424",
          "snippet": "bool __kvm_apic_update_irr(u32 *pir, void *regs, int *max_irr)\n{\n\tu32 i, vec;\n\tu32 pir_val, irr_val, prev_irr_val;\n\tint max_updated_irr;\n\n\tmax_updated_irr = -1;\n\t*max_irr = -1;\n\n\tfor (i = vec = 0; i <= 7; i++, vec += 32) {\n\t\tpir_val = READ_ONCE(pir[i]);\n\t\tirr_val = *((u32 *)(regs + APIC_IRR + i * 0x10));\n\t\tif (pir_val) {\n\t\t\tprev_irr_val = irr_val;\n\t\t\tirr_val |= xchg(&pir[i], 0);\n\t\t\t*((u32 *)(regs + APIC_IRR + i * 0x10)) = irr_val;\n\t\t\tif (prev_irr_val != irr_val) {\n\t\t\t\tmax_updated_irr =\n\t\t\t\t\t__fls(irr_val ^ prev_irr_val) + vec;\n\t\t\t}\n\t\t}\n\t\tif (irr_val)\n\t\t\t*max_irr = __fls(irr_val) + vec;\n\t}\n\n\treturn ((max_updated_irr != -1) &&\n\t\t(max_updated_irr == *max_irr));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool __kvm_apic_update_irr(u32 *pir, void *regs, int *max_irr)\n{\n\tu32 i, vec;\n\tu32 pir_val, irr_val, prev_irr_val;\n\tint max_updated_irr;\n\n\tmax_updated_irr = -1;\n\t*max_irr = -1;\n\n\tfor (i = vec = 0; i <= 7; i++, vec += 32) {\n\t\tpir_val = READ_ONCE(pir[i]);\n\t\tirr_val = *((u32 *)(regs + APIC_IRR + i * 0x10));\n\t\tif (pir_val) {\n\t\t\tprev_irr_val = irr_val;\n\t\t\tirr_val |= xchg(&pir[i], 0);\n\t\t\t*((u32 *)(regs + APIC_IRR + i * 0x10)) = irr_val;\n\t\t\tif (prev_irr_val != irr_val) {\n\t\t\t\tmax_updated_irr =\n\t\t\t\t\t__fls(irr_val ^ prev_irr_val) + vec;\n\t\t\t}\n\t\t}\n\t\tif (irr_val)\n\t\t\t*max_irr = __fls(irr_val) + vec;\n\t}\n\n\treturn ((max_updated_irr != -1) &&\n\t\t(max_updated_irr == *max_irr));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir, int *max_irr)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __kvm_apic_update_irr(pir, apic->regs, max_irr);\n}"
  },
  {
    "function_name": "__kvm_apic_update_irr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "397-424",
    "snippet": "bool __kvm_apic_update_irr(u32 *pir, void *regs, int *max_irr)\n{\n\tu32 i, vec;\n\tu32 pir_val, irr_val, prev_irr_val;\n\tint max_updated_irr;\n\n\tmax_updated_irr = -1;\n\t*max_irr = -1;\n\n\tfor (i = vec = 0; i <= 7; i++, vec += 32) {\n\t\tpir_val = READ_ONCE(pir[i]);\n\t\tirr_val = *((u32 *)(regs + APIC_IRR + i * 0x10));\n\t\tif (pir_val) {\n\t\t\tprev_irr_val = irr_val;\n\t\t\tirr_val |= xchg(&pir[i], 0);\n\t\t\t*((u32 *)(regs + APIC_IRR + i * 0x10)) = irr_val;\n\t\t\tif (prev_irr_val != irr_val) {\n\t\t\t\tmax_updated_irr =\n\t\t\t\t\t__fls(irr_val ^ prev_irr_val) + vec;\n\t\t\t}\n\t\t}\n\t\tif (irr_val)\n\t\t\t*max_irr = __fls(irr_val) + vec;\n\t}\n\n\treturn ((max_updated_irr != -1) &&\n\t\t(max_updated_irr == *max_irr));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fls",
          "args": [
            "irr_val"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__fls",
          "args": [
            "irr_val ^ prev_irr_val"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&pir[i]",
            "0"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "pir[i]"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool __kvm_apic_update_irr(u32 *pir, void *regs, int *max_irr)\n{\n\tu32 i, vec;\n\tu32 pir_val, irr_val, prev_irr_val;\n\tint max_updated_irr;\n\n\tmax_updated_irr = -1;\n\t*max_irr = -1;\n\n\tfor (i = vec = 0; i <= 7; i++, vec += 32) {\n\t\tpir_val = READ_ONCE(pir[i]);\n\t\tirr_val = *((u32 *)(regs + APIC_IRR + i * 0x10));\n\t\tif (pir_val) {\n\t\t\tprev_irr_val = irr_val;\n\t\t\tirr_val |= xchg(&pir[i], 0);\n\t\t\t*((u32 *)(regs + APIC_IRR + i * 0x10)) = irr_val;\n\t\t\tif (prev_irr_val != irr_val) {\n\t\t\t\tmax_updated_irr =\n\t\t\t\t\t__fls(irr_val ^ prev_irr_val) + vec;\n\t\t\t}\n\t\t}\n\t\tif (irr_val)\n\t\t\t*max_irr = __fls(irr_val) + vec;\n\t}\n\n\treturn ((max_updated_irr != -1) &&\n\t\t(max_updated_irr == *max_irr));\n}"
  },
  {
    "function_name": "count_vectors",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "383-395",
    "snippet": "static u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define APIC_VECTORS_PER_REG\t\t32",
      "#define MAX_APIC_VECTOR\t\t\t256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "*reg"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_POS",
          "args": [
            "vec"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VECTORS_PER_REG\t\t32\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic u8 count_vectors(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\tu8 count = 0;\n\n\tfor (vec = 0; vec < MAX_APIC_VECTOR; vec += APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tcount += hweight32(*reg);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "find_highest_vector",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "368-381",
    "snippet": "static int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn __fls(*reg) + vec;\n\t}\n\n\treturn -1;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define APIC_VECTORS_PER_REG\t\t32",
      "#define MAX_APIC_VECTOR\t\t\t256"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fls",
          "args": [
            "*reg"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_POS",
          "args": [
            "vec"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VECTORS_PER_REG\t\t32\n#define MAX_APIC_VECTOR\t\t\t256\n\nstatic int find_highest_vector(void *bitmap)\n{\n\tint vec;\n\tu32 *reg;\n\n\tfor (vec = MAX_APIC_VECTOR - APIC_VECTORS_PER_REG;\n\t     vec >= 0; vec -= APIC_VECTORS_PER_REG) {\n\t\treg = bitmap + REG_POS(vec);\n\t\tif (*reg)\n\t\t\treturn __fls(*reg) + vec;\n\t}\n\n\treturn -1;\n}"
  },
  {
    "function_name": "kvm_apic_set_version",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "337-358",
    "snippet": "void kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\t/*\n\t * KVM emulates 82093AA datasheet (with in-kernel IOAPIC implementation)\n\t * which doesn't have EOI register; Some buggy OSes (e.g. Windows with\n\t * Hyper-V role) disable EOI broadcast in lapic not checking for IOAPIC\n\t * version first and level-triggered interrupts never get EOIed in\n\t * IOAPIC.\n\t */\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))) &&\n\t    !ioapic_in_kernel(vcpu->kvm))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))"
    ],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_LVR",
            "v"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "161-164",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioapic_in_kernel",
          "args": [
            "vcpu->kvm"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.h",
          "lines": "109-116",
          "snippet": "static inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "apic->vcpu",
            "0x1",
            "0"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.c",
          "lines": "903-917",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *e;\n\tint i;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\n\t\tif (e->function == function && (e->index == index ||\n\t\t    !(e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX)))\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/processor.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/processor.h>\n#include <linux/sched/stat.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *e;\n\tint i;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\n\t\tif (e->function == function && (e->index == index ||\n\t\t    !(e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX)))\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define APIC_VERSION\t\t\t(0x14UL | ((KVM_APIC_LVT_NUM - 1) << 16))\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_set_version(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tstruct kvm_cpuid_entry2 *feat;\n\tu32 v = APIC_VERSION;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\t/*\n\t * KVM emulates 82093AA datasheet (with in-kernel IOAPIC implementation)\n\t * which doesn't have EOI register; Some buggy OSes (e.g. Windows with\n\t * Hyper-V role) disable EOI broadcast in lapic not checking for IOAPIC\n\t * version first and level-triggered interrupts never get EOIed in\n\t * IOAPIC.\n\t */\n\tfeat = kvm_find_cpuid_entry(apic->vcpu, 0x1, 0);\n\tif (feat && (feat->ecx & (1 << (X86_FEATURE_X2APIC & 31))) &&\n\t    !ioapic_in_kernel(vcpu->kvm))\n\t\tv |= APIC_LVR_DIRECTED_EOI;\n\tkvm_lapic_set_reg(apic, APIC_LVR, v);\n}"
  },
  {
    "function_name": "apic_lvt_nmi_mode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "332-335",
    "snippet": "static inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_lvt_nmi_mode(u32 lvt_val)\n{\n\treturn (lvt_val & (APIC_MODE_MASK | APIC_LVT_MASKED)) == APIC_DM_NMI;\n}"
  },
  {
    "function_name": "apic_lvtt_tscdeadline",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "327-330",
    "snippet": "static inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_tscdeadline(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_TSCDEADLINE;\n}"
  },
  {
    "function_name": "apic_lvtt_period",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "322-325",
    "snippet": "static inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_period(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_PERIODIC;\n}"
  },
  {
    "function_name": "apic_lvtt_oneshot",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "317-320",
    "snippet": "static inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvtt_oneshot(struct kvm_lapic *apic)\n{\n\treturn apic->lapic_timer.timer_mode == APIC_LVT_TIMER_ONESHOT;\n}"
  },
  {
    "function_name": "apic_lvt_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "312-315",
    "snippet": "static inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_lapic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "lvt_type"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_lvt_enabled(struct kvm_lapic *apic, int lvt_type)\n{\n\treturn !(kvm_lapic_get_reg(apic, lvt_type) & APIC_LVT_MASKED);\n}"
  },
  {
    "function_name": "kvm_apic_set_x2apic_id",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "301-310",
    "snippet": "static inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u32 id)\n{\n\tu32 ldr = kvm_apic_calc_x2apic_ldr(id);\n\n\tWARN_ON_ONCE(id != apic->vcpu->vcpu_id);\n\n\tkvm_lapic_set_reg(apic, APIC_ID, id);\n\tkvm_lapic_set_reg(apic, APIC_LDR, ldr);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_LDR",
            "ldr"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "161-164",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "id != apic->vcpu->vcpu_id"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_calc_x2apic_ldr",
          "args": [
            "id"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_calc_x2apic_ldr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "296-299",
          "snippet": "static inline u32 kvm_apic_calc_x2apic_ldr(u32 id)\n{\n\treturn ((id >> 4) << 16) | (1 << (id & 0xf));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline u32 kvm_apic_calc_x2apic_ldr(u32 id)\n{\n\treturn ((id >> 4) << 16) | (1 << (id & 0xf));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u32 id)\n{\n\tu32 ldr = kvm_apic_calc_x2apic_ldr(id);\n\n\tWARN_ON_ONCE(id != apic->vcpu->vcpu_id);\n\n\tkvm_lapic_set_reg(apic, APIC_ID, id);\n\tkvm_lapic_set_reg(apic, APIC_LDR, ldr);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}"
  },
  {
    "function_name": "kvm_apic_calc_x2apic_ldr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "296-299",
    "snippet": "static inline u32 kvm_apic_calc_x2apic_ldr(u32 id)\n{\n\treturn ((id >> 4) << 16) | (1 << (id & 0xf));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline u32 kvm_apic_calc_x2apic_ldr(u32 id)\n{\n\treturn ((id >> 4) << 16) | (1 << (id & 0xf));\n}"
  },
  {
    "function_name": "kvm_apic_set_ldr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "290-294",
    "snippet": "static inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_LDR",
            "id"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "161-164",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_LDR, id);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}"
  },
  {
    "function_name": "kvm_apic_set_xapic_id",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "284-288",
    "snippet": "static inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_ID",
            "id << 24"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "161-164",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void kvm_apic_set_xapic_id(struct kvm_lapic *apic, u8 id)\n{\n\tkvm_lapic_set_reg(apic, APIC_ID, id << 24);\n\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n}"
  },
  {
    "function_name": "apic_set_spiv",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "267-282",
    "snippet": "static inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\n\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct static_key_deferred apic_sw_disabled",
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_key_slow_inc",
          "args": [
            "&apic_sw_disabled.key"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_slow_dec_deferred",
          "args": [
            "&apic_sw_disabled"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_reg",
          "args": [
            "apic",
            "APIC_SPIV",
            "val"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "161-164",
          "snippet": "static inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_reg(struct kvm_lapic *apic, int reg_off, u32 val)\n{\n\t*((u32 *) (apic->regs + reg_off)) = val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstruct static_key_deferred apic_sw_disabled;\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline void apic_set_spiv(struct kvm_lapic *apic, u32 val)\n{\n\tbool enabled = val & APIC_SPIV_APIC_ENABLED;\n\n\tkvm_lapic_set_reg(apic, APIC_SPIV, val);\n\n\tif (enabled != apic->sw_enabled) {\n\t\tapic->sw_enabled = enabled;\n\t\tif (enabled)\n\t\t\tstatic_key_slow_dec_deferred(&apic_sw_disabled);\n\t\telse\n\t\t\tstatic_key_slow_inc(&apic_sw_disabled.key);\n\n\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t}\n}"
  },
  {
    "function_name": "kvm_recalculate_apic_map",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "167-265",
    "snippet": "void kvm_recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tu32 max_id = 255; /* enough space for any xAPIC ID */\n\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/*\n\t\t * Read kvm->arch.apic_map_dirty before\n\t\t * kvm->arch.apic_map\n\t\t */\n\t\tsmp_rmb();\n\t\treturn;\n\t}\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/* Someone else has updated the map. */\n\t\tmutex_unlock(&kvm->arch.apic_map_lock);\n\t\treturn;\n\t}\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (kvm_apic_present(vcpu))\n\t\t\tmax_id = max(max_id, kvm_x2apic_id(vcpu->arch.apic));\n\n\tnew = kvzalloc(sizeof(struct kvm_apic_map) +\n\t                   sizeof(struct kvm_lapic *) * ((u64)max_id + 1),\n\t\t\t   GFP_KERNEL_ACCOUNT);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->max_apic_id = max_id;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tstruct kvm_lapic **cluster;\n\t\tu16 mask;\n\t\tu32 ldr;\n\t\tu8 xapic_id;\n\t\tu32 x2apic_id;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\txapic_id = kvm_xapic_id(apic);\n\t\tx2apic_id = kvm_x2apic_id(apic);\n\n\t\t/* Hotplug hack: see kvm_apic_match_physical_addr(), ... */\n\t\tif ((apic_x2apic_mode(apic) || x2apic_id > 0xff) &&\n\t\t\t\tx2apic_id <= new->max_apic_id)\n\t\t\tnew->phys_map[x2apic_id] = apic;\n\t\t/*\n\t\t * ... xAPIC ID of VCPUs with APIC ID > 0xff will wrap-around,\n\t\t * prevent them from masking VCPUs with APIC ID <= 0xff.\n\t\t */\n\t\tif (!apic_x2apic_mode(apic) && !new->phys_map[xapic_id])\n\t\t\tnew->phys_map[xapic_id] = apic;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tcontinue;\n\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))\n\t\t\tcontinue;\n\n\t\tif (mask)\n\t\t\tcluster[ffs(mask) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\t/*\n\t * Write kvm->arch.apic_map before\n\t * clearing apic->apic_map_dirty\n\t */\n\tsmp_wmb();\n\tkvm->arch.apic_map_dirty = false;\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tcall_rcu(&old->rcu, kvm_apic_map_free);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_scan_ioapic_request",
          "args": [
            "kvm"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_make_scan_ioapic_request",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8034-8037",
          "snippet": "void kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&old->rcu",
            "kvm_apic_map_free"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->arch.apic_map_lock"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "kvm->arch.apic_map",
            "new"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "kvm->arch.apic_map",
            "lockdep_is_held(&kvm->arch.apic_map_lock)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&kvm->arch.apic_map_lock"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "mask"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_l1_tsc_offset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1716-1725",
          "snippet": "static u64 vmx_read_l1_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING))\n\t\treturn vcpu->arch.tsc_offset - vmcs12->tsc_offset;\n\n\treturn vcpu->arch.tsc_offset;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic u64 vmx_read_l1_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING))\n\t\treturn vcpu->arch.tsc_offset - vmcs12->tsc_offset;\n\n\treturn vcpu->arch.tsc_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_map_get_logical_dest",
          "args": [
            "new",
            "ldr",
            "&cluster",
            "&mask"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_map_get_logical_dest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "127-158",
          "snippet": "static inline bool kvm_apic_map_get_logical_dest(struct kvm_apic_map *map,\n\t\tu32 dest_id, struct kvm_lapic ***cluster, u16 *mask) {\n\tswitch (map->mode) {\n\tcase KVM_APIC_MODE_X2APIC: {\n\t\tu32 offset = (dest_id >> 16) * 16;\n\t\tu32 max_apic_id = map->max_apic_id;\n\n\t\tif (offset <= max_apic_id) {\n\t\t\tu8 cluster_size = min(max_apic_id - offset + 1, 16U);\n\n\t\t\toffset = array_index_nospec(offset, map->max_apic_id + 1);\n\t\t\t*cluster = &map->phys_map[offset];\n\t\t\t*mask = dest_id & (0xffff >> (16 - cluster_size));\n\t\t} else {\n\t\t\t*mask = 0;\n\t\t}\n\n\t\treturn true;\n\t\t}\n\tcase KVM_APIC_MODE_XAPIC_FLAT:\n\t\t*cluster = map->xapic_flat_map;\n\t\t*mask = dest_id & 0xff;\n\t\treturn true;\n\tcase KVM_APIC_MODE_XAPIC_CLUSTER:\n\t\t*cluster = map->xapic_cluster_map[(dest_id >> 4) & 0xf];\n\t\t*mask = dest_id & 0xf;\n\t\treturn true;\n\tdefault:\n\t\t/* Not optimized. */\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_apic_map_get_logical_dest(struct kvm_apic_map *map,\n\t\tu32 dest_id, struct kvm_lapic ***cluster, u16 *mask) {\n\tswitch (map->mode) {\n\tcase KVM_APIC_MODE_X2APIC: {\n\t\tu32 offset = (dest_id >> 16) * 16;\n\t\tu32 max_apic_id = map->max_apic_id;\n\n\t\tif (offset <= max_apic_id) {\n\t\t\tu8 cluster_size = min(max_apic_id - offset + 1, 16U);\n\n\t\t\toffset = array_index_nospec(offset, map->max_apic_id + 1);\n\t\t\t*cluster = &map->phys_map[offset];\n\t\t\t*mask = dest_id & (0xffff >> (16 - cluster_size));\n\t\t} else {\n\t\t\t*mask = 0;\n\t\t}\n\n\t\treturn true;\n\t\t}\n\tcase KVM_APIC_MODE_XAPIC_FLAT:\n\t\t*cluster = map->xapic_flat_map;\n\t\t*mask = dest_id & 0xff;\n\t\treturn true;\n\tcase KVM_APIC_MODE_XAPIC_CLUSTER:\n\t\t*cluster = map->xapic_cluster_map[(dest_id >> 4) & 0xf];\n\t\t*mask = dest_id & 0xf;\n\t\treturn true;\n\tdefault:\n\t\t/* Not optimized. */\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_DFR"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_APIC_LOGICAL_ID",
          "args": [
            "ldr"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "apic_x2apic_mode",
          "args": [
            "apic"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "apic_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "203-206",
          "snippet": "static inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int apic_x2apic_mode(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->arch.apic_base & X2APIC_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_sw_enabled",
          "args": [
            "apic"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_sw_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "186-191",
          "snippet": "static inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x2apic_id",
          "args": [
            "apic"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_x2apic_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "111-114",
          "snippet": "static inline u32 kvm_x2apic_id(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->vcpu_id;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline u32 kvm_x2apic_id(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->vcpu_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_xapic_id",
          "args": [
            "apic"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_xapic_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "252-255",
          "snippet": "static inline u8 kvm_xapic_id(struct kvm_lapic *apic)\n{\n\treturn kvm_lapic_get_reg(apic, APIC_ID) >> 24;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u8 kvm_xapic_id(struct kvm_lapic *apic)\n{\n\treturn kvm_lapic_get_reg(apic, APIC_ID) >> 24;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_present",
          "args": [
            "vcpu"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_present",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "193-196",
          "snippet": "static inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_present(struct kvm_vcpu *vcpu)\n{\n\treturn lapic_in_kernel(vcpu) && kvm_apic_hw_enabled(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvzalloc",
          "args": [
            "sizeof(struct kvm_apic_map) +\n\t                   sizeof(struct kvm_lapic *) * ((u64)max_id + 1)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "max_id",
            "kvm_x2apic_id(vcpu->arch.apic)"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->arch.apic_map_lock"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->arch.apic_map_lock"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_recalculate_apic_map(struct kvm *kvm)\n{\n\tstruct kvm_apic_map *new, *old = NULL;\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\tu32 max_id = 255; /* enough space for any xAPIC ID */\n\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/*\n\t\t * Read kvm->arch.apic_map_dirty before\n\t\t * kvm->arch.apic_map\n\t\t */\n\t\tsmp_rmb();\n\t\treturn;\n\t}\n\n\tmutex_lock(&kvm->arch.apic_map_lock);\n\tif (!kvm->arch.apic_map_dirty) {\n\t\t/* Someone else has updated the map. */\n\t\tmutex_unlock(&kvm->arch.apic_map_lock);\n\t\treturn;\n\t}\n\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (kvm_apic_present(vcpu))\n\t\t\tmax_id = max(max_id, kvm_x2apic_id(vcpu->arch.apic));\n\n\tnew = kvzalloc(sizeof(struct kvm_apic_map) +\n\t                   sizeof(struct kvm_lapic *) * ((u64)max_id + 1),\n\t\t\t   GFP_KERNEL_ACCOUNT);\n\n\tif (!new)\n\t\tgoto out;\n\n\tnew->max_apic_id = max_id;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\t\tstruct kvm_lapic **cluster;\n\t\tu16 mask;\n\t\tu32 ldr;\n\t\tu8 xapic_id;\n\t\tu32 x2apic_id;\n\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\txapic_id = kvm_xapic_id(apic);\n\t\tx2apic_id = kvm_x2apic_id(apic);\n\n\t\t/* Hotplug hack: see kvm_apic_match_physical_addr(), ... */\n\t\tif ((apic_x2apic_mode(apic) || x2apic_id > 0xff) &&\n\t\t\t\tx2apic_id <= new->max_apic_id)\n\t\t\tnew->phys_map[x2apic_id] = apic;\n\t\t/*\n\t\t * ... xAPIC ID of VCPUs with APIC ID > 0xff will wrap-around,\n\t\t * prevent them from masking VCPUs with APIC ID <= 0xff.\n\t\t */\n\t\tif (!apic_x2apic_mode(apic) && !new->phys_map[xapic_id])\n\t\t\tnew->phys_map[xapic_id] = apic;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tcontinue;\n\n\t\tldr = kvm_lapic_get_reg(apic, APIC_LDR);\n\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tnew->mode |= KVM_APIC_MODE_X2APIC;\n\t\t} else if (ldr) {\n\t\t\tldr = GET_APIC_LOGICAL_ID(ldr);\n\t\t\tif (kvm_lapic_get_reg(apic, APIC_DFR) == APIC_DFR_FLAT)\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_FLAT;\n\t\t\telse\n\t\t\t\tnew->mode |= KVM_APIC_MODE_XAPIC_CLUSTER;\n\t\t}\n\n\t\tif (!kvm_apic_map_get_logical_dest(new, ldr, &cluster, &mask))\n\t\t\tcontinue;\n\n\t\tif (mask)\n\t\t\tcluster[ffs(mask) - 1] = apic;\n\t}\nout:\n\told = rcu_dereference_protected(kvm->arch.apic_map,\n\t\t\tlockdep_is_held(&kvm->arch.apic_map_lock));\n\trcu_assign_pointer(kvm->arch.apic_map, new);\n\t/*\n\t * Write kvm->arch.apic_map before\n\t * clearing apic->apic_map_dirty\n\t */\n\tsmp_wmb();\n\tkvm->arch.apic_map_dirty = false;\n\tmutex_unlock(&kvm->arch.apic_map_lock);\n\n\tif (old)\n\t\tcall_rcu(&old->rcu, kvm_apic_map_free);\n\n\tkvm_make_scan_ioapic_request(kvm);\n}"
  },
  {
    "function_name": "kvm_apic_map_free",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "160-165",
    "snippet": "static void kvm_apic_map_free(struct rcu_head *rcu)\n{\n\tstruct kvm_apic_map *map = container_of(rcu, struct kvm_apic_map, rcu);\n\n\tkvfree(map);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "map"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structkvm_apic_map",
            "rcu"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_apic_map_free(struct rcu_head *rcu)\n{\n\tstruct kvm_apic_map *map = container_of(rcu, struct kvm_apic_map, rcu);\n\n\tkvfree(map);\n}"
  },
  {
    "function_name": "kvm_apic_map_get_logical_dest",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "127-158",
    "snippet": "static inline bool kvm_apic_map_get_logical_dest(struct kvm_apic_map *map,\n\t\tu32 dest_id, struct kvm_lapic ***cluster, u16 *mask) {\n\tswitch (map->mode) {\n\tcase KVM_APIC_MODE_X2APIC: {\n\t\tu32 offset = (dest_id >> 16) * 16;\n\t\tu32 max_apic_id = map->max_apic_id;\n\n\t\tif (offset <= max_apic_id) {\n\t\t\tu8 cluster_size = min(max_apic_id - offset + 1, 16U);\n\n\t\t\toffset = array_index_nospec(offset, map->max_apic_id + 1);\n\t\t\t*cluster = &map->phys_map[offset];\n\t\t\t*mask = dest_id & (0xffff >> (16 - cluster_size));\n\t\t} else {\n\t\t\t*mask = 0;\n\t\t}\n\n\t\treturn true;\n\t\t}\n\tcase KVM_APIC_MODE_XAPIC_FLAT:\n\t\t*cluster = map->xapic_flat_map;\n\t\t*mask = dest_id & 0xff;\n\t\treturn true;\n\tcase KVM_APIC_MODE_XAPIC_CLUSTER:\n\t\t*cluster = map->xapic_cluster_map[(dest_id >> 4) & 0xf];\n\t\t*mask = dest_id & 0xf;\n\t\treturn true;\n\tdefault:\n\t\t/* Not optimized. */\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "offset",
            "map->max_apic_id + 1"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max_apic_id - offset + 1",
            "16U"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_apic_map_get_logical_dest(struct kvm_apic_map *map,\n\t\tu32 dest_id, struct kvm_lapic ***cluster, u16 *mask) {\n\tswitch (map->mode) {\n\tcase KVM_APIC_MODE_X2APIC: {\n\t\tu32 offset = (dest_id >> 16) * 16;\n\t\tu32 max_apic_id = map->max_apic_id;\n\n\t\tif (offset <= max_apic_id) {\n\t\t\tu8 cluster_size = min(max_apic_id - offset + 1, 16U);\n\n\t\t\toffset = array_index_nospec(offset, map->max_apic_id + 1);\n\t\t\t*cluster = &map->phys_map[offset];\n\t\t\t*mask = dest_id & (0xffff >> (16 - cluster_size));\n\t\t} else {\n\t\t\t*mask = 0;\n\t\t}\n\n\t\treturn true;\n\t\t}\n\tcase KVM_APIC_MODE_XAPIC_FLAT:\n\t\t*cluster = map->xapic_flat_map;\n\t\t*mask = dest_id & 0xff;\n\t\treturn true;\n\tcase KVM_APIC_MODE_XAPIC_CLUSTER:\n\t\t*cluster = map->xapic_cluster_map[(dest_id >> 4) & 0xf];\n\t\t*mask = dest_id & 0xf;\n\t\treturn true;\n\tdefault:\n\t\t/* Not optimized. */\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "kvm_use_posted_timer_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "122-125",
    "snippet": "static bool kvm_use_posted_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_can_post_timer_interrupt(vcpu) && vcpu->mode == IN_GUEST_MODE;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_can_post_timer_interrupt",
          "args": [
            "vcpu"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_can_post_timer_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "116-119",
          "snippet": "bool kvm_can_post_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn pi_inject_timer && kvm_vcpu_apicv_active(vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_can_post_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn pi_inject_timer && kvm_vcpu_apicv_active(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic bool kvm_use_posted_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_can_post_timer_interrupt(vcpu) && vcpu->mode == IN_GUEST_MODE;\n}"
  },
  {
    "function_name": "kvm_can_post_timer_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "116-119",
    "snippet": "bool kvm_can_post_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn pi_inject_timer && kvm_vcpu_apicv_active(vcpu);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_can_post_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn pi_inject_timer && kvm_vcpu_apicv_active(vcpu);\n}"
  },
  {
    "function_name": "kvm_x2apic_id",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "111-114",
    "snippet": "static inline u32 kvm_x2apic_id(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->vcpu_id;\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline u32 kvm_x2apic_id(struct kvm_lapic *apic)\n{\n\treturn apic->vcpu->vcpu_id;\n}"
  },
  {
    "function_name": "apic_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "99-102",
    "snippet": "static inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_hw_enabled",
          "args": [
            "apic"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_hw_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "177-182",
          "snippet": "static inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline int kvm_apic_hw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_hw_disabled.key))\n\t\treturn apic->vcpu->arch.apic_base & MSR_IA32_APICBASE_ENABLE;\n\treturn MSR_IA32_APICBASE_ENABLE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_sw_enabled",
          "args": [
            "apic"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_sw_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "186-191",
          "snippet": "static inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_apic_sw_enabled(struct kvm_lapic *apic)\n{\n\tif (static_key_false(&apic_sw_disabled.key))\n\t\treturn apic->sw_enabled;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nstatic inline int apic_enabled(struct kvm_lapic *apic)\n{\n\treturn kvm_apic_sw_enabled(apic) &&\tkvm_apic_hw_enabled(apic);\n}"
  },
  {
    "function_name": "__apic_test_and_clear_vector",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "91-94",
    "snippet": "static inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__test_and_clear_bit",
          "args": [
            "VEC_POS(vec)",
            "(bitmap) + REG_POS(vec)"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_POS",
          "args": [
            "vec"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VEC_POS",
          "args": [
            "vec"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int __apic_test_and_clear_vector(int vec, void *bitmap)\n{\n\treturn __test_and_clear_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
  },
  {
    "function_name": "__apic_test_and_set_vector",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "86-89",
    "snippet": "static inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__test_and_set_bit",
          "args": [
            "VEC_POS(vec)",
            "(bitmap) + REG_POS(vec)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_POS",
          "args": [
            "vec"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VEC_POS",
          "args": [
            "vec"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int __apic_test_and_set_vector(int vec, void *bitmap)\n{\n\treturn __test_and_set_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
  },
  {
    "function_name": "kvm_apic_pending_eoi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "78-84",
    "snippet": "bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void cancel_hv_timer(struct kvm_lapic *apic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_test_vector",
          "args": [
            "vector",
            "apic->regs + APIC_IRR"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "apic_test_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "73-76",
          "snippet": "static inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}"
  },
  {
    "function_name": "apic_test_vector",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
    "lines": "73-76",
    "snippet": "static inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}",
    "includes": [
      "#include \"hyperv.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"trace.h\"",
      "#include \"irq.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include <linux/jump_label.h>",
      "#include <linux/atomic.h>",
      "#include <asm/delay.h>",
      "#include <asm/apicdef.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/msr.h>",
      "#include <asm/processor.h>",
      "#include <linux/slab.h>",
      "#include <linux/math64.h>",
      "#include <linux/export.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "VEC_POS(vec)",
            "(bitmap) + REG_POS(vec)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REG_POS",
          "args": [
            "vec"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VEC_POS",
          "args": [
            "vec"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int apic_test_vector(int vec, void *bitmap)\n{\n\treturn test_bit(VEC_POS(vec), (bitmap) + REG_POS(vec));\n}"
  }
]