[
  {
    "function_name": "vmx_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "8045-8108",
    "snippet": "static int __init vmx_init(void)\n{\n\tint r;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\t/*\n\t * Enlightened VMCS usage should be recommended and the host needs\n\t * to support eVMCS v1 or above. We can also disable eVMCS support\n\t * with module parameter.\n\t */\n\tif (enlightened_vmcs &&\n\t    ms_hyperv.hints & HV_X64_ENLIGHTENED_VMCS_RECOMMENDED &&\n\t    (ms_hyperv.nested_features & HV_X64_ENLIGHTENED_VMCS_VERSION) >=\n\t    KVM_EVMCS_VERSION) {\n\t\tint cpu;\n\n\t\t/* Check that we have assist pages on all online CPUs */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tif (!hv_get_vp_assist_page(cpu)) {\n\t\t\t\tenlightened_vmcs = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (enlightened_vmcs) {\n\t\t\tpr_info(\"KVM: vmx: using Hyper-V Enlightened VMCS\\n\");\n\t\t\tstatic_branch_enable(&enable_evmcs);\n\t\t}\n\n\t\tif (ms_hyperv.nested_features & HV_X64_NESTED_DIRECT_FLUSH)\n\t\t\tvmx_x86_ops.enable_direct_tlbflush\n\t\t\t\t= hv_enable_direct_tlbflush;\n\n\t} else {\n\t\tenlightened_vmcs = false;\n\t}\n#endif\n\n\tr = kvm_init(&vmx_init_ops, sizeof(struct vcpu_vmx),\n\t\t     __alignof__(struct vcpu_vmx), THIS_MODULE);\n\tif (r)\n\t\treturn r;\n\n\t/*\n\t * Must be called after kvm_init() so enable_ept is properly set\n\t * up. Hand the parameter mitigation value in which was stored in\n\t * the pre module init parser. If no parameter was given, it will\n\t * contain 'auto' which will be turned into the default 'cond'\n\t * mitigation mode.\n\t */\n\tr = vmx_setup_l1d_flush(vmentry_l1d_flush_param);\n\tif (r) {\n\t\tvmx_exit();\n\t\treturn r;\n\t}\n\n#ifdef CONFIG_KEXEC_CORE\n\trcu_assign_pointer(crash_vmclear_loaded_vmcss,\n\t\t\t   crash_vmclear_local_loaded_vmcss);\n#endif\n\tvmx_check_vmcs12_offsets();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_check_vmcs12_offsets",
          "args": [],
          "line": 8105
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_check_vmcs12_offsets",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmcs12.h",
          "lines": "222-370",
          "snippet": "static inline void vmx_check_vmcs12_offsets(void)\n{\n\tCHECK_OFFSET(hdr, 0);\n\tCHECK_OFFSET(abort, 4);\n\tCHECK_OFFSET(launch_state, 8);\n\tCHECK_OFFSET(io_bitmap_a, 40);\n\tCHECK_OFFSET(io_bitmap_b, 48);\n\tCHECK_OFFSET(msr_bitmap, 56);\n\tCHECK_OFFSET(vm_exit_msr_store_addr, 64);\n\tCHECK_OFFSET(vm_exit_msr_load_addr, 72);\n\tCHECK_OFFSET(vm_entry_msr_load_addr, 80);\n\tCHECK_OFFSET(tsc_offset, 88);\n\tCHECK_OFFSET(virtual_apic_page_addr, 96);\n\tCHECK_OFFSET(apic_access_addr, 104);\n\tCHECK_OFFSET(posted_intr_desc_addr, 112);\n\tCHECK_OFFSET(ept_pointer, 120);\n\tCHECK_OFFSET(eoi_exit_bitmap0, 128);\n\tCHECK_OFFSET(eoi_exit_bitmap1, 136);\n\tCHECK_OFFSET(eoi_exit_bitmap2, 144);\n\tCHECK_OFFSET(eoi_exit_bitmap3, 152);\n\tCHECK_OFFSET(xss_exit_bitmap, 160);\n\tCHECK_OFFSET(guest_physical_address, 168);\n\tCHECK_OFFSET(vmcs_link_pointer, 176);\n\tCHECK_OFFSET(guest_ia32_debugctl, 184);\n\tCHECK_OFFSET(guest_ia32_pat, 192);\n\tCHECK_OFFSET(guest_ia32_efer, 200);\n\tCHECK_OFFSET(guest_ia32_perf_global_ctrl, 208);\n\tCHECK_OFFSET(guest_pdptr0, 216);\n\tCHECK_OFFSET(guest_pdptr1, 224);\n\tCHECK_OFFSET(guest_pdptr2, 232);\n\tCHECK_OFFSET(guest_pdptr3, 240);\n\tCHECK_OFFSET(guest_bndcfgs, 248);\n\tCHECK_OFFSET(host_ia32_pat, 256);\n\tCHECK_OFFSET(host_ia32_efer, 264);\n\tCHECK_OFFSET(host_ia32_perf_global_ctrl, 272);\n\tCHECK_OFFSET(vmread_bitmap, 280);\n\tCHECK_OFFSET(vmwrite_bitmap, 288);\n\tCHECK_OFFSET(vm_function_control, 296);\n\tCHECK_OFFSET(eptp_list_address, 304);\n\tCHECK_OFFSET(pml_address, 312);\n\tCHECK_OFFSET(cr0_guest_host_mask, 344);\n\tCHECK_OFFSET(cr4_guest_host_mask, 352);\n\tCHECK_OFFSET(cr0_read_shadow, 360);\n\tCHECK_OFFSET(cr4_read_shadow, 368);\n\tCHECK_OFFSET(cr3_target_value0, 376);\n\tCHECK_OFFSET(cr3_target_value1, 384);\n\tCHECK_OFFSET(cr3_target_value2, 392);\n\tCHECK_OFFSET(cr3_target_value3, 400);\n\tCHECK_OFFSET(exit_qualification, 408);\n\tCHECK_OFFSET(guest_linear_address, 416);\n\tCHECK_OFFSET(guest_cr0, 424);\n\tCHECK_OFFSET(guest_cr3, 432);\n\tCHECK_OFFSET(guest_cr4, 440);\n\tCHECK_OFFSET(guest_es_base, 448);\n\tCHECK_OFFSET(guest_cs_base, 456);\n\tCHECK_OFFSET(guest_ss_base, 464);\n\tCHECK_OFFSET(guest_ds_base, 472);\n\tCHECK_OFFSET(guest_fs_base, 480);\n\tCHECK_OFFSET(guest_gs_base, 488);\n\tCHECK_OFFSET(guest_ldtr_base, 496);\n\tCHECK_OFFSET(guest_tr_base, 504);\n\tCHECK_OFFSET(guest_gdtr_base, 512);\n\tCHECK_OFFSET(guest_idtr_base, 520);\n\tCHECK_OFFSET(guest_dr7, 528);\n\tCHECK_OFFSET(guest_rsp, 536);\n\tCHECK_OFFSET(guest_rip, 544);\n\tCHECK_OFFSET(guest_rflags, 552);\n\tCHECK_OFFSET(guest_pending_dbg_exceptions, 560);\n\tCHECK_OFFSET(guest_sysenter_esp, 568);\n\tCHECK_OFFSET(guest_sysenter_eip, 576);\n\tCHECK_OFFSET(host_cr0, 584);\n\tCHECK_OFFSET(host_cr3, 592);\n\tCHECK_OFFSET(host_cr4, 600);\n\tCHECK_OFFSET(host_fs_base, 608);\n\tCHECK_OFFSET(host_gs_base, 616);\n\tCHECK_OFFSET(host_tr_base, 624);\n\tCHECK_OFFSET(host_gdtr_base, 632);\n\tCHECK_OFFSET(host_idtr_base, 640);\n\tCHECK_OFFSET(host_ia32_sysenter_esp, 648);\n\tCHECK_OFFSET(host_ia32_sysenter_eip, 656);\n\tCHECK_OFFSET(host_rsp, 664);\n\tCHECK_OFFSET(host_rip, 672);\n\tCHECK_OFFSET(pin_based_vm_exec_control, 744);\n\tCHECK_OFFSET(cpu_based_vm_exec_control, 748);\n\tCHECK_OFFSET(exception_bitmap, 752);\n\tCHECK_OFFSET(page_fault_error_code_mask, 756);\n\tCHECK_OFFSET(page_fault_error_code_match, 760);\n\tCHECK_OFFSET(cr3_target_count, 764);\n\tCHECK_OFFSET(vm_exit_controls, 768);\n\tCHECK_OFFSET(vm_exit_msr_store_count, 772);\n\tCHECK_OFFSET(vm_exit_msr_load_count, 776);\n\tCHECK_OFFSET(vm_entry_controls, 780);\n\tCHECK_OFFSET(vm_entry_msr_load_count, 784);\n\tCHECK_OFFSET(vm_entry_intr_info_field, 788);\n\tCHECK_OFFSET(vm_entry_exception_error_code, 792);\n\tCHECK_OFFSET(vm_entry_instruction_len, 796);\n\tCHECK_OFFSET(tpr_threshold, 800);\n\tCHECK_OFFSET(secondary_vm_exec_control, 804);\n\tCHECK_OFFSET(vm_instruction_error, 808);\n\tCHECK_OFFSET(vm_exit_reason, 812);\n\tCHECK_OFFSET(vm_exit_intr_info, 816);\n\tCHECK_OFFSET(vm_exit_intr_error_code, 820);\n\tCHECK_OFFSET(idt_vectoring_info_field, 824);\n\tCHECK_OFFSET(idt_vectoring_error_code, 828);\n\tCHECK_OFFSET(vm_exit_instruction_len, 832);\n\tCHECK_OFFSET(vmx_instruction_info, 836);\n\tCHECK_OFFSET(guest_es_limit, 840);\n\tCHECK_OFFSET(guest_cs_limit, 844);\n\tCHECK_OFFSET(guest_ss_limit, 848);\n\tCHECK_OFFSET(guest_ds_limit, 852);\n\tCHECK_OFFSET(guest_fs_limit, 856);\n\tCHECK_OFFSET(guest_gs_limit, 860);\n\tCHECK_OFFSET(guest_ldtr_limit, 864);\n\tCHECK_OFFSET(guest_tr_limit, 868);\n\tCHECK_OFFSET(guest_gdtr_limit, 872);\n\tCHECK_OFFSET(guest_idtr_limit, 876);\n\tCHECK_OFFSET(guest_es_ar_bytes, 880);\n\tCHECK_OFFSET(guest_cs_ar_bytes, 884);\n\tCHECK_OFFSET(guest_ss_ar_bytes, 888);\n\tCHECK_OFFSET(guest_ds_ar_bytes, 892);\n\tCHECK_OFFSET(guest_fs_ar_bytes, 896);\n\tCHECK_OFFSET(guest_gs_ar_bytes, 900);\n\tCHECK_OFFSET(guest_ldtr_ar_bytes, 904);\n\tCHECK_OFFSET(guest_tr_ar_bytes, 908);\n\tCHECK_OFFSET(guest_interruptibility_info, 912);\n\tCHECK_OFFSET(guest_activity_state, 916);\n\tCHECK_OFFSET(guest_sysenter_cs, 920);\n\tCHECK_OFFSET(host_ia32_sysenter_cs, 924);\n\tCHECK_OFFSET(vmx_preemption_timer_value, 928);\n\tCHECK_OFFSET(virtual_processor_id, 960);\n\tCHECK_OFFSET(posted_intr_nv, 962);\n\tCHECK_OFFSET(guest_es_selector, 964);\n\tCHECK_OFFSET(guest_cs_selector, 966);\n\tCHECK_OFFSET(guest_ss_selector, 968);\n\tCHECK_OFFSET(guest_ds_selector, 970);\n\tCHECK_OFFSET(guest_fs_selector, 972);\n\tCHECK_OFFSET(guest_gs_selector, 974);\n\tCHECK_OFFSET(guest_ldtr_selector, 976);\n\tCHECK_OFFSET(guest_tr_selector, 978);\n\tCHECK_OFFSET(guest_intr_status, 980);\n\tCHECK_OFFSET(host_es_selector, 982);\n\tCHECK_OFFSET(host_cs_selector, 984);\n\tCHECK_OFFSET(host_ss_selector, 986);\n\tCHECK_OFFSET(host_ds_selector, 988);\n\tCHECK_OFFSET(host_fs_selector, 990);\n\tCHECK_OFFSET(host_gs_selector, 992);\n\tCHECK_OFFSET(host_tr_selector, 994);\n\tCHECK_OFFSET(guest_pml_index, 996);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include <linux/build_bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include <linux/build_bug.h>\n\nstatic inline void vmx_check_vmcs12_offsets(void)\n{\n\tCHECK_OFFSET(hdr, 0);\n\tCHECK_OFFSET(abort, 4);\n\tCHECK_OFFSET(launch_state, 8);\n\tCHECK_OFFSET(io_bitmap_a, 40);\n\tCHECK_OFFSET(io_bitmap_b, 48);\n\tCHECK_OFFSET(msr_bitmap, 56);\n\tCHECK_OFFSET(vm_exit_msr_store_addr, 64);\n\tCHECK_OFFSET(vm_exit_msr_load_addr, 72);\n\tCHECK_OFFSET(vm_entry_msr_load_addr, 80);\n\tCHECK_OFFSET(tsc_offset, 88);\n\tCHECK_OFFSET(virtual_apic_page_addr, 96);\n\tCHECK_OFFSET(apic_access_addr, 104);\n\tCHECK_OFFSET(posted_intr_desc_addr, 112);\n\tCHECK_OFFSET(ept_pointer, 120);\n\tCHECK_OFFSET(eoi_exit_bitmap0, 128);\n\tCHECK_OFFSET(eoi_exit_bitmap1, 136);\n\tCHECK_OFFSET(eoi_exit_bitmap2, 144);\n\tCHECK_OFFSET(eoi_exit_bitmap3, 152);\n\tCHECK_OFFSET(xss_exit_bitmap, 160);\n\tCHECK_OFFSET(guest_physical_address, 168);\n\tCHECK_OFFSET(vmcs_link_pointer, 176);\n\tCHECK_OFFSET(guest_ia32_debugctl, 184);\n\tCHECK_OFFSET(guest_ia32_pat, 192);\n\tCHECK_OFFSET(guest_ia32_efer, 200);\n\tCHECK_OFFSET(guest_ia32_perf_global_ctrl, 208);\n\tCHECK_OFFSET(guest_pdptr0, 216);\n\tCHECK_OFFSET(guest_pdptr1, 224);\n\tCHECK_OFFSET(guest_pdptr2, 232);\n\tCHECK_OFFSET(guest_pdptr3, 240);\n\tCHECK_OFFSET(guest_bndcfgs, 248);\n\tCHECK_OFFSET(host_ia32_pat, 256);\n\tCHECK_OFFSET(host_ia32_efer, 264);\n\tCHECK_OFFSET(host_ia32_perf_global_ctrl, 272);\n\tCHECK_OFFSET(vmread_bitmap, 280);\n\tCHECK_OFFSET(vmwrite_bitmap, 288);\n\tCHECK_OFFSET(vm_function_control, 296);\n\tCHECK_OFFSET(eptp_list_address, 304);\n\tCHECK_OFFSET(pml_address, 312);\n\tCHECK_OFFSET(cr0_guest_host_mask, 344);\n\tCHECK_OFFSET(cr4_guest_host_mask, 352);\n\tCHECK_OFFSET(cr0_read_shadow, 360);\n\tCHECK_OFFSET(cr4_read_shadow, 368);\n\tCHECK_OFFSET(cr3_target_value0, 376);\n\tCHECK_OFFSET(cr3_target_value1, 384);\n\tCHECK_OFFSET(cr3_target_value2, 392);\n\tCHECK_OFFSET(cr3_target_value3, 400);\n\tCHECK_OFFSET(exit_qualification, 408);\n\tCHECK_OFFSET(guest_linear_address, 416);\n\tCHECK_OFFSET(guest_cr0, 424);\n\tCHECK_OFFSET(guest_cr3, 432);\n\tCHECK_OFFSET(guest_cr4, 440);\n\tCHECK_OFFSET(guest_es_base, 448);\n\tCHECK_OFFSET(guest_cs_base, 456);\n\tCHECK_OFFSET(guest_ss_base, 464);\n\tCHECK_OFFSET(guest_ds_base, 472);\n\tCHECK_OFFSET(guest_fs_base, 480);\n\tCHECK_OFFSET(guest_gs_base, 488);\n\tCHECK_OFFSET(guest_ldtr_base, 496);\n\tCHECK_OFFSET(guest_tr_base, 504);\n\tCHECK_OFFSET(guest_gdtr_base, 512);\n\tCHECK_OFFSET(guest_idtr_base, 520);\n\tCHECK_OFFSET(guest_dr7, 528);\n\tCHECK_OFFSET(guest_rsp, 536);\n\tCHECK_OFFSET(guest_rip, 544);\n\tCHECK_OFFSET(guest_rflags, 552);\n\tCHECK_OFFSET(guest_pending_dbg_exceptions, 560);\n\tCHECK_OFFSET(guest_sysenter_esp, 568);\n\tCHECK_OFFSET(guest_sysenter_eip, 576);\n\tCHECK_OFFSET(host_cr0, 584);\n\tCHECK_OFFSET(host_cr3, 592);\n\tCHECK_OFFSET(host_cr4, 600);\n\tCHECK_OFFSET(host_fs_base, 608);\n\tCHECK_OFFSET(host_gs_base, 616);\n\tCHECK_OFFSET(host_tr_base, 624);\n\tCHECK_OFFSET(host_gdtr_base, 632);\n\tCHECK_OFFSET(host_idtr_base, 640);\n\tCHECK_OFFSET(host_ia32_sysenter_esp, 648);\n\tCHECK_OFFSET(host_ia32_sysenter_eip, 656);\n\tCHECK_OFFSET(host_rsp, 664);\n\tCHECK_OFFSET(host_rip, 672);\n\tCHECK_OFFSET(pin_based_vm_exec_control, 744);\n\tCHECK_OFFSET(cpu_based_vm_exec_control, 748);\n\tCHECK_OFFSET(exception_bitmap, 752);\n\tCHECK_OFFSET(page_fault_error_code_mask, 756);\n\tCHECK_OFFSET(page_fault_error_code_match, 760);\n\tCHECK_OFFSET(cr3_target_count, 764);\n\tCHECK_OFFSET(vm_exit_controls, 768);\n\tCHECK_OFFSET(vm_exit_msr_store_count, 772);\n\tCHECK_OFFSET(vm_exit_msr_load_count, 776);\n\tCHECK_OFFSET(vm_entry_controls, 780);\n\tCHECK_OFFSET(vm_entry_msr_load_count, 784);\n\tCHECK_OFFSET(vm_entry_intr_info_field, 788);\n\tCHECK_OFFSET(vm_entry_exception_error_code, 792);\n\tCHECK_OFFSET(vm_entry_instruction_len, 796);\n\tCHECK_OFFSET(tpr_threshold, 800);\n\tCHECK_OFFSET(secondary_vm_exec_control, 804);\n\tCHECK_OFFSET(vm_instruction_error, 808);\n\tCHECK_OFFSET(vm_exit_reason, 812);\n\tCHECK_OFFSET(vm_exit_intr_info, 816);\n\tCHECK_OFFSET(vm_exit_intr_error_code, 820);\n\tCHECK_OFFSET(idt_vectoring_info_field, 824);\n\tCHECK_OFFSET(idt_vectoring_error_code, 828);\n\tCHECK_OFFSET(vm_exit_instruction_len, 832);\n\tCHECK_OFFSET(vmx_instruction_info, 836);\n\tCHECK_OFFSET(guest_es_limit, 840);\n\tCHECK_OFFSET(guest_cs_limit, 844);\n\tCHECK_OFFSET(guest_ss_limit, 848);\n\tCHECK_OFFSET(guest_ds_limit, 852);\n\tCHECK_OFFSET(guest_fs_limit, 856);\n\tCHECK_OFFSET(guest_gs_limit, 860);\n\tCHECK_OFFSET(guest_ldtr_limit, 864);\n\tCHECK_OFFSET(guest_tr_limit, 868);\n\tCHECK_OFFSET(guest_gdtr_limit, 872);\n\tCHECK_OFFSET(guest_idtr_limit, 876);\n\tCHECK_OFFSET(guest_es_ar_bytes, 880);\n\tCHECK_OFFSET(guest_cs_ar_bytes, 884);\n\tCHECK_OFFSET(guest_ss_ar_bytes, 888);\n\tCHECK_OFFSET(guest_ds_ar_bytes, 892);\n\tCHECK_OFFSET(guest_fs_ar_bytes, 896);\n\tCHECK_OFFSET(guest_gs_ar_bytes, 900);\n\tCHECK_OFFSET(guest_ldtr_ar_bytes, 904);\n\tCHECK_OFFSET(guest_tr_ar_bytes, 908);\n\tCHECK_OFFSET(guest_interruptibility_info, 912);\n\tCHECK_OFFSET(guest_activity_state, 916);\n\tCHECK_OFFSET(guest_sysenter_cs, 920);\n\tCHECK_OFFSET(host_ia32_sysenter_cs, 924);\n\tCHECK_OFFSET(vmx_preemption_timer_value, 928);\n\tCHECK_OFFSET(virtual_processor_id, 960);\n\tCHECK_OFFSET(posted_intr_nv, 962);\n\tCHECK_OFFSET(guest_es_selector, 964);\n\tCHECK_OFFSET(guest_cs_selector, 966);\n\tCHECK_OFFSET(guest_ss_selector, 968);\n\tCHECK_OFFSET(guest_ds_selector, 970);\n\tCHECK_OFFSET(guest_fs_selector, 972);\n\tCHECK_OFFSET(guest_gs_selector, 974);\n\tCHECK_OFFSET(guest_ldtr_selector, 976);\n\tCHECK_OFFSET(guest_tr_selector, 978);\n\tCHECK_OFFSET(guest_intr_status, 980);\n\tCHECK_OFFSET(host_es_selector, 982);\n\tCHECK_OFFSET(host_cs_selector, 984);\n\tCHECK_OFFSET(host_ss_selector, 986);\n\tCHECK_OFFSET(host_ds_selector, 988);\n\tCHECK_OFFSET(host_fs_selector, 990);\n\tCHECK_OFFSET(host_gs_selector, 992);\n\tCHECK_OFFSET(host_tr_selector, 994);\n\tCHECK_OFFSET(guest_pml_index, 996);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "crash_vmclear_loaded_vmcss",
            "crash_vmclear_local_loaded_vmcss"
          ],
          "line": 8102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_exit",
          "args": [],
          "line": 8097
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_exit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "8009-8042",
          "snippet": "static void vmx_exit(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\n\tkvm_exit();\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (static_branch_unlikely(&enable_evmcs)) {\n\t\tint cpu;\n\t\tstruct hv_vp_assist_page *vp_ap;\n\t\t/*\n\t\t * Reset everything to support using non-enlightened VMCS\n\t\t * access later (e.g. when we reload the module with\n\t\t * enlightened_vmcs=0)\n\t\t */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tvp_ap =\thv_get_vp_assist_page(cpu);\n\n\t\t\tif (!vp_ap)\n\t\t\t\tcontinue;\n\n\t\t\tvp_ap->nested_control.features.directhypercall = 0;\n\t\t\tvp_ap->current_nested_vmcs = 0;\n\t\t\tvp_ap->enlighten_vmentry = 0;\n\t\t}\n\n\t\tstatic_branch_disable(&enable_evmcs);\n\t}\n#endif\n\tvmx_cleanup_l1d_flush();\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_exit(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\n\tkvm_exit();\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (static_branch_unlikely(&enable_evmcs)) {\n\t\tint cpu;\n\t\tstruct hv_vp_assist_page *vp_ap;\n\t\t/*\n\t\t * Reset everything to support using non-enlightened VMCS\n\t\t * access later (e.g. when we reload the module with\n\t\t * enlightened_vmcs=0)\n\t\t */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tvp_ap =\thv_get_vp_assist_page(cpu);\n\n\t\t\tif (!vp_ap)\n\t\t\t\tcontinue;\n\n\t\t\tvp_ap->nested_control.features.directhypercall = 0;\n\t\t\tvp_ap->current_nested_vmcs = 0;\n\t\t\tvp_ap->enlighten_vmentry = 0;\n\t\t}\n\n\t\tstatic_branch_disable(&enable_evmcs);\n\t}\n#endif\n\tvmx_cleanup_l1d_flush();\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_setup_l1d_flush",
          "args": [
            "vmentry_l1d_flush_param"
          ],
          "line": 8095
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_setup_l1d_flush",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "209-288",
          "snippet": "static int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)\n{\n\tstruct page *page;\n\tunsigned int i;\n\n\tif (!boot_cpu_has_bug(X86_BUG_L1TF)) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\treturn 0;\n\t}\n\n\tif (!enable_ept) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;\n\t\treturn 0;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {\n\t\tu64 msr;\n\n\t\trdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);\n\t\tif (msr & ARCH_CAP_SKIP_VMENTRY_L1DFLUSH) {\n\t\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If set to auto use the default l1tf mitigation method */\n\tif (l1tf == VMENTER_L1D_FLUSH_AUTO) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_NEVER;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_COND;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL:\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t\t\tbreak;\n\t\t}\n\t} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {\n\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t}\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&\n\t    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\t/*\n\t\t * This allocation for vmx_l1d_flush_pages is not tied to a VM\n\t\t * lifetime and so should not be charged to a memcg.\n\t\t */\n\t\tpage = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tvmx_l1d_flush_pages = page_address(page);\n\n\t\t/*\n\t\t * Initialize each page with a different pattern in\n\t\t * order to protect against KSM in the nested\n\t\t * virtualization case.\n\t\t */\n\t\tfor (i = 0; i < 1u << L1D_CACHE_ORDER; ++i) {\n\t\t\tmemset(vmx_l1d_flush_pages + i * PAGE_SIZE, i + 1,\n\t\t\t       PAGE_SIZE);\n\t\t}\n\t}\n\n\tl1tf_vmx_mitigation = l1tf;\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER)\n\t\tstatic_branch_enable(&vmx_l1d_should_flush);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_should_flush);\n\n\tif (l1tf == VMENTER_L1D_FLUSH_COND)\n\t\tstatic_branch_enable(&vmx_l1d_flush_cond);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_flush_cond);\n\treturn 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define L1D_CACHE_ORDER 4"
          ],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);",
            "static DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);",
            "static void *vmx_l1d_flush_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define L1D_CACHE_ORDER 4\n\nstatic bool __read_mostly nested = 1;\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);\nstatic void *vmx_l1d_flush_pages;\n\nstatic int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)\n{\n\tstruct page *page;\n\tunsigned int i;\n\n\tif (!boot_cpu_has_bug(X86_BUG_L1TF)) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\treturn 0;\n\t}\n\n\tif (!enable_ept) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;\n\t\treturn 0;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {\n\t\tu64 msr;\n\n\t\trdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);\n\t\tif (msr & ARCH_CAP_SKIP_VMENTRY_L1DFLUSH) {\n\t\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If set to auto use the default l1tf mitigation method */\n\tif (l1tf == VMENTER_L1D_FLUSH_AUTO) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_NEVER;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_COND;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL:\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t\t\tbreak;\n\t\t}\n\t} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {\n\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t}\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&\n\t    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\t/*\n\t\t * This allocation for vmx_l1d_flush_pages is not tied to a VM\n\t\t * lifetime and so should not be charged to a memcg.\n\t\t */\n\t\tpage = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tvmx_l1d_flush_pages = page_address(page);\n\n\t\t/*\n\t\t * Initialize each page with a different pattern in\n\t\t * order to protect against KSM in the nested\n\t\t * virtualization case.\n\t\t */\n\t\tfor (i = 0; i < 1u << L1D_CACHE_ORDER; ++i) {\n\t\t\tmemset(vmx_l1d_flush_pages + i * PAGE_SIZE, i + 1,\n\t\t\t       PAGE_SIZE);\n\t\t}\n\t}\n\n\tl1tf_vmx_mitigation = l1tf;\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER)\n\t\tstatic_branch_enable(&vmx_l1d_should_flush);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_should_flush);\n\n\tif (l1tf == VMENTER_L1D_FLUSH_COND)\n\t\tstatic_branch_enable(&vmx_l1d_flush_cond);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_flush_cond);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_init",
          "args": [
            "&vmx_init_ops",
            "sizeof(struct vcpu_vmx)",
            "__alignof__(struct vcpu_vmx)",
            "THIS_MODULE"
          ],
          "line": 8083
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_init_shadow_ept_mmu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5041-5073",
          "snippet": "void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly,\n\t\t\t     bool accessed_dirty, gpa_t new_eptp)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tu8 level = vmx_eptp_page_walk_level(new_eptp);\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_shadow_ept_root_page_role(vcpu, accessed_dirty,\n\t\t\t\t\t\t   execonly, level);\n\n\t__kvm_mmu_new_cr3(vcpu, new_eptp, new_role.base, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tcontext->shadow_root_level = level;\n\n\tcontext->nx = true;\n\tcontext->ept_ad = accessed_dirty;\n\tcontext->page_fault = ept_page_fault;\n\tcontext->gva_to_gpa = ept_gva_to_gpa;\n\tcontext->sync_page = ept_sync_page;\n\tcontext->invlpg = ept_invlpg;\n\tcontext->update_pte = ept_update_pte;\n\tcontext->root_level = level;\n\tcontext->direct_map = false;\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\n\tupdate_permission_bitmask(vcpu, context, true);\n\tupdate_pkru_bitmask(vcpu, context, true);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_rsvds_bits_mask_ept(vcpu, context, execonly);\n\treset_ept_shadow_zero_bits_mask(vcpu, context, execonly);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly,\n\t\t\t     bool accessed_dirty, gpa_t new_eptp)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tu8 level = vmx_eptp_page_walk_level(new_eptp);\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_shadow_ept_root_page_role(vcpu, accessed_dirty,\n\t\t\t\t\t\t   execonly, level);\n\n\t__kvm_mmu_new_cr3(vcpu, new_eptp, new_role.base, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tcontext->shadow_root_level = level;\n\n\tcontext->nx = true;\n\tcontext->ept_ad = accessed_dirty;\n\tcontext->page_fault = ept_page_fault;\n\tcontext->gva_to_gpa = ept_gva_to_gpa;\n\tcontext->sync_page = ept_sync_page;\n\tcontext->invlpg = ept_invlpg;\n\tcontext->update_pte = ept_update_pte;\n\tcontext->root_level = level;\n\tcontext->direct_map = false;\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\n\tupdate_permission_bitmask(vcpu, context, true);\n\tupdate_pkru_bitmask(vcpu, context, true);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_rsvds_bits_mask_ept(vcpu, context, execonly);\n\treset_ept_shadow_zero_bits_mask(vcpu, context, execonly);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&enable_evmcs"
          ],
          "line": 8071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"KVM: vmx: using Hyper-V Enlightened VMCS\\n\""
          ],
          "line": 8070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hv_get_vp_assist_page",
          "args": [
            "cpu"
          ],
          "line": 8063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HYPERV"
          ],
          "line": 8049
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int __init vmx_init(void)\n{\n\tint r;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\t/*\n\t * Enlightened VMCS usage should be recommended and the host needs\n\t * to support eVMCS v1 or above. We can also disable eVMCS support\n\t * with module parameter.\n\t */\n\tif (enlightened_vmcs &&\n\t    ms_hyperv.hints & HV_X64_ENLIGHTENED_VMCS_RECOMMENDED &&\n\t    (ms_hyperv.nested_features & HV_X64_ENLIGHTENED_VMCS_VERSION) >=\n\t    KVM_EVMCS_VERSION) {\n\t\tint cpu;\n\n\t\t/* Check that we have assist pages on all online CPUs */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tif (!hv_get_vp_assist_page(cpu)) {\n\t\t\t\tenlightened_vmcs = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (enlightened_vmcs) {\n\t\t\tpr_info(\"KVM: vmx: using Hyper-V Enlightened VMCS\\n\");\n\t\t\tstatic_branch_enable(&enable_evmcs);\n\t\t}\n\n\t\tif (ms_hyperv.nested_features & HV_X64_NESTED_DIRECT_FLUSH)\n\t\t\tvmx_x86_ops.enable_direct_tlbflush\n\t\t\t\t= hv_enable_direct_tlbflush;\n\n\t} else {\n\t\tenlightened_vmcs = false;\n\t}\n#endif\n\n\tr = kvm_init(&vmx_init_ops, sizeof(struct vcpu_vmx),\n\t\t     __alignof__(struct vcpu_vmx), THIS_MODULE);\n\tif (r)\n\t\treturn r;\n\n\t/*\n\t * Must be called after kvm_init() so enable_ept is properly set\n\t * up. Hand the parameter mitigation value in which was stored in\n\t * the pre module init parser. If no parameter was given, it will\n\t * contain 'auto' which will be turned into the default 'cond'\n\t * mitigation mode.\n\t */\n\tr = vmx_setup_l1d_flush(vmentry_l1d_flush_param);\n\tif (r) {\n\t\tvmx_exit();\n\t\treturn r;\n\t}\n\n#ifdef CONFIG_KEXEC_CORE\n\trcu_assign_pointer(crash_vmclear_loaded_vmcss,\n\t\t\t   crash_vmclear_local_loaded_vmcss);\n#endif\n\tvmx_check_vmcs12_offsets();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_exit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "8009-8042",
    "snippet": "static void vmx_exit(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\n\tkvm_exit();\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (static_branch_unlikely(&enable_evmcs)) {\n\t\tint cpu;\n\t\tstruct hv_vp_assist_page *vp_ap;\n\t\t/*\n\t\t * Reset everything to support using non-enlightened VMCS\n\t\t * access later (e.g. when we reload the module with\n\t\t * enlightened_vmcs=0)\n\t\t */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tvp_ap =\thv_get_vp_assist_page(cpu);\n\n\t\t\tif (!vp_ap)\n\t\t\t\tcontinue;\n\n\t\t\tvp_ap->nested_control.features.directhypercall = 0;\n\t\t\tvp_ap->current_nested_vmcs = 0;\n\t\t\tvp_ap->enlighten_vmentry = 0;\n\t\t}\n\n\t\tstatic_branch_disable(&enable_evmcs);\n\t}\n#endif\n\tvmx_cleanup_l1d_flush();\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_cleanup_l1d_flush",
          "args": [],
          "line": 8041
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_cleanup_l1d_flush",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "7999-8007",
          "snippet": "static void vmx_cleanup_l1d_flush(void)\n{\n\tif (vmx_l1d_flush_pages) {\n\t\tfree_pages((unsigned long)vmx_l1d_flush_pages, L1D_CACHE_ORDER);\n\t\tvmx_l1d_flush_pages = NULL;\n\t}\n\t/* Restore state so sysfs ignores VMX */\n\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_AUTO;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define L1D_CACHE_ORDER 4"
          ],
          "globals_used": [
            "static void *vmx_l1d_flush_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define L1D_CACHE_ORDER 4\n\nstatic void *vmx_l1d_flush_pages;\n\nstatic void vmx_cleanup_l1d_flush(void)\n{\n\tif (vmx_l1d_flush_pages) {\n\t\tfree_pages((unsigned long)vmx_l1d_flush_pages, L1D_CACHE_ORDER);\n\t\tvmx_l1d_flush_pages = NULL;\n\t}\n\t/* Restore state so sysfs ignores VMX */\n\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_AUTO;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&enable_evmcs"
          ],
          "line": 8038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hv_get_vp_assist_page",
          "args": [
            "cpu"
          ],
          "line": 8028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 8019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HYPERV"
          ],
          "line": 8018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_exit",
          "args": [],
          "line": 8016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 8013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "crash_vmclear_loaded_vmcss",
            "NULL"
          ],
          "line": 8012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_exit(void)\n{\n#ifdef CONFIG_KEXEC_CORE\n\tRCU_INIT_POINTER(crash_vmclear_loaded_vmcss, NULL);\n\tsynchronize_rcu();\n#endif\n\n\tkvm_exit();\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (static_branch_unlikely(&enable_evmcs)) {\n\t\tint cpu;\n\t\tstruct hv_vp_assist_page *vp_ap;\n\t\t/*\n\t\t * Reset everything to support using non-enlightened VMCS\n\t\t * access later (e.g. when we reload the module with\n\t\t * enlightened_vmcs=0)\n\t\t */\n\t\tfor_each_online_cpu(cpu) {\n\t\t\tvp_ap =\thv_get_vp_assist_page(cpu);\n\n\t\t\tif (!vp_ap)\n\t\t\t\tcontinue;\n\n\t\t\tvp_ap->nested_control.features.directhypercall = 0;\n\t\t\tvp_ap->current_nested_vmcs = 0;\n\t\t\tvp_ap->enlighten_vmentry = 0;\n\t\t}\n\n\t\tstatic_branch_disable(&enable_evmcs);\n\t}\n#endif\n\tvmx_cleanup_l1d_flush();\n}"
  },
  {
    "function_name": "vmx_cleanup_l1d_flush",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7999-8007",
    "snippet": "static void vmx_cleanup_l1d_flush(void)\n{\n\tif (vmx_l1d_flush_pages) {\n\t\tfree_pages((unsigned long)vmx_l1d_flush_pages, L1D_CACHE_ORDER);\n\t\tvmx_l1d_flush_pages = NULL;\n\t}\n\t/* Restore state so sysfs ignores VMX */\n\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_AUTO;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define L1D_CACHE_ORDER 4"
    ],
    "globals_used": [
      "static void *vmx_l1d_flush_pages;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)vmx_l1d_flush_pages",
            "L1D_CACHE_ORDER"
          ],
          "line": 8002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define L1D_CACHE_ORDER 4\n\nstatic void *vmx_l1d_flush_pages;\n\nstatic void vmx_cleanup_l1d_flush(void)\n{\n\tif (vmx_l1d_flush_pages) {\n\t\tfree_pages((unsigned long)vmx_l1d_flush_pages, L1D_CACHE_ORDER);\n\t\tvmx_l1d_flush_pages = NULL;\n\t}\n\t/* Restore state so sysfs ignores VMX */\n\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_AUTO;\n}"
  },
  {
    "function_name": "hardware_setup",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7816-7988",
    "snippet": "static __init int hardware_setup(void)\n{\n\tunsigned long host_bndcfgs;\n\tstruct desc_ptr dt;\n\tint r, i, ept_lpage_level;\n\n\tstore_idt(&dt);\n\thost_idt_base = dt.address;\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)\n\t\tkvm_define_shared_msr(i, vmx_msr_index[i]);\n\n\tif (setup_vmcs_config(&vmcs_config, &vmx_capability) < 0)\n\t\treturn -EIO;\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (boot_cpu_has(X86_FEATURE_MPX)) {\n\t\trdmsrl(MSR_IA32_BNDCFGS, host_bndcfgs);\n\t\tWARN_ONCE(host_bndcfgs, \"KVM: BNDCFGS in host will be lost\");\n\t}\n\n\tif (!cpu_has_vmx_mpx())\n\t\tsupported_xcr0 &= ~(XFEATURE_MASK_BNDREGS |\n\t\t\t\t    XFEATURE_MASK_BNDCSR);\n\n\tif (!cpu_has_vmx_vpid() || !cpu_has_vmx_invvpid() ||\n\t    !(cpu_has_vmx_invvpid_single() || cpu_has_vmx_invvpid_global()))\n\t\tenable_vpid = 0;\n\n\tif (!cpu_has_vmx_ept() ||\n\t    !cpu_has_vmx_ept_4levels() ||\n\t    !cpu_has_vmx_ept_mt_wb() ||\n\t    !cpu_has_vmx_invept_global())\n\t\tenable_ept = 0;\n\n\tif (!cpu_has_vmx_ept_ad_bits() || !enable_ept)\n\t\tenable_ept_ad_bits = 0;\n\n\tif (!cpu_has_vmx_unrestricted_guest() || !enable_ept)\n\t\tenable_unrestricted_guest = 0;\n\n\tif (!cpu_has_vmx_flexpriority())\n\t\tflexpriority_enabled = 0;\n\n\tif (!cpu_has_virtual_nmis())\n\t\tenable_vnmi = 0;\n\n\t/*\n\t * set_apic_access_page_addr() is used to reload apic access\n\t * page upon invalidation.  No need to do anything if not\n\t * using the APIC_ACCESS_ADDR VMCS field.\n\t */\n\tif (!flexpriority_enabled)\n\t\tvmx_x86_ops.set_apic_access_page_addr = NULL;\n\n\tif (!cpu_has_vmx_tpr_shadow())\n\t\tvmx_x86_ops.update_cr8_intercept = NULL;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (ms_hyperv.nested_features & HV_X64_NESTED_GUEST_MAPPING_FLUSH\n\t    && enable_ept) {\n\t\tvmx_x86_ops.tlb_remote_flush = hv_remote_flush_tlb;\n\t\tvmx_x86_ops.tlb_remote_flush_with_range =\n\t\t\t\thv_remote_flush_tlb_with_range;\n\t}\n#endif\n\n\tif (!cpu_has_vmx_ple()) {\n\t\tple_gap = 0;\n\t\tple_window = 0;\n\t\tple_window_grow = 0;\n\t\tple_window_max = 0;\n\t\tple_window_shrink = 0;\n\t}\n\n\tif (!cpu_has_vmx_apicv()) {\n\t\tenable_apicv = 0;\n\t\tvmx_x86_ops.sync_pir_to_irr = NULL;\n\t}\n\n\tif (cpu_has_vmx_tsc_scaling()) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 48;\n\t}\n\n\tset_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */\n\n\tif (enable_ept)\n\t\tvmx_enable_tdp();\n\n\tif (!enable_ept)\n\t\tept_lpage_level = 0;\n\telse if (cpu_has_vmx_ept_1g_page())\n\t\tept_lpage_level = PT_PDPE_LEVEL;\n\telse if (cpu_has_vmx_ept_2m_page())\n\t\tept_lpage_level = PT_DIRECTORY_LEVEL;\n\telse\n\t\tept_lpage_level = PT_PAGE_TABLE_LEVEL;\n\tkvm_configure_mmu(enable_ept, ept_lpage_level);\n\n\t/*\n\t * Only enable PML when hardware supports PML feature, and both EPT\n\t * and EPT A/D bit features are enabled -- PML depends on them to work.\n\t */\n\tif (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())\n\t\tenable_pml = 0;\n\n\tif (!enable_pml) {\n\t\tvmx_x86_ops.slot_enable_log_dirty = NULL;\n\t\tvmx_x86_ops.slot_disable_log_dirty = NULL;\n\t\tvmx_x86_ops.flush_log_dirty = NULL;\n\t\tvmx_x86_ops.enable_log_dirty_pt_masked = NULL;\n\t}\n\n\tif (!cpu_has_vmx_preemption_timer())\n\t\tenable_preemption_timer = false;\n\n\tif (enable_preemption_timer) {\n\t\tu64 use_timer_freq = 5000ULL * 1000 * 1000;\n\t\tu64 vmx_msr;\n\n\t\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\t\tcpu_preemption_timer_multi =\n\t\t\tvmx_msr & VMX_MISC_PREEMPTION_TIMER_RATE_MASK;\n\n\t\tif (tsc_khz)\n\t\t\tuse_timer_freq = (u64)tsc_khz * 1000;\n\t\tuse_timer_freq >>= cpu_preemption_timer_multi;\n\n\t\t/*\n\t\t * KVM \"disables\" the preemption timer by setting it to its max\n\t\t * value.  Don't use the timer if it might cause spurious exits\n\t\t * at a rate faster than 0.1 Hz (of uninterrupted guest time).\n\t\t */\n\t\tif (use_timer_freq > 0xffffffffu / 10)\n\t\t\tenable_preemption_timer = false;\n\t}\n\n\tif (!enable_preemption_timer) {\n\t\tvmx_x86_ops.set_hv_timer = NULL;\n\t\tvmx_x86_ops.cancel_hv_timer = NULL;\n\t\tvmx_x86_ops.request_immediate_exit = __kvm_request_immediate_exit;\n\t}\n\n\tkvm_set_posted_intr_wakeup_handler(wakeup_handler);\n\n\tkvm_mce_cap_supported |= MCG_LMCE_P;\n\n\tif (pt_mode != PT_MODE_SYSTEM && pt_mode != PT_MODE_HOST_GUEST)\n\t\treturn -EINVAL;\n\tif (!enable_ept || !cpu_has_vmx_intel_pt())\n\t\tpt_mode = PT_MODE_SYSTEM;\n\n\tif (nested) {\n\t\tnested_vmx_setup_ctls_msrs(&vmcs_config.nested,\n\t\t\t\t\t   vmx_capability.ept);\n\n\t\tr = nested_vmx_hardware_setup(&vmx_x86_ops,\n\t\t\t\t\t      kvm_vmx_exit_handlers);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tvmx_set_cpu_caps();\n\n\tr = alloc_kvm_area();\n\tif (r)\n\t\tnested_vmx_hardware_unsetup();\n\treturn r;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define KVM_VMX_TSC_MULTIPLIER_MAX     0xffffffffffffffffULL"
    ],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static unsigned int ple_gap = KVM_DEFAULT_PLE_GAP;",
      "static unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;",
      "static unsigned int ple_window_grow = KVM_DEFAULT_PLE_WINDOW_GROW;",
      "static unsigned int ple_window_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;",
      "static unsigned int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;",
      "int __read_mostly pt_mode = PT_MODE_SYSTEM;",
      "struct vmcs_config vmcs_config;",
      "struct vmx_capability vmx_capability;",
      "static unsigned long host_idt_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_vmx_hardware_unsetup",
          "args": [],
          "line": 7986
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_hardware_unsetup",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "6234-6242",
          "snippet": "void nested_vmx_hardware_unsetup(void)\n{\n\tint i;\n\n\tif (enable_shadow_vmcs) {\n\t\tfor (i = 0; i < VMX_BITMAP_NR; i++)\n\t\t\tfree_page((unsigned long)vmx_bitmap[i]);\n\t}\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long *vmx_bitmap[VMX_BITMAP_NR];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nstatic unsigned long *vmx_bitmap[VMX_BITMAP_NR];\n\nvoid nested_vmx_hardware_unsetup(void)\n{\n\tint i;\n\n\tif (enable_shadow_vmcs) {\n\t\tfor (i = 0; i < VMX_BITMAP_NR; i++)\n\t\t\tfree_page((unsigned long)vmx_bitmap[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_kvm_area",
          "args": [],
          "line": 7984
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_kvm_area",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2628-2657",
          "snippet": "static __init int alloc_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmcs *vmcs;\n\n\t\tvmcs = alloc_vmcs_cpu(false, cpu, GFP_KERNEL);\n\t\tif (!vmcs) {\n\t\t\tfree_kvm_area();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * When eVMCS is enabled, alloc_vmcs_cpu() sets\n\t\t * vmcs->revision_id to KVM_EVMCS_VERSION instead of\n\t\t * revision_id reported by MSR_IA32_VMX_BASIC.\n\t\t *\n\t\t * However, even though not explicitly documented by\n\t\t * TLFS, VMXArea passed as VMXON argument should\n\t\t * still be marked with revision_id reported by\n\t\t * physical CPU.\n\t\t */\n\t\tif (static_branch_unlikely(&enable_evmcs))\n\t\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\t\tper_cpu(vmxarea, cpu) = vmcs;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct vmcs_config vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct vmcs_config vmcs_config;\n\nstatic __init int alloc_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmcs *vmcs;\n\n\t\tvmcs = alloc_vmcs_cpu(false, cpu, GFP_KERNEL);\n\t\tif (!vmcs) {\n\t\t\tfree_kvm_area();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * When eVMCS is enabled, alloc_vmcs_cpu() sets\n\t\t * vmcs->revision_id to KVM_EVMCS_VERSION instead of\n\t\t * revision_id reported by MSR_IA32_VMX_BASIC.\n\t\t *\n\t\t * However, even though not explicitly documented by\n\t\t * TLFS, VMXArea passed as VMXON argument should\n\t\t * still be marked with revision_id reported by\n\t\t * physical CPU.\n\t\t */\n\t\tif (static_branch_unlikely(&enable_evmcs))\n\t\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\t\tper_cpu(vmxarea, cpu) = vmcs;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_set_cpu_caps",
          "args": [],
          "line": 7982
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_cpu_caps",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "7114-7145",
          "snippet": "static __init void vmx_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\t/* CPUID 0x1 */\n\tif (nested)\n\t\tkvm_cpu_cap_set(X86_FEATURE_VMX);\n\n\t/* CPUID 0x7 */\n\tif (kvm_mpx_supported())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_MPX);\n\tif (cpu_has_vmx_invpcid())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_INVPCID);\n\tif (vmx_pt_mode_is_host_guest())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_INTEL_PT);\n\n\t/* PKU is not yet implemented for shadow paging. */\n\tif (enable_ept && boot_cpu_has(X86_FEATURE_OSPKE))\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_PKU);\n\n\tif (vmx_umip_emulated())\n\t\tkvm_cpu_cap_set(X86_FEATURE_UMIP);\n\n\t/* CPUID 0xD.1 */\n\tsupported_xss = 0;\n\tif (!vmx_xsaves_supported())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_XSAVES);\n\n\t/* CPUID 0x80000001 */\n\tif (!cpu_has_vmx_rdtscp())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_RDTSCP);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\n\nstatic __init void vmx_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\t/* CPUID 0x1 */\n\tif (nested)\n\t\tkvm_cpu_cap_set(X86_FEATURE_VMX);\n\n\t/* CPUID 0x7 */\n\tif (kvm_mpx_supported())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_MPX);\n\tif (cpu_has_vmx_invpcid())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_INVPCID);\n\tif (vmx_pt_mode_is_host_guest())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_INTEL_PT);\n\n\t/* PKU is not yet implemented for shadow paging. */\n\tif (enable_ept && boot_cpu_has(X86_FEATURE_OSPKE))\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_PKU);\n\n\tif (vmx_umip_emulated())\n\t\tkvm_cpu_cap_set(X86_FEATURE_UMIP);\n\n\t/* CPUID 0xD.1 */\n\tsupported_xss = 0;\n\tif (!vmx_xsaves_supported())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_XSAVES);\n\n\t/* CPUID 0x80000001 */\n\tif (!cpu_has_vmx_rdtscp())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_RDTSCP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_hardware_setup",
          "args": [
            "&vmx_x86_ops",
            "kvm_vmx_exit_handlers"
          ],
          "line": 7976
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_hardware_setup",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "6244-6289",
          "snippet": "__init int nested_vmx_hardware_setup(struct kvm_x86_ops *ops,\n\t\t\t\t     int (*exit_handlers[])(struct kvm_vcpu *))\n{\n\tint i;\n\n\tif (!cpu_has_vmx_shadow_vmcs())\n\t\tenable_shadow_vmcs = 0;\n\tif (enable_shadow_vmcs) {\n\t\tfor (i = 0; i < VMX_BITMAP_NR; i++) {\n\t\t\t/*\n\t\t\t * The vmx_bitmap is not tied to a VM and so should\n\t\t\t * not be charged to a memcg.\n\t\t\t */\n\t\t\tvmx_bitmap[i] = (unsigned long *)\n\t\t\t\t__get_free_page(GFP_KERNEL);\n\t\t\tif (!vmx_bitmap[i]) {\n\t\t\t\tnested_vmx_hardware_unsetup();\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tinit_vmcs_shadow_fields();\n\t}\n\n\texit_handlers[EXIT_REASON_VMCLEAR]\t= handle_vmclear;\n\texit_handlers[EXIT_REASON_VMLAUNCH]\t= handle_vmlaunch;\n\texit_handlers[EXIT_REASON_VMPTRLD]\t= handle_vmptrld;\n\texit_handlers[EXIT_REASON_VMPTRST]\t= handle_vmptrst;\n\texit_handlers[EXIT_REASON_VMREAD]\t= handle_vmread;\n\texit_handlers[EXIT_REASON_VMRESUME]\t= handle_vmresume;\n\texit_handlers[EXIT_REASON_VMWRITE]\t= handle_vmwrite;\n\texit_handlers[EXIT_REASON_VMOFF]\t= handle_vmoff;\n\texit_handlers[EXIT_REASON_VMON]\t\t= handle_vmon;\n\texit_handlers[EXIT_REASON_INVEPT]\t= handle_invept;\n\texit_handlers[EXIT_REASON_INVVPID]\t= handle_invvpid;\n\texit_handlers[EXIT_REASON_VMFUNC]\t= handle_vmfunc;\n\n\tops->check_nested_events = vmx_check_nested_events;\n\tops->get_nested_state = vmx_get_nested_state;\n\tops->set_nested_state = vmx_set_nested_state;\n\tops->get_vmcs12_pages = nested_get_vmcs12_pages;\n\tops->nested_enable_evmcs = nested_enable_evmcs;\n\tops->nested_get_evmcs_version = nested_get_evmcs_version;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long *vmx_bitmap[VMX_BITMAP_NR];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nstatic unsigned long *vmx_bitmap[VMX_BITMAP_NR];\n\n__init int nested_vmx_hardware_setup(struct kvm_x86_ops *ops,\n\t\t\t\t     int (*exit_handlers[])(struct kvm_vcpu *))\n{\n\tint i;\n\n\tif (!cpu_has_vmx_shadow_vmcs())\n\t\tenable_shadow_vmcs = 0;\n\tif (enable_shadow_vmcs) {\n\t\tfor (i = 0; i < VMX_BITMAP_NR; i++) {\n\t\t\t/*\n\t\t\t * The vmx_bitmap is not tied to a VM and so should\n\t\t\t * not be charged to a memcg.\n\t\t\t */\n\t\t\tvmx_bitmap[i] = (unsigned long *)\n\t\t\t\t__get_free_page(GFP_KERNEL);\n\t\t\tif (!vmx_bitmap[i]) {\n\t\t\t\tnested_vmx_hardware_unsetup();\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tinit_vmcs_shadow_fields();\n\t}\n\n\texit_handlers[EXIT_REASON_VMCLEAR]\t= handle_vmclear;\n\texit_handlers[EXIT_REASON_VMLAUNCH]\t= handle_vmlaunch;\n\texit_handlers[EXIT_REASON_VMPTRLD]\t= handle_vmptrld;\n\texit_handlers[EXIT_REASON_VMPTRST]\t= handle_vmptrst;\n\texit_handlers[EXIT_REASON_VMREAD]\t= handle_vmread;\n\texit_handlers[EXIT_REASON_VMRESUME]\t= handle_vmresume;\n\texit_handlers[EXIT_REASON_VMWRITE]\t= handle_vmwrite;\n\texit_handlers[EXIT_REASON_VMOFF]\t= handle_vmoff;\n\texit_handlers[EXIT_REASON_VMON]\t\t= handle_vmon;\n\texit_handlers[EXIT_REASON_INVEPT]\t= handle_invept;\n\texit_handlers[EXIT_REASON_INVVPID]\t= handle_invvpid;\n\texit_handlers[EXIT_REASON_VMFUNC]\t= handle_vmfunc;\n\n\tops->check_nested_events = vmx_check_nested_events;\n\tops->get_nested_state = vmx_get_nested_state;\n\tops->set_nested_state = vmx_set_nested_state;\n\tops->get_vmcs12_pages = nested_get_vmcs12_pages;\n\tops->nested_enable_evmcs = nested_enable_evmcs;\n\tops->nested_get_evmcs_version = nested_get_evmcs_version;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_setup_ctls_msrs",
          "args": [
            "&vmcs_config.nested",
            "vmx_capability.ept"
          ],
          "line": 7973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_intel_pt",
          "args": [],
          "line": 7969
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_intel_pt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "341-350",
          "snippet": "static inline bool cpu_has_vmx_intel_pt(void)\n{\n\tu64 vmx_msr;\n\n\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\treturn (vmx_msr & MSR_IA32_VMX_MISC_INTEL_PT) &&\n\t\t(vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_PT_USE_GPA) &&\n\t\t(vmcs_config.vmexit_ctrl & VM_EXIT_CLEAR_IA32_RTIT_CTL) &&\n\t\t(vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_RTIT_CTL);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_intel_pt(void)\n{\n\tu64 vmx_msr;\n\n\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\treturn (vmx_msr & MSR_IA32_VMX_MISC_INTEL_PT) &&\n\t\t(vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_PT_USE_GPA) &&\n\t\t(vmcs_config.vmexit_ctrl & VM_EXIT_CLEAR_IA32_RTIT_CTL) &&\n\t\t(vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_RTIT_CTL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_posted_intr_wakeup_handler",
          "args": [
            "wakeup_handler"
          ],
          "line": 7963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_VMX_MISC",
            "vmx_msr"
          ],
          "line": 7940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_preemption_timer",
          "args": [],
          "line": 7933
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_preemption_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "80-84",
          "snippet": "static inline bool cpu_has_vmx_preemption_timer(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_preemption_timer(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_pml",
          "args": [],
          "line": 7923
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_pml",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "240-243",
          "snippet": "static inline bool cpu_has_vmx_pml(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_ENABLE_PML;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_pml(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_ENABLE_PML;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_configure_mmu",
          "args": [
            "enable_ept",
            "ept_lpage_level"
          ],
          "line": 7917
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_configure_mmu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5563-5580",
          "snippet": "void kvm_configure_mmu(bool enable_tdp, int tdp_page_level)\n{\n\ttdp_enabled = enable_tdp;\n\n\t/*\n\t * max_page_level reflects the capabilities of KVM's MMU irrespective\n\t * of kernel support, e.g. KVM may be capable of using 1GB pages when\n\t * the kernel is not.  But, KVM never creates a page size greater than\n\t * what is used by the kernel for any given HVA, i.e. the kernel's\n\t * capabilities are ultimately consulted by kvm_mmu_hugepage_adjust().\n\t */\n\tif (tdp_enabled)\n\t\tmax_page_level = tdp_page_level;\n\telse if (boot_cpu_has(X86_FEATURE_GBPAGES))\n\t\tmax_page_level = PT_PDPE_LEVEL;\n\telse\n\t\tmax_page_level = PT_DIRECTORY_LEVEL;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool tdp_enabled = false;",
            "static int max_page_level"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic int max_page_level;\n\nvoid kvm_configure_mmu(bool enable_tdp, int tdp_page_level)\n{\n\ttdp_enabled = enable_tdp;\n\n\t/*\n\t * max_page_level reflects the capabilities of KVM's MMU irrespective\n\t * of kernel support, e.g. KVM may be capable of using 1GB pages when\n\t * the kernel is not.  But, KVM never creates a page size greater than\n\t * what is used by the kernel for any given HVA, i.e. the kernel's\n\t * capabilities are ultimately consulted by kvm_mmu_hugepage_adjust().\n\t */\n\tif (tdp_enabled)\n\t\tmax_page_level = tdp_page_level;\n\telse if (boot_cpu_has(X86_FEATURE_GBPAGES))\n\t\tmax_page_level = PT_PDPE_LEVEL;\n\telse\n\t\tmax_page_level = PT_DIRECTORY_LEVEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_ept_2m_page",
          "args": [],
          "line": 7913
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_ept_2m_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "296-299",
          "snippet": "static inline bool cpu_has_vmx_ept_2m_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_2MB_PAGE_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_ept_2m_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_2MB_PAGE_BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_ept_1g_page",
          "args": [],
          "line": 7911
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_ept_1g_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "301-304",
          "snippet": "static inline bool cpu_has_vmx_ept_1g_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_1GB_PAGE_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_ept_1g_page(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_1GB_PAGE_BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_enable_tdp",
          "args": [],
          "line": 7907
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_enable_tdp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5305-5315",
          "snippet": "static void vmx_enable_tdp(void)\n{\n\tkvm_mmu_set_mask_ptes(VMX_EPT_READABLE_MASK,\n\t\tenable_ept_ad_bits ? VMX_EPT_ACCESS_BIT : 0ull,\n\t\tenable_ept_ad_bits ? VMX_EPT_DIRTY_BIT : 0ull,\n\t\t0ull, VMX_EPT_EXECUTABLE_MASK,\n\t\tcpu_has_vmx_ept_execute_only() ? 0ull : VMX_EPT_READABLE_MASK,\n\t\tVMX_EPT_RWX_MASK, 0ull);\n\n\tept_set_mmio_spte_mask();\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_enable_tdp(void)\n{\n\tkvm_mmu_set_mask_ptes(VMX_EPT_READABLE_MASK,\n\t\tenable_ept_ad_bits ? VMX_EPT_ACCESS_BIT : 0ull,\n\t\tenable_ept_ad_bits ? VMX_EPT_DIRTY_BIT : 0ull,\n\t\t0ull, VMX_EPT_EXECUTABLE_MASK,\n\t\tcpu_has_vmx_ept_execute_only() ? 0ull : VMX_EPT_READABLE_MASK,\n\t\tVMX_EPT_RWX_MASK, 0ull);\n\n\tept_set_mmio_spte_mask();\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "0",
            "vmx_vpid_bitmap"
          ],
          "line": 7904
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "224-232",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_tsc_scaling",
          "args": [],
          "line": 7898
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_tsc_scaling",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "257-261",
          "snippet": "static inline bool cpu_has_vmx_tsc_scaling(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_TSC_SCALING;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_tsc_scaling(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_TSC_SCALING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_apicv",
          "args": [],
          "line": 7893
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_apicv",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "263-268",
          "snippet": "static inline bool cpu_has_vmx_apicv(void)\n{\n\treturn cpu_has_vmx_apic_register_virt() &&\n\t\tcpu_has_vmx_virtual_intr_delivery() &&\n\t\tcpu_has_vmx_posted_intr();\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_apicv(void)\n{\n\treturn cpu_has_vmx_apic_register_virt() &&\n\t\tcpu_has_vmx_virtual_intr_delivery() &&\n\t\tcpu_has_vmx_posted_intr();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_ple",
          "args": [],
          "line": 7885
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_ple",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "191-195",
          "snippet": "static inline bool cpu_has_vmx_ple(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_ple(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HYPERV"
          ],
          "line": 7876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_tpr_shadow",
          "args": [],
          "line": 7873
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_tpr_shadow",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "110-113",
          "snippet": "static inline bool cpu_has_vmx_tpr_shadow(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_tpr_shadow(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_virtual_nmis",
          "args": [],
          "line": 7862
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_virtual_nmis",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "75-78",
          "snippet": "static inline bool cpu_has_virtual_nmis(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl & PIN_BASED_VIRTUAL_NMIS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_virtual_nmis(void)\n{\n\treturn vmcs_config.pin_based_exec_ctrl & PIN_BASED_VIRTUAL_NMIS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_flexpriority",
          "args": [],
          "line": 7859
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_flexpriority",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "270-274",
          "snippet": "static inline bool cpu_has_vmx_flexpriority(void)\n{\n\treturn cpu_has_vmx_tpr_shadow() &&\n\t\tcpu_has_vmx_virtualize_apic_accesses();\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_flexpriority(void)\n{\n\treturn cpu_has_vmx_tpr_shadow() &&\n\t\tcpu_has_vmx_virtualize_apic_accesses();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_unrestricted_guest",
          "args": [],
          "line": 7856
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_unrestricted_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "173-177",
          "snippet": "static inline bool cpu_has_vmx_unrestricted_guest(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_unrestricted_guest(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_ept_ad_bits",
          "args": [],
          "line": 7853
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_ept_ad_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "306-309",
          "snippet": "static inline bool cpu_has_vmx_ept_ad_bits(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_AD_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_ept_ad_bits(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_AD_BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_invept_global",
          "args": [],
          "line": 7850
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_invept_global",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "316-319",
          "snippet": "static inline bool cpu_has_vmx_invept_global(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_GLOBAL_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_invept_global(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_GLOBAL_BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_ept_mt_wb",
          "args": [],
          "line": 7849
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_ept_mt_wb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "291-294",
          "snippet": "static inline bool cpu_has_vmx_ept_mt_wb(void)\n{\n\treturn vmx_capability.ept & VMX_EPTP_WB_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_ept_mt_wb(void)\n{\n\treturn vmx_capability.ept & VMX_EPTP_WB_BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_ept_4levels",
          "args": [],
          "line": 7848
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_ept_4levels",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "281-284",
          "snippet": "static inline bool cpu_has_vmx_ept_4levels(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_PAGE_WALK_4_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_ept_4levels(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_PAGE_WALK_4_BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_invvpid_global",
          "args": [],
          "line": 7844
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_invvpid_global",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "336-339",
          "snippet": "static inline bool cpu_has_vmx_invvpid_global(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_invvpid_global(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_invvpid_single",
          "args": [],
          "line": 7844
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_invvpid_single",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "331-334",
          "snippet": "static inline bool cpu_has_vmx_invvpid_single(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_invvpid_single(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_vpid",
          "args": [],
          "line": 7843
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_vpid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "161-165",
          "snippet": "static inline bool cpu_has_vmx_vpid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_VPID;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_vpid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_VPID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_mpx",
          "args": [],
          "line": 7839
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_mpx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "104-108",
          "snippet": "static inline bool cpu_has_vmx_mpx(void)\n{\n\treturn (vmcs_config.vmexit_ctrl & VM_EXIT_CLEAR_BNDCFGS) &&\n\t\t(vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_BNDCFGS);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_mpx(void)\n{\n\treturn (vmcs_config.vmexit_ctrl & VM_EXIT_CLEAR_BNDCFGS) &&\n\t\t(vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_BNDCFGS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "host_bndcfgs",
            "\"KVM: BNDCFGS in host will be lost\""
          ],
          "line": 7836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_BNDCFGS",
            "host_bndcfgs"
          ],
          "line": 7835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_MPX"
          ],
          "line": 7834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_enable_efer_bits",
          "args": [
            "EFER_NX"
          ],
          "line": 7832
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_enable_efer_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1457-1460",
          "snippet": "void kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_NX"
          ],
          "line": 7831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_vmcs_config",
          "args": [
            "&vmcs_config",
            "&vmx_capability"
          ],
          "line": 7828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_define_shared_msr",
          "args": [
            "i",
            "vmx_msr_index[i]"
          ],
          "line": 7826
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_define_shared_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "295-301",
          "snippet": "void kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tBUG_ON(slot >= KVM_NR_SHARED_MSRS);\n\tshared_msrs_global.msrs[slot] = msr;\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_NR_SHARED_MSRS 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_NR_SHARED_MSRS 16\n\nvoid kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n\tBUG_ON(slot >= KVM_NR_SHARED_MSRS);\n\tshared_msrs_global.msrs[slot] = msr;\n\tif (slot >= shared_msrs_global.nr)\n\t\tshared_msrs_global.nr = slot + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vmx_msr_index"
          ],
          "line": 7825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "store_idt",
          "args": [
            "&dt"
          ],
          "line": 7822
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define KVM_VMX_TSC_MULTIPLIER_MAX     0xffffffffffffffffULL\n\nstatic bool __read_mostly nested = 1;\nstatic unsigned int ple_gap = KVM_DEFAULT_PLE_GAP;\nstatic unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nstatic unsigned int ple_window_grow = KVM_DEFAULT_PLE_WINDOW_GROW;\nstatic unsigned int ple_window_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;\nstatic unsigned int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nint __read_mostly pt_mode = PT_MODE_SYSTEM;\nstruct vmcs_config vmcs_config;\nstruct vmx_capability vmx_capability;\nstatic unsigned long host_idt_base;\n\nstatic __init int hardware_setup(void)\n{\n\tunsigned long host_bndcfgs;\n\tstruct desc_ptr dt;\n\tint r, i, ept_lpage_level;\n\n\tstore_idt(&dt);\n\thost_idt_base = dt.address;\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i)\n\t\tkvm_define_shared_msr(i, vmx_msr_index[i]);\n\n\tif (setup_vmcs_config(&vmcs_config, &vmx_capability) < 0)\n\t\treturn -EIO;\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (boot_cpu_has(X86_FEATURE_MPX)) {\n\t\trdmsrl(MSR_IA32_BNDCFGS, host_bndcfgs);\n\t\tWARN_ONCE(host_bndcfgs, \"KVM: BNDCFGS in host will be lost\");\n\t}\n\n\tif (!cpu_has_vmx_mpx())\n\t\tsupported_xcr0 &= ~(XFEATURE_MASK_BNDREGS |\n\t\t\t\t    XFEATURE_MASK_BNDCSR);\n\n\tif (!cpu_has_vmx_vpid() || !cpu_has_vmx_invvpid() ||\n\t    !(cpu_has_vmx_invvpid_single() || cpu_has_vmx_invvpid_global()))\n\t\tenable_vpid = 0;\n\n\tif (!cpu_has_vmx_ept() ||\n\t    !cpu_has_vmx_ept_4levels() ||\n\t    !cpu_has_vmx_ept_mt_wb() ||\n\t    !cpu_has_vmx_invept_global())\n\t\tenable_ept = 0;\n\n\tif (!cpu_has_vmx_ept_ad_bits() || !enable_ept)\n\t\tenable_ept_ad_bits = 0;\n\n\tif (!cpu_has_vmx_unrestricted_guest() || !enable_ept)\n\t\tenable_unrestricted_guest = 0;\n\n\tif (!cpu_has_vmx_flexpriority())\n\t\tflexpriority_enabled = 0;\n\n\tif (!cpu_has_virtual_nmis())\n\t\tenable_vnmi = 0;\n\n\t/*\n\t * set_apic_access_page_addr() is used to reload apic access\n\t * page upon invalidation.  No need to do anything if not\n\t * using the APIC_ACCESS_ADDR VMCS field.\n\t */\n\tif (!flexpriority_enabled)\n\t\tvmx_x86_ops.set_apic_access_page_addr = NULL;\n\n\tif (!cpu_has_vmx_tpr_shadow())\n\t\tvmx_x86_ops.update_cr8_intercept = NULL;\n\n#if IS_ENABLED(CONFIG_HYPERV)\n\tif (ms_hyperv.nested_features & HV_X64_NESTED_GUEST_MAPPING_FLUSH\n\t    && enable_ept) {\n\t\tvmx_x86_ops.tlb_remote_flush = hv_remote_flush_tlb;\n\t\tvmx_x86_ops.tlb_remote_flush_with_range =\n\t\t\t\thv_remote_flush_tlb_with_range;\n\t}\n#endif\n\n\tif (!cpu_has_vmx_ple()) {\n\t\tple_gap = 0;\n\t\tple_window = 0;\n\t\tple_window_grow = 0;\n\t\tple_window_max = 0;\n\t\tple_window_shrink = 0;\n\t}\n\n\tif (!cpu_has_vmx_apicv()) {\n\t\tenable_apicv = 0;\n\t\tvmx_x86_ops.sync_pir_to_irr = NULL;\n\t}\n\n\tif (cpu_has_vmx_tsc_scaling()) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = KVM_VMX_TSC_MULTIPLIER_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 48;\n\t}\n\n\tset_bit(0, vmx_vpid_bitmap); /* 0 is reserved for host */\n\n\tif (enable_ept)\n\t\tvmx_enable_tdp();\n\n\tif (!enable_ept)\n\t\tept_lpage_level = 0;\n\telse if (cpu_has_vmx_ept_1g_page())\n\t\tept_lpage_level = PT_PDPE_LEVEL;\n\telse if (cpu_has_vmx_ept_2m_page())\n\t\tept_lpage_level = PT_DIRECTORY_LEVEL;\n\telse\n\t\tept_lpage_level = PT_PAGE_TABLE_LEVEL;\n\tkvm_configure_mmu(enable_ept, ept_lpage_level);\n\n\t/*\n\t * Only enable PML when hardware supports PML feature, and both EPT\n\t * and EPT A/D bit features are enabled -- PML depends on them to work.\n\t */\n\tif (!enable_ept || !enable_ept_ad_bits || !cpu_has_vmx_pml())\n\t\tenable_pml = 0;\n\n\tif (!enable_pml) {\n\t\tvmx_x86_ops.slot_enable_log_dirty = NULL;\n\t\tvmx_x86_ops.slot_disable_log_dirty = NULL;\n\t\tvmx_x86_ops.flush_log_dirty = NULL;\n\t\tvmx_x86_ops.enable_log_dirty_pt_masked = NULL;\n\t}\n\n\tif (!cpu_has_vmx_preemption_timer())\n\t\tenable_preemption_timer = false;\n\n\tif (enable_preemption_timer) {\n\t\tu64 use_timer_freq = 5000ULL * 1000 * 1000;\n\t\tu64 vmx_msr;\n\n\t\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\t\tcpu_preemption_timer_multi =\n\t\t\tvmx_msr & VMX_MISC_PREEMPTION_TIMER_RATE_MASK;\n\n\t\tif (tsc_khz)\n\t\t\tuse_timer_freq = (u64)tsc_khz * 1000;\n\t\tuse_timer_freq >>= cpu_preemption_timer_multi;\n\n\t\t/*\n\t\t * KVM \"disables\" the preemption timer by setting it to its max\n\t\t * value.  Don't use the timer if it might cause spurious exits\n\t\t * at a rate faster than 0.1 Hz (of uninterrupted guest time).\n\t\t */\n\t\tif (use_timer_freq > 0xffffffffu / 10)\n\t\t\tenable_preemption_timer = false;\n\t}\n\n\tif (!enable_preemption_timer) {\n\t\tvmx_x86_ops.set_hv_timer = NULL;\n\t\tvmx_x86_ops.cancel_hv_timer = NULL;\n\t\tvmx_x86_ops.request_immediate_exit = __kvm_request_immediate_exit;\n\t}\n\n\tkvm_set_posted_intr_wakeup_handler(wakeup_handler);\n\n\tkvm_mce_cap_supported |= MCG_LMCE_P;\n\n\tif (pt_mode != PT_MODE_SYSTEM && pt_mode != PT_MODE_HOST_GUEST)\n\t\treturn -EINVAL;\n\tif (!enable_ept || !cpu_has_vmx_intel_pt())\n\t\tpt_mode = PT_MODE_SYSTEM;\n\n\tif (nested) {\n\t\tnested_vmx_setup_ctls_msrs(&vmcs_config.nested,\n\t\t\t\t\t   vmx_capability.ept);\n\n\t\tr = nested_vmx_hardware_setup(&vmx_x86_ops,\n\t\t\t\t\t      kvm_vmx_exit_handlers);\n\t\tif (r)\n\t\t\treturn r;\n\t}\n\n\tvmx_set_cpu_caps();\n\n\tr = alloc_kvm_area();\n\tif (r)\n\t\tnested_vmx_hardware_unsetup();\n\treturn r;\n}"
  },
  {
    "function_name": "vmx_check_apicv_inhibit_reasons",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7671-7677",
    "snippet": "static bool vmx_check_apicv_inhibit_reasons(ulong bit)\n{\n\tulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_HYPERV);\n\n\treturn supported & BIT(bit);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 7676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "APICV_INHIBIT_REASON_HYPERV"
          ],
          "line": 7674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "APICV_INHIBIT_REASON_DISABLE"
          ],
          "line": 7673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool vmx_check_apicv_inhibit_reasons(ulong bit)\n{\n\tulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_HYPERV);\n\n\treturn supported & BIT(bit);\n}"
  },
  {
    "function_name": "hardware_unsetup",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7663-7669",
    "snippet": "static void hardware_unsetup(void)\n{\n\tif (nested)\n\t\tnested_vmx_hardware_unsetup();\n\n\tfree_kvm_area();\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_kvm_area",
          "args": [],
          "line": 7668
        },
        "resolved": true,
        "details": {
          "function_name": "free_kvm_area",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2618-2626",
          "snippet": "static void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_hardware_unsetup",
          "args": [],
          "line": 7666
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_hardware_unsetup",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "6234-6242",
          "snippet": "void nested_vmx_hardware_unsetup(void)\n{\n\tint i;\n\n\tif (enable_shadow_vmcs) {\n\t\tfor (i = 0; i < VMX_BITMAP_NR; i++)\n\t\t\tfree_page((unsigned long)vmx_bitmap[i]);\n\t}\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned long *vmx_bitmap[VMX_BITMAP_NR];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nstatic unsigned long *vmx_bitmap[VMX_BITMAP_NR];\n\nvoid nested_vmx_hardware_unsetup(void)\n{\n\tint i;\n\n\tif (enable_shadow_vmcs) {\n\t\tfor (i = 0; i < VMX_BITMAP_NR; i++)\n\t\t\tfree_page((unsigned long)vmx_bitmap[i]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\n\nstatic void hardware_unsetup(void)\n{\n\tif (nested)\n\t\tnested_vmx_hardware_unsetup();\n\n\tfree_kvm_area();\n}"
  },
  {
    "function_name": "vmx_apic_init_signal_blocked",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7658-7661",
    "snippet": "static bool vmx_apic_init_signal_blocked(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.vmxon;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 7660
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool vmx_apic_init_signal_blocked(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.vmxon;\n}"
  },
  {
    "function_name": "vmx_need_emulation_on_page_fault",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7653-7656",
    "snippet": "static bool vmx_need_emulation_on_page_fault(struct kvm_vcpu *vcpu)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool vmx_need_emulation_on_page_fault(struct kvm_vcpu *vcpu)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "enable_smi_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7648-7651",
    "snippet": "static int enable_smi_window(struct kvm_vcpu *vcpu)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int enable_smi_window(struct kvm_vcpu *vcpu)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_pre_leave_smm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7628-7646",
    "snippet": "static int vmx_pre_leave_smm(struct kvm_vcpu *vcpu, const char *smstate)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint ret;\n\n\tif (vmx->nested.smm.vmxon) {\n\t\tvmx->nested.vmxon = true;\n\t\tvmx->nested.smm.vmxon = false;\n\t}\n\n\tif (vmx->nested.smm.guest_mode) {\n\t\tret = nested_vmx_enter_non_root_mode(vcpu, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvmx->nested.smm.guest_mode = false;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_vmx_enter_non_root_mode",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 7639
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_enter_non_root_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "3192-3329",
          "snippet": "enum nvmx_vmentry_status nested_vmx_enter_non_root_mode(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\tbool from_vmentry)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tbool evaluate_pending_interrupts;\n\tu32 exit_reason = EXIT_REASON_INVALID_STATE;\n\tu32 exit_qual;\n\n\tevaluate_pending_interrupts = exec_controls_get(vmx) &\n\t\t(CPU_BASED_INTR_WINDOW_EXITING | CPU_BASED_NMI_WINDOW_EXITING);\n\tif (likely(!evaluate_pending_interrupts) && kvm_vcpu_apicv_active(vcpu))\n\t\tevaluate_pending_interrupts |= vmx_has_apicv_interrupt(vcpu);\n\n\tif (!(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS))\n\t\tvmx->nested.vmcs01_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\tif (kvm_mpx_supported() &&\n\t\t!(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS))\n\t\tvmx->nested.vmcs01_guest_bndcfgs = vmcs_read64(GUEST_BNDCFGS);\n\n\t/*\n\t * Overwrite vmcs01.GUEST_CR3 with L1's CR3 if EPT is disabled *and*\n\t * nested early checks are disabled.  In the event of a \"late\" VM-Fail,\n\t * i.e. a VM-Fail detected by hardware but not KVM, KVM must unwind its\n\t * software model to the pre-VMEntry host state.  When EPT is disabled,\n\t * GUEST_CR3 holds KVM's shadow CR3, not L1's \"real\" CR3, which causes\n\t * nested_vmx_restore_host_state() to corrupt vcpu->arch.cr3.  Stuffing\n\t * vmcs01.GUEST_CR3 results in the unwind naturally setting arch.cr3 to\n\t * the correct value.  Smashing vmcs01.GUEST_CR3 is safe because nested\n\t * VM-Exits, and the unwind, reset KVM's MMU, i.e. vmcs01.GUEST_CR3 is\n\t * guaranteed to be overwritten with a shadow CR3 prior to re-entering\n\t * L1.  Don't stuff vmcs01.GUEST_CR3 when using nested early checks as\n\t * KVM modifies vcpu->arch.cr3 if and only if the early hardware checks\n\t * pass, and early VM-Fails do not reset KVM's MMU, i.e. the VM-Fail\n\t * path would need to manually save/restore vmcs01.GUEST_CR3.\n\t */\n\tif (!enable_ept && !nested_early_check)\n\t\tvmcs_writel(GUEST_CR3, vcpu->arch.cr3);\n\n\tvmx_switch_vmcs(vcpu, &vmx->nested.vmcs02);\n\n\tprepare_vmcs02_early(vmx, vmcs12);\n\n\tif (from_vmentry) {\n\t\tif (unlikely(!nested_get_vmcs12_pages(vcpu)))\n\t\t\treturn NVMX_VMENTRY_KVM_INTERNAL_ERROR;\n\n\t\tif (nested_vmx_check_vmentry_hw(vcpu)) {\n\t\t\tvmx_switch_vmcs(vcpu, &vmx->vmcs01);\n\t\t\treturn NVMX_VMENTRY_VMFAIL;\n\t\t}\n\n\t\tif (nested_vmx_check_guest_state(vcpu, vmcs12, &exit_qual))\n\t\t\tgoto vmentry_fail_vmexit;\n\t}\n\n\tenter_guest_mode(vcpu);\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING)\n\t\tvcpu->arch.tsc_offset += vmcs12->tsc_offset;\n\n\tif (prepare_vmcs02(vcpu, vmcs12, &exit_qual))\n\t\tgoto vmentry_fail_vmexit_guest_mode;\n\n\tif (from_vmentry) {\n\t\texit_reason = EXIT_REASON_MSR_LOAD_FAIL;\n\t\texit_qual = nested_vmx_load_msr(vcpu,\n\t\t\t\t\t\tvmcs12->vm_entry_msr_load_addr,\n\t\t\t\t\t\tvmcs12->vm_entry_msr_load_count);\n\t\tif (exit_qual)\n\t\t\tgoto vmentry_fail_vmexit_guest_mode;\n\t} else {\n\t\t/*\n\t\t * The MMU is not initialized to point at the right entities yet and\n\t\t * \"get pages\" would need to read data from the guest (i.e. we will\n\t\t * need to perform gpa to hpa translation). Request a call\n\t\t * to nested_get_vmcs12_pages before the next VM-entry.  The MSRs\n\t\t * have already been set at vmentry time and should not be reset.\n\t\t */\n\t\tkvm_make_request(KVM_REQ_GET_VMCS12_PAGES, vcpu);\n\t}\n\n\t/*\n\t * If L1 had a pending IRQ/NMI until it executed\n\t * VMLAUNCH/VMRESUME which wasn't delivered because it was\n\t * disallowed (e.g. interrupts disabled), L0 needs to\n\t * evaluate if this pending event should cause an exit from L2\n\t * to L1 or delivered directly to L2 (e.g. In case L1 don't\n\t * intercept EXTERNAL_INTERRUPT).\n\t *\n\t * Usually this would be handled by the processor noticing an\n\t * IRQ/NMI window request, or checking RVI during evaluation of\n\t * pending virtual interrupts.  However, this setting was done\n\t * on VMCS01 and now VMCS02 is active instead. Thus, we force L0\n\t * to perform pending event evaluation by requesting a KVM_REQ_EVENT.\n\t */\n\tif (unlikely(evaluate_pending_interrupts))\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t/*\n\t * Do not start the preemption timer hrtimer until after we know\n\t * we are successful, so that only nested_vmx_vmexit needs to cancel\n\t * the timer.\n\t */\n\tvmx->nested.preemption_timer_expired = false;\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\tvmx_start_preemption_timer(vcpu);\n\n\t/*\n\t * Note no nested_vmx_succeed or nested_vmx_fail here. At this point\n\t * we are no longer running L1, and VMLAUNCH/VMRESUME has not yet\n\t * returned as far as L1 is concerned. It will only return (and set\n\t * the success flag) when L2 exits (see nested_vmx_vmexit()).\n\t */\n\treturn NVMX_VMENTRY_SUCCESS;\n\n\t/*\n\t * A failed consistency check that leads to a VMExit during L1's\n\t * VMEnter to L2 is a variation of a normal VMexit, as explained in\n\t * 26.7 \"VM-entry failures during or after loading guest state\".\n\t */\nvmentry_fail_vmexit_guest_mode:\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING)\n\t\tvcpu->arch.tsc_offset -= vmcs12->tsc_offset;\n\tleave_guest_mode(vcpu);\n\nvmentry_fail_vmexit:\n\tvmx_switch_vmcs(vcpu, &vmx->vmcs01);\n\n\tif (!from_vmentry)\n\t\treturn NVMX_VMENTRY_VMEXIT;\n\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\tvmcs12->vm_exit_reason = exit_reason | VMX_EXIT_REASONS_FAILED_VMENTRY;\n\tvmcs12->exit_qualification = exit_qual;\n\tif (enable_shadow_vmcs || vmx->nested.hv_evmcs)\n\t\tvmx->nested.need_vmcs12_to_shadow_sync = true;\n\treturn NVMX_VMENTRY_VMEXIT;\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nstatic void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);\n\nenum nvmx_vmentry_status nested_vmx_enter_non_root_mode(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\tbool from_vmentry)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tbool evaluate_pending_interrupts;\n\tu32 exit_reason = EXIT_REASON_INVALID_STATE;\n\tu32 exit_qual;\n\n\tevaluate_pending_interrupts = exec_controls_get(vmx) &\n\t\t(CPU_BASED_INTR_WINDOW_EXITING | CPU_BASED_NMI_WINDOW_EXITING);\n\tif (likely(!evaluate_pending_interrupts) && kvm_vcpu_apicv_active(vcpu))\n\t\tevaluate_pending_interrupts |= vmx_has_apicv_interrupt(vcpu);\n\n\tif (!(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_DEBUG_CONTROLS))\n\t\tvmx->nested.vmcs01_debugctl = vmcs_read64(GUEST_IA32_DEBUGCTL);\n\tif (kvm_mpx_supported() &&\n\t\t!(vmcs12->vm_entry_controls & VM_ENTRY_LOAD_BNDCFGS))\n\t\tvmx->nested.vmcs01_guest_bndcfgs = vmcs_read64(GUEST_BNDCFGS);\n\n\t/*\n\t * Overwrite vmcs01.GUEST_CR3 with L1's CR3 if EPT is disabled *and*\n\t * nested early checks are disabled.  In the event of a \"late\" VM-Fail,\n\t * i.e. a VM-Fail detected by hardware but not KVM, KVM must unwind its\n\t * software model to the pre-VMEntry host state.  When EPT is disabled,\n\t * GUEST_CR3 holds KVM's shadow CR3, not L1's \"real\" CR3, which causes\n\t * nested_vmx_restore_host_state() to corrupt vcpu->arch.cr3.  Stuffing\n\t * vmcs01.GUEST_CR3 results in the unwind naturally setting arch.cr3 to\n\t * the correct value.  Smashing vmcs01.GUEST_CR3 is safe because nested\n\t * VM-Exits, and the unwind, reset KVM's MMU, i.e. vmcs01.GUEST_CR3 is\n\t * guaranteed to be overwritten with a shadow CR3 prior to re-entering\n\t * L1.  Don't stuff vmcs01.GUEST_CR3 when using nested early checks as\n\t * KVM modifies vcpu->arch.cr3 if and only if the early hardware checks\n\t * pass, and early VM-Fails do not reset KVM's MMU, i.e. the VM-Fail\n\t * path would need to manually save/restore vmcs01.GUEST_CR3.\n\t */\n\tif (!enable_ept && !nested_early_check)\n\t\tvmcs_writel(GUEST_CR3, vcpu->arch.cr3);\n\n\tvmx_switch_vmcs(vcpu, &vmx->nested.vmcs02);\n\n\tprepare_vmcs02_early(vmx, vmcs12);\n\n\tif (from_vmentry) {\n\t\tif (unlikely(!nested_get_vmcs12_pages(vcpu)))\n\t\t\treturn NVMX_VMENTRY_KVM_INTERNAL_ERROR;\n\n\t\tif (nested_vmx_check_vmentry_hw(vcpu)) {\n\t\t\tvmx_switch_vmcs(vcpu, &vmx->vmcs01);\n\t\t\treturn NVMX_VMENTRY_VMFAIL;\n\t\t}\n\n\t\tif (nested_vmx_check_guest_state(vcpu, vmcs12, &exit_qual))\n\t\t\tgoto vmentry_fail_vmexit;\n\t}\n\n\tenter_guest_mode(vcpu);\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING)\n\t\tvcpu->arch.tsc_offset += vmcs12->tsc_offset;\n\n\tif (prepare_vmcs02(vcpu, vmcs12, &exit_qual))\n\t\tgoto vmentry_fail_vmexit_guest_mode;\n\n\tif (from_vmentry) {\n\t\texit_reason = EXIT_REASON_MSR_LOAD_FAIL;\n\t\texit_qual = nested_vmx_load_msr(vcpu,\n\t\t\t\t\t\tvmcs12->vm_entry_msr_load_addr,\n\t\t\t\t\t\tvmcs12->vm_entry_msr_load_count);\n\t\tif (exit_qual)\n\t\t\tgoto vmentry_fail_vmexit_guest_mode;\n\t} else {\n\t\t/*\n\t\t * The MMU is not initialized to point at the right entities yet and\n\t\t * \"get pages\" would need to read data from the guest (i.e. we will\n\t\t * need to perform gpa to hpa translation). Request a call\n\t\t * to nested_get_vmcs12_pages before the next VM-entry.  The MSRs\n\t\t * have already been set at vmentry time and should not be reset.\n\t\t */\n\t\tkvm_make_request(KVM_REQ_GET_VMCS12_PAGES, vcpu);\n\t}\n\n\t/*\n\t * If L1 had a pending IRQ/NMI until it executed\n\t * VMLAUNCH/VMRESUME which wasn't delivered because it was\n\t * disallowed (e.g. interrupts disabled), L0 needs to\n\t * evaluate if this pending event should cause an exit from L2\n\t * to L1 or delivered directly to L2 (e.g. In case L1 don't\n\t * intercept EXTERNAL_INTERRUPT).\n\t *\n\t * Usually this would be handled by the processor noticing an\n\t * IRQ/NMI window request, or checking RVI during evaluation of\n\t * pending virtual interrupts.  However, this setting was done\n\t * on VMCS01 and now VMCS02 is active instead. Thus, we force L0\n\t * to perform pending event evaluation by requesting a KVM_REQ_EVENT.\n\t */\n\tif (unlikely(evaluate_pending_interrupts))\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t/*\n\t * Do not start the preemption timer hrtimer until after we know\n\t * we are successful, so that only nested_vmx_vmexit needs to cancel\n\t * the timer.\n\t */\n\tvmx->nested.preemption_timer_expired = false;\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\tvmx_start_preemption_timer(vcpu);\n\n\t/*\n\t * Note no nested_vmx_succeed or nested_vmx_fail here. At this point\n\t * we are no longer running L1, and VMLAUNCH/VMRESUME has not yet\n\t * returned as far as L1 is concerned. It will only return (and set\n\t * the success flag) when L2 exits (see nested_vmx_vmexit()).\n\t */\n\treturn NVMX_VMENTRY_SUCCESS;\n\n\t/*\n\t * A failed consistency check that leads to a VMExit during L1's\n\t * VMEnter to L2 is a variation of a normal VMexit, as explained in\n\t * 26.7 \"VM-entry failures during or after loading guest state\".\n\t */\nvmentry_fail_vmexit_guest_mode:\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING)\n\t\tvcpu->arch.tsc_offset -= vmcs12->tsc_offset;\n\tleave_guest_mode(vcpu);\n\nvmentry_fail_vmexit:\n\tvmx_switch_vmcs(vcpu, &vmx->vmcs01);\n\n\tif (!from_vmentry)\n\t\treturn NVMX_VMENTRY_VMEXIT;\n\n\tload_vmcs12_host_state(vcpu, vmcs12);\n\tvmcs12->vm_exit_reason = exit_reason | VMX_EXIT_REASONS_FAILED_VMENTRY;\n\tvmcs12->exit_qualification = exit_qual;\n\tif (enable_shadow_vmcs || vmx->nested.hv_evmcs)\n\t\tvmx->nested.need_vmcs12_to_shadow_sync = true;\n\treturn NVMX_VMENTRY_VMEXIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 7630
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_pre_leave_smm(struct kvm_vcpu *vcpu, const char *smstate)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint ret;\n\n\tif (vmx->nested.smm.vmxon) {\n\t\tvmx->nested.vmxon = true;\n\t\tvmx->nested.smm.vmxon = false;\n\t}\n\n\tif (vmx->nested.smm.guest_mode) {\n\t\tret = nested_vmx_enter_non_root_mode(vcpu, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tvmx->nested.smm.guest_mode = false;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_pre_enter_smm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7614-7626",
    "snippet": "static int vmx_pre_enter_smm(struct kvm_vcpu *vcpu, char *smstate)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx->nested.smm.guest_mode = is_guest_mode(vcpu);\n\tif (vmx->nested.smm.guest_mode)\n\t\tnested_vmx_vmexit(vcpu, -1, 0, 0);\n\n\tvmx->nested.smm.vmxon = vmx->nested.vmxon;\n\tvmx->nested.vmxon = false;\n\tvmx_clear_hlt(vcpu);\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_clear_hlt",
          "args": [
            "vcpu"
          ],
          "line": 7624
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_clear_hlt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1610-1621",
          "snippet": "static void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_vmexit",
          "args": [
            "vcpu",
            "-1",
            "0",
            "0"
          ],
          "line": 7620
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_vmexit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "4274-4398",
          "snippet": "void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t       u32 exit_intr_info, unsigned long exit_qualification)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\t/* trying to cancel vmlaunch/vmresume is a bug */\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\tleave_guest_mode(vcpu);\n\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\thrtimer_cancel(&to_vmx(vcpu)->nested.preemption_timer);\n\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING)\n\t\tvcpu->arch.tsc_offset -= vmcs12->tsc_offset;\n\n\tif (likely(!vmx->fail)) {\n\t\tsync_vmcs02_to_vmcs12(vcpu, vmcs12);\n\n\t\tif (exit_reason != -1)\n\t\t\tprepare_vmcs12(vcpu, vmcs12, exit_reason, exit_intr_info,\n\t\t\t\t       exit_qualification);\n\n\t\t/*\n\t\t * Must happen outside of sync_vmcs02_to_vmcs12() as it will\n\t\t * also be used to capture vmcs12 cache as part of\n\t\t * capturing nVMX state for snapshot (migration).\n\t\t *\n\t\t * Otherwise, this flush will dirty guest memory at a\n\t\t * point it is already assumed by user-space to be\n\t\t * immutable.\n\t\t */\n\t\tnested_flush_cached_shadow_vmcs12(vcpu, vmcs12);\n\t} else {\n\t\t/*\n\t\t * The only expected VM-instruction error is \"VM entry with\n\t\t * invalid control field(s).\" Anything else indicates a\n\t\t * problem with L0.  And we should never get here with a\n\t\t * VMFail of any type if early consistency checks are enabled.\n\t\t */\n\t\tWARN_ON_ONCE(vmcs_read32(VM_INSTRUCTION_ERROR) !=\n\t\t\t     VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tWARN_ON_ONCE(nested_early_check);\n\t}\n\n\tvmx_switch_vmcs(vcpu, &vmx->vmcs01);\n\n\t/* Update any VMCS fields that might have changed while L2 ran */\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.host.nr);\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.guest.nr);\n\tvmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);\n\tif (vmx->nested.l1_tpr_threshold != -1)\n\t\tvmcs_write32(TPR_THRESHOLD, vmx->nested.l1_tpr_threshold);\n\n\tif (kvm_has_tsc_control)\n\t\tdecache_tsc_multiplier(vmx);\n\n\tif (vmx->nested.change_vmcs01_virtual_apic_mode) {\n\t\tvmx->nested.change_vmcs01_virtual_apic_mode = false;\n\t\tvmx_set_virtual_apic_mode(vcpu);\n\t}\n\n\t/* Unpin physical memory we referred to in vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tkvm_release_page_clean(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tkvm_vcpu_unmap(vcpu, &vmx->nested.virtual_apic_map, true);\n\tkvm_vcpu_unmap(vcpu, &vmx->nested.pi_desc_map, true);\n\tvmx->nested.pi_desc = NULL;\n\n\t/*\n\t * We are now running in L2, mmu_notifier will force to reload the\n\t * page's hpa for L2 vmcs. Need to reload it for L1 before entering L1.\n\t */\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\tif ((exit_reason != -1) && (enable_shadow_vmcs || vmx->nested.hv_evmcs))\n\t\tvmx->nested.need_vmcs12_to_shadow_sync = true;\n\n\t/* in case we halted in L2 */\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tif (likely(!vmx->fail)) {\n\t\tif (exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT &&\n\t\t    nested_exit_intr_ack_set(vcpu)) {\n\t\t\tint irq = kvm_cpu_get_interrupt(vcpu);\n\t\t\tWARN_ON(irq < 0);\n\t\t\tvmcs12->vm_exit_intr_info = irq |\n\t\t\t\tINTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR;\n\t\t}\n\n\t\tif (exit_reason != -1)\n\t\t\ttrace_kvm_nested_vmexit_inject(vmcs12->vm_exit_reason,\n\t\t\t\t\t\t       vmcs12->exit_qualification,\n\t\t\t\t\t\t       vmcs12->idt_vectoring_info_field,\n\t\t\t\t\t\t       vmcs12->vm_exit_intr_info,\n\t\t\t\t\t\t       vmcs12->vm_exit_intr_error_code,\n\t\t\t\t\t\t       KVM_ISA_VMX);\n\n\t\tload_vmcs12_host_state(vcpu, vmcs12);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * After an early L2 VM-entry failure, we're now back\n\t * in L1 which thinks it just finished a VMLAUNCH or\n\t * VMRESUME instruction, so we need to set the failure\n\t * flag and the VM-instruction error field of the VMCS\n\t * accordingly, and skip the emulated instruction.\n\t */\n\t(void)nested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\n\t/*\n\t * Restore L1's host state to KVM's software model.  We're here\n\t * because a consistency check was caught by hardware, which\n\t * means some amount of guest state has been propagated to KVM's\n\t * model and needs to be unwound to the host's state.\n\t */\n\tnested_vmx_restore_host_state(vcpu);\n\n\tvmx->fail = 0;\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nstatic void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);\n\nvoid nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t       u32 exit_intr_info, unsigned long exit_qualification)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\t/* trying to cancel vmlaunch/vmresume is a bug */\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\tleave_guest_mode(vcpu);\n\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\thrtimer_cancel(&to_vmx(vcpu)->nested.preemption_timer);\n\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING)\n\t\tvcpu->arch.tsc_offset -= vmcs12->tsc_offset;\n\n\tif (likely(!vmx->fail)) {\n\t\tsync_vmcs02_to_vmcs12(vcpu, vmcs12);\n\n\t\tif (exit_reason != -1)\n\t\t\tprepare_vmcs12(vcpu, vmcs12, exit_reason, exit_intr_info,\n\t\t\t\t       exit_qualification);\n\n\t\t/*\n\t\t * Must happen outside of sync_vmcs02_to_vmcs12() as it will\n\t\t * also be used to capture vmcs12 cache as part of\n\t\t * capturing nVMX state for snapshot (migration).\n\t\t *\n\t\t * Otherwise, this flush will dirty guest memory at a\n\t\t * point it is already assumed by user-space to be\n\t\t * immutable.\n\t\t */\n\t\tnested_flush_cached_shadow_vmcs12(vcpu, vmcs12);\n\t} else {\n\t\t/*\n\t\t * The only expected VM-instruction error is \"VM entry with\n\t\t * invalid control field(s).\" Anything else indicates a\n\t\t * problem with L0.  And we should never get here with a\n\t\t * VMFail of any type if early consistency checks are enabled.\n\t\t */\n\t\tWARN_ON_ONCE(vmcs_read32(VM_INSTRUCTION_ERROR) !=\n\t\t\t     VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tWARN_ON_ONCE(nested_early_check);\n\t}\n\n\tvmx_switch_vmcs(vcpu, &vmx->vmcs01);\n\n\t/* Update any VMCS fields that might have changed while L2 ran */\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.host.nr);\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.guest.nr);\n\tvmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);\n\tif (vmx->nested.l1_tpr_threshold != -1)\n\t\tvmcs_write32(TPR_THRESHOLD, vmx->nested.l1_tpr_threshold);\n\n\tif (kvm_has_tsc_control)\n\t\tdecache_tsc_multiplier(vmx);\n\n\tif (vmx->nested.change_vmcs01_virtual_apic_mode) {\n\t\tvmx->nested.change_vmcs01_virtual_apic_mode = false;\n\t\tvmx_set_virtual_apic_mode(vcpu);\n\t}\n\n\t/* Unpin physical memory we referred to in vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tkvm_release_page_clean(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tkvm_vcpu_unmap(vcpu, &vmx->nested.virtual_apic_map, true);\n\tkvm_vcpu_unmap(vcpu, &vmx->nested.pi_desc_map, true);\n\tvmx->nested.pi_desc = NULL;\n\n\t/*\n\t * We are now running in L2, mmu_notifier will force to reload the\n\t * page's hpa for L2 vmcs. Need to reload it for L1 before entering L1.\n\t */\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\tif ((exit_reason != -1) && (enable_shadow_vmcs || vmx->nested.hv_evmcs))\n\t\tvmx->nested.need_vmcs12_to_shadow_sync = true;\n\n\t/* in case we halted in L2 */\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tif (likely(!vmx->fail)) {\n\t\tif (exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT &&\n\t\t    nested_exit_intr_ack_set(vcpu)) {\n\t\t\tint irq = kvm_cpu_get_interrupt(vcpu);\n\t\t\tWARN_ON(irq < 0);\n\t\t\tvmcs12->vm_exit_intr_info = irq |\n\t\t\t\tINTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR;\n\t\t}\n\n\t\tif (exit_reason != -1)\n\t\t\ttrace_kvm_nested_vmexit_inject(vmcs12->vm_exit_reason,\n\t\t\t\t\t\t       vmcs12->exit_qualification,\n\t\t\t\t\t\t       vmcs12->idt_vectoring_info_field,\n\t\t\t\t\t\t       vmcs12->vm_exit_intr_info,\n\t\t\t\t\t\t       vmcs12->vm_exit_intr_error_code,\n\t\t\t\t\t\t       KVM_ISA_VMX);\n\n\t\tload_vmcs12_host_state(vcpu, vmcs12);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * After an early L2 VM-entry failure, we're now back\n\t * in L1 which thinks it just finished a VMLAUNCH or\n\t * VMRESUME instruction, so we need to set the failure\n\t * flag and the VM-instruction error field of the VMCS\n\t * accordingly, and skip the emulated instruction.\n\t */\n\t(void)nested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\n\t/*\n\t * Restore L1's host state to KVM's software model.  We're here\n\t * because a consistency check was caught by hardware, which\n\t * means some amount of guest state has been propagated to KVM's\n\t * model and needs to be unwound to the host's state.\n\t */\n\tnested_vmx_restore_host_state(vcpu);\n\n\tvmx->fail = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 7618
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 7616
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_pre_enter_smm(struct kvm_vcpu *vcpu, char *smstate)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx->nested.smm.guest_mode = is_guest_mode(vcpu);\n\tif (vmx->nested.smm.guest_mode)\n\t\tnested_vmx_vmexit(vcpu, -1, 0, 0);\n\n\tvmx->nested.smm.vmxon = vmx->nested.vmxon;\n\tvmx->nested.vmxon = false;\n\tvmx_clear_hlt(vcpu);\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_smi_allowed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7606-7612",
    "snippet": "static int vmx_smi_allowed(struct kvm_vcpu *vcpu)\n{\n\t/* we need a nested vmexit to enter SMM, postpone if run is pending */\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn 0;\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 7609
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_smi_allowed(struct kvm_vcpu *vcpu)\n{\n\t/* we need a nested vmexit to enter SMM, postpone if run is pending */\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn 0;\n\treturn 1;\n}"
  },
  {
    "function_name": "vmx_setup_mce",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7596-7604",
    "snippet": "static void vmx_setup_mce(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mcg_cap & MCG_LMCE_P)\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEAT_CTL_LMCE_ENABLED;\n\telse\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=\n\t\t\t~FEAT_CTL_LMCE_ENABLED;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 7602
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_setup_mce(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mcg_cap & MCG_LMCE_P)\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEAT_CTL_LMCE_ENABLED;\n\telse\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=\n\t\t\t~FEAT_CTL_LMCE_ENABLED;\n}"
  },
  {
    "function_name": "vmx_update_pi_irte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7511-7594",
    "snippet": "static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,\n\t\t\t      uint32_t guest_irq, bool set)\n{\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_lapic_irq irq;\n\tstruct kvm_vcpu *vcpu;\n\tstruct vcpu_data vcpu_info;\n\tint idx, ret = 0;\n\n\tif (!kvm_arch_has_assigned_device(kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP) ||\n\t\t!kvm_vcpu_apicv_active(kvm->vcpus[0]))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tif (guest_irq >= irq_rt->nr_rt_entries ||\n\t    hlist_empty(&irq_rt->map[guest_irq])) {\n\t\tpr_warn_once(\"no route for guest_irq %u/%u (broken user space?)\\n\",\n\t\t\t     guest_irq, irq_rt->nr_rt_entries);\n\t\tgoto out;\n\t}\n\n\thlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {\n\t\tif (e->type != KVM_IRQ_ROUTING_MSI)\n\t\t\tcontinue;\n\t\t/*\n\t\t * VT-d PI cannot support posting multicast/broadcast\n\t\t * interrupts to a vCPU, we still use interrupt remapping\n\t\t * for these kind of interrupts.\n\t\t *\n\t\t * For lowest-priority interrupts, we only support\n\t\t * those with single CPU as the destination, e.g. user\n\t\t * configures the interrupts via /proc/irq or uses\n\t\t * irqbalance to make the interrupts single-CPU.\n\t\t *\n\t\t * We will support full lowest-priority interrupt later.\n\t\t *\n\t\t * In addition, we can only inject generic interrupts using\n\t\t * the PI mechanism, refuse to route others through it.\n\t\t */\n\n\t\tkvm_set_msi_irq(kvm, e, &irq);\n\t\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu) ||\n\t\t    !kvm_irq_is_postable(&irq)) {\n\t\t\t/*\n\t\t\t * Make sure the IRTE is in remapped mode if\n\t\t\t * we don't handle it in posted mode.\n\t\t\t */\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t   \"failed to back to remapped mode, irq: %u\\n\",\n\t\t\t\t   host_irq);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));\n\t\tvcpu_info.vector = irq.vector;\n\n\t\ttrace_kvm_pi_irte_update(host_irq, vcpu->vcpu_id, e->gsi,\n\t\t\t\tvcpu_info.vector, vcpu_info.pi_desc_addr, set);\n\n\t\tif (set)\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &vcpu_info);\n\t\telse\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_INFO \"%s: failed to update PI IRTE\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->irq_srcu",
            "idx"
          ],
          "line": 7592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"%s: failed to update PI IRTE\\n\"",
            "__func__"
          ],
          "line": 7584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_vcpu_affinity",
          "args": [
            "host_irq",
            "NULL"
          ],
          "line": 7581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_vcpu_affinity",
          "args": [
            "host_irq",
            "&vcpu_info"
          ],
          "line": 7579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_pi_irte_update",
          "args": [
            "host_irq",
            "vcpu->vcpu_id",
            "e->gsi",
            "vcpu_info.vector",
            "vcpu_info.pi_desc_addr",
            "set"
          ],
          "line": 7575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vcpu_to_pi_desc(vcpu)"
          ],
          "line": 7572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_pi_desc",
          "args": [
            "vcpu"
          ],
          "line": 7572
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_pi_desc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "484-487",
          "snippet": "static inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO\n\t\t\t\t   \"failed to back to remapped mode, irq: %u\\n\"",
            "host_irq"
          ],
          "line": 7563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_vcpu_affinity",
          "args": [
            "host_irq",
            "NULL"
          ],
          "line": 7561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_irq_is_postable",
          "args": [
            "&irq"
          ],
          "line": 7556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_intr_is_single_vcpu",
          "args": [
            "kvm",
            "&irq",
            "&vcpu"
          ],
          "line": 7555
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_intr_is_single_vcpu_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "997-1023",
          "snippet": "bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tbool ret = false;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (kvm_apic_map_get_dest_lapic(kvm, NULL, irq, map, &dst, &bitmap) &&\n\t\t\thweight16(bitmap) == 1) {\n\t\tunsigned long i = find_first_bit(&bitmap, 16);\n\n\t\tif (dst[i]) {\n\t\t\t*dest_vcpu = dst[i]->vcpu;\n\t\t\tret = true;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tbool ret = false;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (kvm_apic_map_get_dest_lapic(kvm, NULL, irq, map, &dst, &bitmap) &&\n\t\t\thweight16(bitmap) == 1) {\n\t\tunsigned long i = find_first_bit(&bitmap, 16);\n\n\t\tif (dst[i]) {\n\t\t\t*dest_vcpu = dst[i]->vcpu;\n\t\t\tret = true;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_msi_irq",
          "args": [
            "kvm",
            "e",
            "&irq"
          ],
          "line": 7554
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msi_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "104-125",
          "snippet": "void kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "e",
            "&irq_rt->map[guest_irq]",
            "link"
          ],
          "line": 7535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "\"no route for guest_irq %u/%u (broken user space?)\\n\"",
            "guest_irq",
            "irq_rt->nr_rt_entries"
          ],
          "line": 7530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "&irq_rt->map[guest_irq]"
          ],
          "line": 7529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference",
          "args": [
            "kvm->irq_routing",
            "&kvm->irq_srcu"
          ],
          "line": 7527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->irq_srcu"
          ],
          "line": 7526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "kvm->vcpus[0]"
          ],
          "line": 7523
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_remapping_cap",
          "args": [
            "IRQ_POSTING_CAP"
          ],
          "line": 7522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_has_assigned_device",
          "args": [
            "kvm"
          ],
          "line": 7521
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_has_assigned_device",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10460-10463",
          "snippet": "bool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq,\n\t\t\t      uint32_t guest_irq, bool set)\n{\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_lapic_irq irq;\n\tstruct kvm_vcpu *vcpu;\n\tstruct vcpu_data vcpu_info;\n\tint idx, ret = 0;\n\n\tif (!kvm_arch_has_assigned_device(kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP) ||\n\t\t!kvm_vcpu_apicv_active(kvm->vcpus[0]))\n\t\treturn 0;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tif (guest_irq >= irq_rt->nr_rt_entries ||\n\t    hlist_empty(&irq_rt->map[guest_irq])) {\n\t\tpr_warn_once(\"no route for guest_irq %u/%u (broken user space?)\\n\",\n\t\t\t     guest_irq, irq_rt->nr_rt_entries);\n\t\tgoto out;\n\t}\n\n\thlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {\n\t\tif (e->type != KVM_IRQ_ROUTING_MSI)\n\t\t\tcontinue;\n\t\t/*\n\t\t * VT-d PI cannot support posting multicast/broadcast\n\t\t * interrupts to a vCPU, we still use interrupt remapping\n\t\t * for these kind of interrupts.\n\t\t *\n\t\t * For lowest-priority interrupts, we only support\n\t\t * those with single CPU as the destination, e.g. user\n\t\t * configures the interrupts via /proc/irq or uses\n\t\t * irqbalance to make the interrupts single-CPU.\n\t\t *\n\t\t * We will support full lowest-priority interrupt later.\n\t\t *\n\t\t * In addition, we can only inject generic interrupts using\n\t\t * the PI mechanism, refuse to route others through it.\n\t\t */\n\n\t\tkvm_set_msi_irq(kvm, e, &irq);\n\t\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu) ||\n\t\t    !kvm_irq_is_postable(&irq)) {\n\t\t\t/*\n\t\t\t * Make sure the IRTE is in remapped mode if\n\t\t\t * we don't handle it in posted mode.\n\t\t\t */\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t   \"failed to back to remapped mode, irq: %u\\n\",\n\t\t\t\t   host_irq);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tvcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu));\n\t\tvcpu_info.vector = irq.vector;\n\n\t\ttrace_kvm_pi_irte_update(host_irq, vcpu->vcpu_id, e->gsi,\n\t\t\t\tvcpu_info.vector, vcpu_info.pi_desc_addr, set);\n\n\t\tif (set)\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &vcpu_info);\n\t\telse\n\t\t\tret = irq_set_vcpu_affinity(host_irq, NULL);\n\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_INFO \"%s: failed to update PI IRTE\\n\",\n\t\t\t\t\t__func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}"
  },
  {
    "function_name": "vmx_post_block",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7494-7500",
    "snippet": "static void vmx_post_block(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_x86_ops.set_hv_timer)\n\t\tkvm_lapic_switch_to_hv_timer(vcpu);\n\n\tpi_post_block(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pi_post_block",
          "args": [
            "vcpu"
          ],
          "line": 7499
        },
        "resolved": true,
        "details": {
          "function_name": "pi_post_block",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "7483-7492",
          "snippet": "static void pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->pre_pcpu == -1)\n\t\treturn;\n\n\tWARN_ON(irqs_disabled());\n\tlocal_irq_disable();\n\t__pi_post_block(vcpu);\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->pre_pcpu == -1)\n\t\treturn;\n\n\tWARN_ON(irqs_disabled());\n\tlocal_irq_disable();\n\t__pi_post_block(vcpu);\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_switch_to_hv_timer",
          "args": [
            "vcpu"
          ],
          "line": 7497
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_switch_to_hv_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1852-1855",
          "snippet": "void kvm_lapic_switch_to_hv_timer(struct kvm_vcpu *vcpu)\n{\n\trestart_apic_timer(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_switch_to_hv_timer(struct kvm_vcpu *vcpu)\n{\n\trestart_apic_timer(vcpu->arch.apic);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_post_block(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_x86_ops.set_hv_timer)\n\t\tkvm_lapic_switch_to_hv_timer(vcpu);\n\n\tpi_post_block(vcpu);\n}"
  },
  {
    "function_name": "pi_post_block",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7483-7492",
    "snippet": "static void pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->pre_pcpu == -1)\n\t\treturn;\n\n\tWARN_ON(irqs_disabled());\n\tlocal_irq_disable();\n\t__pi_post_block(vcpu);\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 7491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pi_post_block",
          "args": [
            "vcpu"
          ],
          "line": 7490
        },
        "resolved": true,
        "details": {
          "function_name": "__pi_post_block",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "7371-7400",
          "snippet": "static void __pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\t\tWARN(old.nv != POSTED_INTR_WAKEUP_VECTOR,\n\t\t     \"Wakeup handler not enabled while the VCPU is blocked\\n\");\n\n\t\tdest = cpu_physical_id(vcpu->cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'notification vector' */\n\t\tnew.nv = POSTED_INTR_VECTOR;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\n\tif (!WARN_ON_ONCE(vcpu->pre_pcpu == -1)) {\n\t\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tlist_del(&vcpu->blocked_vcpu_list);\n\t\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tvcpu->pre_pcpu = -1;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);\n\nstatic void __pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\t\tWARN(old.nv != POSTED_INTR_WAKEUP_VECTOR,\n\t\t     \"Wakeup handler not enabled while the VCPU is blocked\\n\");\n\n\t\tdest = cpu_physical_id(vcpu->cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'notification vector' */\n\t\tnew.nv = POSTED_INTR_VECTOR;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\n\tif (!WARN_ON_ONCE(vcpu->pre_pcpu == -1)) {\n\t\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tlist_del(&vcpu->blocked_vcpu_list);\n\t\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tvcpu->pre_pcpu = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 7489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irqs_disabled()"
          ],
          "line": 7488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 7488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->pre_pcpu == -1)\n\t\treturn;\n\n\tWARN_ON(irqs_disabled());\n\tlocal_irq_disable();\n\t__pi_post_block(vcpu);\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "vmx_pre_block",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7472-7481",
    "snippet": "static int vmx_pre_block(struct kvm_vcpu *vcpu)\n{\n\tif (pi_pre_block(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_hv_timer_in_use(vcpu))\n\t\tkvm_lapic_switch_to_sw_timer(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_switch_to_sw_timer",
          "args": [
            "vcpu"
          ],
          "line": 7478
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_switch_to_sw_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1858-1867",
          "snippet": "void kvm_lapic_switch_to_sw_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tpreempt_disable();\n\t/* Possibly the TSC deadline timer is not enabled yet */\n\tif (apic->lapic_timer.hv_timer_in_use)\n\t\tstart_sw_timer(apic);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_switch_to_sw_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tpreempt_disable();\n\t/* Possibly the TSC deadline timer is not enabled yet */\n\tif (apic->lapic_timer.hv_timer_in_use)\n\t\tstart_sw_timer(apic);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_hv_timer_in_use",
          "args": [
            "vcpu"
          ],
          "line": 7477
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_hv_timer_in_use",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1742-1748",
          "snippet": "bool kvm_lapic_hv_timer_in_use(struct kvm_vcpu *vcpu)\n{\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn false;\n\n\treturn vcpu->arch.apic->lapic_timer.hv_timer_in_use;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_lapic_hv_timer_in_use(struct kvm_vcpu *vcpu)\n{\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn false;\n\n\treturn vcpu->arch.apic->lapic_timer.hv_timer_in_use;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pi_pre_block",
          "args": [
            "vcpu"
          ],
          "line": 7474
        },
        "resolved": true,
        "details": {
          "function_name": "pi_pre_block",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "7415-7470",
          "snippet": "static int pi_pre_block(struct kvm_vcpu *vcpu)\n{\n\tunsigned int dest;\n\tstruct pi_desc old, new;\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn 0;\n\n\tWARN_ON(irqs_disabled());\n\tlocal_irq_disable();\n\tif (!WARN_ON_ONCE(vcpu->pre_pcpu != -1)) {\n\t\tvcpu->pre_pcpu = vcpu->cpu;\n\t\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tlist_add_tail(&vcpu->blocked_vcpu_list,\n\t\t\t      &per_cpu(blocked_vcpu_on_cpu,\n\t\t\t\t       vcpu->pre_pcpu));\n\t\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t}\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\tWARN((pi_desc->sn == 1),\n\t\t     \"Warning: SN field of posted-interrupts \"\n\t\t     \"is set before blocking\\n\");\n\n\t\t/*\n\t\t * Since vCPU can be preempted during this process,\n\t\t * vcpu->cpu could be different with pre_pcpu, we\n\t\t * need to set pre_pcpu as the destination of wakeup\n\t\t * notification event, then we can find the right vCPU\n\t\t * to wakeup in wakeup handler if interrupts happen\n\t\t * when the vCPU is in blocked state.\n\t\t */\n\t\tdest = cpu_physical_id(vcpu->pre_pcpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'wakeup vector' */\n\t\tnew.nv = POSTED_INTR_WAKEUP_VECTOR;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\n\t/* We should not block the vCPU if an interrupt is posted for it.  */\n\tif (pi_test_on(pi_desc) == 1)\n\t\t__pi_post_block(vcpu);\n\n\tlocal_irq_enable();\n\treturn (vcpu->pre_pcpu == -1);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);",
            "static DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);\nstatic DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);\n\nstatic int pi_pre_block(struct kvm_vcpu *vcpu)\n{\n\tunsigned int dest;\n\tstruct pi_desc old, new;\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn 0;\n\n\tWARN_ON(irqs_disabled());\n\tlocal_irq_disable();\n\tif (!WARN_ON_ONCE(vcpu->pre_pcpu != -1)) {\n\t\tvcpu->pre_pcpu = vcpu->cpu;\n\t\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tlist_add_tail(&vcpu->blocked_vcpu_list,\n\t\t\t      &per_cpu(blocked_vcpu_on_cpu,\n\t\t\t\t       vcpu->pre_pcpu));\n\t\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t}\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\tWARN((pi_desc->sn == 1),\n\t\t     \"Warning: SN field of posted-interrupts \"\n\t\t     \"is set before blocking\\n\");\n\n\t\t/*\n\t\t * Since vCPU can be preempted during this process,\n\t\t * vcpu->cpu could be different with pre_pcpu, we\n\t\t * need to set pre_pcpu as the destination of wakeup\n\t\t * notification event, then we can find the right vCPU\n\t\t * to wakeup in wakeup handler if interrupts happen\n\t\t * when the vCPU is in blocked state.\n\t\t */\n\t\tdest = cpu_physical_id(vcpu->pre_pcpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'wakeup vector' */\n\t\tnew.nv = POSTED_INTR_WAKEUP_VECTOR;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\n\t/* We should not block the vCPU if an interrupt is posted for it.  */\n\tif (pi_test_on(pi_desc) == 1)\n\t\t__pi_post_block(vcpu);\n\n\tlocal_irq_enable();\n\treturn (vcpu->pre_pcpu == -1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_pre_block(struct kvm_vcpu *vcpu)\n{\n\tif (pi_pre_block(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_hv_timer_in_use(vcpu))\n\t\tkvm_lapic_switch_to_sw_timer(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pi_pre_block",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7415-7470",
    "snippet": "static int pi_pre_block(struct kvm_vcpu *vcpu)\n{\n\tunsigned int dest;\n\tstruct pi_desc old, new;\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn 0;\n\n\tWARN_ON(irqs_disabled());\n\tlocal_irq_disable();\n\tif (!WARN_ON_ONCE(vcpu->pre_pcpu != -1)) {\n\t\tvcpu->pre_pcpu = vcpu->cpu;\n\t\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tlist_add_tail(&vcpu->blocked_vcpu_list,\n\t\t\t      &per_cpu(blocked_vcpu_on_cpu,\n\t\t\t\t       vcpu->pre_pcpu));\n\t\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t}\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\tWARN((pi_desc->sn == 1),\n\t\t     \"Warning: SN field of posted-interrupts \"\n\t\t     \"is set before blocking\\n\");\n\n\t\t/*\n\t\t * Since vCPU can be preempted during this process,\n\t\t * vcpu->cpu could be different with pre_pcpu, we\n\t\t * need to set pre_pcpu as the destination of wakeup\n\t\t * notification event, then we can find the right vCPU\n\t\t * to wakeup in wakeup handler if interrupts happen\n\t\t * when the vCPU is in blocked state.\n\t\t */\n\t\tdest = cpu_physical_id(vcpu->pre_pcpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'wakeup vector' */\n\t\tnew.nv = POSTED_INTR_WAKEUP_VECTOR;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\n\t/* We should not block the vCPU if an interrupt is posted for it.  */\n\tif (pi_test_on(pi_desc) == 1)\n\t\t__pi_post_block(vcpu);\n\n\tlocal_irq_enable();\n\treturn (vcpu->pre_pcpu == -1);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);",
      "static DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 7468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pi_post_block",
          "args": [
            "vcpu"
          ],
          "line": 7466
        },
        "resolved": true,
        "details": {
          "function_name": "__pi_post_block",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "7371-7400",
          "snippet": "static void __pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\t\tWARN(old.nv != POSTED_INTR_WAKEUP_VECTOR,\n\t\t     \"Wakeup handler not enabled while the VCPU is blocked\\n\");\n\n\t\tdest = cpu_physical_id(vcpu->cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'notification vector' */\n\t\tnew.nv = POSTED_INTR_VECTOR;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\n\tif (!WARN_ON_ONCE(vcpu->pre_pcpu == -1)) {\n\t\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tlist_del(&vcpu->blocked_vcpu_list);\n\t\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tvcpu->pre_pcpu = -1;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);\n\nstatic void __pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\t\tWARN(old.nv != POSTED_INTR_WAKEUP_VECTOR,\n\t\t     \"Wakeup handler not enabled while the VCPU is blocked\\n\");\n\n\t\tdest = cpu_physical_id(vcpu->cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'notification vector' */\n\t\tnew.nv = POSTED_INTR_VECTOR;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\n\tif (!WARN_ON_ONCE(vcpu->pre_pcpu == -1)) {\n\t\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tlist_del(&vcpu->blocked_vcpu_list);\n\t\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tvcpu->pre_pcpu = -1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pi_test_on",
          "args": [
            "pi_desc"
          ],
          "line": 7465
        },
        "resolved": true,
        "details": {
          "function_name": "pi_test_on",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "401-405",
          "snippet": "static inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_ON  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_ON  0\n\nstatic inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg64",
          "args": [
            "&pi_desc->control",
            "old.control",
            "new.control"
          ],
          "line": 7461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x2apic_enabled",
          "args": [],
          "line": 7454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_physical_id",
          "args": [
            "vcpu->pre_pcpu"
          ],
          "line": 7452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "(pi_desc->sn == 1)",
            "\"Warning: SN field of posted-interrupts \"\n\t\t     \"is set before blocking\\n\""
          ],
          "line": 7440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu)"
          ],
          "line": 7434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "blocked_vcpu_on_cpu_lock",
            "vcpu->pre_pcpu"
          ],
          "line": 7434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&vcpu->blocked_vcpu_list",
            "&per_cpu(blocked_vcpu_on_cpu,\n\t\t\t\t       vcpu->pre_pcpu)"
          ],
          "line": 7431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "blocked_vcpu_on_cpu",
            "vcpu->pre_pcpu"
          ],
          "line": 7432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu)"
          ],
          "line": 7430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "blocked_vcpu_on_cpu_lock",
            "vcpu->pre_pcpu"
          ],
          "line": 7430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "vcpu->pre_pcpu != -1"
          ],
          "line": 7428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 7427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "irqs_disabled()"
          ],
          "line": 7426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqs_disabled",
          "args": [],
          "line": 7426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 7423
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_remapping_cap",
          "args": [
            "IRQ_POSTING_CAP"
          ],
          "line": 7422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_has_assigned_device",
          "args": [
            "vcpu->kvm"
          ],
          "line": 7421
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_has_assigned_device",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10460-10463",
          "snippet": "bool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pi_desc",
          "args": [
            "vcpu"
          ],
          "line": 7419
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_pi_desc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "484-487",
          "snippet": "static inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);\nstatic DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);\n\nstatic int pi_pre_block(struct kvm_vcpu *vcpu)\n{\n\tunsigned int dest;\n\tstruct pi_desc old, new;\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn 0;\n\n\tWARN_ON(irqs_disabled());\n\tlocal_irq_disable();\n\tif (!WARN_ON_ONCE(vcpu->pre_pcpu != -1)) {\n\t\tvcpu->pre_pcpu = vcpu->cpu;\n\t\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tlist_add_tail(&vcpu->blocked_vcpu_list,\n\t\t\t      &per_cpu(blocked_vcpu_on_cpu,\n\t\t\t\t       vcpu->pre_pcpu));\n\t\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t}\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\tWARN((pi_desc->sn == 1),\n\t\t     \"Warning: SN field of posted-interrupts \"\n\t\t     \"is set before blocking\\n\");\n\n\t\t/*\n\t\t * Since vCPU can be preempted during this process,\n\t\t * vcpu->cpu could be different with pre_pcpu, we\n\t\t * need to set pre_pcpu as the destination of wakeup\n\t\t * notification event, then we can find the right vCPU\n\t\t * to wakeup in wakeup handler if interrupts happen\n\t\t * when the vCPU is in blocked state.\n\t\t */\n\t\tdest = cpu_physical_id(vcpu->pre_pcpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'wakeup vector' */\n\t\tnew.nv = POSTED_INTR_WAKEUP_VECTOR;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\n\t/* We should not block the vCPU if an interrupt is posted for it.  */\n\tif (pi_test_on(pi_desc) == 1)\n\t\t__pi_post_block(vcpu);\n\n\tlocal_irq_enable();\n\treturn (vcpu->pre_pcpu == -1);\n}"
  },
  {
    "function_name": "__pi_post_block",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7371-7400",
    "snippet": "static void __pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\t\tWARN(old.nv != POSTED_INTR_WAKEUP_VECTOR,\n\t\t     \"Wakeup handler not enabled while the VCPU is blocked\\n\");\n\n\t\tdest = cpu_physical_id(vcpu->cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'notification vector' */\n\t\tnew.nv = POSTED_INTR_VECTOR;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\n\tif (!WARN_ON_ONCE(vcpu->pre_pcpu == -1)) {\n\t\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tlist_del(&vcpu->blocked_vcpu_list);\n\t\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tvcpu->pre_pcpu = -1;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu)"
          ],
          "line": 7397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "blocked_vcpu_on_cpu_lock",
            "vcpu->pre_pcpu"
          ],
          "line": 7397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&vcpu->blocked_vcpu_list"
          ],
          "line": 7396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu)"
          ],
          "line": 7395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "blocked_vcpu_on_cpu_lock",
            "vcpu->pre_pcpu"
          ],
          "line": 7395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "vcpu->pre_pcpu == -1"
          ],
          "line": 7394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg64",
          "args": [
            "&pi_desc->control",
            "old.control",
            "new.control"
          ],
          "line": 7391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x2apic_enabled",
          "args": [],
          "line": 7384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_physical_id",
          "args": [
            "vcpu->cpu"
          ],
          "line": 7382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "old.nv != POSTED_INTR_WAKEUP_VECTOR",
            "\"Wakeup handler not enabled while the VCPU is blocked\\n\""
          ],
          "line": 7379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_pi_desc",
          "args": [
            "vcpu"
          ],
          "line": 7373
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_pi_desc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "484-487",
          "snippet": "static inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);\n\nstatic void __pi_post_block(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\t\tWARN(old.nv != POSTED_INTR_WAKEUP_VECTOR,\n\t\t     \"Wakeup handler not enabled while the VCPU is blocked\\n\");\n\n\t\tdest = cpu_physical_id(vcpu->cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\t/* set 'NV' to 'notification vector' */\n\t\tnew.nv = POSTED_INTR_VECTOR;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\n\tif (!WARN_ON_ONCE(vcpu->pre_pcpu == -1)) {\n\t\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tlist_del(&vcpu->blocked_vcpu_list);\n\t\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, vcpu->pre_pcpu));\n\t\tvcpu->pre_pcpu = -1;\n\t}\n}"
  },
  {
    "function_name": "vmx_enable_log_dirty_pt_masked",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7364-7369",
    "snippet": "static void vmx_enable_log_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\t\t   struct kvm_memory_slot *memslot,\n\t\t\t\t\t   gfn_t offset, unsigned long mask)\n{\n\tkvm_mmu_clear_dirty_pt_masked(kvm, memslot, offset, mask);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_clear_dirty_pt_masked",
          "args": [
            "kvm",
            "memslot",
            "offset",
            "mask"
          ],
          "line": 7368
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_clear_dirty_pt_masked",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1703-1717",
          "snippet": "void kvm_mmu_clear_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_clear_dirty(kvm, rmap_head);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_clear_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_clear_dirty(kvm, rmap_head);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_enable_log_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\t\t   struct kvm_memory_slot *memslot,\n\t\t\t\t\t   gfn_t offset, unsigned long mask)\n{\n\tkvm_mmu_clear_dirty_pt_masked(kvm, memslot, offset, mask);\n}"
  },
  {
    "function_name": "vmx_write_pml_buffer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7328-7362",
    "snippet": "static int vmx_write_pml_buffer(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tgpa_t gpa, dst;\n\n\tif (is_guest_mode(vcpu)) {\n\t\tWARN_ON_ONCE(vmx->nested.pml_full);\n\n\t\t/*\n\t\t * Check if PML is enabled for the nested guest.\n\t\t * Whether eptp bit 6 is set is already checked\n\t\t * as part of A/D emulation.\n\t\t */\n\t\tvmcs12 = get_vmcs12(vcpu);\n\t\tif (!nested_cpu_has_pml(vmcs12))\n\t\t\treturn 0;\n\n\t\tif (vmcs12->guest_pml_index >= PML_ENTITY_NUM) {\n\t\t\tvmx->nested.pml_full = true;\n\t\t\treturn 1;\n\t\t}\n\n\t\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS) & ~0xFFFull;\n\t\tdst = vmcs12->pml_address + sizeof(u64) * vmcs12->guest_pml_index;\n\n\t\tif (kvm_write_guest_page(vcpu->kvm, gpa_to_gfn(dst), &gpa,\n\t\t\t\t\t offset_in_page(dst), sizeof(gpa)))\n\t\t\treturn 0;\n\n\t\tvmcs12->guest_pml_index--;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_write_guest_page",
          "args": [
            "vcpu->kvm",
            "gpa_to_gfn(dst)",
            "&gpa",
            "offset_in_page(dst)",
            "sizeof(gpa)"
          ],
          "line": 7354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "dst"
          ],
          "line": 7355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "dst"
          ],
          "line": 7354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_read64",
          "args": [
            "GUEST_PHYSICAL_ADDRESS"
          ],
          "line": 7351
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "120-130",
          "snippet": "static __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_cpu_has_pml",
          "args": [
            "vmcs12"
          ],
          "line": 7343
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has_pml",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "196-199",
          "snippet": "static inline bool nested_cpu_has_pml(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_PML);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_pml(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_PML);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 7342
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "vmx->nested.pml_full"
          ],
          "line": 7335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 7334
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 7331
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_write_pml_buffer(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tgpa_t gpa, dst;\n\n\tif (is_guest_mode(vcpu)) {\n\t\tWARN_ON_ONCE(vmx->nested.pml_full);\n\n\t\t/*\n\t\t * Check if PML is enabled for the nested guest.\n\t\t * Whether eptp bit 6 is set is already checked\n\t\t * as part of A/D emulation.\n\t\t */\n\t\tvmcs12 = get_vmcs12(vcpu);\n\t\tif (!nested_cpu_has_pml(vmcs12))\n\t\t\treturn 0;\n\n\t\tif (vmcs12->guest_pml_index >= PML_ENTITY_NUM) {\n\t\t\tvmx->nested.pml_full = true;\n\t\t\treturn 1;\n\t\t}\n\n\t\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS) & ~0xFFFull;\n\t\tdst = vmcs12->pml_address + sizeof(u64) * vmcs12->guest_pml_index;\n\n\t\tif (kvm_write_guest_page(vcpu->kvm, gpa_to_gfn(dst), &gpa,\n\t\t\t\t\t offset_in_page(dst), sizeof(gpa)))\n\t\t\treturn 0;\n\n\t\tvmcs12->guest_pml_index--;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_flush_log_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7323-7326",
    "snippet": "static void vmx_flush_log_dirty(struct kvm *kvm)\n{\n\tkvm_flush_pml_buffers(kvm);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_pml_buffers",
          "args": [
            "kvm"
          ],
          "line": 7325
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_flush_pml_buffers",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5631-5643",
          "snippet": "static void kvm_flush_pml_buffers(struct kvm *kvm)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\t/*\n\t * We only need to kick vcpu out of guest mode here, as PML buffer\n\t * is flushed at beginning of all VMEXITs, and it's obvious that only\n\t * vcpus running in guest are possible to have unflushed GPAs in PML\n\t * buffer.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_vcpu_kick(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void kvm_flush_pml_buffers(struct kvm *kvm)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\t/*\n\t * We only need to kick vcpu out of guest mode here, as PML buffer\n\t * is flushed at beginning of all VMEXITs, and it's obvious that only\n\t * vcpus running in guest are possible to have unflushed GPAs in PML\n\t * buffer.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_vcpu_kick(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_flush_log_dirty(struct kvm *kvm)\n{\n\tkvm_flush_pml_buffers(kvm);\n}"
  },
  {
    "function_name": "vmx_slot_disable_log_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7317-7321",
    "snippet": "static void vmx_slot_disable_log_dirty(struct kvm *kvm,\n\t\t\t\t       struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_slot_set_dirty(kvm, slot);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_slot_set_dirty",
          "args": [
            "kvm",
            "slot"
          ],
          "line": 7320
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_slot_set_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "6001-6012",
          "snippet": "void kvm_mmu_slot_set_dirty(struct kvm *kvm,\n\t\t\t    struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_all_level(kvm, memslot, __rmap_set_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_slot_set_dirty(struct kvm *kvm,\n\t\t\t    struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_all_level(kvm, memslot, __rmap_set_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_slot_disable_log_dirty(struct kvm *kvm,\n\t\t\t\t       struct kvm_memory_slot *slot)\n{\n\tkvm_mmu_slot_set_dirty(kvm, slot);\n}"
  },
  {
    "function_name": "vmx_slot_enable_log_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7309-7315",
    "snippet": "static void vmx_slot_enable_log_dirty(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot)\n{\n\tif (!kvm_dirty_log_manual_protect_and_init_set(kvm))\n\t\tkvm_mmu_slot_leaf_clear_dirty(kvm, slot);\n\tkvm_mmu_slot_largepage_remove_write_access(kvm, slot);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_slot_largepage_remove_write_access",
          "args": [
            "kvm",
            "slot"
          ],
          "line": 7314
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_slot_largepage_remove_write_access",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5986-5998",
          "snippet": "void kvm_mmu_slot_largepage_remove_write_access(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_large_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\t\tfalse);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_slot_largepage_remove_write_access(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_large_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\t\tfalse);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_slot_leaf_clear_dirty",
          "args": [
            "kvm",
            "slot"
          ],
          "line": 7313
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_slot_leaf_clear_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5966-5983",
          "snippet": "void kvm_mmu_slot_leaf_clear_dirty(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_leaf(kvm, memslot, __rmap_clear_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/*\n\t * It's also safe to flush TLBs out of mmu lock here as currently this\n\t * function is only used for dirty logging, in which case flushing TLB\n\t * out of mmu lock also guarantees no dirty pages will be lost in\n\t * dirty_bitmap.\n\t */\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_slot_leaf_clear_dirty(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_leaf(kvm, memslot, __rmap_clear_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/*\n\t * It's also safe to flush TLBs out of mmu lock here as currently this\n\t * function is only used for dirty logging, in which case flushing TLB\n\t * out of mmu lock also guarantees no dirty pages will be lost in\n\t * dirty_bitmap.\n\t */\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_dirty_log_manual_protect_and_init_set",
          "args": [
            "kvm"
          ],
          "line": 7312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_slot_enable_log_dirty(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot)\n{\n\tif (!kvm_dirty_log_manual_protect_and_init_set(kvm))\n\t\tkvm_mmu_slot_leaf_clear_dirty(kvm, slot);\n\tkvm_mmu_slot_largepage_remove_write_access(kvm, slot);\n}"
  },
  {
    "function_name": "vmx_sched_in",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7303-7307",
    "snippet": "static void vmx_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (!kvm_pause_in_guest(vcpu->kvm))\n\t\tshrink_ple_window(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shrink_ple_window",
          "args": [
            "vcpu"
          ],
          "line": 7306
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_ple_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5270-5284",
          "snippet": "static void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old, ple_window,\n\t\t\t\t\t      ple_window_shrink,\n\t\t\t\t\t      ple_window);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;",
            "static unsigned int ple_window_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nstatic unsigned int ple_window_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old, ple_window,\n\t\t\t\t\t      ple_window_shrink,\n\t\t\t\t\t      ple_window);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pause_in_guest",
          "args": [
            "vcpu->kvm"
          ],
          "line": 7305
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pause_in_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "321-324",
          "snippet": "static inline bool kvm_pause_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.pause_in_guest;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_pause_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.pause_in_guest;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (!kvm_pause_in_guest(vcpu->kvm))\n\t\tshrink_ple_window(vcpu);\n}"
  },
  {
    "function_name": "vmx_cancel_hv_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7297-7300",
    "snippet": "static void vmx_cancel_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tto_vmx(vcpu)->hv_deadline_tsc = -1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 7299
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_cancel_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tto_vmx(vcpu)->hv_deadline_tsc = -1;\n}"
  },
  {
    "function_name": "vmx_set_hv_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7253-7295",
    "snippet": "static int vmx_set_hv_timer(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc,\n\t\t\t    bool *expired)\n{\n\tstruct vcpu_vmx *vmx;\n\tu64 tscl, guest_tscl, delta_tsc, lapic_timer_advance_cycles;\n\tstruct kvm_timer *ktimer = &vcpu->arch.apic->lapic_timer;\n\n\tif (kvm_mwait_in_guest(vcpu->kvm) ||\n\t\tkvm_can_post_timer_interrupt(vcpu))\n\t\treturn -EOPNOTSUPP;\n\n\tvmx = to_vmx(vcpu);\n\ttscl = rdtsc();\n\tguest_tscl = kvm_read_l1_tsc(vcpu, tscl);\n\tdelta_tsc = max(guest_deadline_tsc, guest_tscl) - guest_tscl;\n\tlapic_timer_advance_cycles = nsec_to_cycles(vcpu,\n\t\t\t\t\t\t    ktimer->timer_advance_ns);\n\n\tif (delta_tsc > lapic_timer_advance_cycles)\n\t\tdelta_tsc -= lapic_timer_advance_cycles;\n\telse\n\t\tdelta_tsc = 0;\n\n\t/* Convert to host delta tsc if tsc scaling is enabled */\n\tif (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio &&\n\t    delta_tsc && u64_shl_div_u64(delta_tsc,\n\t\t\t\tkvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tvcpu->arch.tsc_scaling_ratio, &delta_tsc))\n\t\treturn -ERANGE;\n\n\t/*\n\t * If the delta tsc can't fit in the 32 bit after the multi shift,\n\t * we can't use the preemption timer.\n\t * It's possible that it fits on later vmentries, but checking\n\t * on every vmentry is costly so we just use an hrtimer.\n\t */\n\tif (delta_tsc >> (cpu_preemption_timer_multi + 32))\n\t\treturn -ERANGE;\n\n\tvmx->hv_deadline_tsc = tscl + delta_tsc;\n\t*expired = !delta_tsc;\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "u64_shl_div_u64",
          "args": [
            "delta_tsc",
            "kvm_tsc_scaling_ratio_frac_bits",
            "vcpu->arch.tsc_scaling_ratio",
            "&delta_tsc"
          ],
          "line": 7278
        },
        "resolved": true,
        "details": {
          "function_name": "u64_shl_div_u64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "7236-7251",
          "snippet": "static inline int u64_shl_div_u64(u64 a, unsigned int shift,\n\t\t\t\t  u64 divisor, u64 *result)\n{\n\tu64 low = a << shift, high = a >> (64 - shift);\n\n\t/* To avoid the overflow on divq */\n\tif (high >= divisor)\n\t\treturn 1;\n\n\t/* Low hold the result, high hold rem which is discarded */\n\tasm(\"divq %2\\n\\t\" : \"=a\" (low), \"=d\" (high) :\n\t    \"rm\" (divisor), \"0\" (low), \"1\" (high));\n\t*result = low;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline int u64_shl_div_u64(u64 a, unsigned int shift,\n\t\t\t\t  u64 divisor, u64 *result)\n{\n\tu64 low = a << shift, high = a >> (64 - shift);\n\n\t/* To avoid the overflow on divq */\n\tif (high >= divisor)\n\t\treturn 1;\n\n\t/* Low hold the result, high hold rem which is discarded */\n\tasm(\"divq %2\\n\\t\" : \"=a\" (low), \"=d\" (high) :\n\t    \"rm\" (divisor), \"0\" (low), \"1\" (high));\n\t*result = low;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsec_to_cycles",
          "args": [
            "vcpu",
            "ktimer->timer_advance_ns"
          ],
          "line": 7268
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_to_cycles",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "291-295",
          "snippet": "static inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline u64 nsec_to_cycles(struct kvm_vcpu *vcpu, u64 nsec)\n{\n\treturn pvclock_scale_delta(nsec, vcpu->arch.virtual_tsc_mult,\n\t\t\t\t   vcpu->arch.virtual_tsc_shift);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "guest_deadline_tsc",
            "guest_tscl"
          ],
          "line": 7267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_l1_tsc",
          "args": [
            "vcpu",
            "tscl"
          ],
          "line": 7266
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_l1_tsc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1951-1956",
          "snippet": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 7265
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_rdtscp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "149-153",
          "snippet": "static inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 7264
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_can_post_timer_interrupt",
          "args": [
            "vcpu"
          ],
          "line": 7261
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_can_post_timer_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "116-119",
          "snippet": "bool kvm_can_post_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn pi_inject_timer && kvm_vcpu_apicv_active(vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_can_post_timer_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn pi_inject_timer && kvm_vcpu_apicv_active(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mwait_in_guest",
          "args": [
            "vcpu->kvm"
          ],
          "line": 7260
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mwait_in_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "311-314",
          "snippet": "static inline bool kvm_mwait_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.mwait_in_guest;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_mwait_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.mwait_in_guest;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_set_hv_timer(struct kvm_vcpu *vcpu, u64 guest_deadline_tsc,\n\t\t\t    bool *expired)\n{\n\tstruct vcpu_vmx *vmx;\n\tu64 tscl, guest_tscl, delta_tsc, lapic_timer_advance_cycles;\n\tstruct kvm_timer *ktimer = &vcpu->arch.apic->lapic_timer;\n\n\tif (kvm_mwait_in_guest(vcpu->kvm) ||\n\t\tkvm_can_post_timer_interrupt(vcpu))\n\t\treturn -EOPNOTSUPP;\n\n\tvmx = to_vmx(vcpu);\n\ttscl = rdtsc();\n\tguest_tscl = kvm_read_l1_tsc(vcpu, tscl);\n\tdelta_tsc = max(guest_deadline_tsc, guest_tscl) - guest_tscl;\n\tlapic_timer_advance_cycles = nsec_to_cycles(vcpu,\n\t\t\t\t\t\t    ktimer->timer_advance_ns);\n\n\tif (delta_tsc > lapic_timer_advance_cycles)\n\t\tdelta_tsc -= lapic_timer_advance_cycles;\n\telse\n\t\tdelta_tsc = 0;\n\n\t/* Convert to host delta tsc if tsc scaling is enabled */\n\tif (vcpu->arch.tsc_scaling_ratio != kvm_default_tsc_scaling_ratio &&\n\t    delta_tsc && u64_shl_div_u64(delta_tsc,\n\t\t\t\tkvm_tsc_scaling_ratio_frac_bits,\n\t\t\t\tvcpu->arch.tsc_scaling_ratio, &delta_tsc))\n\t\treturn -ERANGE;\n\n\t/*\n\t * If the delta tsc can't fit in the 32 bit after the multi shift,\n\t * we can't use the preemption timer.\n\t * It's possible that it fits on later vmentries, but checking\n\t * on every vmentry is costly so we just use an hrtimer.\n\t */\n\tif (delta_tsc >> (cpu_preemption_timer_multi + 32))\n\t\treturn -ERANGE;\n\n\tvmx->hv_deadline_tsc = tscl + delta_tsc;\n\t*expired = !delta_tsc;\n\treturn 0;\n}"
  },
  {
    "function_name": "u64_shl_div_u64",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7236-7251",
    "snippet": "static inline int u64_shl_div_u64(u64 a, unsigned int shift,\n\t\t\t\t  u64 divisor, u64 *result)\n{\n\tu64 low = a << shift, high = a >> (64 - shift);\n\n\t/* To avoid the overflow on divq */\n\tif (high >= divisor)\n\t\treturn 1;\n\n\t/* Low hold the result, high hold rem which is discarded */\n\tasm(\"divq %2\\n\\t\" : \"=a\" (low), \"=d\" (high) :\n\t    \"rm\" (divisor), \"0\" (low), \"1\" (high));\n\t*result = low;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline int u64_shl_div_u64(u64 a, unsigned int shift,\n\t\t\t\t  u64 divisor, u64 *result)\n{\n\tu64 low = a << shift, high = a >> (64 - shift);\n\n\t/* To avoid the overflow on divq */\n\tif (high >= divisor)\n\t\treturn 1;\n\n\t/* Low hold the result, high hold rem which is discarded */\n\tasm(\"divq %2\\n\\t\" : \"=a\" (low), \"=d\" (high) :\n\t    \"rm\" (divisor), \"0\" (low), \"1\" (high));\n\t*result = low;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_check_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7186-7232",
    "snippet": "static int vmx_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tswitch (info->intercept) {\n\t/*\n\t * RDPID causes #UD if disabled through secondary execution controls.\n\t * Because it is marked as EmulateOnUD, we need to intercept it here.\n\t */\n\tcase x86_intercept_rdtscp:\n\t\tif (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDTSCP)) {\n\t\t\texception->vector = UD_VECTOR;\n\t\t\texception->error_code_valid = false;\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\t}\n\t\tbreak;\n\n\tcase x86_intercept_in:\n\tcase x86_intercept_ins:\n\tcase x86_intercept_out:\n\tcase x86_intercept_outs:\n\t\treturn vmx_check_intercept_io(vcpu, info);\n\n\tcase x86_intercept_lgdt:\n\tcase x86_intercept_lidt:\n\tcase x86_intercept_lldt:\n\tcase x86_intercept_ltr:\n\tcase x86_intercept_sgdt:\n\tcase x86_intercept_sidt:\n\tcase x86_intercept_sldt:\n\tcase x86_intercept_str:\n\t\tif (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC))\n\t\t\treturn X86EMUL_CONTINUE;\n\n\t\t/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */\n\t\tbreak;\n\n\t/* TODO: check more intercepts... */\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn X86EMUL_UNHANDLEABLE;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "vmcs12",
            "SECONDARY_EXEC_DESC"
          ],
          "line": 7220
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_check_intercept_io",
          "args": [
            "vcpu",
            "info"
          ],
          "line": 7210
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_check_intercept_io",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "7152-7184",
          "snippet": "static int vmx_check_intercept_io(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct x86_instruction_info *info)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tunsigned short port;\n\tbool intercept;\n\tint size;\n\n\tif (info->intercept == x86_intercept_in ||\n\t    info->intercept == x86_intercept_ins) {\n\t\tport = info->src_val;\n\t\tsize = info->dst_bytes;\n\t} else {\n\t\tport = info->dst_val;\n\t\tsize = info->src_bytes;\n\t}\n\n\t/*\n\t * If the 'use IO bitmaps' VM-execution control is 0, IO instruction\n\t * VM-exits depend on the 'unconditional IO exiting' VM-execution\n\t * control.\n\t *\n\t * Otherwise, IO instruction VM-exits are controlled by the IO bitmaps.\n\t */\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\tintercept = nested_cpu_has(vmcs12,\n\t\t\t\t\t   CPU_BASED_UNCOND_IO_EXITING);\n\telse\n\t\tintercept = nested_vmx_check_io_bitmaps(vcpu, port, size);\n\n\t/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */\n\treturn intercept ? X86EMUL_UNHANDLEABLE : X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_check_intercept_io(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct x86_instruction_info *info)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tunsigned short port;\n\tbool intercept;\n\tint size;\n\n\tif (info->intercept == x86_intercept_in ||\n\t    info->intercept == x86_intercept_ins) {\n\t\tport = info->src_val;\n\t\tsize = info->dst_bytes;\n\t} else {\n\t\tport = info->dst_val;\n\t\tsize = info->src_bytes;\n\t}\n\n\t/*\n\t * If the 'use IO bitmaps' VM-execution control is 0, IO instruction\n\t * VM-exits depend on the 'unconditional IO exiting' VM-execution\n\t * control.\n\t *\n\t * Otherwise, IO instruction VM-exits are controlled by the IO bitmaps.\n\t */\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\tintercept = nested_cpu_has(vmcs12,\n\t\t\t\t\t   CPU_BASED_UNCOND_IO_EXITING);\n\telse\n\t\tintercept = nested_vmx_check_io_bitmaps(vcpu, port, size);\n\n\t/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */\n\treturn intercept ? X86EMUL_UNHANDLEABLE : X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 7191
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tswitch (info->intercept) {\n\t/*\n\t * RDPID causes #UD if disabled through secondary execution controls.\n\t * Because it is marked as EmulateOnUD, we need to intercept it here.\n\t */\n\tcase x86_intercept_rdtscp:\n\t\tif (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDTSCP)) {\n\t\t\texception->vector = UD_VECTOR;\n\t\t\texception->error_code_valid = false;\n\t\t\treturn X86EMUL_PROPAGATE_FAULT;\n\t\t}\n\t\tbreak;\n\n\tcase x86_intercept_in:\n\tcase x86_intercept_ins:\n\tcase x86_intercept_out:\n\tcase x86_intercept_outs:\n\t\treturn vmx_check_intercept_io(vcpu, info);\n\n\tcase x86_intercept_lgdt:\n\tcase x86_intercept_lidt:\n\tcase x86_intercept_lldt:\n\tcase x86_intercept_ltr:\n\tcase x86_intercept_sgdt:\n\tcase x86_intercept_sidt:\n\tcase x86_intercept_sldt:\n\tcase x86_intercept_str:\n\t\tif (!nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC))\n\t\t\treturn X86EMUL_CONTINUE;\n\n\t\t/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */\n\t\tbreak;\n\n\t/* TODO: check more intercepts... */\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn X86EMUL_UNHANDLEABLE;\n}"
  },
  {
    "function_name": "vmx_check_intercept_io",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7152-7184",
    "snippet": "static int vmx_check_intercept_io(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct x86_instruction_info *info)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tunsigned short port;\n\tbool intercept;\n\tint size;\n\n\tif (info->intercept == x86_intercept_in ||\n\t    info->intercept == x86_intercept_ins) {\n\t\tport = info->src_val;\n\t\tsize = info->dst_bytes;\n\t} else {\n\t\tport = info->dst_val;\n\t\tsize = info->src_bytes;\n\t}\n\n\t/*\n\t * If the 'use IO bitmaps' VM-execution control is 0, IO instruction\n\t * VM-exits depend on the 'unconditional IO exiting' VM-execution\n\t * control.\n\t *\n\t * Otherwise, IO instruction VM-exits are controlled by the IO bitmaps.\n\t */\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\tintercept = nested_cpu_has(vmcs12,\n\t\t\t\t\t   CPU_BASED_UNCOND_IO_EXITING);\n\telse\n\t\tintercept = nested_vmx_check_io_bitmaps(vcpu, port, size);\n\n\t/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */\n\treturn intercept ? X86EMUL_UNHANDLEABLE : X86EMUL_CONTINUE;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_vmx_check_io_bitmaps",
          "args": [
            "vcpu",
            "port",
            "size"
          ],
          "line": 7180
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_check_io_bitmaps",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "5338-5369",
          "snippet": "bool nested_vmx_check_io_bitmaps(struct kvm_vcpu *vcpu, unsigned int port,\n\t\t\t\t int size)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tgpa_t bitmap, last_bitmap;\n\tu8 b;\n\n\tlast_bitmap = (gpa_t)-1;\n\tb = -1;\n\n\twhile (size > 0) {\n\t\tif (port < 0x8000)\n\t\t\tbitmap = vmcs12->io_bitmap_a;\n\t\telse if (port < 0x10000)\n\t\t\tbitmap = vmcs12->io_bitmap_b;\n\t\telse\n\t\t\treturn true;\n\t\tbitmap += (port & 0x7fff) / 8;\n\n\t\tif (last_bitmap != bitmap)\n\t\t\tif (kvm_vcpu_read_guest(vcpu, bitmap, &b, 1))\n\t\t\t\treturn true;\n\t\tif (b & (1 << (port & 7)))\n\t\t\treturn true;\n\n\t\tport++;\n\t\tsize--;\n\t\tlast_bitmap = bitmap;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nstatic void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);\n\nbool nested_vmx_check_io_bitmaps(struct kvm_vcpu *vcpu, unsigned int port,\n\t\t\t\t int size)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tgpa_t bitmap, last_bitmap;\n\tu8 b;\n\n\tlast_bitmap = (gpa_t)-1;\n\tb = -1;\n\n\twhile (size > 0) {\n\t\tif (port < 0x8000)\n\t\t\tbitmap = vmcs12->io_bitmap_a;\n\t\telse if (port < 0x10000)\n\t\t\tbitmap = vmcs12->io_bitmap_b;\n\t\telse\n\t\t\treturn true;\n\t\tbitmap += (port & 0x7fff) / 8;\n\n\t\tif (last_bitmap != bitmap)\n\t\t\tif (kvm_vcpu_read_guest(vcpu, bitmap, &b, 1))\n\t\t\t\treturn true;\n\t\tif (b & (1 << (port & 7)))\n\t\t\treturn true;\n\n\t\tport++;\n\t\tsize--;\n\t\tlast_bitmap = bitmap;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_cpu_has",
          "args": [
            "vmcs12",
            "CPU_BASED_UNCOND_IO_EXITING"
          ],
          "line": 7177
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 7155
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_check_intercept_io(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct x86_instruction_info *info)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tunsigned short port;\n\tbool intercept;\n\tint size;\n\n\tif (info->intercept == x86_intercept_in ||\n\t    info->intercept == x86_intercept_ins) {\n\t\tport = info->src_val;\n\t\tsize = info->dst_bytes;\n\t} else {\n\t\tport = info->dst_val;\n\t\tsize = info->src_bytes;\n\t}\n\n\t/*\n\t * If the 'use IO bitmaps' VM-execution control is 0, IO instruction\n\t * VM-exits depend on the 'unconditional IO exiting' VM-execution\n\t * control.\n\t *\n\t * Otherwise, IO instruction VM-exits are controlled by the IO bitmaps.\n\t */\n\tif (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS))\n\t\tintercept = nested_cpu_has(vmcs12,\n\t\t\t\t\t   CPU_BASED_UNCOND_IO_EXITING);\n\telse\n\t\tintercept = nested_vmx_check_io_bitmaps(vcpu, port, size);\n\n\t/* FIXME: produce nested vmexit and return X86EMUL_INTERCEPTED.  */\n\treturn intercept ? X86EMUL_UNHANDLEABLE : X86EMUL_CONTINUE;\n}"
  },
  {
    "function_name": "vmx_request_immediate_exit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7147-7150",
    "snippet": "static void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)\n{\n\tto_vmx(vcpu)->req_immediate_exit = true;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 7149
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_request_immediate_exit(struct kvm_vcpu *vcpu)\n{\n\tto_vmx(vcpu)->req_immediate_exit = true;\n}"
  },
  {
    "function_name": "vmx_set_cpu_caps",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7114-7145",
    "snippet": "static __init void vmx_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\t/* CPUID 0x1 */\n\tif (nested)\n\t\tkvm_cpu_cap_set(X86_FEATURE_VMX);\n\n\t/* CPUID 0x7 */\n\tif (kvm_mpx_supported())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_MPX);\n\tif (cpu_has_vmx_invpcid())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_INVPCID);\n\tif (vmx_pt_mode_is_host_guest())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_INTEL_PT);\n\n\t/* PKU is not yet implemented for shadow paging. */\n\tif (enable_ept && boot_cpu_has(X86_FEATURE_OSPKE))\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_PKU);\n\n\tif (vmx_umip_emulated())\n\t\tkvm_cpu_cap_set(X86_FEATURE_UMIP);\n\n\t/* CPUID 0xD.1 */\n\tsupported_xss = 0;\n\tif (!vmx_xsaves_supported())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_XSAVES);\n\n\t/* CPUID 0x80000001 */\n\tif (!cpu_has_vmx_rdtscp())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_RDTSCP);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_cpu_cap_clear",
          "args": [
            "X86_FEATURE_RDTSCP"
          ],
          "line": 7144
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_cap_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "271-277",
          "snippet": "static __always_inline void kvm_cpu_cap_clear(unsigned int x86_feature)\n{\n\tunsigned int x86_leaf = x86_feature / 32;\n\n\treverse_cpuid_check(x86_leaf);\n\tkvm_cpu_caps[x86_leaf] &= ~__feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline void kvm_cpu_cap_clear(unsigned int x86_feature)\n{\n\tunsigned int x86_leaf = x86_feature / 32;\n\n\treverse_cpuid_check(x86_leaf);\n\tkvm_cpu_caps[x86_leaf] &= ~__feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_rdtscp",
          "args": [],
          "line": 7143
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_rdtscp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "149-153",
          "snippet": "static inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_xsaves_supported",
          "args": [],
          "line": 7139
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_xsaves_supported",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "245-249",
          "snippet": "static inline bool vmx_xsaves_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_XSAVES;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool vmx_xsaves_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_XSAVES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_cap_set",
          "args": [
            "X86_FEATURE_UMIP"
          ],
          "line": 7135
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_cap_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "279-285",
          "snippet": "static __always_inline void kvm_cpu_cap_set(unsigned int x86_feature)\n{\n\tunsigned int x86_leaf = x86_feature / 32;\n\n\treverse_cpuid_check(x86_leaf);\n\tkvm_cpu_caps[x86_leaf] |= __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline void kvm_cpu_cap_set(unsigned int x86_feature)\n{\n\tunsigned int x86_leaf = x86_feature / 32;\n\n\treverse_cpuid_check(x86_leaf);\n\tkvm_cpu_caps[x86_leaf] |= __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_umip_emulated",
          "args": [],
          "line": 7134
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_umip_emulated",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "143-147",
          "snippet": "static inline bool vmx_umip_emulated(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_DESC;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool vmx_umip_emulated(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_DESC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_cap_check_and_set",
          "args": [
            "X86_FEATURE_PKU"
          ],
          "line": 7132
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_cap_check_and_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "300-304",
          "snippet": "static __always_inline void kvm_cpu_cap_check_and_set(unsigned int x86_feature)\n{\n\tif (boot_cpu_has(x86_feature))\n\t\tkvm_cpu_cap_set(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline void kvm_cpu_cap_check_and_set(unsigned int x86_feature)\n{\n\tif (boot_cpu_has(x86_feature))\n\t\tkvm_cpu_cap_set(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_OSPKE"
          ],
          "line": 7131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_pt_mode_is_host_guest",
          "args": [],
          "line": 7127
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_pt_mode_is_host_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "365-368",
          "snippet": "static inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [
            "#define PT_MODE_HOST_GUEST\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\n#define PT_MODE_HOST_GUEST\t1\n\nstatic inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_invpcid",
          "args": [],
          "line": 7125
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_invpcid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "203-207",
          "snippet": "static inline bool cpu_has_vmx_invpcid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_invpcid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mpx_supported",
          "args": [],
          "line": 7123
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mpx_supported",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "277-281",
          "snippet": "static inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cpu_caps",
          "args": [],
          "line": 7116
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cpu_caps",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.c",
          "lines": "275-425",
          "snippet": "void kvm_set_cpu_caps(void)\n{\n\tunsigned int f_nx = is_efer_nx() ? F(NX) : 0;\n#ifdef CONFIG_X86_64\n\tunsigned int f_gbpages = F(GBPAGES);\n\tunsigned int f_lm = F(LM);\n#else\n\tunsigned int f_gbpages = 0;\n\tunsigned int f_lm = 0;\n#endif\n\n\tBUILD_BUG_ON(sizeof(kvm_cpu_caps) >\n\t\t     sizeof(boot_cpu_data.x86_capability));\n\n\tmemcpy(&kvm_cpu_caps, &boot_cpu_data.x86_capability,\n\t       sizeof(kvm_cpu_caps));\n\n\tkvm_cpu_cap_mask(CPUID_1_ECX,\n\t\t/*\n\t\t * NOTE: MONITOR (and MWAIT) are emulated as NOP, but *not*\n\t\t * advertised to guests via CPUID!\n\t\t */\n\t\tF(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |\n\t\t0 /* DS-CPL, VMX, SMX, EST */ |\n\t\t0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |\n\t\tF(FMA) | F(CX16) | 0 /* xTPR Update, PDCM */ |\n\t\tF(PCID) | 0 /* Reserved, DCA */ | F(XMM4_1) |\n\t\tF(XMM4_2) | F(X2APIC) | F(MOVBE) | F(POPCNT) |\n\t\t0 /* Reserved*/ | F(AES) | F(XSAVE) | 0 /* OSXSAVE */ | F(AVX) |\n\t\tF(F16C) | F(RDRAND)\n\t);\n\t/* KVM emulates x2apic in software irrespective of host support. */\n\tkvm_cpu_cap_set(X86_FEATURE_X2APIC);\n\n\tkvm_cpu_cap_mask(CPUID_1_EDX,\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SEP) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* PSN */ | F(CLFLUSH) |\n\t\t0 /* Reserved, DS, ACPI */ | F(MMX) |\n\t\tF(FXSR) | F(XMM) | F(XMM2) | F(SELFSNOOP) |\n\t\t0 /* HTT, TM, Reserved, PBE */\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_7_0_EBX,\n\t\tF(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |\n\t\tF(BMI2) | F(ERMS) | 0 /*INVPCID*/ | F(RTM) | 0 /*MPX*/ | F(RDSEED) |\n\t\tF(ADX) | F(SMAP) | F(AVX512IFMA) | F(AVX512F) | F(AVX512PF) |\n\t\tF(AVX512ER) | F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(AVX512DQ) |\n\t\tF(SHA_NI) | F(AVX512BW) | F(AVX512VL) | 0 /*INTEL_PT*/\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_7_ECX,\n\t\tF(AVX512VBMI) | F(LA57) | 0 /*PKU*/ | 0 /*OSPKE*/ | F(RDPID) |\n\t\tF(AVX512_VPOPCNTDQ) | F(UMIP) | F(AVX512_VBMI2) | F(GFNI) |\n\t\tF(VAES) | F(VPCLMULQDQ) | F(AVX512_VNNI) | F(AVX512_BITALG) |\n\t\tF(CLDEMOTE) | F(MOVDIRI) | F(MOVDIR64B) | 0 /*WAITPKG*/\n\t);\n\t/* Set LA57 based on hardware capability. */\n\tif (cpuid_ecx(7) & F(LA57))\n\t\tkvm_cpu_cap_set(X86_FEATURE_LA57);\n\n\tkvm_cpu_cap_mask(CPUID_7_EDX,\n\t\tF(AVX512_4VNNIW) | F(AVX512_4FMAPS) | F(SPEC_CTRL) |\n\t\tF(SPEC_CTRL_SSBD) | F(ARCH_CAPABILITIES) | F(INTEL_STIBP) |\n\t\tF(MD_CLEAR) | F(AVX512_VP2INTERSECT) | F(FSRM)\n\t);\n\n\t/* TSC_ADJUST and ARCH_CAPABILITIES are emulated in software. */\n\tkvm_cpu_cap_set(X86_FEATURE_TSC_ADJUST);\n\tkvm_cpu_cap_set(X86_FEATURE_ARCH_CAPABILITIES);\n\n\tif (boot_cpu_has(X86_FEATURE_IBPB) && boot_cpu_has(X86_FEATURE_IBRS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_SPEC_CTRL);\n\tif (boot_cpu_has(X86_FEATURE_STIBP))\n\t\tkvm_cpu_cap_set(X86_FEATURE_INTEL_STIBP);\n\tif (boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_SPEC_CTRL_SSBD);\n\n\tkvm_cpu_cap_mask(CPUID_7_1_EAX,\n\t\tF(AVX512_BF16)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_D_1_EAX,\n\t\tF(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | F(XSAVES)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0001_ECX,\n\t\tF(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |\n\t\tF(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |\n\t\tF(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |\n\t\t0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM) |\n\t\tF(TOPOEXT) | F(PERFCTR_CORE)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0001_EDX,\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SYSCALL) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* Reserved */ |\n\t\tf_nx | 0 /* Reserved */ | F(MMXEXT) | F(MMX) |\n\t\tF(FXSR) | F(FXSR_OPT) | f_gbpages | F(RDTSCP) |\n\t\t0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW)\n\t);\n\n\tif (!tdp_enabled && IS_ENABLED(CONFIG_X86_64))\n\t\tkvm_cpu_cap_set(X86_FEATURE_GBPAGES);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0008_EBX,\n\t\tF(CLZERO) | F(XSAVEERPTR) |\n\t\tF(WBNOINVD) | F(AMD_IBPB) | F(AMD_IBRS) | F(AMD_SSBD) | F(VIRT_SSBD) |\n\t\tF(AMD_SSB_NO) | F(AMD_STIBP) | F(AMD_STIBP_ALWAYS_ON)\n\t);\n\n\t/*\n\t * AMD has separate bits for each SPEC_CTRL bit.\n\t * arch/x86/kernel/cpu/bugs.c is kind enough to\n\t * record that in cpufeatures so use them.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_IBPB))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_IBPB);\n\tif (boot_cpu_has(X86_FEATURE_IBRS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_IBRS);\n\tif (boot_cpu_has(X86_FEATURE_STIBP))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_STIBP);\n\tif (boot_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_SSBD);\n\tif (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_SSB_NO);\n\t/*\n\t * The preference is to use SPEC CTRL MSR instead of the\n\t * VIRT_SPEC MSR.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);\n\n\t/*\n\t * Hide all SVM features by default, SVM will set the cap bits for\n\t * features it emulates and/or exposes for L1.\n\t */\n\tkvm_cpu_cap_mask(CPUID_8000_000A_EDX, 0);\n\n\tkvm_cpu_cap_mask(CPUID_C000_0001_EDX,\n\t\tF(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |\n\t\tF(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |\n\t\tF(PMM) | F(PMM_EN)\n\t);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/processor.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define F feature_bit"
          ],
          "globals_used": [
            "u32 kvm_cpu_caps[NCAPINTS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/processor.h>\n#include <linux/sched/stat.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/kvm_host.h>\n\n#define F feature_bit\n\nu32 kvm_cpu_caps[NCAPINTS];\n\nvoid kvm_set_cpu_caps(void)\n{\n\tunsigned int f_nx = is_efer_nx() ? F(NX) : 0;\n#ifdef CONFIG_X86_64\n\tunsigned int f_gbpages = F(GBPAGES);\n\tunsigned int f_lm = F(LM);\n#else\n\tunsigned int f_gbpages = 0;\n\tunsigned int f_lm = 0;\n#endif\n\n\tBUILD_BUG_ON(sizeof(kvm_cpu_caps) >\n\t\t     sizeof(boot_cpu_data.x86_capability));\n\n\tmemcpy(&kvm_cpu_caps, &boot_cpu_data.x86_capability,\n\t       sizeof(kvm_cpu_caps));\n\n\tkvm_cpu_cap_mask(CPUID_1_ECX,\n\t\t/*\n\t\t * NOTE: MONITOR (and MWAIT) are emulated as NOP, but *not*\n\t\t * advertised to guests via CPUID!\n\t\t */\n\t\tF(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |\n\t\t0 /* DS-CPL, VMX, SMX, EST */ |\n\t\t0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |\n\t\tF(FMA) | F(CX16) | 0 /* xTPR Update, PDCM */ |\n\t\tF(PCID) | 0 /* Reserved, DCA */ | F(XMM4_1) |\n\t\tF(XMM4_2) | F(X2APIC) | F(MOVBE) | F(POPCNT) |\n\t\t0 /* Reserved*/ | F(AES) | F(XSAVE) | 0 /* OSXSAVE */ | F(AVX) |\n\t\tF(F16C) | F(RDRAND)\n\t);\n\t/* KVM emulates x2apic in software irrespective of host support. */\n\tkvm_cpu_cap_set(X86_FEATURE_X2APIC);\n\n\tkvm_cpu_cap_mask(CPUID_1_EDX,\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SEP) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* PSN */ | F(CLFLUSH) |\n\t\t0 /* Reserved, DS, ACPI */ | F(MMX) |\n\t\tF(FXSR) | F(XMM) | F(XMM2) | F(SELFSNOOP) |\n\t\t0 /* HTT, TM, Reserved, PBE */\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_7_0_EBX,\n\t\tF(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |\n\t\tF(BMI2) | F(ERMS) | 0 /*INVPCID*/ | F(RTM) | 0 /*MPX*/ | F(RDSEED) |\n\t\tF(ADX) | F(SMAP) | F(AVX512IFMA) | F(AVX512F) | F(AVX512PF) |\n\t\tF(AVX512ER) | F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(AVX512DQ) |\n\t\tF(SHA_NI) | F(AVX512BW) | F(AVX512VL) | 0 /*INTEL_PT*/\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_7_ECX,\n\t\tF(AVX512VBMI) | F(LA57) | 0 /*PKU*/ | 0 /*OSPKE*/ | F(RDPID) |\n\t\tF(AVX512_VPOPCNTDQ) | F(UMIP) | F(AVX512_VBMI2) | F(GFNI) |\n\t\tF(VAES) | F(VPCLMULQDQ) | F(AVX512_VNNI) | F(AVX512_BITALG) |\n\t\tF(CLDEMOTE) | F(MOVDIRI) | F(MOVDIR64B) | 0 /*WAITPKG*/\n\t);\n\t/* Set LA57 based on hardware capability. */\n\tif (cpuid_ecx(7) & F(LA57))\n\t\tkvm_cpu_cap_set(X86_FEATURE_LA57);\n\n\tkvm_cpu_cap_mask(CPUID_7_EDX,\n\t\tF(AVX512_4VNNIW) | F(AVX512_4FMAPS) | F(SPEC_CTRL) |\n\t\tF(SPEC_CTRL_SSBD) | F(ARCH_CAPABILITIES) | F(INTEL_STIBP) |\n\t\tF(MD_CLEAR) | F(AVX512_VP2INTERSECT) | F(FSRM)\n\t);\n\n\t/* TSC_ADJUST and ARCH_CAPABILITIES are emulated in software. */\n\tkvm_cpu_cap_set(X86_FEATURE_TSC_ADJUST);\n\tkvm_cpu_cap_set(X86_FEATURE_ARCH_CAPABILITIES);\n\n\tif (boot_cpu_has(X86_FEATURE_IBPB) && boot_cpu_has(X86_FEATURE_IBRS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_SPEC_CTRL);\n\tif (boot_cpu_has(X86_FEATURE_STIBP))\n\t\tkvm_cpu_cap_set(X86_FEATURE_INTEL_STIBP);\n\tif (boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_SPEC_CTRL_SSBD);\n\n\tkvm_cpu_cap_mask(CPUID_7_1_EAX,\n\t\tF(AVX512_BF16)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_D_1_EAX,\n\t\tF(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | F(XSAVES)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0001_ECX,\n\t\tF(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |\n\t\tF(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |\n\t\tF(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |\n\t\t0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM) |\n\t\tF(TOPOEXT) | F(PERFCTR_CORE)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0001_EDX,\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SYSCALL) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* Reserved */ |\n\t\tf_nx | 0 /* Reserved */ | F(MMXEXT) | F(MMX) |\n\t\tF(FXSR) | F(FXSR_OPT) | f_gbpages | F(RDTSCP) |\n\t\t0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW)\n\t);\n\n\tif (!tdp_enabled && IS_ENABLED(CONFIG_X86_64))\n\t\tkvm_cpu_cap_set(X86_FEATURE_GBPAGES);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0008_EBX,\n\t\tF(CLZERO) | F(XSAVEERPTR) |\n\t\tF(WBNOINVD) | F(AMD_IBPB) | F(AMD_IBRS) | F(AMD_SSBD) | F(VIRT_SSBD) |\n\t\tF(AMD_SSB_NO) | F(AMD_STIBP) | F(AMD_STIBP_ALWAYS_ON)\n\t);\n\n\t/*\n\t * AMD has separate bits for each SPEC_CTRL bit.\n\t * arch/x86/kernel/cpu/bugs.c is kind enough to\n\t * record that in cpufeatures so use them.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_IBPB))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_IBPB);\n\tif (boot_cpu_has(X86_FEATURE_IBRS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_IBRS);\n\tif (boot_cpu_has(X86_FEATURE_STIBP))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_STIBP);\n\tif (boot_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_SSBD);\n\tif (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_SSB_NO);\n\t/*\n\t * The preference is to use SPEC CTRL MSR instead of the\n\t * VIRT_SPEC MSR.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);\n\n\t/*\n\t * Hide all SVM features by default, SVM will set the cap bits for\n\t * features it emulates and/or exposes for L1.\n\t */\n\tkvm_cpu_cap_mask(CPUID_8000_000A_EDX, 0);\n\n\tkvm_cpu_cap_mask(CPUID_C000_0001_EDX,\n\t\tF(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |\n\t\tF(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |\n\t\tF(PMM) | F(PMM_EN)\n\t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\n\nstatic __init void vmx_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\t/* CPUID 0x1 */\n\tif (nested)\n\t\tkvm_cpu_cap_set(X86_FEATURE_VMX);\n\n\t/* CPUID 0x7 */\n\tif (kvm_mpx_supported())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_MPX);\n\tif (cpu_has_vmx_invpcid())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_INVPCID);\n\tif (vmx_pt_mode_is_host_guest())\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_INTEL_PT);\n\n\t/* PKU is not yet implemented for shadow paging. */\n\tif (enable_ept && boot_cpu_has(X86_FEATURE_OSPKE))\n\t\tkvm_cpu_cap_check_and_set(X86_FEATURE_PKU);\n\n\tif (vmx_umip_emulated())\n\t\tkvm_cpu_cap_set(X86_FEATURE_UMIP);\n\n\t/* CPUID 0xD.1 */\n\tsupported_xss = 0;\n\tif (!vmx_xsaves_supported())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_XSAVES);\n\n\t/* CPUID 0x80000001 */\n\tif (!cpu_has_vmx_rdtscp())\n\t\tkvm_cpu_cap_clear(X86_FEATURE_RDTSCP);\n}"
  },
  {
    "function_name": "vmx_cpuid_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7074-7112",
    "snippet": "static void vmx_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/* xsaves_enabled is recomputed in vmx_compute_secondary_exec_control(). */\n\tvcpu->arch.xsaves_enabled = false;\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmx_compute_secondary_exec_control(vmx);\n\t\tvmcs_set_secondary_exec_control(vmx);\n\t}\n\n\tif (nested_vmx_allowed(vcpu))\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEAT_CTL_VMX_ENABLED_INSIDE_SMX |\n\t\t\tFEAT_CTL_VMX_ENABLED_OUTSIDE_SMX;\n\telse\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=\n\t\t\t~(FEAT_CTL_VMX_ENABLED_INSIDE_SMX |\n\t\t\t  FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX);\n\n\tif (nested_vmx_allowed(vcpu)) {\n\t\tnested_vmx_cr_fixed1_bits_update(vcpu);\n\t\tnested_vmx_entry_exit_ctls_update(vcpu);\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_INTEL_PT) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_INTEL_PT))\n\t\tupdate_intel_pt_cfg(vcpu);\n\n\tif (boot_cpu_has(X86_FEATURE_RTM)) {\n\t\tstruct shared_msr_entry *msr;\n\t\tmsr = find_msr_entry(vmx, MSR_IA32_TSX_CTRL);\n\t\tif (msr) {\n\t\t\tbool enabled = guest_cpuid_has(vcpu, X86_FEATURE_RTM);\n\t\t\tvmx_set_guest_msr(vmx, msr, enabled ? 0 : TSX_CTRL_RTM_DISABLE);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_set_guest_msr",
          "args": [
            "vmx",
            "msr",
            "enabled ? 0 : TSX_CTRL_RTM_DISABLE"
          ],
          "line": 7109
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_guest_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "643-658",
          "snippet": "static int vmx_set_guest_msr(struct vcpu_vmx *vmx, struct shared_msr_entry *msr, u64 data)\n{\n\tint ret = 0;\n\n\tu64 old_msr_data = msr->data;\n\tmsr->data = data;\n\tif (msr - vmx->guest_msrs < vmx->save_nmsrs) {\n\t\tpreempt_disable();\n\t\tret = kvm_set_shared_msr(msr->index, msr->data,\n\t\t\t\t\t msr->mask);\n\t\tpreempt_enable();\n\t\tif (ret)\n\t\t\tmsr->data = old_msr_data;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int vmx_set_guest_msr(struct vcpu_vmx *vmx, struct shared_msr_entry *msr, u64 data)\n{\n\tint ret = 0;\n\n\tu64 old_msr_data = msr->data;\n\tmsr->data = data;\n\tif (msr - vmx->guest_msrs < vmx->save_nmsrs) {\n\t\tpreempt_disable();\n\t\tret = kvm_set_shared_msr(msr->index, msr->data,\n\t\t\t\t\t msr->mask);\n\t\tpreempt_enable();\n\t\tif (ret)\n\t\t\tmsr->data = old_msr_data;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_RTM"
          ],
          "line": 7108
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_msr_entry",
          "args": [
            "vmx",
            "MSR_IA32_TSX_CTRL"
          ],
          "line": 7106
        },
        "resolved": true,
        "details": {
          "function_name": "find_msr_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "633-641",
          "snippet": "struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_RTM"
          ],
          "line": 7104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_intel_pt_cfg",
          "args": [
            "vcpu"
          ],
          "line": 7102
        },
        "resolved": true,
        "details": {
          "function_name": "update_intel_pt_cfg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "7005-7072",
          "snippet": "static void update_intel_pt_cfg(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\tint i;\n\n\tfor (i = 0; i < PT_CPUID_LEAVES; i++) {\n\t\tbest = kvm_find_cpuid_entry(vcpu, 0x14, i);\n\t\tif (!best)\n\t\t\treturn;\n\t\tvmx->pt_desc.caps[CPUID_EAX + i*PT_CPUID_REGS_NUM] = best->eax;\n\t\tvmx->pt_desc.caps[CPUID_EBX + i*PT_CPUID_REGS_NUM] = best->ebx;\n\t\tvmx->pt_desc.caps[CPUID_ECX + i*PT_CPUID_REGS_NUM] = best->ecx;\n\t\tvmx->pt_desc.caps[CPUID_EDX + i*PT_CPUID_REGS_NUM] = best->edx;\n\t}\n\n\t/* Get the number of configurable Address Ranges for filtering */\n\tvmx->pt_desc.addr_range = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_num_address_ranges);\n\n\t/* Initialize and clear the no dependency bits */\n\tvmx->pt_desc.ctl_bitmask = ~(RTIT_CTL_TRACEEN | RTIT_CTL_OS |\n\t\t\tRTIT_CTL_USR | RTIT_CTL_TSC_EN | RTIT_CTL_DISRETC);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[0]=1 CR3Filter can be set otherwise\n\t * will inject an #GP\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_cr3_filtering))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_CR3EN;\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[1]=1 CYCEn, CycThresh and\n\t * PSBFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_CYCLEACC |\n\t\t\t\tRTIT_CTL_CYC_THRESH | RTIT_CTL_PSB_FREQ);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[3]=1 MTCEn BranchEn and\n\t * MTCFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_MTC_EN |\n\t\t\t\tRTIT_CTL_BRANCH_EN | RTIT_CTL_MTC_RANGE);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[4]=1 FUPonPTW and PTWEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_ptwrite))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_FUP_ON_PTW |\n\t\t\t\t\t\t\tRTIT_CTL_PTW_EN);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[5]=1 PwrEvEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_power_event_trace))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_PWR_EVT_EN;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[0]=1 ToPA can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_topa_output))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_TOPA;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[3]=1 FabircEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_output_subsys))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_FABRIC_EN;\n\n\t/* unmask address range configure area */\n\tfor (i = 0; i < vmx->pt_desc.addr_range; i++)\n\t\tvmx->pt_desc.ctl_bitmask &= ~(0xfULL << (32 + i * 4));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void update_intel_pt_cfg(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\tint i;\n\n\tfor (i = 0; i < PT_CPUID_LEAVES; i++) {\n\t\tbest = kvm_find_cpuid_entry(vcpu, 0x14, i);\n\t\tif (!best)\n\t\t\treturn;\n\t\tvmx->pt_desc.caps[CPUID_EAX + i*PT_CPUID_REGS_NUM] = best->eax;\n\t\tvmx->pt_desc.caps[CPUID_EBX + i*PT_CPUID_REGS_NUM] = best->ebx;\n\t\tvmx->pt_desc.caps[CPUID_ECX + i*PT_CPUID_REGS_NUM] = best->ecx;\n\t\tvmx->pt_desc.caps[CPUID_EDX + i*PT_CPUID_REGS_NUM] = best->edx;\n\t}\n\n\t/* Get the number of configurable Address Ranges for filtering */\n\tvmx->pt_desc.addr_range = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_num_address_ranges);\n\n\t/* Initialize and clear the no dependency bits */\n\tvmx->pt_desc.ctl_bitmask = ~(RTIT_CTL_TRACEEN | RTIT_CTL_OS |\n\t\t\tRTIT_CTL_USR | RTIT_CTL_TSC_EN | RTIT_CTL_DISRETC);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[0]=1 CR3Filter can be set otherwise\n\t * will inject an #GP\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_cr3_filtering))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_CR3EN;\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[1]=1 CYCEn, CycThresh and\n\t * PSBFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_CYCLEACC |\n\t\t\t\tRTIT_CTL_CYC_THRESH | RTIT_CTL_PSB_FREQ);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[3]=1 MTCEn BranchEn and\n\t * MTCFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_MTC_EN |\n\t\t\t\tRTIT_CTL_BRANCH_EN | RTIT_CTL_MTC_RANGE);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[4]=1 FUPonPTW and PTWEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_ptwrite))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_FUP_ON_PTW |\n\t\t\t\t\t\t\tRTIT_CTL_PTW_EN);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[5]=1 PwrEvEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_power_event_trace))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_PWR_EVT_EN;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[0]=1 ToPA can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_topa_output))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_TOPA;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[3]=1 FabircEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_output_subsys))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_FABRIC_EN;\n\n\t/* unmask address range configure area */\n\tfor (i = 0; i < vmx->pt_desc.addr_range; i++)\n\t\tvmx->pt_desc.ctl_bitmask &= ~(0xfULL << (32 + i * 4));\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_INTEL_PT"
          ],
          "line": 7100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_vmx_entry_exit_ctls_update",
          "args": [
            "vcpu"
          ],
          "line": 7097
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_entry_exit_ctls_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6988-7003",
          "snippet": "static void nested_vmx_entry_exit_ctls_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (kvm_mpx_supported()) {\n\t\tbool mpx_enabled = guest_cpuid_has(vcpu, X86_FEATURE_MPX);\n\n\t\tif (mpx_enabled) {\n\t\t\tvmx->nested.msrs.entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\t\t} else {\n\t\t\tvmx->nested.msrs.entry_ctls_high &= ~VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high &= ~VM_EXIT_CLEAR_BNDCFGS;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void nested_vmx_entry_exit_ctls_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (kvm_mpx_supported()) {\n\t\tbool mpx_enabled = guest_cpuid_has(vcpu, X86_FEATURE_MPX);\n\n\t\tif (mpx_enabled) {\n\t\t\tvmx->nested.msrs.entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\t\t} else {\n\t\t\tvmx->nested.msrs.entry_ctls_high &= ~VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high &= ~VM_EXIT_CLEAR_BNDCFGS;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_cr_fixed1_bits_update",
          "args": [
            "vcpu"
          ],
          "line": 7096
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_cr_fixed1_bits_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6948-6986",
          "snippet": "static void nested_vmx_cr_fixed1_bits_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tvmx->nested.msrs.cr0_fixed1 = 0xffffffff;\n\tvmx->nested.msrs.cr4_fixed1 = X86_CR4_PCE;\n\n#define cr4_fixed1_update(_cr4_mask, _reg, _cpuid_mask) do {\t\t\\\n\tif (entry && (entry->_reg & (_cpuid_mask)))\t\t\t\\\n\t\tvmx->nested.msrs.cr4_fixed1 |= (_cr4_mask);\t\\\n} while (0)\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tcr4_fixed1_update(X86_CR4_VME,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_PVI,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_TSD,        edx, feature_bit(TSC));\n\tcr4_fixed1_update(X86_CR4_DE,         edx, feature_bit(DE));\n\tcr4_fixed1_update(X86_CR4_PSE,        edx, feature_bit(PSE));\n\tcr4_fixed1_update(X86_CR4_PAE,        edx, feature_bit(PAE));\n\tcr4_fixed1_update(X86_CR4_MCE,        edx, feature_bit(MCE));\n\tcr4_fixed1_update(X86_CR4_PGE,        edx, feature_bit(PGE));\n\tcr4_fixed1_update(X86_CR4_OSFXSR,     edx, feature_bit(FXSR));\n\tcr4_fixed1_update(X86_CR4_OSXMMEXCPT, edx, feature_bit(XMM));\n\tcr4_fixed1_update(X86_CR4_VMXE,       ecx, feature_bit(VMX));\n\tcr4_fixed1_update(X86_CR4_SMXE,       ecx, feature_bit(SMX));\n\tcr4_fixed1_update(X86_CR4_PCIDE,      ecx, feature_bit(PCID));\n\tcr4_fixed1_update(X86_CR4_OSXSAVE,    ecx, feature_bit(XSAVE));\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tcr4_fixed1_update(X86_CR4_FSGSBASE,   ebx, feature_bit(FSGSBASE));\n\tcr4_fixed1_update(X86_CR4_SMEP,       ebx, feature_bit(SMEP));\n\tcr4_fixed1_update(X86_CR4_SMAP,       ebx, feature_bit(SMAP));\n\tcr4_fixed1_update(X86_CR4_PKE,        ecx, feature_bit(PKU));\n\tcr4_fixed1_update(X86_CR4_UMIP,       ecx, feature_bit(UMIP));\n\tcr4_fixed1_update(X86_CR4_LA57,       ecx, feature_bit(LA57));\n\n#undef cr4_fixed1_update\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void nested_vmx_cr_fixed1_bits_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tvmx->nested.msrs.cr0_fixed1 = 0xffffffff;\n\tvmx->nested.msrs.cr4_fixed1 = X86_CR4_PCE;\n\n#define cr4_fixed1_update(_cr4_mask, _reg, _cpuid_mask) do {\t\t\\\n\tif (entry && (entry->_reg & (_cpuid_mask)))\t\t\t\\\n\t\tvmx->nested.msrs.cr4_fixed1 |= (_cr4_mask);\t\\\n} while (0)\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tcr4_fixed1_update(X86_CR4_VME,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_PVI,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_TSD,        edx, feature_bit(TSC));\n\tcr4_fixed1_update(X86_CR4_DE,         edx, feature_bit(DE));\n\tcr4_fixed1_update(X86_CR4_PSE,        edx, feature_bit(PSE));\n\tcr4_fixed1_update(X86_CR4_PAE,        edx, feature_bit(PAE));\n\tcr4_fixed1_update(X86_CR4_MCE,        edx, feature_bit(MCE));\n\tcr4_fixed1_update(X86_CR4_PGE,        edx, feature_bit(PGE));\n\tcr4_fixed1_update(X86_CR4_OSFXSR,     edx, feature_bit(FXSR));\n\tcr4_fixed1_update(X86_CR4_OSXMMEXCPT, edx, feature_bit(XMM));\n\tcr4_fixed1_update(X86_CR4_VMXE,       ecx, feature_bit(VMX));\n\tcr4_fixed1_update(X86_CR4_SMXE,       ecx, feature_bit(SMX));\n\tcr4_fixed1_update(X86_CR4_PCIDE,      ecx, feature_bit(PCID));\n\tcr4_fixed1_update(X86_CR4_OSXSAVE,    ecx, feature_bit(XSAVE));\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tcr4_fixed1_update(X86_CR4_FSGSBASE,   ebx, feature_bit(FSGSBASE));\n\tcr4_fixed1_update(X86_CR4_SMEP,       ebx, feature_bit(SMEP));\n\tcr4_fixed1_update(X86_CR4_SMAP,       ebx, feature_bit(SMAP));\n\tcr4_fixed1_update(X86_CR4_PKE,        ecx, feature_bit(PKU));\n\tcr4_fixed1_update(X86_CR4_UMIP,       ecx, feature_bit(UMIP));\n\tcr4_fixed1_update(X86_CR4_LA57,       ecx, feature_bit(LA57));\n\n#undef cr4_fixed1_update\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_allowed",
          "args": [
            "vcpu"
          ],
          "line": 7095
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_allowed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1755-1758",
          "snippet": "bool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nbool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 7091
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_set_secondary_exec_control",
          "args": [
            "vmx"
          ],
          "line": 7083
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_secondary_exec_control",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6924-6942",
          "snippet": "static void vmcs_set_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\t/*\n\t * These bits in the secondary execution controls field\n\t * are dynamic, the others are mostly based on the hypervisor\n\t * architecture and the guest's CPUID.  Do not touch the\n\t * dynamic bits.\n\t */\n\tu32 mask =\n\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_DESC;\n\n\tu32 new_ctl = vmx->secondary_exec_control;\n\tu32 cur_ctl = secondary_exec_controls_get(vmx);\n\n\tsecondary_exec_controls_set(vmx, (new_ctl & ~mask) | (cur_ctl & mask));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmcs_set_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\t/*\n\t * These bits in the secondary execution controls field\n\t * are dynamic, the others are mostly based on the hypervisor\n\t * architecture and the guest's CPUID.  Do not touch the\n\t * dynamic bits.\n\t */\n\tu32 mask =\n\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_DESC;\n\n\tu32 new_ctl = vmx->secondary_exec_control;\n\tu32 cur_ctl = secondary_exec_controls_get(vmx);\n\n\tsecondary_exec_controls_set(vmx, (new_ctl & ~mask) | (cur_ctl & mask));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_compute_secondary_exec_control",
          "args": [
            "vmx"
          ],
          "line": 7082
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_compute_secondary_exec_control",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4002-4147",
          "snippet": "static void vmx_compute_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tstruct kvm_vcpu *vcpu = &vmx->vcpu;\n\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\texec_control &= ~(SECONDARY_EXEC_PT_USE_GPA | SECONDARY_EXEC_PT_CONCEAL_VMX);\n\tif (!cpu_need_virtualize_apic_accesses(vcpu))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (kvm_pause_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\n\t/* SECONDARY_EXEC_DESC is enabled/disabled on writes to CR4.UMIP,\n\t * in vmx_set_cr4.  */\n\texec_control &= ~SECONDARY_EXEC_DESC;\n\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\n\tif (!enable_pml)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_PML;\n\n\tif (vmx_xsaves_supported()) {\n\t\t/* Exposing XSAVES only when XSAVE is exposed */\n\t\tbool xsaves_enabled =\n\t\t\tboot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVES);\n\n\t\tvcpu->arch.xsaves_enabled = xsaves_enabled;\n\n\t\tif (!xsaves_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_XSAVES;\n\n\t\tif (nested) {\n\t\t\tif (xsaves_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_XSAVES;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_XSAVES;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_rdtscp()) {\n\t\tbool rdtscp_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP);\n\t\tif (!rdtscp_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\n\t\tif (nested) {\n\t\t\tif (rdtscp_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDTSCP;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDTSCP;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_invpcid()) {\n\t\t/* Exposing INVPCID only when PCID is exposed */\n\t\tbool invpcid_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_INVPCID) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_PCID);\n\n\t\tif (!invpcid_enabled) {\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\tguest_cpuid_clear(vcpu, X86_FEATURE_INVPCID);\n\t\t}\n\n\t\tif (nested) {\n\t\t\tif (invpcid_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t}\n\t}\n\n\tif (vmx_rdrand_supported()) {\n\t\tbool rdrand_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDRAND);\n\t\tif (rdrand_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDRAND_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdrand_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDRAND_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDRAND_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_rdseed_supported()) {\n\t\tbool rdseed_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDSEED);\n\t\tif (rdseed_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDSEED_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdseed_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDSEED_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDSEED_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_waitpkg_supported()) {\n\t\tbool waitpkg_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_WAITPKG);\n\n\t\tif (!waitpkg_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\n\t\tif (nested) {\n\t\t\tif (waitpkg_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t}\n\t}\n\n\tvmx->secondary_exec_control = exec_control;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "struct vmcs_config vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmcs_config vmcs_config;\n\nstatic void vmx_compute_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tstruct kvm_vcpu *vcpu = &vmx->vcpu;\n\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\texec_control &= ~(SECONDARY_EXEC_PT_USE_GPA | SECONDARY_EXEC_PT_CONCEAL_VMX);\n\tif (!cpu_need_virtualize_apic_accesses(vcpu))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (kvm_pause_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\n\t/* SECONDARY_EXEC_DESC is enabled/disabled on writes to CR4.UMIP,\n\t * in vmx_set_cr4.  */\n\texec_control &= ~SECONDARY_EXEC_DESC;\n\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\n\tif (!enable_pml)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_PML;\n\n\tif (vmx_xsaves_supported()) {\n\t\t/* Exposing XSAVES only when XSAVE is exposed */\n\t\tbool xsaves_enabled =\n\t\t\tboot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVES);\n\n\t\tvcpu->arch.xsaves_enabled = xsaves_enabled;\n\n\t\tif (!xsaves_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_XSAVES;\n\n\t\tif (nested) {\n\t\t\tif (xsaves_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_XSAVES;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_XSAVES;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_rdtscp()) {\n\t\tbool rdtscp_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP);\n\t\tif (!rdtscp_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\n\t\tif (nested) {\n\t\t\tif (rdtscp_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDTSCP;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDTSCP;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_invpcid()) {\n\t\t/* Exposing INVPCID only when PCID is exposed */\n\t\tbool invpcid_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_INVPCID) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_PCID);\n\n\t\tif (!invpcid_enabled) {\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\tguest_cpuid_clear(vcpu, X86_FEATURE_INVPCID);\n\t\t}\n\n\t\tif (nested) {\n\t\t\tif (invpcid_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t}\n\t}\n\n\tif (vmx_rdrand_supported()) {\n\t\tbool rdrand_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDRAND);\n\t\tif (rdrand_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDRAND_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdrand_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDRAND_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDRAND_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_rdseed_supported()) {\n\t\tbool rdseed_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDSEED);\n\t\tif (rdseed_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDSEED_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdseed_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDSEED_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDSEED_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_waitpkg_supported()) {\n\t\tbool waitpkg_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_WAITPKG);\n\n\t\tif (!waitpkg_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\n\t\tif (nested) {\n\t\t\tif (waitpkg_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t}\n\t}\n\n\tvmx->secondary_exec_control = exec_control;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_secondary_exec_ctrls",
          "args": [],
          "line": 7081
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_secondary_exec_ctrls",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "125-129",
          "snippet": "static inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/* xsaves_enabled is recomputed in vmx_compute_secondary_exec_control(). */\n\tvcpu->arch.xsaves_enabled = false;\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmx_compute_secondary_exec_control(vmx);\n\t\tvmcs_set_secondary_exec_control(vmx);\n\t}\n\n\tif (nested_vmx_allowed(vcpu))\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits |=\n\t\t\tFEAT_CTL_VMX_ENABLED_INSIDE_SMX |\n\t\t\tFEAT_CTL_VMX_ENABLED_OUTSIDE_SMX;\n\telse\n\t\tto_vmx(vcpu)->msr_ia32_feature_control_valid_bits &=\n\t\t\t~(FEAT_CTL_VMX_ENABLED_INSIDE_SMX |\n\t\t\t  FEAT_CTL_VMX_ENABLED_OUTSIDE_SMX);\n\n\tif (nested_vmx_allowed(vcpu)) {\n\t\tnested_vmx_cr_fixed1_bits_update(vcpu);\n\t\tnested_vmx_entry_exit_ctls_update(vcpu);\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_INTEL_PT) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_INTEL_PT))\n\t\tupdate_intel_pt_cfg(vcpu);\n\n\tif (boot_cpu_has(X86_FEATURE_RTM)) {\n\t\tstruct shared_msr_entry *msr;\n\t\tmsr = find_msr_entry(vmx, MSR_IA32_TSX_CTRL);\n\t\tif (msr) {\n\t\t\tbool enabled = guest_cpuid_has(vcpu, X86_FEATURE_RTM);\n\t\t\tvmx_set_guest_msr(vmx, msr, enabled ? 0 : TSX_CTRL_RTM_DISABLE);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "update_intel_pt_cfg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "7005-7072",
    "snippet": "static void update_intel_pt_cfg(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\tint i;\n\n\tfor (i = 0; i < PT_CPUID_LEAVES; i++) {\n\t\tbest = kvm_find_cpuid_entry(vcpu, 0x14, i);\n\t\tif (!best)\n\t\t\treturn;\n\t\tvmx->pt_desc.caps[CPUID_EAX + i*PT_CPUID_REGS_NUM] = best->eax;\n\t\tvmx->pt_desc.caps[CPUID_EBX + i*PT_CPUID_REGS_NUM] = best->ebx;\n\t\tvmx->pt_desc.caps[CPUID_ECX + i*PT_CPUID_REGS_NUM] = best->ecx;\n\t\tvmx->pt_desc.caps[CPUID_EDX + i*PT_CPUID_REGS_NUM] = best->edx;\n\t}\n\n\t/* Get the number of configurable Address Ranges for filtering */\n\tvmx->pt_desc.addr_range = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_num_address_ranges);\n\n\t/* Initialize and clear the no dependency bits */\n\tvmx->pt_desc.ctl_bitmask = ~(RTIT_CTL_TRACEEN | RTIT_CTL_OS |\n\t\t\tRTIT_CTL_USR | RTIT_CTL_TSC_EN | RTIT_CTL_DISRETC);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[0]=1 CR3Filter can be set otherwise\n\t * will inject an #GP\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_cr3_filtering))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_CR3EN;\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[1]=1 CYCEn, CycThresh and\n\t * PSBFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_CYCLEACC |\n\t\t\t\tRTIT_CTL_CYC_THRESH | RTIT_CTL_PSB_FREQ);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[3]=1 MTCEn BranchEn and\n\t * MTCFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_MTC_EN |\n\t\t\t\tRTIT_CTL_BRANCH_EN | RTIT_CTL_MTC_RANGE);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[4]=1 FUPonPTW and PTWEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_ptwrite))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_FUP_ON_PTW |\n\t\t\t\t\t\t\tRTIT_CTL_PTW_EN);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[5]=1 PwrEvEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_power_event_trace))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_PWR_EVT_EN;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[0]=1 ToPA can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_topa_output))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_TOPA;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[3]=1 FabircEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_output_subsys))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_FABRIC_EN;\n\n\t/* unmask address range configure area */\n\tfor (i = 0; i < vmx->pt_desc.addr_range; i++)\n\t\tvmx->pt_desc.ctl_bitmask &= ~(0xfULL << (32 + i * 4));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_output_subsys"
          ],
          "line": 7066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_topa_output"
          ],
          "line": 7062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_power_event_trace"
          ],
          "line": 7058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_ptwrite"
          ],
          "line": 7053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_mtc"
          ],
          "line": 7048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_psb_cyc"
          ],
          "line": 7040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_cr3_filtering"
          ],
          "line": 7033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_num_address_ranges"
          ],
          "line": 7022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "vcpu",
            "0x14",
            "i"
          ],
          "line": 7012
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.c",
          "lines": "903-917",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *e;\n\tint i;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\n\t\tif (e->function == function && (e->index == index ||\n\t\t    !(e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX)))\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/processor.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/processor.h>\n#include <linux/sched/stat.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *e;\n\tint i;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\n\t\tif (e->function == function && (e->index == index ||\n\t\t    !(e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX)))\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 7007
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void update_intel_pt_cfg(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *best = NULL;\n\tint i;\n\n\tfor (i = 0; i < PT_CPUID_LEAVES; i++) {\n\t\tbest = kvm_find_cpuid_entry(vcpu, 0x14, i);\n\t\tif (!best)\n\t\t\treturn;\n\t\tvmx->pt_desc.caps[CPUID_EAX + i*PT_CPUID_REGS_NUM] = best->eax;\n\t\tvmx->pt_desc.caps[CPUID_EBX + i*PT_CPUID_REGS_NUM] = best->ebx;\n\t\tvmx->pt_desc.caps[CPUID_ECX + i*PT_CPUID_REGS_NUM] = best->ecx;\n\t\tvmx->pt_desc.caps[CPUID_EDX + i*PT_CPUID_REGS_NUM] = best->edx;\n\t}\n\n\t/* Get the number of configurable Address Ranges for filtering */\n\tvmx->pt_desc.addr_range = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_num_address_ranges);\n\n\t/* Initialize and clear the no dependency bits */\n\tvmx->pt_desc.ctl_bitmask = ~(RTIT_CTL_TRACEEN | RTIT_CTL_OS |\n\t\t\tRTIT_CTL_USR | RTIT_CTL_TSC_EN | RTIT_CTL_DISRETC);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[0]=1 CR3Filter can be set otherwise\n\t * will inject an #GP\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_cr3_filtering))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_CR3EN;\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[1]=1 CYCEn, CycThresh and\n\t * PSBFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_CYCLEACC |\n\t\t\t\tRTIT_CTL_CYC_THRESH | RTIT_CTL_PSB_FREQ);\n\n\t/*\n\t * If CPUID.(EAX=14H,ECX=0):EBX[3]=1 MTCEn BranchEn and\n\t * MTCFreq can be set\n\t */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_MTC_EN |\n\t\t\t\tRTIT_CTL_BRANCH_EN | RTIT_CTL_MTC_RANGE);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[4]=1 FUPonPTW and PTWEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_ptwrite))\n\t\tvmx->pt_desc.ctl_bitmask &= ~(RTIT_CTL_FUP_ON_PTW |\n\t\t\t\t\t\t\tRTIT_CTL_PTW_EN);\n\n\t/* If CPUID.(EAX=14H,ECX=0):EBX[5]=1 PwrEvEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_power_event_trace))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_PWR_EVT_EN;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[0]=1 ToPA can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_topa_output))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_TOPA;\n\n\t/* If CPUID.(EAX=14H,ECX=0):ECX[3]=1 FabircEn can be set */\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_output_subsys))\n\t\tvmx->pt_desc.ctl_bitmask &= ~RTIT_CTL_FABRIC_EN;\n\n\t/* unmask address range configure area */\n\tfor (i = 0; i < vmx->pt_desc.addr_range; i++)\n\t\tvmx->pt_desc.ctl_bitmask &= ~(0xfULL << (32 + i * 4));\n}"
  },
  {
    "function_name": "nested_vmx_entry_exit_ctls_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6988-7003",
    "snippet": "static void nested_vmx_entry_exit_ctls_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (kvm_mpx_supported()) {\n\t\tbool mpx_enabled = guest_cpuid_has(vcpu, X86_FEATURE_MPX);\n\n\t\tif (mpx_enabled) {\n\t\t\tvmx->nested.msrs.entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\t\t} else {\n\t\t\tvmx->nested.msrs.entry_ctls_high &= ~VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high &= ~VM_EXIT_CLEAR_BNDCFGS;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_MPX"
          ],
          "line": 6993
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mpx_supported",
          "args": [],
          "line": 6992
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mpx_supported",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "277-281",
          "snippet": "static inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 6990
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void nested_vmx_entry_exit_ctls_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (kvm_mpx_supported()) {\n\t\tbool mpx_enabled = guest_cpuid_has(vcpu, X86_FEATURE_MPX);\n\n\t\tif (mpx_enabled) {\n\t\t\tvmx->nested.msrs.entry_ctls_high |= VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high |= VM_EXIT_CLEAR_BNDCFGS;\n\t\t} else {\n\t\t\tvmx->nested.msrs.entry_ctls_high &= ~VM_ENTRY_LOAD_BNDCFGS;\n\t\t\tvmx->nested.msrs.exit_ctls_high &= ~VM_EXIT_CLEAR_BNDCFGS;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "nested_vmx_cr_fixed1_bits_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6948-6986",
    "snippet": "static void nested_vmx_cr_fixed1_bits_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tvmx->nested.msrs.cr0_fixed1 = 0xffffffff;\n\tvmx->nested.msrs.cr4_fixed1 = X86_CR4_PCE;\n\n#define cr4_fixed1_update(_cr4_mask, _reg, _cpuid_mask) do {\t\t\\\n\tif (entry && (entry->_reg & (_cpuid_mask)))\t\t\t\\\n\t\tvmx->nested.msrs.cr4_fixed1 |= (_cr4_mask);\t\\\n} while (0)\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tcr4_fixed1_update(X86_CR4_VME,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_PVI,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_TSD,        edx, feature_bit(TSC));\n\tcr4_fixed1_update(X86_CR4_DE,         edx, feature_bit(DE));\n\tcr4_fixed1_update(X86_CR4_PSE,        edx, feature_bit(PSE));\n\tcr4_fixed1_update(X86_CR4_PAE,        edx, feature_bit(PAE));\n\tcr4_fixed1_update(X86_CR4_MCE,        edx, feature_bit(MCE));\n\tcr4_fixed1_update(X86_CR4_PGE,        edx, feature_bit(PGE));\n\tcr4_fixed1_update(X86_CR4_OSFXSR,     edx, feature_bit(FXSR));\n\tcr4_fixed1_update(X86_CR4_OSXMMEXCPT, edx, feature_bit(XMM));\n\tcr4_fixed1_update(X86_CR4_VMXE,       ecx, feature_bit(VMX));\n\tcr4_fixed1_update(X86_CR4_SMXE,       ecx, feature_bit(SMX));\n\tcr4_fixed1_update(X86_CR4_PCIDE,      ecx, feature_bit(PCID));\n\tcr4_fixed1_update(X86_CR4_OSXSAVE,    ecx, feature_bit(XSAVE));\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tcr4_fixed1_update(X86_CR4_FSGSBASE,   ebx, feature_bit(FSGSBASE));\n\tcr4_fixed1_update(X86_CR4_SMEP,       ebx, feature_bit(SMEP));\n\tcr4_fixed1_update(X86_CR4_SMAP,       ebx, feature_bit(SMAP));\n\tcr4_fixed1_update(X86_CR4_PKE,        ecx, feature_bit(PKU));\n\tcr4_fixed1_update(X86_CR4_UMIP,       ecx, feature_bit(UMIP));\n\tcr4_fixed1_update(X86_CR4_LA57,       ecx, feature_bit(LA57));\n\n#undef cr4_fixed1_update\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_LA57",
            "ecx",
            "feature_bit(LA57)"
          ],
          "line": 6983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "feature_bit",
          "args": [
            "LA57"
          ],
          "line": 6983
        },
        "resolved": true,
        "details": {
          "function_name": "__feature_bit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "85-89",
          "snippet": "static __always_inline u32 __feature_bit(int x86_feature)\n{\n\treverse_cpuid_check(x86_feature / 32);\n\treturn 1 << (x86_feature & 31);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline u32 __feature_bit(int x86_feature)\n{\n\treverse_cpuid_check(x86_feature / 32);\n\treturn 1 << (x86_feature & 31);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_UMIP",
            "ecx",
            "feature_bit(UMIP)"
          ],
          "line": 6982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_PKE",
            "ecx",
            "feature_bit(PKU)"
          ],
          "line": 6981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_SMAP",
            "ebx",
            "feature_bit(SMAP)"
          ],
          "line": 6980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_SMEP",
            "ebx",
            "feature_bit(SMEP)"
          ],
          "line": 6979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_FSGSBASE",
            "ebx",
            "feature_bit(FSGSBASE)"
          ],
          "line": 6978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "vcpu",
            "0x7",
            "0"
          ],
          "line": 6977
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.c",
          "lines": "903-917",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *e;\n\tint i;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\n\t\tif (e->function == function && (e->index == index ||\n\t\t    !(e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX)))\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/processor.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/processor.h>\n#include <linux/sched/stat.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *e;\n\tint i;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\n\t\tif (e->function == function && (e->index == index ||\n\t\t    !(e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX)))\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_OSXSAVE",
            "ecx",
            "feature_bit(XSAVE)"
          ],
          "line": 6975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_PCIDE",
            "ecx",
            "feature_bit(PCID)"
          ],
          "line": 6974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_SMXE",
            "ecx",
            "feature_bit(SMX)"
          ],
          "line": 6973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_VMXE",
            "ecx",
            "feature_bit(VMX)"
          ],
          "line": 6972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_OSXMMEXCPT",
            "edx",
            "feature_bit(XMM)"
          ],
          "line": 6971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_OSFXSR",
            "edx",
            "feature_bit(FXSR)"
          ],
          "line": 6970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_PGE",
            "edx",
            "feature_bit(PGE)"
          ],
          "line": 6969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_MCE",
            "edx",
            "feature_bit(MCE)"
          ],
          "line": 6968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_PAE",
            "edx",
            "feature_bit(PAE)"
          ],
          "line": 6967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_PSE",
            "edx",
            "feature_bit(PSE)"
          ],
          "line": 6966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_DE",
            "edx",
            "feature_bit(DE)"
          ],
          "line": 6965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_TSD",
            "edx",
            "feature_bit(TSC)"
          ],
          "line": 6964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_PVI",
            "edx",
            "feature_bit(VME)"
          ],
          "line": 6963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_fixed1_update",
          "args": [
            "X86_CR4_VME",
            "edx",
            "feature_bit(VME)"
          ],
          "line": 6962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 6950
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void nested_vmx_cr_fixed1_bits_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_cpuid_entry2 *entry;\n\n\tvmx->nested.msrs.cr0_fixed1 = 0xffffffff;\n\tvmx->nested.msrs.cr4_fixed1 = X86_CR4_PCE;\n\n#define cr4_fixed1_update(_cr4_mask, _reg, _cpuid_mask) do {\t\t\\\n\tif (entry && (entry->_reg & (_cpuid_mask)))\t\t\t\\\n\t\tvmx->nested.msrs.cr4_fixed1 |= (_cr4_mask);\t\\\n} while (0)\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tcr4_fixed1_update(X86_CR4_VME,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_PVI,        edx, feature_bit(VME));\n\tcr4_fixed1_update(X86_CR4_TSD,        edx, feature_bit(TSC));\n\tcr4_fixed1_update(X86_CR4_DE,         edx, feature_bit(DE));\n\tcr4_fixed1_update(X86_CR4_PSE,        edx, feature_bit(PSE));\n\tcr4_fixed1_update(X86_CR4_PAE,        edx, feature_bit(PAE));\n\tcr4_fixed1_update(X86_CR4_MCE,        edx, feature_bit(MCE));\n\tcr4_fixed1_update(X86_CR4_PGE,        edx, feature_bit(PGE));\n\tcr4_fixed1_update(X86_CR4_OSFXSR,     edx, feature_bit(FXSR));\n\tcr4_fixed1_update(X86_CR4_OSXMMEXCPT, edx, feature_bit(XMM));\n\tcr4_fixed1_update(X86_CR4_VMXE,       ecx, feature_bit(VMX));\n\tcr4_fixed1_update(X86_CR4_SMXE,       ecx, feature_bit(SMX));\n\tcr4_fixed1_update(X86_CR4_PCIDE,      ecx, feature_bit(PCID));\n\tcr4_fixed1_update(X86_CR4_OSXSAVE,    ecx, feature_bit(XSAVE));\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0x7, 0);\n\tcr4_fixed1_update(X86_CR4_FSGSBASE,   ebx, feature_bit(FSGSBASE));\n\tcr4_fixed1_update(X86_CR4_SMEP,       ebx, feature_bit(SMEP));\n\tcr4_fixed1_update(X86_CR4_SMAP,       ebx, feature_bit(SMAP));\n\tcr4_fixed1_update(X86_CR4_PKE,        ecx, feature_bit(PKU));\n\tcr4_fixed1_update(X86_CR4_UMIP,       ecx, feature_bit(UMIP));\n\tcr4_fixed1_update(X86_CR4_LA57,       ecx, feature_bit(LA57));\n\n#undef cr4_fixed1_update\n}"
  },
  {
    "function_name": "vmcs_set_secondary_exec_control",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6924-6942",
    "snippet": "static void vmcs_set_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\t/*\n\t * These bits in the secondary execution controls field\n\t * are dynamic, the others are mostly based on the hypervisor\n\t * architecture and the guest's CPUID.  Do not touch the\n\t * dynamic bits.\n\t */\n\tu32 mask =\n\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_DESC;\n\n\tu32 new_ctl = vmx->secondary_exec_control;\n\tu32 cur_ctl = secondary_exec_controls_get(vmx);\n\n\tsecondary_exec_controls_set(vmx, (new_ctl & ~mask) | (cur_ctl & mask));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "secondary_exec_controls_set",
          "args": [
            "vmx",
            "(new_ctl & ~mask) | (cur_ctl & mask)"
          ],
          "line": 6941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "secondary_exec_controls_get",
          "args": [
            "vmx"
          ],
          "line": 6939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmcs_set_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\t/*\n\t * These bits in the secondary execution controls field\n\t * are dynamic, the others are mostly based on the hypervisor\n\t * architecture and the guest's CPUID.  Do not touch the\n\t * dynamic bits.\n\t */\n\tu32 mask =\n\t\tSECONDARY_EXEC_SHADOW_VMCS |\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE |\n\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\tSECONDARY_EXEC_DESC;\n\n\tu32 new_ctl = vmx->secondary_exec_control;\n\tu32 cur_ctl = secondary_exec_controls_get(vmx);\n\n\tsecondary_exec_controls_set(vmx, (new_ctl & ~mask) | (cur_ctl & mask));\n}"
  },
  {
    "function_name": "vmx_get_mt_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6875-6922",
    "snippet": "static u64 vmx_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\tu8 cache;\n\tu64 ipat = 0;\n\n\t/* We wanted to honor guest CD/MTRR/PAT, but doing so could result in\n\t * memory aliases with conflicting memory types and sometimes MCEs.\n\t * We have to be careful as to what are honored and when.\n\t *\n\t * For MMIO, guest CD/MTRR are ignored.  The EPT memory type is set to\n\t * UC.  The effective memory type is UC or WC depending on guest PAT.\n\t * This was historically the source of MCEs and we want to be\n\t * conservative.\n\t *\n\t * When there is no need to deal with noncoherent DMA (e.g., no VT-d\n\t * or VT-d has snoop control), guest CD/MTRR/PAT are all ignored.  The\n\t * EPT memory type is set to WB.  The effective memory type is forced\n\t * WB.\n\t *\n\t * Otherwise, we trust guest.  Guest CD/MTRR/PAT are all honored.  The\n\t * EPT memory type is used to emulate guest CD/MTRR.\n\t */\n\n\tif (is_mmio) {\n\t\tcache = MTRR_TYPE_UNCACHABLE;\n\t\tgoto exit;\n\t}\n\n\tif (!kvm_arch_has_noncoherent_dma(vcpu->kvm)) {\n\t\tipat = VMX_EPT_IPAT_BIT;\n\t\tcache = MTRR_TYPE_WRBACK;\n\t\tgoto exit;\n\t}\n\n\tif (kvm_read_cr0(vcpu) & X86_CR0_CD) {\n\t\tipat = VMX_EPT_IPAT_BIT;\n\t\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\t\tcache = MTRR_TYPE_WRBACK;\n\t\telse\n\t\t\tcache = MTRR_TYPE_UNCACHABLE;\n\t\tgoto exit;\n\t}\n\n\tcache = kvm_mtrr_get_guest_memory_type(vcpu, gfn);\n\nexit:\n\treturn (cache << VMX_EPT_MT_EPTE_SHIFT) | ipat;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mtrr_get_guest_memory_type",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 6918
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mtrr_get_guest_memory_type",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mtrr.c",
          "lines": "619-692",
          "snippet": "u8 kvm_mtrr_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\tconst int wt_wb_mask = (1 << MTRR_TYPE_WRBACK)\n\t\t\t       | (1 << MTRR_TYPE_WRTHROUGH);\n\n\tstart = gfn_to_gpa(gfn);\n\tend = start + PAGE_SIZE;\n\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tint curr_type = iter.mem_type;\n\n\t\t/*\n\t\t * Please refer to Intel SDM Volume 3: 11.11.4.1 MTRR\n\t\t * Precedences.\n\t\t */\n\n\t\tif (type == -1) {\n\t\t\ttype = curr_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and the\n\t\t * memory types are identical, then that memory type is\n\t\t * used.\n\t\t */\n\t\tif (type == curr_type)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and one of\n\t\t * the memory types is UC, the UC memory type used.\n\t\t */\n\t\tif (curr_type == MTRR_TYPE_UNCACHABLE)\n\t\t\treturn MTRR_TYPE_UNCACHABLE;\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and the\n\t\t * memory types are WT and WB, the WT memory type is used.\n\t\t */\n\t\tif (((1 << type) & wt_wb_mask) &&\n\t\t      ((1 << curr_type) & wt_wb_mask)) {\n\t\t\ttype = MTRR_TYPE_WRTHROUGH;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For overlaps not defined by the above rules, processor\n\t\t * behavior is undefined.\n\t\t */\n\n\t\t/* We use WB for this undefined behavior. :( */\n\t\treturn MTRR_TYPE_WRBACK;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn mtrr_disabled_type(vcpu);\n\n\t/* not contained in any MTRRs. */\n\tif (type == -1)\n\t\treturn mtrr_default_type(mtrr_state);\n\n\t/*\n\t * We just check one page, partially covered by MTRRs is\n\t * impossible.\n\t */\n\tWARN_ON(iter.partial_map);\n\n\treturn type;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nu8 kvm_mtrr_get_guest_memory_type(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\tconst int wt_wb_mask = (1 << MTRR_TYPE_WRBACK)\n\t\t\t       | (1 << MTRR_TYPE_WRTHROUGH);\n\n\tstart = gfn_to_gpa(gfn);\n\tend = start + PAGE_SIZE;\n\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tint curr_type = iter.mem_type;\n\n\t\t/*\n\t\t * Please refer to Intel SDM Volume 3: 11.11.4.1 MTRR\n\t\t * Precedences.\n\t\t */\n\n\t\tif (type == -1) {\n\t\t\ttype = curr_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and the\n\t\t * memory types are identical, then that memory type is\n\t\t * used.\n\t\t */\n\t\tif (type == curr_type)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and one of\n\t\t * the memory types is UC, the UC memory type used.\n\t\t */\n\t\tif (curr_type == MTRR_TYPE_UNCACHABLE)\n\t\t\treturn MTRR_TYPE_UNCACHABLE;\n\n\t\t/*\n\t\t * If two or more variable memory ranges match and the\n\t\t * memory types are WT and WB, the WT memory type is used.\n\t\t */\n\t\tif (((1 << type) & wt_wb_mask) &&\n\t\t      ((1 << curr_type) & wt_wb_mask)) {\n\t\t\ttype = MTRR_TYPE_WRTHROUGH;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * For overlaps not defined by the above rules, processor\n\t\t * behavior is undefined.\n\t\t */\n\n\t\t/* We use WB for this undefined behavior. :( */\n\t\treturn MTRR_TYPE_WRBACK;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn mtrr_disabled_type(vcpu);\n\n\t/* not contained in any MTRRs. */\n\tif (type == -1)\n\t\treturn mtrr_default_type(mtrr_state);\n\n\t/*\n\t * We just check one page, partially covered by MTRRs is\n\t * impossible.\n\t */\n\tWARN_ON(iter.partial_map);\n\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_has_quirk",
          "args": [
            "vcpu->kvm",
            "KVM_X86_QUIRK_CD_NW_CLEARED"
          ],
          "line": 6911
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_check_has_quirk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "233-236",
          "snippet": "static inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "vcpu"
          ],
          "line": 6909
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "124-127",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_arch_has_noncoherent_dma",
          "args": [
            "vcpu->kvm"
          ],
          "line": 6903
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_has_noncoherent_dma",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10478-10481",
          "snippet": "bool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_noncoherent_dma(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.noncoherent_dma_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic u64 vmx_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\tu8 cache;\n\tu64 ipat = 0;\n\n\t/* We wanted to honor guest CD/MTRR/PAT, but doing so could result in\n\t * memory aliases with conflicting memory types and sometimes MCEs.\n\t * We have to be careful as to what are honored and when.\n\t *\n\t * For MMIO, guest CD/MTRR are ignored.  The EPT memory type is set to\n\t * UC.  The effective memory type is UC or WC depending on guest PAT.\n\t * This was historically the source of MCEs and we want to be\n\t * conservative.\n\t *\n\t * When there is no need to deal with noncoherent DMA (e.g., no VT-d\n\t * or VT-d has snoop control), guest CD/MTRR/PAT are all ignored.  The\n\t * EPT memory type is set to WB.  The effective memory type is forced\n\t * WB.\n\t *\n\t * Otherwise, we trust guest.  Guest CD/MTRR/PAT are all honored.  The\n\t * EPT memory type is used to emulate guest CD/MTRR.\n\t */\n\n\tif (is_mmio) {\n\t\tcache = MTRR_TYPE_UNCACHABLE;\n\t\tgoto exit;\n\t}\n\n\tif (!kvm_arch_has_noncoherent_dma(vcpu->kvm)) {\n\t\tipat = VMX_EPT_IPAT_BIT;\n\t\tcache = MTRR_TYPE_WRBACK;\n\t\tgoto exit;\n\t}\n\n\tif (kvm_read_cr0(vcpu) & X86_CR0_CD) {\n\t\tipat = VMX_EPT_IPAT_BIT;\n\t\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\t\tcache = MTRR_TYPE_WRBACK;\n\t\telse\n\t\t\tcache = MTRR_TYPE_UNCACHABLE;\n\t\tgoto exit;\n\t}\n\n\tcache = kvm_mtrr_get_guest_memory_type(vcpu, gfn);\n\nexit:\n\treturn (cache << VMX_EPT_MT_EPTE_SHIFT) | ipat;\n}"
  },
  {
    "function_name": "vmx_check_processor_compat",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6852-6873",
    "snippet": "static int __init vmx_check_processor_compat(void)\n{\n\tstruct vmcs_config vmcs_conf;\n\tstruct vmx_capability vmx_cap;\n\n\tif (!this_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||\n\t    !this_cpu_has(X86_FEATURE_VMX)) {\n\t\tpr_err(\"kvm: VMX is disabled on CPU %d\\n\", smp_processor_id());\n\t\treturn -EIO;\n\t}\n\n\tif (setup_vmcs_config(&vmcs_conf, &vmx_cap) < 0)\n\t\treturn -EIO;\n\tif (nested)\n\t\tnested_vmx_setup_ctls_msrs(&vmcs_conf.nested, vmx_cap.ept);\n\tif (memcmp(&vmcs_config, &vmcs_conf, sizeof(struct vmcs_config)) != 0) {\n\t\tprintk(KERN_ERR \"kvm: CPU %d feature inconsistency!\\n\",\n\t\t\t\tsmp_processor_id());\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "struct vmcs_config vmcs_config;",
      "struct vmx_capability vmx_capability;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"kvm: CPU %d feature inconsistency!\\n\"",
            "smp_processor_id()"
          ],
          "line": 6868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 6869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&vmcs_config",
            "&vmcs_conf",
            "sizeof(struct vmcs_config)"
          ],
          "line": 6867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_vmx_setup_ctls_msrs",
          "args": [
            "&vmcs_conf.nested",
            "vmx_cap.ept"
          ],
          "line": 6866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_vmcs_config",
          "args": [
            "&vmcs_conf",
            "&vmx_cap"
          ],
          "line": 6863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"kvm: VMX is disabled on CPU %d\\n\"",
            "smp_processor_id()"
          ],
          "line": 6859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 6859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_has",
          "args": [
            "X86_FEATURE_VMX"
          ],
          "line": 6858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_has",
          "args": [
            "X86_FEATURE_MSR_IA32_FEAT_CTL"
          ],
          "line": 6857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstruct vmcs_config vmcs_config;\nstruct vmx_capability vmx_capability;\n\nstatic int __init vmx_check_processor_compat(void)\n{\n\tstruct vmcs_config vmcs_conf;\n\tstruct vmx_capability vmx_cap;\n\n\tif (!this_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||\n\t    !this_cpu_has(X86_FEATURE_VMX)) {\n\t\tpr_err(\"kvm: VMX is disabled on CPU %d\\n\", smp_processor_id());\n\t\treturn -EIO;\n\t}\n\n\tif (setup_vmcs_config(&vmcs_conf, &vmx_cap) < 0)\n\t\treturn -EIO;\n\tif (nested)\n\t\tnested_vmx_setup_ctls_msrs(&vmcs_conf.nested, vmx_cap.ept);\n\tif (memcmp(&vmcs_config, &vmcs_conf, sizeof(struct vmcs_config)) != 0) {\n\t\tprintk(KERN_ERR \"kvm: CPU %d feature inconsistency!\\n\",\n\t\t\t\tsmp_processor_id());\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_vm_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6818-6850",
    "snippet": "static int vmx_vm_init(struct kvm *kvm)\n{\n\tspin_lock_init(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\n\tif (!ple_gap)\n\t\tkvm->arch.pause_in_guest = true;\n\n\tif (boot_cpu_has(X86_BUG_L1TF) && enable_ept) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\t\t/* 'I explicitly don't care' is set */\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\tcase L1TF_MITIGATION_FULL:\n\t\t\t/*\n\t\t\t * Warn upon starting the first VM in a potentially\n\t\t\t * insecure environment.\n\t\t\t */\n\t\t\tif (sched_smt_active())\n\t\t\t\tpr_warn_once(L1TF_MSG_SMT);\n\t\t\tif (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_NEVER)\n\t\t\t\tpr_warn_once(L1TF_MSG_L1D);\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\t/* Flush is enforced */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkvm_apicv_init(kvm, enable_apicv);\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define L1TF_MSG_L1D \"L1TF CPU bug present and virtualization mitigation disabled, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/l1tf.html for details.\\n\"",
      "#define L1TF_MSG_SMT \"L1TF CPU bug present and SMT on, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/l1tf.html for details.\\n\""
    ],
    "globals_used": [
      "static unsigned int ple_gap = KVM_DEFAULT_PLE_GAP;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apicv_init",
          "args": [
            "kvm",
            "enable_apicv"
          ],
          "line": 6848
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apicv_init",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7501-7509",
          "snippet": "void kvm_apicv_init(struct kvm *kvm, bool enable)\n{\n\tif (enable)\n\t\tclear_bit(APICV_INHIBIT_REASON_DISABLE,\n\t\t\t  &kvm->arch.apicv_inhibit_reasons);\n\telse\n\t\tset_bit(APICV_INHIBIT_REASON_DISABLE,\n\t\t\t&kvm->arch.apicv_inhibit_reasons);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_apicv_init(struct kvm *kvm, bool enable)\n{\n\tif (enable)\n\t\tclear_bit(APICV_INHIBIT_REASON_DISABLE,\n\t\t\t  &kvm->arch.apicv_inhibit_reasons);\n\telse\n\t\tset_bit(APICV_INHIBIT_REASON_DISABLE,\n\t\t\t&kvm->arch.apicv_inhibit_reasons);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "L1TF_MSG_L1D"
          ],
          "line": 6841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_once",
          "args": [
            "L1TF_MSG_SMT"
          ],
          "line": 6839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_smt_active",
          "args": [],
          "line": 6838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_BUG_L1TF"
          ],
          "line": 6825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&to_kvm_vmx(kvm)->ept_pointer_lock"
          ],
          "line": 6820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_vmx",
          "args": [
            "kvm"
          ],
          "line": 6820
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "474-477",
          "snippet": "static inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define L1TF_MSG_L1D \"L1TF CPU bug present and virtualization mitigation disabled, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/l1tf.html for details.\\n\"\n#define L1TF_MSG_SMT \"L1TF CPU bug present and SMT on, data leak possible. See CVE-2018-3646 and https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/l1tf.html for details.\\n\"\n\nstatic unsigned int ple_gap = KVM_DEFAULT_PLE_GAP;\n\nstatic int vmx_vm_init(struct kvm *kvm)\n{\n\tspin_lock_init(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\n\tif (!ple_gap)\n\t\tkvm->arch.pause_in_guest = true;\n\n\tif (boot_cpu_has(X86_BUG_L1TF) && enable_ept) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\t\t/* 'I explicitly don't care' is set */\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\tcase L1TF_MITIGATION_FULL:\n\t\t\t/*\n\t\t\t * Warn upon starting the first VM in a potentially\n\t\t\t * insecure environment.\n\t\t\t */\n\t\t\tif (sched_smt_active())\n\t\t\t\tpr_warn_once(L1TF_MSG_SMT);\n\t\t\tif (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_NEVER)\n\t\t\t\tpr_warn_once(L1TF_MSG_L1D);\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\t/* Flush is enforced */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkvm_apicv_init(kvm, enable_apicv);\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_create_vcpu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6689-6813",
    "snippet": "static int vmx_create_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx;\n\tunsigned long *msr_bitmap;\n\tint i, cpu, err;\n\n\tBUILD_BUG_ON(offsetof(struct vcpu_vmx, vcpu) != 0);\n\tvmx = to_vmx(vcpu);\n\n\terr = -ENOMEM;\n\n\tvmx->vpid = allocate_vpid();\n\n\t/*\n\t * If PML is turned on, failure on enabling PML just results in failure\n\t * of creating the vcpu, therefore we can simplify PML logic (by\n\t * avoiding dealing with cases, such as enabling PML partially on vcpus\n\t * for the guest), etc.\n\t */\n\tif (enable_pml) {\n\t\tvmx->pml_pg = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\t\tif (!vmx->pml_pg)\n\t\t\tgoto free_vpid;\n\t}\n\n\tBUILD_BUG_ON(ARRAY_SIZE(vmx_msr_index) != NR_SHARED_MSRS);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i) {\n\t\tu32 index = vmx_msr_index[i];\n\t\tu32 data_low, data_high;\n\t\tint j = vmx->nmsrs;\n\n\t\tif (rdmsr_safe(index, &data_low, &data_high) < 0)\n\t\t\tcontinue;\n\t\tif (wrmsr_safe(index, data_low, data_high) < 0)\n\t\t\tcontinue;\n\n\t\tvmx->guest_msrs[j].index = i;\n\t\tvmx->guest_msrs[j].data = 0;\n\t\tswitch (index) {\n\t\tcase MSR_IA32_TSX_CTRL:\n\t\t\t/*\n\t\t\t * No need to pass TSX_CTRL_CPUID_CLEAR through, so\n\t\t\t * let's avoid changing CPUID bits under the host\n\t\t\t * kernel's feet.\n\t\t\t */\n\t\t\tvmx->guest_msrs[j].mask = ~(u64)TSX_CTRL_CPUID_CLEAR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvmx->guest_msrs[j].mask = -1ull;\n\t\t\tbreak;\n\t\t}\n\t\t++vmx->nmsrs;\n\t}\n\n\terr = alloc_loaded_vmcs(&vmx->vmcs01);\n\tif (err < 0)\n\t\tgoto free_pml;\n\n\tmsr_bitmap = vmx->vmcs01.msr_bitmap;\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_IA32_TSC, MSR_TYPE_R);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_FS_BASE, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_GS_BASE, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_KERNEL_GS_BASE, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_IA32_SYSENTER_CS, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_IA32_SYSENTER_ESP, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_IA32_SYSENTER_EIP, MSR_TYPE_RW);\n\tif (kvm_cstate_in_guest(vcpu->kvm)) {\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_CORE_C1_RES, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_CORE_C3_RESIDENCY, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_CORE_C6_RESIDENCY, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_CORE_C7_RESIDENCY, MSR_TYPE_R);\n\t}\n\tvmx->msr_bitmap_mode = 0;\n\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\tcpu = get_cpu();\n\tvmx_vcpu_load(vcpu, cpu);\n\tvcpu->cpu = cpu;\n\tinit_vmcs(vmx);\n\tvmx_vcpu_put(vcpu);\n\tput_cpu();\n\tif (cpu_need_virtualize_apic_accesses(vcpu)) {\n\t\terr = alloc_apic_access_page(vcpu->kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (enable_ept && !enable_unrestricted_guest) {\n\t\terr = init_rmode_identity_map(vcpu->kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (nested)\n\t\tnested_vmx_setup_ctls_msrs(&vmx->nested.msrs,\n\t\t\t\t\t   vmx_capability.ept);\n\telse\n\t\tmemset(&vmx->nested.msrs, 0, sizeof(vmx->nested.msrs));\n\n\tvmx->nested.posted_intr_nv = -1;\n\tvmx->nested.current_vmptr = -1ull;\n\n\tvcpu->arch.microcode_version = 0x100000000ULL;\n\tvmx->msr_ia32_feature_control_valid_bits = FEAT_CTL_LOCKED;\n\n\t/*\n\t * Enforce invariant: pi_desc.nv is always either POSTED_INTR_VECTOR\n\t * or POSTED_INTR_WAKEUP_VECTOR.\n\t */\n\tvmx->pi_desc.nv = POSTED_INTR_VECTOR;\n\tvmx->pi_desc.sn = 1;\n\n\tvmx->ept_pointer = INVALID_PAGE;\n\n\treturn 0;\n\nfree_vmcs:\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\nfree_pml:\n\tvmx_destroy_pml_buffer(vmx);\nfree_vpid:\n\tfree_vpid(vmx->vpid);\n\treturn err;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "struct vmx_capability vmx_capability;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_vpid",
          "args": [
            "vmx->vpid"
          ],
          "line": 6811
        },
        "resolved": true,
        "details": {
          "function_name": "free_vpid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3582-3589",
          "snippet": "void free_vpid(int vpid)\n{\n\tif (!enable_vpid || vpid == 0)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\t__clear_bit(vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmx_vpid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic DEFINE_SPINLOCK(vmx_vpid_lock);\n\nvoid free_vpid(int vpid)\n{\n\tif (!enable_vpid || vpid == 0)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\t__clear_bit(vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_destroy_pml_buffer",
          "args": [
            "vmx"
          ],
          "line": 6809
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_destroy_pml_buffer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5588-5594",
          "snippet": "static void vmx_destroy_pml_buffer(struct vcpu_vmx *vmx)\n{\n\tif (vmx->pml_pg) {\n\t\t__free_page(vmx->pml_pg);\n\t\tvmx->pml_pg = NULL;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_destroy_pml_buffer(struct vcpu_vmx *vmx)\n{\n\tif (vmx->pml_pg) {\n\t\t__free_page(vmx->pml_pg);\n\t\tvmx->pml_pg = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_loaded_vmcs",
          "args": [
            "vmx->loaded_vmcs"
          ],
          "line": 6807
        },
        "resolved": true,
        "details": {
          "function_name": "free_loaded_vmcs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2565-2575",
          "snippet": "void free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tif (loaded_vmcs->msr_bitmap)\n\t\tfree_page((unsigned long)loaded_vmcs->msr_bitmap);\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tif (loaded_vmcs->msr_bitmap)\n\t\tfree_page((unsigned long)loaded_vmcs->msr_bitmap);\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&vmx->nested.msrs",
            "0",
            "sizeof(vmx->nested.msrs)"
          ],
          "line": 6787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_vmx_setup_ctls_msrs",
          "args": [
            "&vmx->nested.msrs",
            "vmx_capability.ept"
          ],
          "line": 6784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rmode_identity_map",
          "args": [
            "vcpu->kvm"
          ],
          "line": 6778
        },
        "resolved": true,
        "details": {
          "function_name": "init_rmode_identity_map",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3480-3519",
          "snippet": "static int init_rmode_identity_map(struct kvm *kvm)\n{\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(kvm);\n\tint i, r = 0;\n\tkvm_pfn_t identity_map_pfn;\n\tu32 tmp;\n\n\t/* Protect kvm_vmx->ept_identity_pagetable_done. */\n\tmutex_lock(&kvm->slots_lock);\n\n\tif (likely(kvm_vmx->ept_identity_pagetable_done))\n\t\tgoto out;\n\n\tif (!kvm_vmx->ept_identity_map_addr)\n\t\tkvm_vmx->ept_identity_map_addr = VMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\tidentity_map_pfn = kvm_vmx->ept_identity_map_addr >> PAGE_SHIFT;\n\n\tr = __x86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,\n\t\t\t\t    kvm_vmx->ept_identity_map_addr, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = kvm_clear_guest_page(kvm, identity_map_pfn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\t/* Set up identity-mapping pagetable for EPT in real mode */\n\tfor (i = 0; i < PT32_ENT_PER_PAGE; i++) {\n\t\ttmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |\n\t\t\t_PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_PSE);\n\t\tr = kvm_write_guest_page(kvm, identity_map_pfn,\n\t\t\t\t&tmp, i * sizeof(tmp), sizeof(tmp));\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\tkvm_vmx->ept_identity_pagetable_done = true;\n\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int init_rmode_identity_map(struct kvm *kvm)\n{\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(kvm);\n\tint i, r = 0;\n\tkvm_pfn_t identity_map_pfn;\n\tu32 tmp;\n\n\t/* Protect kvm_vmx->ept_identity_pagetable_done. */\n\tmutex_lock(&kvm->slots_lock);\n\n\tif (likely(kvm_vmx->ept_identity_pagetable_done))\n\t\tgoto out;\n\n\tif (!kvm_vmx->ept_identity_map_addr)\n\t\tkvm_vmx->ept_identity_map_addr = VMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\tidentity_map_pfn = kvm_vmx->ept_identity_map_addr >> PAGE_SHIFT;\n\n\tr = __x86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,\n\t\t\t\t    kvm_vmx->ept_identity_map_addr, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = kvm_clear_guest_page(kvm, identity_map_pfn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\t/* Set up identity-mapping pagetable for EPT in real mode */\n\tfor (i = 0; i < PT32_ENT_PER_PAGE; i++) {\n\t\ttmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |\n\t\t\t_PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_PSE);\n\t\tr = kvm_write_guest_page(kvm, identity_map_pfn,\n\t\t\t\t&tmp, i * sizeof(tmp), sizeof(tmp));\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\tkvm_vmx->ept_identity_pagetable_done = true;\n\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_apic_access_page",
          "args": [
            "vcpu->kvm"
          ],
          "line": 6772
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_apic_access_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3536-3564",
          "snippet": "static int alloc_apic_access_page(struct kvm *kvm)\n{\n\tstruct page *page;\n\tint r = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tif (kvm->arch.apic_access_page_done)\n\t\tgoto out;\n\tr = __x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t    APIC_DEFAULT_PHYS_BASE, PAGE_SIZE);\n\tif (r)\n\t\tgoto out;\n\n\tpage = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not pin the page in memory, so that memory hot-unplug\n\t * is able to migrate it.\n\t */\n\tput_page(page);\n\tkvm->arch.apic_access_page_done = true;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int alloc_apic_access_page(struct kvm *kvm)\n{\n\tstruct page *page;\n\tint r = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tif (kvm->arch.apic_access_page_done)\n\t\tgoto out;\n\tr = __x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t    APIC_DEFAULT_PHYS_BASE, PAGE_SIZE);\n\tif (r)\n\t\tgoto out;\n\n\tpage = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not pin the page in memory, so that memory hot-unplug\n\t * is able to migrate it.\n\t */\n\tput_page(page);\n\tkvm->arch.apic_access_page_done = true;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_need_virtualize_apic_accesses",
          "args": [
            "vcpu"
          ],
          "line": 6771
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_need_virtualize_apic_accesses",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "613-616",
          "snippet": "static inline bool cpu_need_virtualize_apic_accesses(struct kvm_vcpu *vcpu)\n{\n\treturn flexpriority_enabled && lapic_in_kernel(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic inline bool cpu_need_virtualize_apic_accesses(struct kvm_vcpu *vcpu)\n{\n\treturn flexpriority_enabled && lapic_in_kernel(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 6770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_vcpu_put",
          "args": [
            "vcpu"
          ],
          "line": 6769
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_vcpu_put",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1393-1398",
          "snippet": "static void vmx_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tvmx_vcpu_pi_put(vcpu);\n\n\tvmx_prepare_switch_to_host(to_vmx(vcpu));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tvmx_vcpu_pi_put(vcpu);\n\n\tvmx_prepare_switch_to_host(to_vmx(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_vmcs",
          "args": [
            "vmx"
          ],
          "line": 6768
        },
        "resolved": true,
        "details": {
          "function_name": "init_vmcs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4165-4255",
          "snippet": "static void init_vmcs(struct vcpu_vmx *vmx)\n{\n\tif (nested)\n\t\tnested_vmx_set_vmcs_shadowing_bitmap();\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx->vmcs01.msr_bitmap));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tpin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));\n\n\texec_controls_set(vmx, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmx_compute_secondary_exec_control(vmx);\n\t\tsecondary_exec_controls_set(vmx, vmx->secondary_exec_control);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&vmx->vcpu)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (!kvm_pause_in_guest(vmx->vcpu.kvm)) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n\n\tif (cpu_has_vmx_vmfunc())\n\t\tvmcs_write64(VM_FUNCTION_CONTROL, 0);\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host.val));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest.val));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\tvm_exit_controls_set(vmx, vmx_vmexit_ctrl());\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_set(vmx, vmx_vmentry_ctrl());\n\n\tvmx->vcpu.arch.cr0_guest_owned_bits = X86_CR0_TS;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~X86_CR0_TS);\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmx->vpid != 0)\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\n\tif (vmx_xsaves_supported())\n\t\tvmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);\n\n\tif (enable_pml) {\n\t\tvmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));\n\t\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n\t}\n\n\tif (cpu_has_vmx_encls_vmexit())\n\t\tvmcs_write64(ENCLS_EXITING_BITMAP, -1ull);\n\n\tif (vmx_pt_mode_is_host_guest()) {\n\t\tmemset(&vmx->pt_desc, 0, sizeof(vmx->pt_desc));\n\t\t/* Bit[6~0] are forced to 1, writes are ignored. */\n\t\tvmx->pt_desc.guest.output_mask = 0x7F;\n\t\tvmcs_write64(GUEST_IA32_RTIT_CTL, 0);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define VMX_XSS_EXIT_BITMAP 0"
          ],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static unsigned int ple_gap = KVM_DEFAULT_PLE_GAP;",
            "static unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "struct vmcs_config vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define VMX_XSS_EXIT_BITMAP 0\n\nstatic bool __read_mostly nested = 1;\nstatic unsigned int ple_gap = KVM_DEFAULT_PLE_GAP;\nstatic unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmcs_config vmcs_config;\n\nstatic void init_vmcs(struct vcpu_vmx *vmx)\n{\n\tif (nested)\n\t\tnested_vmx_set_vmcs_shadowing_bitmap();\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx->vmcs01.msr_bitmap));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tpin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));\n\n\texec_controls_set(vmx, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmx_compute_secondary_exec_control(vmx);\n\t\tsecondary_exec_controls_set(vmx, vmx->secondary_exec_control);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&vmx->vcpu)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (!kvm_pause_in_guest(vmx->vcpu.kvm)) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n\n\tif (cpu_has_vmx_vmfunc())\n\t\tvmcs_write64(VM_FUNCTION_CONTROL, 0);\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host.val));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest.val));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\tvm_exit_controls_set(vmx, vmx_vmexit_ctrl());\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_set(vmx, vmx_vmentry_ctrl());\n\n\tvmx->vcpu.arch.cr0_guest_owned_bits = X86_CR0_TS;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~X86_CR0_TS);\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmx->vpid != 0)\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\n\tif (vmx_xsaves_supported())\n\t\tvmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);\n\n\tif (enable_pml) {\n\t\tvmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));\n\t\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n\t}\n\n\tif (cpu_has_vmx_encls_vmexit())\n\t\tvmcs_write64(ENCLS_EXITING_BITMAP, -1ull);\n\n\tif (vmx_pt_mode_is_host_guest()) {\n\t\tmemset(&vmx->pt_desc, 0, sizeof(vmx->pt_desc));\n\t\t/* Bit[6~0] are forced to 1, writes are ignored. */\n\t\tvmx->pt_desc.guest.output_mask = 0x7F;\n\t\tvmcs_write64(GUEST_IA32_RTIT_CTL, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_vcpu_load",
          "args": [
            "vcpu",
            "cpu"
          ],
          "line": 6766
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_vcpu_load",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1367-1377",
          "snippet": "void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx_vcpu_load_vmcs(vcpu, cpu);\n\n\tvmx_vcpu_pi_load(vcpu, cpu);\n\n\tvmx->host_pkru = read_pkru();\n\tvmx->host_debugctlmsr = get_debugctlmsr();\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx_vcpu_load_vmcs(vcpu, cpu);\n\n\tvmx_vcpu_pi_load(vcpu, cpu);\n\n\tvmx->host_pkru = read_pkru();\n\tvmx->host_debugctlmsr = get_debugctlmsr();\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 6765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_disable_intercept_for_msr",
          "args": [
            "msr_bitmap",
            "MSR_CORE_C7_RESIDENCY",
            "MSR_TYPE_R"
          ],
          "line": 6760
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_disable_intercept_for_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3591-3627",
          "snippet": "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cstate_in_guest",
          "args": [
            "vcpu->kvm"
          ],
          "line": 6756
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cstate_in_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "326-329",
          "snippet": "static inline bool kvm_cstate_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.cstate_in_guest;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_cstate_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.cstate_in_guest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_loaded_vmcs",
          "args": [
            "&vmx->vmcs01"
          ],
          "line": 6744
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_loaded_vmcs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2577-2616",
          "snippet": "int alloc_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tloaded_vmcs->vmcs = alloc_vmcs(false);\n\tif (!loaded_vmcs->vmcs)\n\t\treturn -ENOMEM;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\n\tloaded_vmcs->shadow_vmcs = NULL;\n\tloaded_vmcs->hv_timer_soft_disabled = false;\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n\n\tif (cpu_has_vmx_msr_bitmap()) {\n\t\tloaded_vmcs->msr_bitmap = (unsigned long *)\n\t\t\t\t__get_free_page(GFP_KERNEL_ACCOUNT);\n\t\tif (!loaded_vmcs->msr_bitmap)\n\t\t\tgoto out_vmcs;\n\t\tmemset(loaded_vmcs->msr_bitmap, 0xff, PAGE_SIZE);\n\n\t\tif (IS_ENABLED(CONFIG_HYPERV) &&\n\t\t    static_branch_unlikely(&enable_evmcs) &&\n\t\t    (ms_hyperv.nested_features & HV_X64_NESTED_MSR_BITMAP)) {\n\t\t\tstruct hv_enlightened_vmcs *evmcs =\n\t\t\t\t(struct hv_enlightened_vmcs *)loaded_vmcs->vmcs;\n\n\t\t\tevmcs->hv_enlightenments_control.msr_bitmap = 1;\n\t\t}\n\t}\n\n\tmemset(&loaded_vmcs->host_state, 0, sizeof(struct vmcs_host_state));\n\tmemset(&loaded_vmcs->controls_shadow, 0,\n\t\tsizeof(struct vmcs_controls_shadow));\n\n\treturn 0;\n\nout_vmcs:\n\tfree_loaded_vmcs(loaded_vmcs);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nint alloc_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tloaded_vmcs->vmcs = alloc_vmcs(false);\n\tif (!loaded_vmcs->vmcs)\n\t\treturn -ENOMEM;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\n\tloaded_vmcs->shadow_vmcs = NULL;\n\tloaded_vmcs->hv_timer_soft_disabled = false;\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n\n\tif (cpu_has_vmx_msr_bitmap()) {\n\t\tloaded_vmcs->msr_bitmap = (unsigned long *)\n\t\t\t\t__get_free_page(GFP_KERNEL_ACCOUNT);\n\t\tif (!loaded_vmcs->msr_bitmap)\n\t\t\tgoto out_vmcs;\n\t\tmemset(loaded_vmcs->msr_bitmap, 0xff, PAGE_SIZE);\n\n\t\tif (IS_ENABLED(CONFIG_HYPERV) &&\n\t\t    static_branch_unlikely(&enable_evmcs) &&\n\t\t    (ms_hyperv.nested_features & HV_X64_NESTED_MSR_BITMAP)) {\n\t\t\tstruct hv_enlightened_vmcs *evmcs =\n\t\t\t\t(struct hv_enlightened_vmcs *)loaded_vmcs->vmcs;\n\n\t\t\tevmcs->hv_enlightenments_control.msr_bitmap = 1;\n\t\t}\n\t}\n\n\tmemset(&loaded_vmcs->host_state, 0, sizeof(struct vmcs_host_state));\n\tmemset(&loaded_vmcs->controls_shadow, 0,\n\t\tsizeof(struct vmcs_controls_shadow));\n\n\treturn 0;\n\nout_vmcs:\n\tfree_loaded_vmcs(loaded_vmcs);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrmsr_safe",
          "args": [
            "index",
            "data_low",
            "data_high"
          ],
          "line": 6723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsr_safe",
          "args": [
            "index",
            "&data_low",
            "&data_high"
          ],
          "line": 6721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vmx_msr_index"
          ],
          "line": 6716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ARRAY_SIZE(vmx_msr_index) != NR_SHARED_MSRS"
          ],
          "line": 6714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vmx_msr_index"
          ],
          "line": 6714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL_ACCOUNT | __GFP_ZERO"
          ],
          "line": 6709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_vpid",
          "args": [],
          "line": 6700
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_vpid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3566-3580",
          "snippet": "int allocate_vpid(void)\n{\n\tint vpid;\n\n\tif (!enable_vpid)\n\t\treturn 0;\n\tspin_lock(&vmx_vpid_lock);\n\tvpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);\n\tif (vpid < VMX_NR_VPIDS)\n\t\t__set_bit(vpid, vmx_vpid_bitmap);\n\telse\n\t\tvpid = 0;\n\tspin_unlock(&vmx_vpid_lock);\n\treturn vpid;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_BITMAP(vmx_vpid_bitmap, VMX_NR_VPIDS);",
            "static DEFINE_SPINLOCK(vmx_vpid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic DECLARE_BITMAP(vmx_vpid_bitmap, VMX_NR_VPIDS);\nstatic DEFINE_SPINLOCK(vmx_vpid_lock);\n\nint allocate_vpid(void)\n{\n\tint vpid;\n\n\tif (!enable_vpid)\n\t\treturn 0;\n\tspin_lock(&vmx_vpid_lock);\n\tvpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);\n\tif (vpid < VMX_NR_VPIDS)\n\t\t__set_bit(vpid, vmx_vpid_bitmap);\n\telse\n\t\tvpid = 0;\n\tspin_unlock(&vmx_vpid_lock);\n\treturn vpid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 6696
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct vcpu_vmx, vcpu) != 0"
          ],
          "line": 6695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmx_capability vmx_capability;\n\nstatic int vmx_create_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx;\n\tunsigned long *msr_bitmap;\n\tint i, cpu, err;\n\n\tBUILD_BUG_ON(offsetof(struct vcpu_vmx, vcpu) != 0);\n\tvmx = to_vmx(vcpu);\n\n\terr = -ENOMEM;\n\n\tvmx->vpid = allocate_vpid();\n\n\t/*\n\t * If PML is turned on, failure on enabling PML just results in failure\n\t * of creating the vcpu, therefore we can simplify PML logic (by\n\t * avoiding dealing with cases, such as enabling PML partially on vcpus\n\t * for the guest), etc.\n\t */\n\tif (enable_pml) {\n\t\tvmx->pml_pg = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_ZERO);\n\t\tif (!vmx->pml_pg)\n\t\t\tgoto free_vpid;\n\t}\n\n\tBUILD_BUG_ON(ARRAY_SIZE(vmx_msr_index) != NR_SHARED_MSRS);\n\n\tfor (i = 0; i < ARRAY_SIZE(vmx_msr_index); ++i) {\n\t\tu32 index = vmx_msr_index[i];\n\t\tu32 data_low, data_high;\n\t\tint j = vmx->nmsrs;\n\n\t\tif (rdmsr_safe(index, &data_low, &data_high) < 0)\n\t\t\tcontinue;\n\t\tif (wrmsr_safe(index, data_low, data_high) < 0)\n\t\t\tcontinue;\n\n\t\tvmx->guest_msrs[j].index = i;\n\t\tvmx->guest_msrs[j].data = 0;\n\t\tswitch (index) {\n\t\tcase MSR_IA32_TSX_CTRL:\n\t\t\t/*\n\t\t\t * No need to pass TSX_CTRL_CPUID_CLEAR through, so\n\t\t\t * let's avoid changing CPUID bits under the host\n\t\t\t * kernel's feet.\n\t\t\t */\n\t\t\tvmx->guest_msrs[j].mask = ~(u64)TSX_CTRL_CPUID_CLEAR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvmx->guest_msrs[j].mask = -1ull;\n\t\t\tbreak;\n\t\t}\n\t\t++vmx->nmsrs;\n\t}\n\n\terr = alloc_loaded_vmcs(&vmx->vmcs01);\n\tif (err < 0)\n\t\tgoto free_pml;\n\n\tmsr_bitmap = vmx->vmcs01.msr_bitmap;\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_IA32_TSC, MSR_TYPE_R);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_FS_BASE, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_GS_BASE, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_KERNEL_GS_BASE, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_IA32_SYSENTER_CS, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_IA32_SYSENTER_ESP, MSR_TYPE_RW);\n\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_IA32_SYSENTER_EIP, MSR_TYPE_RW);\n\tif (kvm_cstate_in_guest(vcpu->kvm)) {\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_CORE_C1_RES, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_CORE_C3_RESIDENCY, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_CORE_C6_RESIDENCY, MSR_TYPE_R);\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, MSR_CORE_C7_RESIDENCY, MSR_TYPE_R);\n\t}\n\tvmx->msr_bitmap_mode = 0;\n\n\tvmx->loaded_vmcs = &vmx->vmcs01;\n\tcpu = get_cpu();\n\tvmx_vcpu_load(vcpu, cpu);\n\tvcpu->cpu = cpu;\n\tinit_vmcs(vmx);\n\tvmx_vcpu_put(vcpu);\n\tput_cpu();\n\tif (cpu_need_virtualize_apic_accesses(vcpu)) {\n\t\terr = alloc_apic_access_page(vcpu->kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (enable_ept && !enable_unrestricted_guest) {\n\t\terr = init_rmode_identity_map(vcpu->kvm);\n\t\tif (err)\n\t\t\tgoto free_vmcs;\n\t}\n\n\tif (nested)\n\t\tnested_vmx_setup_ctls_msrs(&vmx->nested.msrs,\n\t\t\t\t\t   vmx_capability.ept);\n\telse\n\t\tmemset(&vmx->nested.msrs, 0, sizeof(vmx->nested.msrs));\n\n\tvmx->nested.posted_intr_nv = -1;\n\tvmx->nested.current_vmptr = -1ull;\n\n\tvcpu->arch.microcode_version = 0x100000000ULL;\n\tvmx->msr_ia32_feature_control_valid_bits = FEAT_CTL_LOCKED;\n\n\t/*\n\t * Enforce invariant: pi_desc.nv is always either POSTED_INTR_VECTOR\n\t * or POSTED_INTR_WAKEUP_VECTOR.\n\t */\n\tvmx->pi_desc.nv = POSTED_INTR_VECTOR;\n\tvmx->pi_desc.sn = 1;\n\n\tvmx->ept_pointer = INVALID_PAGE;\n\n\treturn 0;\n\nfree_vmcs:\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\nfree_pml:\n\tvmx_destroy_pml_buffer(vmx);\nfree_vpid:\n\tfree_vpid(vmx->vpid);\n\treturn err;\n}"
  },
  {
    "function_name": "vmx_free_vcpu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6678-6687",
    "snippet": "static void vmx_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (enable_pml)\n\t\tvmx_destroy_pml_buffer(vmx);\n\tfree_vpid(vmx->vpid);\n\tnested_vmx_free_vcpu(vcpu);\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_loaded_vmcs",
          "args": [
            "vmx->loaded_vmcs"
          ],
          "line": 6686
        },
        "resolved": true,
        "details": {
          "function_name": "free_loaded_vmcs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2565-2575",
          "snippet": "void free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tif (loaded_vmcs->msr_bitmap)\n\t\tfree_page((unsigned long)loaded_vmcs->msr_bitmap);\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tif (loaded_vmcs->msr_bitmap)\n\t\tfree_page((unsigned long)loaded_vmcs->msr_bitmap);\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_free_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 6685
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_free_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "317-324",
          "snippet": "void nested_vmx_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tvcpu_load(vcpu);\n\tvmx_leave_nested(vcpu);\n\tvmx_switch_vmcs(vcpu, &to_vmx(vcpu)->vmcs01);\n\tfree_nested(vcpu);\n\tvcpu_put(vcpu);\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nvoid nested_vmx_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tvcpu_load(vcpu);\n\tvmx_leave_nested(vcpu);\n\tvmx_switch_vmcs(vcpu, &to_vmx(vcpu)->vmcs01);\n\tfree_nested(vcpu);\n\tvcpu_put(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_vpid",
          "args": [
            "vmx->vpid"
          ],
          "line": 6684
        },
        "resolved": true,
        "details": {
          "function_name": "free_vpid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3582-3589",
          "snippet": "void free_vpid(int vpid)\n{\n\tif (!enable_vpid || vpid == 0)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\t__clear_bit(vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(vmx_vpid_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic DEFINE_SPINLOCK(vmx_vpid_lock);\n\nvoid free_vpid(int vpid)\n{\n\tif (!enable_vpid || vpid == 0)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\t__clear_bit(vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_destroy_pml_buffer",
          "args": [
            "vmx"
          ],
          "line": 6683
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_destroy_pml_buffer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5588-5594",
          "snippet": "static void vmx_destroy_pml_buffer(struct vcpu_vmx *vmx)\n{\n\tif (vmx->pml_pg) {\n\t\t__free_page(vmx->pml_pg);\n\t\tvmx->pml_pg = NULL;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_destroy_pml_buffer(struct vcpu_vmx *vmx)\n{\n\tif (vmx->pml_pg) {\n\t\t__free_page(vmx->pml_pg);\n\t\tvmx->pml_pg = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 6680
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (enable_pml)\n\t\tvmx_destroy_pml_buffer(vmx);\n\tfree_vpid(vmx->vpid);\n\tnested_vmx_free_vcpu(vcpu);\n\tfree_loaded_vmcs(vmx->loaded_vmcs);\n}"
  },
  {
    "function_name": "vmx_vcpu_run",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6500-6676",
    "snippet": "static void vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long cr3, cr4;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked))\n\t\tvmx->loaded_vmcs->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\t/*\n\t * We did this in prepare_switch_to_guest, because it needs to\n\t * be within srcu_read_lock.\n\t */\n\tWARN_ON_ONCE(vmx->nested.need_vmcs12_to_shadow_sync);\n\n\tif (kvm_register_is_dirty(vcpu, VCPU_REGS_RSP))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (kvm_register_is_dirty(vcpu, VCPU_REGS_RIP))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\tcr3 = __get_current_cr3_fast();\n\tif (unlikely(cr3 != vmx->loaded_vmcs->host_state.cr3)) {\n\t\tvmcs_writel(HOST_CR3, cr3);\n\t\tvmx->loaded_vmcs->host_state.cr3 = cr3;\n\t}\n\n\tcr4 = cr4_read_shadow();\n\tif (unlikely(cr4 != vmx->loaded_vmcs->host_state.cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->loaded_vmcs->host_state.cr4 = cr4;\n\t}\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tkvm_load_guest_xsave_state(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_PKU) &&\n\t    kvm_read_cr4_bits(vcpu, X86_CR4_PKE) &&\n\t    vcpu->arch.pkru != vmx->host_pkru)\n\t\t__write_pkru(vcpu->arch.pkru);\n\n\tpt_guest_enter(vmx);\n\n\tif (vcpu_to_pmu(vcpu)->version)\n\t\tatomic_switch_perf_msrs(vmx);\n\tatomic_switch_umwait_control_msr(vmx);\n\n\tif (enable_preemption_timer)\n\t\tvmx_update_hv_timer(vcpu);\n\n\tif (lapic_in_kernel(vcpu) &&\n\t\tvcpu->arch.apic->lapic_timer.timer_advance_ns)\n\t\tkvm_wait_lapic_expire(vcpu);\n\n\t/*\n\t * If this vCPU has touched SPEC_CTRL, restore the guest's value if\n\t * it's non-zero. Since vmentry is serialising on affected CPUs, there\n\t * is no need to worry about the conditional branch over the wrmsr\n\t * being speculatively taken.\n\t */\n\tx86_spec_ctrl_set_guest(vmx->spec_ctrl, 0);\n\n\t/* L1D Flush includes CPU buffer clear to mitigate MDS */\n\tif (static_branch_unlikely(&vmx_l1d_should_flush))\n\t\tvmx_l1d_flush(vcpu);\n\telse if (static_branch_unlikely(&mds_user_clear))\n\t\tmds_clear_cpu_buffers();\n\n\tif (vcpu->arch.cr2 != read_cr2())\n\t\twrite_cr2(vcpu->arch.cr2);\n\n\tvmx->fail = __vmx_vcpu_run(vmx, (unsigned long *)&vcpu->arch.regs,\n\t\t\t\t   vmx->loaded_vmcs->launched);\n\n\tvcpu->arch.cr2 = read_cr2();\n\n\t/*\n\t * We do not use IBRS in the kernel. If this vCPU has used the\n\t * SPEC_CTRL MSR it may have left it on; save the value and\n\t * turn it off. This is much more efficient than blindly adding\n\t * it to the atomic save/restore list. Especially as the former\n\t * (Saving guest MSRs on vmexit) doesn't even exist in KVM.\n\t *\n\t * For non-nested case:\n\t * If the L01 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t *\n\t * For nested case:\n\t * If the L02 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t */\n\tif (unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))\n\t\tvmx->spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);\n\n\tx86_spec_ctrl_restore_host(vmx->spec_ctrl, 0);\n\n\t/* All fields are clean at this point */\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tcurrent_evmcs->hv_clean_fields |=\n\t\t\tHV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tcurrent_evmcs->hv_vp_id = vcpu->arch.hyperv.vp_index;\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (vmx->host_debugctlmsr)\n\t\tupdate_debugctlmsr(vmx->host_debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_prepare_switch_to_host() since that\n\t * function may be executed in interrupt context, which saves and\n\t * restore segments around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)\n\t\t\t\t  | (1 << VCPU_EXREG_RFLAGS)\n\t\t\t\t  | (1 << VCPU_EXREG_PDPTR)\n\t\t\t\t  | (1 << VCPU_EXREG_SEGMENTS)\n\t\t\t\t  | (1 << VCPU_EXREG_CR3));\n\tvcpu->arch.regs_dirty = 0;\n\n\tpt_guest_exit(vmx);\n\n\t/*\n\t * eager fpu is enabled if PKEY is supported and CR4 is switched\n\t * back on host, so it is safe to read guest PKRU from current\n\t * XSAVE.\n\t */\n\tif (static_cpu_has(X86_FEATURE_PKU) &&\n\t    kvm_read_cr4_bits(vcpu, X86_CR4_PKE)) {\n\t\tvcpu->arch.pkru = rdpkru();\n\t\tif (vcpu->arch.pkru != vmx->host_pkru)\n\t\t\t__write_pkru(vmx->host_pkru);\n\t}\n\n\tkvm_load_host_xsave_state(vcpu);\n\n\tvmx->nested.nested_run_pending = 0;\n\tvmx->idt_vectoring_info = 0;\n\n\tvmx->exit_reason = vmx->fail ? 0xdead : vmcs_read32(VM_EXIT_REASON);\n\tif ((u16)vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY)\n\t\tkvm_machine_check();\n\n\tif (vmx->fail || (vmx->exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY))\n\t\treturn;\n\n\tvmx->loaded_vmcs->launched = 1;\n\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;",
      "static DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_complete_interrupts",
          "args": [
            "vmx"
          ],
          "line": 6675
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_complete_interrupts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6412-6417",
          "snippet": "static void vmx_complete_interrupts(struct vcpu_vmx *vmx)\n{\n\t__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,\n\t\t\t\t  VM_EXIT_INSTRUCTION_LEN,\n\t\t\t\t  IDT_VECTORING_ERROR_CODE);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_complete_interrupts(struct vcpu_vmx *vmx)\n{\n\t__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,\n\t\t\t\t  VM_EXIT_INSTRUCTION_LEN,\n\t\t\t\t  IDT_VECTORING_ERROR_CODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_recover_nmi_blocking",
          "args": [
            "vmx"
          ],
          "line": 6674
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_recover_nmi_blocking",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6315-6356",
          "snippet": "static void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tbool unblock_nmi;\n\tu8 vector;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tif (enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->nmi_known_unmasked)\n\t\t\treturn;\n\t\t/*\n\t\t * Can't use vmx->exit_intr_info since we're not sure what\n\t\t * the exit reason is.\n\t\t */\n\t\texit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\t\tunblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;\n\t\tvector = exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Re-set bit \"block by NMI\" before VM entry if vmexit caused by\n\t\t * a guest IRET fault.\n\t\t * SDM 3: 23.2.2 (September 2008)\n\t\t * Bit 12 is undefined in any of the following cases:\n\t\t *  If the VM exit sets the valid bit in the IDT-vectoring\n\t\t *   information field.\n\t\t *  If the VM exit is due to a double fault.\n\t\t */\n\t\tif ((exit_intr_info & INTR_INFO_VALID_MASK) && unblock_nmi &&\n\t\t    vector != DF_VECTOR && !idtv_info_valid)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmx->loaded_vmcs->nmi_known_unmasked =\n\t\t\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\n\t\t\t\t  & GUEST_INTR_STATE_NMI);\n\t} else if (unlikely(vmx->loaded_vmcs->soft_vnmi_blocked))\n\t\tvmx->loaded_vmcs->vnmi_blocked_time +=\n\t\t\tktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t      vmx->loaded_vmcs->entry_time));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tbool unblock_nmi;\n\tu8 vector;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tif (enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->nmi_known_unmasked)\n\t\t\treturn;\n\t\t/*\n\t\t * Can't use vmx->exit_intr_info since we're not sure what\n\t\t * the exit reason is.\n\t\t */\n\t\texit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\t\tunblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;\n\t\tvector = exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Re-set bit \"block by NMI\" before VM entry if vmexit caused by\n\t\t * a guest IRET fault.\n\t\t * SDM 3: 23.2.2 (September 2008)\n\t\t * Bit 12 is undefined in any of the following cases:\n\t\t *  If the VM exit sets the valid bit in the IDT-vectoring\n\t\t *   information field.\n\t\t *  If the VM exit is due to a double fault.\n\t\t */\n\t\tif ((exit_intr_info & INTR_INFO_VALID_MASK) && unblock_nmi &&\n\t\t    vector != DF_VECTOR && !idtv_info_valid)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmx->loaded_vmcs->nmi_known_unmasked =\n\t\t\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\n\t\t\t\t  & GUEST_INTR_STATE_NMI);\n\t} else if (unlikely(vmx->loaded_vmcs->soft_vnmi_blocked))\n\t\tvmx->loaded_vmcs->vnmi_blocked_time +=\n\t\t\tktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t      vmx->loaded_vmcs->entry_time));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "IDT_VECTORING_INFO_FIELD"
          ],
          "line": 6672
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_machine_check",
          "args": [],
          "line": 6666
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_machine_check",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4577-4587",
          "snippet": "static void kvm_machine_check(void)\n{\n#if defined(CONFIG_X86_MCE) && defined(CONFIG_X86_64)\n\tstruct pt_regs regs = {\n\t\t.cs = 3, /* Fake ring 3 no matter what the guest ran on */\n\t\t.flags = X86_EFLAGS_IF,\n\t};\n\n\tdo_machine_check(&regs, 0);\n#endif\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void kvm_machine_check(void)\n{\n#if defined(CONFIG_X86_MCE) && defined(CONFIG_X86_64)\n\tstruct pt_regs regs = {\n\t\t.cs = 3, /* Fake ring 3 no matter what the guest ran on */\n\t\t.flags = X86_EFLAGS_IF,\n\t};\n\n\tdo_machine_check(&regs, 0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_load_host_xsave_state",
          "args": [
            "vcpu"
          ],
          "line": 6659
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_load_host_xsave_state",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "842-854",
          "snippet": "void kvm_load_host_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, host_xss);\n\t}\n\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static u64 __read_mostly host_xss;",
            "u64 __read_mostly host_xcr0;",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic u64 __read_mostly host_xss;\nu64 __read_mostly host_xcr0;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_load_host_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, host_xss);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "__write_pkru",
          "args": [
            "vmx->host_pkru"
          ],
          "line": 6656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdpkru",
          "args": [],
          "line": 6654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_PKE"
          ],
          "line": 6653
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "129-135",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_PKU"
          ],
          "line": 6652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pt_guest_exit",
          "args": [
            "vmx"
          ],
          "line": 6645
        },
        "resolved": true,
        "details": {
          "function_name": "pt_guest_exit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1082-1094",
          "snippet": "static void pt_guest_exit(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\tpt_save_msr(&vmx->pt_desc.guest, vmx->pt_desc.addr_range);\n\t\tpt_load_msr(&vmx->pt_desc.host, vmx->pt_desc.addr_range);\n\t}\n\n\t/* Reload host state (IA32_RTIT_CTL will be cleared on VM exit). */\n\twrmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void pt_guest_exit(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\tpt_save_msr(&vmx->pt_desc.guest, vmx->pt_desc.addr_range);\n\t\tpt_load_msr(&vmx->pt_desc.host, vmx->pt_desc.addr_range);\n\t}\n\n\t/* Reload host state (IA32_RTIT_CTL will be cleared on VM exit). */\n\twrmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "es",
            "__USER_DS"
          ],
          "line": 6635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "ds",
            "__USER_DS"
          ],
          "line": 6634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_debugctlmsr",
          "args": [
            "vmx->host_debugctlmsr"
          ],
          "line": 6623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 6618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 6614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86_spec_ctrl_restore_host",
          "args": [
            "vmx->spec_ctrl",
            "0"
          ],
          "line": 6611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_read_msr",
          "args": [
            "MSR_IA32_SPEC_CTRL"
          ],
          "line": 6609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)"
          ],
          "line": 6608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msr_write_intercepted",
          "args": [
            "vcpu",
            "MSR_IA32_SPEC_CTRL"
          ],
          "line": 6608
        },
        "resolved": true,
        "details": {
          "function_name": "msr_write_intercepted",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "798-816",
          "snippet": "static bool msr_write_intercepted(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tunsigned long *msr_bitmap;\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn true;\n\n\tmsr_bitmap = to_vmx(vcpu)->loaded_vmcs->msr_bitmap;\n\n\tif (msr <= 0x1fff) {\n\t\treturn !!test_bit(msr, msr_bitmap + 0x800 / f);\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\treturn !!test_bit(msr, msr_bitmap + 0xc00 / f);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool msr_write_intercepted(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tunsigned long *msr_bitmap;\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn true;\n\n\tmsr_bitmap = to_vmx(vcpu)->loaded_vmcs->msr_bitmap;\n\n\tif (msr <= 0x1fff) {\n\t\treturn !!test_bit(msr, msr_bitmap + 0x800 / f);\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\treturn !!test_bit(msr, msr_bitmap + 0xc00 / f);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_cr2",
          "args": [],
          "line": 6591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmx_vcpu_run",
          "args": [
            "vmx",
            "(unsigned long *)&vcpu->arch.regs",
            "vmx->loaded_vmcs->launched"
          ],
          "line": 6588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_cr2",
          "args": [
            "vcpu->arch.cr2"
          ],
          "line": 6586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cr2",
          "args": [],
          "line": 6585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mds_clear_cpu_buffers",
          "args": [],
          "line": 6583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&mds_user_clear"
          ],
          "line": 6582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_l1d_flush",
          "args": [
            "vcpu"
          ],
          "line": 6581
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_l1d_flush",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5976-6034",
          "snippet": "static void vmx_l1d_flush(struct kvm_vcpu *vcpu)\n{\n\tint size = PAGE_SIZE << L1D_CACHE_ORDER;\n\n\t/*\n\t * This code is only executed when the the flush mode is 'cond' or\n\t * 'always'\n\t */\n\tif (static_branch_likely(&vmx_l1d_flush_cond)) {\n\t\tbool flush_l1d;\n\n\t\t/*\n\t\t * Clear the per-vcpu flush bit, it gets set again\n\t\t * either from vcpu_run() or from one of the unsafe\n\t\t * VMEXIT handlers.\n\t\t */\n\t\tflush_l1d = vcpu->arch.l1tf_flush_l1d;\n\t\tvcpu->arch.l1tf_flush_l1d = false;\n\n\t\t/*\n\t\t * Clear the per-cpu flush bit, it gets set again from\n\t\t * the interrupt handlers.\n\t\t */\n\t\tflush_l1d |= kvm_get_cpu_l1tf_flush_l1d();\n\t\tkvm_clear_cpu_l1tf_flush_l1d();\n\n\t\tif (!flush_l1d)\n\t\t\treturn;\n\t}\n\n\tvcpu->stat.l1d_flush++;\n\n\tif (static_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\twrmsrl(MSR_IA32_FLUSH_CMD, L1D_FLUSH);\n\t\treturn;\n\t}\n\n\tasm volatile(\n\t\t/* First ensure the pages are in the TLB */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lpopulate_tlb:\\n\\t\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$4096, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lpopulate_tlb\\n\\t\"\n\t\t\"xorl\t%%eax, %%eax\\n\\t\"\n\t\t\"cpuid\\n\\t\"\n\t\t/* Now fill the cache */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lfill_cache:\\n\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$64, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lfill_cache\\n\\t\"\n\t\t\"lfence\\n\"\n\t\t:: [flush_pages] \"r\" (vmx_l1d_flush_pages),\n\t\t    [size] \"r\" (size)\n\t\t: \"eax\", \"ebx\", \"ecx\", \"edx\");\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define L1D_CACHE_ORDER 4"
          ],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);",
            "static void *vmx_l1d_flush_pages;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define L1D_CACHE_ORDER 4\n\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);\nstatic void *vmx_l1d_flush_pages;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_l1d_flush(struct kvm_vcpu *vcpu)\n{\n\tint size = PAGE_SIZE << L1D_CACHE_ORDER;\n\n\t/*\n\t * This code is only executed when the the flush mode is 'cond' or\n\t * 'always'\n\t */\n\tif (static_branch_likely(&vmx_l1d_flush_cond)) {\n\t\tbool flush_l1d;\n\n\t\t/*\n\t\t * Clear the per-vcpu flush bit, it gets set again\n\t\t * either from vcpu_run() or from one of the unsafe\n\t\t * VMEXIT handlers.\n\t\t */\n\t\tflush_l1d = vcpu->arch.l1tf_flush_l1d;\n\t\tvcpu->arch.l1tf_flush_l1d = false;\n\n\t\t/*\n\t\t * Clear the per-cpu flush bit, it gets set again from\n\t\t * the interrupt handlers.\n\t\t */\n\t\tflush_l1d |= kvm_get_cpu_l1tf_flush_l1d();\n\t\tkvm_clear_cpu_l1tf_flush_l1d();\n\n\t\tif (!flush_l1d)\n\t\t\treturn;\n\t}\n\n\tvcpu->stat.l1d_flush++;\n\n\tif (static_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\twrmsrl(MSR_IA32_FLUSH_CMD, L1D_FLUSH);\n\t\treturn;\n\t}\n\n\tasm volatile(\n\t\t/* First ensure the pages are in the TLB */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lpopulate_tlb:\\n\\t\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$4096, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lpopulate_tlb\\n\\t\"\n\t\t\"xorl\t%%eax, %%eax\\n\\t\"\n\t\t\"cpuid\\n\\t\"\n\t\t/* Now fill the cache */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lfill_cache:\\n\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$64, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lfill_cache\\n\\t\"\n\t\t\"lfence\\n\"\n\t\t:: [flush_pages] \"r\" (vmx_l1d_flush_pages),\n\t\t    [size] \"r\" (size)\n\t\t: \"eax\", \"ebx\", \"ecx\", \"edx\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&vmx_l1d_should_flush"
          ],
          "line": 6580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86_spec_ctrl_set_guest",
          "args": [
            "vmx->spec_ctrl",
            "0"
          ],
          "line": 6577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_wait_lapic_expire",
          "args": [
            "vcpu"
          ],
          "line": 6569
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_wait_lapic_expire",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1579-1583",
          "snippet": "void kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_timer_int_injected(vcpu))\n\t\t__kvm_wait_lapic_expire(vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_timer_int_injected(vcpu))\n\t\t__kvm_wait_lapic_expire(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 6567
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_update_hv_timer",
          "args": [
            "vcpu"
          ],
          "line": 6565
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_update_hv_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6464-6488",
          "snippet": "static void vmx_update_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 tscl;\n\tu32 delta_tsc;\n\n\tif (vmx->req_immediate_exit) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, 0);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (vmx->hv_deadline_tsc != -1) {\n\t\ttscl = rdtsc();\n\t\tif (vmx->hv_deadline_tsc > tscl)\n\t\t\t/* set_hv_timer ensures the delta fits in 32-bits */\n\t\t\tdelta_tsc = (u32)((vmx->hv_deadline_tsc - tscl) >>\n\t\t\t\tcpu_preemption_timer_multi);\n\t\telse\n\t\t\tdelta_tsc = 0;\n\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, delta_tsc);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (!vmx->loaded_vmcs->hv_timer_soft_disabled) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, -1);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = true;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_update_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 tscl;\n\tu32 delta_tsc;\n\n\tif (vmx->req_immediate_exit) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, 0);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (vmx->hv_deadline_tsc != -1) {\n\t\ttscl = rdtsc();\n\t\tif (vmx->hv_deadline_tsc > tscl)\n\t\t\t/* set_hv_timer ensures the delta fits in 32-bits */\n\t\t\tdelta_tsc = (u32)((vmx->hv_deadline_tsc - tscl) >>\n\t\t\t\tcpu_preemption_timer_multi);\n\t\telse\n\t\t\tdelta_tsc = 0;\n\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, delta_tsc);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (!vmx->loaded_vmcs->hv_timer_soft_disabled) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, -1);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_switch_umwait_control_msr",
          "args": [
            "vmx"
          ],
          "line": 6562
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_switch_umwait_control_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6447-6462",
          "snippet": "static void atomic_switch_umwait_control_msr(struct vcpu_vmx *vmx)\n{\n\tu32 host_umwait_control;\n\n\tif (!vmx_has_waitpkg(vmx))\n\t\treturn;\n\n\thost_umwait_control = get_umwait_control_msr();\n\n\tif (vmx->msr_ia32_umwait_control != host_umwait_control)\n\t\tadd_atomic_switch_msr(vmx, MSR_IA32_UMWAIT_CONTROL,\n\t\t\tvmx->msr_ia32_umwait_control,\n\t\t\thost_umwait_control, false);\n\telse\n\t\tclear_atomic_switch_msr(vmx, MSR_IA32_UMWAIT_CONTROL);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void atomic_switch_umwait_control_msr(struct vcpu_vmx *vmx)\n{\n\tu32 host_umwait_control;\n\n\tif (!vmx_has_waitpkg(vmx))\n\t\treturn;\n\n\thost_umwait_control = get_umwait_control_msr();\n\n\tif (vmx->msr_ia32_umwait_control != host_umwait_control)\n\t\tadd_atomic_switch_msr(vmx, MSR_IA32_UMWAIT_CONTROL,\n\t\t\tvmx->msr_ia32_umwait_control,\n\t\t\thost_umwait_control, false);\n\telse\n\t\tclear_atomic_switch_msr(vmx, MSR_IA32_UMWAIT_CONTROL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_switch_perf_msrs",
          "args": [
            "vmx"
          ],
          "line": 6561
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_switch_perf_msrs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6429-6445",
          "snippet": "static void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\n\tif (!msrs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host, false);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\n\tif (!msrs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 6560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pt_guest_enter",
          "args": [
            "vmx"
          ],
          "line": 6558
        },
        "resolved": true,
        "details": {
          "function_name": "pt_guest_enter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1065-1080",
          "snippet": "static void pt_guest_enter(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\t/*\n\t * GUEST_IA32_RTIT_CTL is already set in the VMCS.\n\t * Save host state before VM entry.\n\t */\n\trdmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\twrmsrl(MSR_IA32_RTIT_CTL, 0);\n\t\tpt_save_msr(&vmx->pt_desc.host, vmx->pt_desc.addr_range);\n\t\tpt_load_msr(&vmx->pt_desc.guest, vmx->pt_desc.addr_range);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void pt_guest_enter(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\t/*\n\t * GUEST_IA32_RTIT_CTL is already set in the VMCS.\n\t * Save host state before VM entry.\n\t */\n\trdmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\twrmsrl(MSR_IA32_RTIT_CTL, 0);\n\t\tpt_save_msr(&vmx->pt_desc.host, vmx->pt_desc.addr_range);\n\t\tpt_load_msr(&vmx->pt_desc.guest, vmx->pt_desc.addr_range);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__write_pkru",
          "args": [
            "vcpu->arch.pkru"
          ],
          "line": 6556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_PKU"
          ],
          "line": 6553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_load_guest_xsave_state",
          "args": [
            "vcpu"
          ],
          "line": 6551
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_load_guest_xsave_state",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "828-839",
          "snippet": "void kvm_load_guest_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, vcpu->arch.ia32_xss);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static u64 __read_mostly host_xss;",
            "u64 __read_mostly host_xcr0;",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic u64 __read_mostly host_xss;\nu64 __read_mostly host_xcr0;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_load_guest_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, vcpu->arch.ia32_xss);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_set_interrupt_shadow",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 6549
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_interrupt_shadow",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1460-1474",
          "snippet": "void vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "HOST_CR4",
            "cr4"
          ],
          "line": 6539
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cr4 != vmx->loaded_vmcs->host_state.cr4"
          ],
          "line": 6538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_read_shadow",
          "args": [],
          "line": 6537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cr3 != vmx->loaded_vmcs->host_state.cr3"
          ],
          "line": 6532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_current_cr3_fast",
          "args": [],
          "line": 6531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_register_is_dirty",
          "args": [
            "vcpu",
            "VCPU_REGS_RIP"
          ],
          "line": 6528
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_is_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "46-50",
          "snippet": "static inline bool kvm_register_is_dirty(struct kvm_vcpu *vcpu,\n\t\t\t\t\t enum kvm_reg reg)\n{\n\treturn test_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool kvm_register_is_dirty(struct kvm_vcpu *vcpu,\n\t\t\t\t\t enum kvm_reg reg)\n{\n\treturn test_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "vmx->nested.need_vmcs12_to_shadow_sync"
          ],
          "line": 6524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "PLE_WINDOW",
            "vmx->ple_window"
          ],
          "line": 6517
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 6508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked"
          ],
          "line": 6506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 6502
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long cr3, cr4;\n\n\t/* Record the guest's net vcpu time for enforced NMI injections. */\n\tif (unlikely(!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked))\n\t\tvmx->loaded_vmcs->entry_time = ktime_get();\n\n\t/* Don't enter VMX if guest state is invalid, let the exit handler\n\t   start emulation until we arrive back to a valid state */\n\tif (vmx->emulation_required)\n\t\treturn;\n\n\tif (vmx->ple_window_dirty) {\n\t\tvmx->ple_window_dirty = false;\n\t\tvmcs_write32(PLE_WINDOW, vmx->ple_window);\n\t}\n\n\t/*\n\t * We did this in prepare_switch_to_guest, because it needs to\n\t * be within srcu_read_lock.\n\t */\n\tWARN_ON_ONCE(vmx->nested.need_vmcs12_to_shadow_sync);\n\n\tif (kvm_register_is_dirty(vcpu, VCPU_REGS_RSP))\n\t\tvmcs_writel(GUEST_RSP, vcpu->arch.regs[VCPU_REGS_RSP]);\n\tif (kvm_register_is_dirty(vcpu, VCPU_REGS_RIP))\n\t\tvmcs_writel(GUEST_RIP, vcpu->arch.regs[VCPU_REGS_RIP]);\n\n\tcr3 = __get_current_cr3_fast();\n\tif (unlikely(cr3 != vmx->loaded_vmcs->host_state.cr3)) {\n\t\tvmcs_writel(HOST_CR3, cr3);\n\t\tvmx->loaded_vmcs->host_state.cr3 = cr3;\n\t}\n\n\tcr4 = cr4_read_shadow();\n\tif (unlikely(cr4 != vmx->loaded_vmcs->host_state.cr4)) {\n\t\tvmcs_writel(HOST_CR4, cr4);\n\t\tvmx->loaded_vmcs->host_state.cr4 = cr4;\n\t}\n\n\t/* When single-stepping over STI and MOV SS, we must clear the\n\t * corresponding interruptibility bits in the guest state. Otherwise\n\t * vmentry fails as it then expects bit 14 (BS) in pending debug\n\t * exceptions being set, but that's not correct for the guest debugging\n\t * case. */\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\tkvm_load_guest_xsave_state(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_PKU) &&\n\t    kvm_read_cr4_bits(vcpu, X86_CR4_PKE) &&\n\t    vcpu->arch.pkru != vmx->host_pkru)\n\t\t__write_pkru(vcpu->arch.pkru);\n\n\tpt_guest_enter(vmx);\n\n\tif (vcpu_to_pmu(vcpu)->version)\n\t\tatomic_switch_perf_msrs(vmx);\n\tatomic_switch_umwait_control_msr(vmx);\n\n\tif (enable_preemption_timer)\n\t\tvmx_update_hv_timer(vcpu);\n\n\tif (lapic_in_kernel(vcpu) &&\n\t\tvcpu->arch.apic->lapic_timer.timer_advance_ns)\n\t\tkvm_wait_lapic_expire(vcpu);\n\n\t/*\n\t * If this vCPU has touched SPEC_CTRL, restore the guest's value if\n\t * it's non-zero. Since vmentry is serialising on affected CPUs, there\n\t * is no need to worry about the conditional branch over the wrmsr\n\t * being speculatively taken.\n\t */\n\tx86_spec_ctrl_set_guest(vmx->spec_ctrl, 0);\n\n\t/* L1D Flush includes CPU buffer clear to mitigate MDS */\n\tif (static_branch_unlikely(&vmx_l1d_should_flush))\n\t\tvmx_l1d_flush(vcpu);\n\telse if (static_branch_unlikely(&mds_user_clear))\n\t\tmds_clear_cpu_buffers();\n\n\tif (vcpu->arch.cr2 != read_cr2())\n\t\twrite_cr2(vcpu->arch.cr2);\n\n\tvmx->fail = __vmx_vcpu_run(vmx, (unsigned long *)&vcpu->arch.regs,\n\t\t\t\t   vmx->loaded_vmcs->launched);\n\n\tvcpu->arch.cr2 = read_cr2();\n\n\t/*\n\t * We do not use IBRS in the kernel. If this vCPU has used the\n\t * SPEC_CTRL MSR it may have left it on; save the value and\n\t * turn it off. This is much more efficient than blindly adding\n\t * it to the atomic save/restore list. Especially as the former\n\t * (Saving guest MSRs on vmexit) doesn't even exist in KVM.\n\t *\n\t * For non-nested case:\n\t * If the L01 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t *\n\t * For nested case:\n\t * If the L02 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t */\n\tif (unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))\n\t\tvmx->spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);\n\n\tx86_spec_ctrl_restore_host(vmx->spec_ctrl, 0);\n\n\t/* All fields are clean at this point */\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tcurrent_evmcs->hv_clean_fields |=\n\t\t\tHV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tcurrent_evmcs->hv_vp_id = vcpu->arch.hyperv.vp_index;\n\n\t/* MSR_IA32_DEBUGCTLMSR is zeroed on vmexit. Restore it if needed */\n\tif (vmx->host_debugctlmsr)\n\t\tupdate_debugctlmsr(vmx->host_debugctlmsr);\n\n#ifndef CONFIG_X86_64\n\t/*\n\t * The sysexit path does not restore ds/es, so we must set them to\n\t * a reasonable value ourselves.\n\t *\n\t * We can't defer this to vmx_prepare_switch_to_host() since that\n\t * function may be executed in interrupt context, which saves and\n\t * restore segments around it, nullifying its effect.\n\t */\n\tloadsegment(ds, __USER_DS);\n\tloadsegment(es, __USER_DS);\n#endif\n\n\tvcpu->arch.regs_avail = ~((1 << VCPU_REGS_RIP) | (1 << VCPU_REGS_RSP)\n\t\t\t\t  | (1 << VCPU_EXREG_RFLAGS)\n\t\t\t\t  | (1 << VCPU_EXREG_PDPTR)\n\t\t\t\t  | (1 << VCPU_EXREG_SEGMENTS)\n\t\t\t\t  | (1 << VCPU_EXREG_CR3));\n\tvcpu->arch.regs_dirty = 0;\n\n\tpt_guest_exit(vmx);\n\n\t/*\n\t * eager fpu is enabled if PKEY is supported and CR4 is switched\n\t * back on host, so it is safe to read guest PKRU from current\n\t * XSAVE.\n\t */\n\tif (static_cpu_has(X86_FEATURE_PKU) &&\n\t    kvm_read_cr4_bits(vcpu, X86_CR4_PKE)) {\n\t\tvcpu->arch.pkru = rdpkru();\n\t\tif (vcpu->arch.pkru != vmx->host_pkru)\n\t\t\t__write_pkru(vmx->host_pkru);\n\t}\n\n\tkvm_load_host_xsave_state(vcpu);\n\n\tvmx->nested.nested_run_pending = 0;\n\tvmx->idt_vectoring_info = 0;\n\n\tvmx->exit_reason = vmx->fail ? 0xdead : vmcs_read32(VM_EXIT_REASON);\n\tif ((u16)vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY)\n\t\tkvm_machine_check();\n\n\tif (vmx->fail || (vmx->exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY))\n\t\treturn;\n\n\tvmx->loaded_vmcs->launched = 1;\n\tvmx->idt_vectoring_info = vmcs_read32(IDT_VECTORING_INFO_FIELD);\n\n\tvmx_recover_nmi_blocking(vmx);\n\tvmx_complete_interrupts(vmx);\n}"
  },
  {
    "function_name": "vmx_update_host_rsp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6490-6496",
    "snippet": "void vmx_update_host_rsp(struct vcpu_vmx *vmx, unsigned long host_rsp)\n{\n\tif (unlikely(host_rsp != vmx->loaded_vmcs->host_state.rsp)) {\n\t\tvmx->loaded_vmcs->host_state.rsp = host_rsp;\n\t\tvmcs_writel(HOST_RSP, host_rsp);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "HOST_RSP",
            "host_rsp"
          ],
          "line": 6494
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "host_rsp != vmx->loaded_vmcs->host_state.rsp"
          ],
          "line": 6492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid vmx_update_host_rsp(struct vcpu_vmx *vmx, unsigned long host_rsp)\n{\n\tif (unlikely(host_rsp != vmx->loaded_vmcs->host_state.rsp)) {\n\t\tvmx->loaded_vmcs->host_state.rsp = host_rsp;\n\t\tvmcs_writel(HOST_RSP, host_rsp);\n\t}\n}"
  },
  {
    "function_name": "vmx_update_hv_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6464-6488",
    "snippet": "static void vmx_update_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 tscl;\n\tu32 delta_tsc;\n\n\tif (vmx->req_immediate_exit) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, 0);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (vmx->hv_deadline_tsc != -1) {\n\t\ttscl = rdtsc();\n\t\tif (vmx->hv_deadline_tsc > tscl)\n\t\t\t/* set_hv_timer ensures the delta fits in 32-bits */\n\t\t\tdelta_tsc = (u32)((vmx->hv_deadline_tsc - tscl) >>\n\t\t\t\tcpu_preemption_timer_multi);\n\t\telse\n\t\t\tdelta_tsc = 0;\n\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, delta_tsc);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (!vmx->loaded_vmcs->hv_timer_soft_disabled) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, -1);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = true;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "VMX_PREEMPTION_TIMER_VALUE",
            "-1"
          ],
          "line": 6485
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(vmx->hv_deadline_tsc - tscl) >>\n\t\t\t\tcpu_preemption_timer_multi"
          ],
          "line": 6477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 6474
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_rdtscp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "149-153",
          "snippet": "static inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 6466
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_update_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 tscl;\n\tu32 delta_tsc;\n\n\tif (vmx->req_immediate_exit) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, 0);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (vmx->hv_deadline_tsc != -1) {\n\t\ttscl = rdtsc();\n\t\tif (vmx->hv_deadline_tsc > tscl)\n\t\t\t/* set_hv_timer ensures the delta fits in 32-bits */\n\t\t\tdelta_tsc = (u32)((vmx->hv_deadline_tsc - tscl) >>\n\t\t\t\tcpu_preemption_timer_multi);\n\t\telse\n\t\t\tdelta_tsc = 0;\n\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, delta_tsc);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = false;\n\t} else if (!vmx->loaded_vmcs->hv_timer_soft_disabled) {\n\t\tvmcs_write32(VMX_PREEMPTION_TIMER_VALUE, -1);\n\t\tvmx->loaded_vmcs->hv_timer_soft_disabled = true;\n\t}\n}"
  },
  {
    "function_name": "atomic_switch_umwait_control_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6447-6462",
    "snippet": "static void atomic_switch_umwait_control_msr(struct vcpu_vmx *vmx)\n{\n\tu32 host_umwait_control;\n\n\tif (!vmx_has_waitpkg(vmx))\n\t\treturn;\n\n\thost_umwait_control = get_umwait_control_msr();\n\n\tif (vmx->msr_ia32_umwait_control != host_umwait_control)\n\t\tadd_atomic_switch_msr(vmx, MSR_IA32_UMWAIT_CONTROL,\n\t\t\tvmx->msr_ia32_umwait_control,\n\t\t\thost_umwait_control, false);\n\telse\n\t\tclear_atomic_switch_msr(vmx, MSR_IA32_UMWAIT_CONTROL);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_atomic_switch_msr",
          "args": [
            "vmx",
            "MSR_IA32_UMWAIT_CONTROL"
          ],
          "line": 6461
        },
        "resolved": true,
        "details": {
          "function_name": "clear_atomic_switch_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "836-874",
          "snippet": "static void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tint i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (i < 0)\n\t\tgoto skip_guest;\n\t--m->guest.nr;\n\tm->guest.val[i] = m->guest.val[m->guest.nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\nskip_guest:\n\ti = vmx_find_msr_index(&m->host, msr);\n\tif (i < 0)\n\t\treturn;\n\n\t--m->host.nr;\n\tm->host.val[i] = m->host.val[m->host.nr];\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tint i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (i < 0)\n\t\tgoto skip_guest;\n\t--m->guest.nr;\n\tm->guest.val[i] = m->guest.val[m->guest.nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\nskip_guest:\n\ti = vmx_find_msr_index(&m->host, msr);\n\tif (i < 0)\n\t\treturn;\n\n\t--m->host.nr;\n\tm->host.val[i] = m->host.val[m->host.nr];\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_atomic_switch_msr",
          "args": [
            "vmx",
            "MSR_IA32_UMWAIT_CONTROL",
            "vmx->msr_ia32_umwait_control",
            "host_umwait_control",
            "false"
          ],
          "line": 6457
        },
        "resolved": true,
        "details": {
          "function_name": "add_atomic_switch_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "888-952",
          "snippet": "static void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val, bool entry_only)\n{\n\tint i, j = 0;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (!entry_only)\n\t\tj = vmx_find_msr_index(&m->host, msr);\n\n\tif ((i < 0 && m->guest.nr == NR_LOADSTORE_MSRS) ||\n\t\t(j < 0 &&  m->host.nr == NR_LOADSTORE_MSRS)) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t}\n\tif (i < 0) {\n\t\ti = m->guest.nr++;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\t}\n\tm->guest.val[i].index = msr;\n\tm->guest.val[i].value = guest_val;\n\n\tif (entry_only)\n\t\treturn;\n\n\tif (j < 0) {\n\t\tj = m->host.nr++;\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n\t}\n\tm->host.val[j].index = msr;\n\tm->host.val[j].value = host_val;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val, bool entry_only)\n{\n\tint i, j = 0;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (!entry_only)\n\t\tj = vmx_find_msr_index(&m->host, msr);\n\n\tif ((i < 0 && m->guest.nr == NR_LOADSTORE_MSRS) ||\n\t\t(j < 0 &&  m->host.nr == NR_LOADSTORE_MSRS)) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t}\n\tif (i < 0) {\n\t\ti = m->guest.nr++;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\t}\n\tm->guest.val[i].index = msr;\n\tm->guest.val[i].value = guest_val;\n\n\tif (entry_only)\n\t\treturn;\n\n\tif (j < 0) {\n\t\tj = m->host.nr++;\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n\t}\n\tm->host.val[j].index = msr;\n\tm->host.val[j].value = host_val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_umwait_control_msr",
          "args": [],
          "line": 6454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_has_waitpkg",
          "args": [
            "vmx"
          ],
          "line": 6451
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_has_waitpkg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "527-531",
          "snippet": "static inline bool vmx_has_waitpkg(struct vcpu_vmx *vmx)\n{\n\treturn vmx->secondary_exec_control &\n\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool vmx_has_waitpkg(struct vcpu_vmx *vmx)\n{\n\treturn vmx->secondary_exec_control &\n\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void atomic_switch_umwait_control_msr(struct vcpu_vmx *vmx)\n{\n\tu32 host_umwait_control;\n\n\tif (!vmx_has_waitpkg(vmx))\n\t\treturn;\n\n\thost_umwait_control = get_umwait_control_msr();\n\n\tif (vmx->msr_ia32_umwait_control != host_umwait_control)\n\t\tadd_atomic_switch_msr(vmx, MSR_IA32_UMWAIT_CONTROL,\n\t\t\tvmx->msr_ia32_umwait_control,\n\t\t\thost_umwait_control, false);\n\telse\n\t\tclear_atomic_switch_msr(vmx, MSR_IA32_UMWAIT_CONTROL);\n}"
  },
  {
    "function_name": "atomic_switch_perf_msrs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6429-6445",
    "snippet": "static void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\n\tif (!msrs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host, false);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_atomic_switch_msr",
          "args": [
            "vmx",
            "msrs[i].msr",
            "msrs[i].guest",
            "msrs[i].host",
            "false"
          ],
          "line": 6443
        },
        "resolved": true,
        "details": {
          "function_name": "add_atomic_switch_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "888-952",
          "snippet": "static void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val, bool entry_only)\n{\n\tint i, j = 0;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (!entry_only)\n\t\tj = vmx_find_msr_index(&m->host, msr);\n\n\tif ((i < 0 && m->guest.nr == NR_LOADSTORE_MSRS) ||\n\t\t(j < 0 &&  m->host.nr == NR_LOADSTORE_MSRS)) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t}\n\tif (i < 0) {\n\t\ti = m->guest.nr++;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\t}\n\tm->guest.val[i].index = msr;\n\tm->guest.val[i].value = guest_val;\n\n\tif (entry_only)\n\t\treturn;\n\n\tif (j < 0) {\n\t\tj = m->host.nr++;\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n\t}\n\tm->host.val[j].index = msr;\n\tm->host.val[j].value = host_val;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val, bool entry_only)\n{\n\tint i, j = 0;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (!entry_only)\n\t\tj = vmx_find_msr_index(&m->host, msr);\n\n\tif ((i < 0 && m->guest.nr == NR_LOADSTORE_MSRS) ||\n\t\t(j < 0 &&  m->host.nr == NR_LOADSTORE_MSRS)) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t}\n\tif (i < 0) {\n\t\ti = m->guest.nr++;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\t}\n\tm->guest.val[i].index = msr;\n\tm->guest.val[i].value = guest_val;\n\n\tif (entry_only)\n\t\treturn;\n\n\tif (j < 0) {\n\t\tj = m->host.nr++;\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n\t}\n\tm->host.val[j].index = msr;\n\tm->host.val[j].value = host_val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_atomic_switch_msr",
          "args": [
            "vmx",
            "msrs[i].msr"
          ],
          "line": 6441
        },
        "resolved": true,
        "details": {
          "function_name": "clear_atomic_switch_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "836-874",
          "snippet": "static void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tint i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (i < 0)\n\t\tgoto skip_guest;\n\t--m->guest.nr;\n\tm->guest.val[i] = m->guest.val[m->guest.nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\nskip_guest:\n\ti = vmx_find_msr_index(&m->host, msr);\n\tif (i < 0)\n\t\treturn;\n\n\t--m->host.nr;\n\tm->host.val[i] = m->host.val[m->host.nr];\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tint i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (i < 0)\n\t\tgoto skip_guest;\n\t--m->guest.nr;\n\tm->guest.val[i] = m->guest.val[m->guest.nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\nskip_guest:\n\ti = vmx_find_msr_index(&m->host, msr);\n\tif (i < 0)\n\t\treturn;\n\n\t--m->host.nr;\n\tm->host.val[i] = m->host.val[m->host.nr];\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_guest_get_msrs",
          "args": [
            "&nr_msrs"
          ],
          "line": 6434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void atomic_switch_perf_msrs(struct vcpu_vmx *vmx)\n{\n\tint i, nr_msrs;\n\tstruct perf_guest_switch_msr *msrs;\n\n\tmsrs = perf_guest_get_msrs(&nr_msrs);\n\n\tif (!msrs)\n\t\treturn;\n\n\tfor (i = 0; i < nr_msrs; i++)\n\t\tif (msrs[i].host == msrs[i].guest)\n\t\t\tclear_atomic_switch_msr(vmx, msrs[i].msr);\n\t\telse\n\t\t\tadd_atomic_switch_msr(vmx, msrs[i].msr, msrs[i].guest,\n\t\t\t\t\tmsrs[i].host, false);\n}"
  },
  {
    "function_name": "vmx_cancel_injection",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6419-6427",
    "snippet": "static void vmx_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\t__vmx_complete_interrupts(vcpu,\n\t\t\t\t  vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t\t\t\t  VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t\t  VM_ENTRY_EXCEPTION_ERROR_CODE);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "VM_ENTRY_INTR_INFO_FIELD",
            "0"
          ],
          "line": 6426
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__vmx_complete_interrupts",
          "args": [
            "vcpu",
            "vmcs_read32(VM_ENTRY_INTR_INFO_FIELD)",
            "VM_ENTRY_INSTRUCTION_LEN",
            "VM_ENTRY_EXCEPTION_ERROR_CODE"
          ],
          "line": 6421
        },
        "resolved": true,
        "details": {
          "function_name": "__vmx_complete_interrupts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6358-6410",
          "snippet": "static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "VM_ENTRY_INTR_INFO_FIELD"
          ],
          "line": 6422
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\t__vmx_complete_interrupts(vcpu,\n\t\t\t\t  vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t\t\t\t  VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t\t  VM_ENTRY_EXCEPTION_ERROR_CODE);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);\n}"
  },
  {
    "function_name": "vmx_complete_interrupts",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6412-6417",
    "snippet": "static void vmx_complete_interrupts(struct vcpu_vmx *vmx)\n{\n\t__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,\n\t\t\t\t  VM_EXIT_INSTRUCTION_LEN,\n\t\t\t\t  IDT_VECTORING_ERROR_CODE);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmx_complete_interrupts",
          "args": [
            "&vmx->vcpu",
            "vmx->idt_vectoring_info",
            "VM_EXIT_INSTRUCTION_LEN",
            "IDT_VECTORING_ERROR_CODE"
          ],
          "line": 6414
        },
        "resolved": true,
        "details": {
          "function_name": "__vmx_complete_interrupts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6358-6410",
          "snippet": "static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_complete_interrupts(struct vcpu_vmx *vmx)\n{\n\t__vmx_complete_interrupts(&vmx->vcpu, vmx->idt_vectoring_info,\n\t\t\t\t  VM_EXIT_INSTRUCTION_LEN,\n\t\t\t\t  IDT_VECTORING_ERROR_CODE);\n}"
  },
  {
    "function_name": "__vmx_complete_interrupts",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6358-6410",
    "snippet": "static void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_interrupt",
          "args": [
            "vcpu",
            "vector",
            "type == INTR_TYPE_SOFT_INTR"
          ],
          "line": 6405
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "56-62",
          "snippet": "static inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.injected = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.injected = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "instr_len_field"
          ],
          "line": 6402
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_requeue_exception",
          "args": [
            "vcpu",
            "vector"
          ],
          "line": 6399
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_requeue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "569-572",
          "snippet": "void kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, true);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_requeue_exception_e",
          "args": [
            "vcpu",
            "vector",
            "err"
          ],
          "line": 6397
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_requeue_exception_e",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "637-640",
          "snippet": "void kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, true);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_set_nmi_mask",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 6389
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_nmi_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4441-4459",
          "snippet": "void vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->soft_vnmi_blocked != masked) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = masked;\n\t\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->soft_vnmi_blocked != masked) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = masked;\n\t\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 6376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_clear_interrupt_queue",
          "args": [
            "vcpu"
          ],
          "line": 6371
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_interrupt_queue",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "64-67",
          "snippet": "static inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.injected = false;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.injected = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_exception_queue",
          "args": [
            "vcpu"
          ],
          "line": 6370
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_exception_queue",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "50-54",
          "snippet": "static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n\tvcpu->arch.exception.injected = false;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n\tvcpu->arch.exception.injected = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic void __vmx_complete_interrupts(struct kvm_vcpu *vcpu,\n\t\t\t\t      u32 idt_vectoring_info,\n\t\t\t\t      int instr_len_field,\n\t\t\t\t      int error_code_field)\n{\n\tu8 vector;\n\tint type;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tvcpu->arch.nmi_injected = false;\n\tkvm_clear_exception_queue(vcpu);\n\tkvm_clear_interrupt_queue(vcpu);\n\n\tif (!idtv_info_valid)\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\tvector = idt_vectoring_info & VECTORING_INFO_VECTOR_MASK;\n\ttype = idt_vectoring_info & VECTORING_INFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase INTR_TYPE_NMI_INTR:\n\t\tvcpu->arch.nmi_injected = true;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Clear bit \"block by NMI\" before VM entry if a NMI\n\t\t * delivery faulted.\n\t\t */\n\t\tvmx_set_nmi_mask(vcpu, false);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\tif (idt_vectoring_info & VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\tu32 err = vmcs_read32(error_code_field);\n\t\t\tkvm_requeue_exception_e(vcpu, vector, err);\n\t\t} else\n\t\t\tkvm_requeue_exception(vcpu, vector);\n\t\tbreak;\n\tcase INTR_TYPE_SOFT_INTR:\n\t\tvcpu->arch.event_exit_inst_len = vmcs_read32(instr_len_field);\n\t\t/* fall through */\n\tcase INTR_TYPE_EXT_INTR:\n\t\tkvm_queue_interrupt(vcpu, vector, type == INTR_TYPE_SOFT_INTR);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "vmx_recover_nmi_blocking",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6315-6356",
    "snippet": "static void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tbool unblock_nmi;\n\tu8 vector;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tif (enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->nmi_known_unmasked)\n\t\t\treturn;\n\t\t/*\n\t\t * Can't use vmx->exit_intr_info since we're not sure what\n\t\t * the exit reason is.\n\t\t */\n\t\texit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\t\tunblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;\n\t\tvector = exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Re-set bit \"block by NMI\" before VM entry if vmexit caused by\n\t\t * a guest IRET fault.\n\t\t * SDM 3: 23.2.2 (September 2008)\n\t\t * Bit 12 is undefined in any of the following cases:\n\t\t *  If the VM exit sets the valid bit in the IDT-vectoring\n\t\t *   information field.\n\t\t *  If the VM exit is due to a double fault.\n\t\t */\n\t\tif ((exit_intr_info & INTR_INFO_VALID_MASK) && unblock_nmi &&\n\t\t    vector != DF_VECTOR && !idtv_info_valid)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmx->loaded_vmcs->nmi_known_unmasked =\n\t\t\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\n\t\t\t\t  & GUEST_INTR_STATE_NMI);\n\t} else if (unlikely(vmx->loaded_vmcs->soft_vnmi_blocked))\n\t\tvmx->loaded_vmcs->vnmi_blocked_time +=\n\t\t\tktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t      vmx->loaded_vmcs->entry_time));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ktime_get(),\n\t\t\t\t\t      vmx->loaded_vmcs->entry_time)"
          ],
          "line": 6354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get()",
            "vmx->loaded_vmcs->entry_time"
          ],
          "line": 6354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 6354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vmx->loaded_vmcs->soft_vnmi_blocked"
          ],
          "line": 6352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO"
          ],
          "line": 6350
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_set_bits",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO",
            "GUEST_INTR_STATE_NMI"
          ],
          "line": 6346
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "224-232",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)\n{\n\tu32 exit_intr_info;\n\tbool unblock_nmi;\n\tu8 vector;\n\tbool idtv_info_valid;\n\n\tidtv_info_valid = vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n\n\tif (enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->nmi_known_unmasked)\n\t\t\treturn;\n\t\t/*\n\t\t * Can't use vmx->exit_intr_info since we're not sure what\n\t\t * the exit reason is.\n\t\t */\n\t\texit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\t\tunblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;\n\t\tvector = exit_intr_info & INTR_INFO_VECTOR_MASK;\n\t\t/*\n\t\t * SDM 3: 27.7.1.2 (September 2008)\n\t\t * Re-set bit \"block by NMI\" before VM entry if vmexit caused by\n\t\t * a guest IRET fault.\n\t\t * SDM 3: 23.2.2 (September 2008)\n\t\t * Bit 12 is undefined in any of the following cases:\n\t\t *  If the VM exit sets the valid bit in the IDT-vectoring\n\t\t *   information field.\n\t\t *  If the VM exit is due to a double fault.\n\t\t */\n\t\tif ((exit_intr_info & INTR_INFO_VALID_MASK) && unblock_nmi &&\n\t\t    vector != DF_VECTOR && !idtv_info_valid)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmx->loaded_vmcs->nmi_known_unmasked =\n\t\t\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\n\t\t\t\t  & GUEST_INTR_STATE_NMI);\n\t} else if (unlikely(vmx->loaded_vmcs->soft_vnmi_blocked))\n\t\tvmx->loaded_vmcs->vnmi_blocked_time +=\n\t\t\tktime_to_ns(ktime_sub(ktime_get(),\n\t\t\t\t\t      vmx->loaded_vmcs->entry_time));\n}"
  },
  {
    "function_name": "vmx_has_emulated_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6296-6313",
    "snippet": "static bool vmx_has_emulated_msr(int index)\n{\n\tswitch (index) {\n\tcase MSR_IA32_SMBASE:\n\t\t/*\n\t\t * We cannot do SMM unless we can run the guest in big\n\t\t * real mode.\n\t\t */\n\t\treturn enable_unrestricted_guest || emulate_invalid_guest_state;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\treturn nested;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\t\t/* This is AMD only.  */\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\n\nstatic bool vmx_has_emulated_msr(int index)\n{\n\tswitch (index) {\n\tcase MSR_IA32_SMBASE:\n\t\t/*\n\t\t * We cannot do SMM unless we can run the guest in big\n\t\t * real mode.\n\t\t */\n\t\treturn enable_unrestricted_guest || emulate_invalid_guest_state;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\treturn nested;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\t\t/* This is AMD only.  */\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}"
  },
  {
    "function_name": "vmx_handle_exit_irqoff",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6282-6294",
    "snippet": "static void vmx_handle_exit_irqoff(struct kvm_vcpu *vcpu,\n\tenum exit_fastpath_completion *exit_fastpath)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (vmx->exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t\thandle_external_interrupt_irqoff(vcpu);\n\telse if (vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI)\n\t\thandle_exception_nmi_irqoff(vmx);\n\telse if (!is_guest_mode(vcpu) &&\n\t\tvmx->exit_reason == EXIT_REASON_MSR_WRITE)\n\t\t*exit_fastpath = handle_fastpath_set_msr_irqoff(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_fastpath_set_msr_irqoff",
          "args": [
            "vcpu"
          ],
          "line": 6293
        },
        "resolved": true,
        "details": {
          "function_name": "handle_fastpath_set_msr_irqoff",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1602-1623",
          "snippet": "enum exit_fastpath_completion handle_fastpath_set_msr_irqoff(struct kvm_vcpu *vcpu)\n{\n\tu32 msr = kvm_rcx_read(vcpu);\n\tu64 data;\n\tint ret = 0;\n\n\tswitch (msr) {\n\tcase APIC_BASE_MSR + (APIC_ICR >> 4):\n\t\tdata = kvm_read_edx_eax(vcpu);\n\t\tret = handle_fastpath_set_x2apic_icr_irqoff(vcpu, data);\n\t\tbreak;\n\tdefault:\n\t\treturn EXIT_FASTPATH_NONE;\n\t}\n\n\tif (!ret) {\n\t\ttrace_kvm_msr_write(msr, data);\n\t\treturn EXIT_FASTPATH_SKIP_EMUL_INS;\n\t}\n\n\treturn EXIT_FASTPATH_NONE;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nenum exit_fastpath_completion handle_fastpath_set_msr_irqoff(struct kvm_vcpu *vcpu)\n{\n\tu32 msr = kvm_rcx_read(vcpu);\n\tu64 data;\n\tint ret = 0;\n\n\tswitch (msr) {\n\tcase APIC_BASE_MSR + (APIC_ICR >> 4):\n\t\tdata = kvm_read_edx_eax(vcpu);\n\t\tret = handle_fastpath_set_x2apic_icr_irqoff(vcpu, data);\n\t\tbreak;\n\tdefault:\n\t\treturn EXIT_FASTPATH_NONE;\n\t}\n\n\tif (!ret) {\n\t\ttrace_kvm_msr_write(msr, data);\n\t\treturn EXIT_FASTPATH_SKIP_EMUL_INS;\n\t}\n\n\treturn EXIT_FASTPATH_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 6291
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_exception_nmi_irqoff",
          "args": [
            "vmx"
          ],
          "line": 6290
        },
        "resolved": true,
        "details": {
          "function_name": "handle_exception_nmi_irqoff",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6218-6234",
          "snippet": "static void handle_exception_nmi_irqoff(struct vcpu_vmx *vmx)\n{\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\t/* if exit due to PF check for async PF */\n\tif (is_page_fault(vmx->exit_intr_info)) {\n\t\tvmx->vcpu.arch.apf.host_apf_reason = kvm_read_and_reset_pf_reason();\n\t/* Handle machine checks before interrupts are enabled */\n\t} else if (is_machine_check(vmx->exit_intr_info)) {\n\t\tkvm_machine_check();\n\t/* We need to handle NMIs before interrupts are enabled */\n\t} else if (is_nmi(vmx->exit_intr_info)) {\n\t\tkvm_before_interrupt(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_interrupt(&vmx->vcpu);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void handle_exception_nmi_irqoff(struct vcpu_vmx *vmx)\n{\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\t/* if exit due to PF check for async PF */\n\tif (is_page_fault(vmx->exit_intr_info)) {\n\t\tvmx->vcpu.arch.apf.host_apf_reason = kvm_read_and_reset_pf_reason();\n\t/* Handle machine checks before interrupts are enabled */\n\t} else if (is_machine_check(vmx->exit_intr_info)) {\n\t\tkvm_machine_check();\n\t/* We need to handle NMIs before interrupts are enabled */\n\t} else if (is_nmi(vmx->exit_intr_info)) {\n\t\tkvm_before_interrupt(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_interrupt(&vmx->vcpu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_external_interrupt_irqoff",
          "args": [
            "vcpu"
          ],
          "line": 6288
        },
        "resolved": true,
        "details": {
          "function_name": "handle_external_interrupt_irqoff",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6236-6279",
          "snippet": "static void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n{\n\tunsigned int vector;\n\tunsigned long entry;\n#ifdef CONFIG_X86_64\n\tunsigned long tmp;\n#endif\n\tgate_desc *desc;\n\tu32 intr_info;\n\n\tintr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tif (WARN_ONCE(!is_external_intr(intr_info),\n\t    \"KVM: unexpected VM-Exit interrupt info: 0x%x\", intr_info))\n\t\treturn;\n\n\tvector = intr_info & INTR_INFO_VECTOR_MASK;\n\tdesc = (gate_desc *)host_idt_base + vector;\n\tentry = gate_offset(desc);\n\n\tkvm_before_interrupt(vcpu);\n\n\tasm volatile(\n#ifdef CONFIG_X86_64\n\t\t\"mov %%\" _ASM_SP \", %[sp]\\n\\t\"\n\t\t\"and $0xfffffffffffffff0, %%\" _ASM_SP \"\\n\\t\"\n\t\t\"push $%c[ss]\\n\\t\"\n\t\t\"push %[sp]\\n\\t\"\n#endif\n\t\t\"pushf\\n\\t\"\n\t\t__ASM_SIZE(push) \" $%c[cs]\\n\\t\"\n\t\tCALL_NOSPEC\n\t\t:\n#ifdef CONFIG_X86_64\n\t\t[sp]\"=&r\"(tmp),\n#endif\n\t\tASM_CALL_CONSTRAINT\n\t\t:\n\t\t[thunk_target]\"r\"(entry),\n\t\t[ss]\"i\"(__KERNEL_DS),\n\t\t[cs]\"i\"(__KERNEL_CS)\n\t);\n\n\tkvm_after_interrupt(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static unsigned long host_idt_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic unsigned long host_idt_base;\n\nstatic void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n{\n\tunsigned int vector;\n\tunsigned long entry;\n#ifdef CONFIG_X86_64\n\tunsigned long tmp;\n#endif\n\tgate_desc *desc;\n\tu32 intr_info;\n\n\tintr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tif (WARN_ONCE(!is_external_intr(intr_info),\n\t    \"KVM: unexpected VM-Exit interrupt info: 0x%x\", intr_info))\n\t\treturn;\n\n\tvector = intr_info & INTR_INFO_VECTOR_MASK;\n\tdesc = (gate_desc *)host_idt_base + vector;\n\tentry = gate_offset(desc);\n\n\tkvm_before_interrupt(vcpu);\n\n\tasm volatile(\n#ifdef CONFIG_X86_64\n\t\t\"mov %%\" _ASM_SP \", %[sp]\\n\\t\"\n\t\t\"and $0xfffffffffffffff0, %%\" _ASM_SP \"\\n\\t\"\n\t\t\"push $%c[ss]\\n\\t\"\n\t\t\"push %[sp]\\n\\t\"\n#endif\n\t\t\"pushf\\n\\t\"\n\t\t__ASM_SIZE(push) \" $%c[cs]\\n\\t\"\n\t\tCALL_NOSPEC\n\t\t:\n#ifdef CONFIG_X86_64\n\t\t[sp]\"=&r\"(tmp),\n#endif\n\t\tASM_CALL_CONSTRAINT\n\t\t:\n\t\t[thunk_target]\"r\"(entry),\n\t\t[ss]\"i\"(__KERNEL_DS),\n\t\t[cs]\"i\"(__KERNEL_CS)\n\t);\n\n\tkvm_after_interrupt(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 6285
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_handle_exit_irqoff(struct kvm_vcpu *vcpu,\n\tenum exit_fastpath_completion *exit_fastpath)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (vmx->exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t\thandle_external_interrupt_irqoff(vcpu);\n\telse if (vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI)\n\t\thandle_exception_nmi_irqoff(vmx);\n\telse if (!is_guest_mode(vcpu) &&\n\t\tvmx->exit_reason == EXIT_REASON_MSR_WRITE)\n\t\t*exit_fastpath = handle_fastpath_set_msr_irqoff(vcpu);\n}"
  },
  {
    "function_name": "handle_external_interrupt_irqoff",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6236-6279",
    "snippet": "static void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n{\n\tunsigned int vector;\n\tunsigned long entry;\n#ifdef CONFIG_X86_64\n\tunsigned long tmp;\n#endif\n\tgate_desc *desc;\n\tu32 intr_info;\n\n\tintr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tif (WARN_ONCE(!is_external_intr(intr_info),\n\t    \"KVM: unexpected VM-Exit interrupt info: 0x%x\", intr_info))\n\t\treturn;\n\n\tvector = intr_info & INTR_INFO_VECTOR_MASK;\n\tdesc = (gate_desc *)host_idt_base + vector;\n\tentry = gate_offset(desc);\n\n\tkvm_before_interrupt(vcpu);\n\n\tasm volatile(\n#ifdef CONFIG_X86_64\n\t\t\"mov %%\" _ASM_SP \", %[sp]\\n\\t\"\n\t\t\"and $0xfffffffffffffff0, %%\" _ASM_SP \"\\n\\t\"\n\t\t\"push $%c[ss]\\n\\t\"\n\t\t\"push %[sp]\\n\\t\"\n#endif\n\t\t\"pushf\\n\\t\"\n\t\t__ASM_SIZE(push) \" $%c[cs]\\n\\t\"\n\t\tCALL_NOSPEC\n\t\t:\n#ifdef CONFIG_X86_64\n\t\t[sp]\"=&r\"(tmp),\n#endif\n\t\tASM_CALL_CONSTRAINT\n\t\t:\n\t\t[thunk_target]\"r\"(entry),\n\t\t[ss]\"i\"(__KERNEL_DS),\n\t\t[cs]\"i\"(__KERNEL_CS)\n\t);\n\n\tkvm_after_interrupt(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static unsigned long host_idt_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_after_interrupt",
          "args": [
            "vcpu"
          ],
          "line": 6278
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_after_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "338-341",
          "snippet": "static inline void kvm_after_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_after_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "\"i\"",
          "args": [
            "__KERNEL_CS"
          ],
          "line": 6275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"i\"",
          "args": [
            "__KERNEL_DS"
          ],
          "line": 6274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"r\"",
          "args": [
            "entry"
          ],
          "line": 6273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asm volatile",
          "args": [
            "push"
          ],
          "line": 6257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_before_interrupt",
          "args": [
            "vcpu"
          ],
          "line": 6255
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_before_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "333-336",
          "snippet": "static inline void kvm_before_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_before_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gate_offset",
          "args": [
            "desc"
          ],
          "line": 6253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!is_external_intr(intr_info)",
            "\"KVM: unexpected VM-Exit interrupt info: 0x%x\"",
            "intr_info"
          ],
          "line": 6247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_external_intr",
          "args": [
            "intr_info"
          ],
          "line": 6247
        },
        "resolved": true,
        "details": {
          "function_name": "is_external_intr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmcs.h",
          "lines": "127-131",
          "snippet": "static inline bool is_external_intr(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_VALID_MASK | INTR_INFO_INTR_TYPE_MASK))\n\t\t== (INTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR);\n}",
          "includes": [
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm.h>",
            "#include <linux/nospec.h>",
            "#include <linux/list.h>",
            "#include <linux/ktime.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/kvm.h>\n#include <linux/nospec.h>\n#include <linux/list.h>\n#include <linux/ktime.h>\n\nstatic inline bool is_external_intr(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_VALID_MASK | INTR_INFO_INTR_TYPE_MASK))\n\t\t== (INTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "VM_EXIT_INTR_INFO"
          ],
          "line": 6246
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic unsigned long host_idt_base;\n\nstatic void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n{\n\tunsigned int vector;\n\tunsigned long entry;\n#ifdef CONFIG_X86_64\n\tunsigned long tmp;\n#endif\n\tgate_desc *desc;\n\tu32 intr_info;\n\n\tintr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tif (WARN_ONCE(!is_external_intr(intr_info),\n\t    \"KVM: unexpected VM-Exit interrupt info: 0x%x\", intr_info))\n\t\treturn;\n\n\tvector = intr_info & INTR_INFO_VECTOR_MASK;\n\tdesc = (gate_desc *)host_idt_base + vector;\n\tentry = gate_offset(desc);\n\n\tkvm_before_interrupt(vcpu);\n\n\tasm volatile(\n#ifdef CONFIG_X86_64\n\t\t\"mov %%\" _ASM_SP \", %[sp]\\n\\t\"\n\t\t\"and $0xfffffffffffffff0, %%\" _ASM_SP \"\\n\\t\"\n\t\t\"push $%c[ss]\\n\\t\"\n\t\t\"push %[sp]\\n\\t\"\n#endif\n\t\t\"pushf\\n\\t\"\n\t\t__ASM_SIZE(push) \" $%c[cs]\\n\\t\"\n\t\tCALL_NOSPEC\n\t\t:\n#ifdef CONFIG_X86_64\n\t\t[sp]\"=&r\"(tmp),\n#endif\n\t\tASM_CALL_CONSTRAINT\n\t\t:\n\t\t[thunk_target]\"r\"(entry),\n\t\t[ss]\"i\"(__KERNEL_DS),\n\t\t[cs]\"i\"(__KERNEL_CS)\n\t);\n\n\tkvm_after_interrupt(vcpu);\n}"
  },
  {
    "function_name": "handle_exception_nmi_irqoff",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6218-6234",
    "snippet": "static void handle_exception_nmi_irqoff(struct vcpu_vmx *vmx)\n{\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\t/* if exit due to PF check for async PF */\n\tif (is_page_fault(vmx->exit_intr_info)) {\n\t\tvmx->vcpu.arch.apf.host_apf_reason = kvm_read_and_reset_pf_reason();\n\t/* Handle machine checks before interrupts are enabled */\n\t} else if (is_machine_check(vmx->exit_intr_info)) {\n\t\tkvm_machine_check();\n\t/* We need to handle NMIs before interrupts are enabled */\n\t} else if (is_nmi(vmx->exit_intr_info)) {\n\t\tkvm_before_interrupt(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_interrupt(&vmx->vcpu);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_after_interrupt",
          "args": [
            "&vmx->vcpu"
          ],
          "line": 6232
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_after_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "338-341",
          "snippet": "static inline void kvm_after_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_after_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_before_interrupt",
          "args": [
            "&vmx->vcpu"
          ],
          "line": 6230
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_before_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "333-336",
          "snippet": "static inline void kvm_before_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_before_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nmi",
          "args": [
            "vmx->exit_intr_info"
          ],
          "line": 6229
        },
        "resolved": true,
        "details": {
          "function_name": "is_nmi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmcs.h",
          "lines": "121-125",
          "snippet": "static inline bool is_nmi(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);\n}",
          "includes": [
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm.h>",
            "#include <linux/nospec.h>",
            "#include <linux/list.h>",
            "#include <linux/ktime.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/kvm.h>\n#include <linux/nospec.h>\n#include <linux/list.h>\n#include <linux/ktime.h>\n\nstatic inline bool is_nmi(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_machine_check",
          "args": [],
          "line": 6227
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_machine_check",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4577-4587",
          "snippet": "static void kvm_machine_check(void)\n{\n#if defined(CONFIG_X86_MCE) && defined(CONFIG_X86_64)\n\tstruct pt_regs regs = {\n\t\t.cs = 3, /* Fake ring 3 no matter what the guest ran on */\n\t\t.flags = X86_EFLAGS_IF,\n\t};\n\n\tdo_machine_check(&regs, 0);\n#endif\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void kvm_machine_check(void)\n{\n#if defined(CONFIG_X86_MCE) && defined(CONFIG_X86_64)\n\tstruct pt_regs regs = {\n\t\t.cs = 3, /* Fake ring 3 no matter what the guest ran on */\n\t\t.flags = X86_EFLAGS_IF,\n\t};\n\n\tdo_machine_check(&regs, 0);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_machine_check",
          "args": [
            "vmx->exit_intr_info"
          ],
          "line": 6226
        },
        "resolved": true,
        "details": {
          "function_name": "is_machine_check",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmcs.h",
          "lines": "107-112",
          "snippet": "static inline bool is_machine_check(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | MC_VECTOR | INTR_INFO_VALID_MASK);\n}",
          "includes": [
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm.h>",
            "#include <linux/nospec.h>",
            "#include <linux/list.h>",
            "#include <linux/ktime.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/kvm.h>\n#include <linux/nospec.h>\n#include <linux/list.h>\n#include <linux/ktime.h>\n\nstatic inline bool is_machine_check(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | MC_VECTOR | INTR_INFO_VALID_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_and_reset_pf_reason",
          "args": [],
          "line": 6224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_page_fault",
          "args": [
            "vmx->exit_intr_info"
          ],
          "line": 6223
        },
        "resolved": true,
        "details": {
          "function_name": "is_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmcs.h",
          "lines": "92-95",
          "snippet": "static inline bool is_page_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, PF_VECTOR);\n}",
          "includes": [
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm.h>",
            "#include <linux/nospec.h>",
            "#include <linux/list.h>",
            "#include <linux/ktime.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/kvm.h>\n#include <linux/nospec.h>\n#include <linux/list.h>\n#include <linux/ktime.h>\n\nstatic inline bool is_page_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, PF_VECTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "VM_EXIT_INTR_INFO"
          ],
          "line": 6220
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void handle_exception_nmi_irqoff(struct vcpu_vmx *vmx)\n{\n\tvmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\t/* if exit due to PF check for async PF */\n\tif (is_page_fault(vmx->exit_intr_info)) {\n\t\tvmx->vcpu.arch.apf.host_apf_reason = kvm_read_and_reset_pf_reason();\n\t/* Handle machine checks before interrupts are enabled */\n\t} else if (is_machine_check(vmx->exit_intr_info)) {\n\t\tkvm_machine_check();\n\t/* We need to handle NMIs before interrupts are enabled */\n\t} else if (is_nmi(vmx->exit_intr_info)) {\n\t\tkvm_before_interrupt(&vmx->vcpu);\n\t\tasm(\"int $2\");\n\t\tkvm_after_interrupt(&vmx->vcpu);\n\t}\n}"
  },
  {
    "function_name": "vmx_apicv_post_state_restore",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6210-6216",
    "snippet": "static void vmx_apicv_post_state_restore(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tpi_clear_on(&vmx->pi_desc);\n\tmemset(vmx->pi_desc.pir, 0, sizeof(vmx->pi_desc.pir));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vmx->pi_desc.pir",
            "0",
            "sizeof(vmx->pi_desc.pir)"
          ],
          "line": 6215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pi_clear_on",
          "args": [
            "&vmx->pi_desc"
          ],
          "line": 6214
        },
        "resolved": true,
        "details": {
          "function_name": "pi_clear_on",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "389-393",
          "snippet": "static inline void pi_clear_on(struct pi_desc *pi_desc)\n{\n\tclear_bit(POSTED_INTR_ON,\n\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_ON  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_ON  0\n\nstatic inline void pi_clear_on(struct pi_desc *pi_desc)\n{\n\tclear_bit(POSTED_INTR_ON,\n\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 6212
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_apicv_post_state_restore(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tpi_clear_on(&vmx->pi_desc);\n\tmemset(vmx->pi_desc.pir, 0, sizeof(vmx->pi_desc.pir));\n}"
  },
  {
    "function_name": "vmx_load_eoi_exitmap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6199-6208",
    "snippet": "static void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tvmcs_write64(EOI_EXIT_BITMAP0, eoi_exit_bitmap[0]);\n\tvmcs_write64(EOI_EXIT_BITMAP1, eoi_exit_bitmap[1]);\n\tvmcs_write64(EOI_EXIT_BITMAP2, eoi_exit_bitmap[2]);\n\tvmcs_write64(EOI_EXIT_BITMAP3, eoi_exit_bitmap[3]);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write64",
          "args": [
            "EOI_EXIT_BITMAP3",
            "eoi_exit_bitmap[3]"
          ],
          "line": 6207
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "193-203",
          "snippet": "static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 6201
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tvmcs_write64(EOI_EXIT_BITMAP0, eoi_exit_bitmap[0]);\n\tvmcs_write64(EOI_EXIT_BITMAP1, eoi_exit_bitmap[1]);\n\tvmcs_write64(EOI_EXIT_BITMAP2, eoi_exit_bitmap[2]);\n\tvmcs_write64(EOI_EXIT_BITMAP3, eoi_exit_bitmap[3]);\n}"
  },
  {
    "function_name": "vmx_dy_apicv_has_pending_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6191-6197",
    "snippet": "static bool vmx_dy_apicv_has_pending_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\treturn pi_test_on(pi_desc) ||\n\t\t(pi_test_sn(pi_desc) && !pi_is_pir_empty(pi_desc));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pi_is_pir_empty",
          "args": [
            "pi_desc"
          ],
          "line": 6196
        },
        "resolved": true,
        "details": {
          "function_name": "pi_is_pir_empty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "372-375",
          "snippet": "static inline bool pi_is_pir_empty(struct pi_desc *pi_desc)\n{\n\treturn bitmap_empty((unsigned long *)pi_desc->pir, NR_VECTORS);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool pi_is_pir_empty(struct pi_desc *pi_desc)\n{\n\treturn bitmap_empty((unsigned long *)pi_desc->pir, NR_VECTORS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pi_test_sn",
          "args": [
            "pi_desc"
          ],
          "line": 6196
        },
        "resolved": true,
        "details": {
          "function_name": "pi_test_sn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "407-411",
          "snippet": "static inline int pi_test_sn(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_SN  1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_SN  1\n\nstatic inline int pi_test_sn(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pi_test_on",
          "args": [
            "pi_desc"
          ],
          "line": 6195
        },
        "resolved": true,
        "details": {
          "function_name": "pi_test_on",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "401-405",
          "snippet": "static inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_ON  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_ON  0\n\nstatic inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pi_desc",
          "args": [
            "vcpu"
          ],
          "line": 6193
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_pi_desc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "484-487",
          "snippet": "static inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool vmx_dy_apicv_has_pending_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\treturn pi_test_on(pi_desc) ||\n\t\t(pi_test_sn(pi_desc) && !pi_is_pir_empty(pi_desc));\n}"
  },
  {
    "function_name": "vmx_sync_pir_to_irr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6153-6189",
    "snippet": "static int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint max_irr;\n\tbool max_irr_updated;\n\n\tWARN_ON(!vcpu->arch.apicv_active);\n\tif (pi_test_on(&vmx->pi_desc)) {\n\t\tpi_clear_on(&vmx->pi_desc);\n\t\t/*\n\t\t * IOMMU can write to PID.ON, so the barrier matters even on UP.\n\t\t * But on x86 this is just a compiler barrier anyway.\n\t\t */\n\t\tsmp_mb__after_atomic();\n\t\tmax_irr_updated =\n\t\t\tkvm_apic_update_irr(vcpu, vmx->pi_desc.pir, &max_irr);\n\n\t\t/*\n\t\t * If we are running L2 and L1 has a new pending interrupt\n\t\t * which can be injected, we should re-evaluate\n\t\t * what should be done with this new L1 interrupt.\n\t\t * If L1 intercepts external-interrupts, we should\n\t\t * exit from L2 to L1. Otherwise, interrupt should be\n\t\t * delivered directly to L2.\n\t\t */\n\t\tif (is_guest_mode(vcpu) && max_irr_updated) {\n\t\t\tif (nested_exit_on_intr(vcpu))\n\t\t\t\tkvm_vcpu_exiting_guest_mode(vcpu);\n\t\t\telse\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t}\n\t} else {\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\t}\n\tvmx_hwapic_irr_update(vcpu, max_irr);\n\treturn max_irr;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_hwapic_irr_update",
          "args": [
            "vcpu",
            "max_irr"
          ],
          "line": 6187
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_hwapic_irr_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6139-6151",
          "snippet": "static void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n\t/*\n\t * When running L2, updating RVI is only relevant when\n\t * vmcs12 virtual-interrupt-delivery enabled.\n\t * However, it can be enabled only when L1 also\n\t * intercepts external-interrupts and in that case\n\t * we should not update vmcs02 RVI but instead intercept\n\t * interrupt. Therefore, do nothing when running L2.\n\t */\n\tif (!is_guest_mode(vcpu))\n\t\tvmx_set_rvi(max_irr);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n\t/*\n\t * When running L2, updating RVI is only relevant when\n\t * vmcs12 virtual-interrupt-delivery enabled.\n\t * However, it can be enabled only when L1 also\n\t * intercepts external-interrupts and in that case\n\t * we should not update vmcs02 RVI but instead intercept\n\t * interrupt. Therefore, do nothing when running L2.\n\t */\n\tif (!is_guest_mode(vcpu))\n\t\tvmx_set_rvi(max_irr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_find_highest_irr",
          "args": [
            "vcpu"
          ],
          "line": 6185
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_find_highest_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "548-556",
          "snippet": "int kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_find_highest_irr(struct kvm_vcpu *vcpu)\n{\n\t/* This may race with setting of irr in __apic_accept_irq() and\n\t * value returned may be wrong, but kvm_vcpu_kick() in __apic_accept_irq\n\t * will cause vmexit immediately and the value will be recalculated\n\t * on the next vmentry.\n\t */\n\treturn apic_find_highest_irr(vcpu->arch.apic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 6182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_exiting_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 6180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_exit_on_intr",
          "args": [
            "vcpu"
          ],
          "line": 6179
        },
        "resolved": true,
        "details": {
          "function_name": "nested_exit_on_intr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "253-257",
          "snippet": "static inline bool nested_exit_on_intr(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_EXT_INTR_MASK;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_exit_on_intr(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_EXT_INTR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 6178
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_update_irr",
          "args": [
            "vcpu",
            "vmx->pi_desc.pir",
            "&max_irr"
          ],
          "line": 6168
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_update_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "427-432",
          "snippet": "bool kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir, int *max_irr)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __kvm_apic_update_irr(pir, apic->regs, max_irr);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_update_irr(struct kvm_vcpu *vcpu, u32 *pir, int *max_irr)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __kvm_apic_update_irr(pir, apic->regs, max_irr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 6166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pi_clear_on",
          "args": [
            "&vmx->pi_desc"
          ],
          "line": 6161
        },
        "resolved": true,
        "details": {
          "function_name": "pi_clear_on",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "389-393",
          "snippet": "static inline void pi_clear_on(struct pi_desc *pi_desc)\n{\n\tclear_bit(POSTED_INTR_ON,\n\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_ON  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_ON  0\n\nstatic inline void pi_clear_on(struct pi_desc *pi_desc)\n{\n\tclear_bit(POSTED_INTR_ON,\n\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pi_test_on",
          "args": [
            "&vmx->pi_desc"
          ],
          "line": 6160
        },
        "resolved": true,
        "details": {
          "function_name": "pi_test_on",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "401-405",
          "snippet": "static inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_ON  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_ON  0\n\nstatic inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!vcpu->arch.apicv_active"
          ],
          "line": 6159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 6155
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_sync_pir_to_irr(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint max_irr;\n\tbool max_irr_updated;\n\n\tWARN_ON(!vcpu->arch.apicv_active);\n\tif (pi_test_on(&vmx->pi_desc)) {\n\t\tpi_clear_on(&vmx->pi_desc);\n\t\t/*\n\t\t * IOMMU can write to PID.ON, so the barrier matters even on UP.\n\t\t * But on x86 this is just a compiler barrier anyway.\n\t\t */\n\t\tsmp_mb__after_atomic();\n\t\tmax_irr_updated =\n\t\t\tkvm_apic_update_irr(vcpu, vmx->pi_desc.pir, &max_irr);\n\n\t\t/*\n\t\t * If we are running L2 and L1 has a new pending interrupt\n\t\t * which can be injected, we should re-evaluate\n\t\t * what should be done with this new L1 interrupt.\n\t\t * If L1 intercepts external-interrupts, we should\n\t\t * exit from L2 to L1. Otherwise, interrupt should be\n\t\t * delivered directly to L2.\n\t\t */\n\t\tif (is_guest_mode(vcpu) && max_irr_updated) {\n\t\t\tif (nested_exit_on_intr(vcpu))\n\t\t\t\tkvm_vcpu_exiting_guest_mode(vcpu);\n\t\t\telse\n\t\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t}\n\t} else {\n\t\tmax_irr = kvm_lapic_find_highest_irr(vcpu);\n\t}\n\tvmx_hwapic_irr_update(vcpu, max_irr);\n\treturn max_irr;\n}"
  },
  {
    "function_name": "vmx_hwapic_irr_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6139-6151",
    "snippet": "static void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n\t/*\n\t * When running L2, updating RVI is only relevant when\n\t * vmcs12 virtual-interrupt-delivery enabled.\n\t * However, it can be enabled only when L1 also\n\t * intercepts external-interrupts and in that case\n\t * we should not update vmcs02 RVI but instead intercept\n\t * interrupt. Therefore, do nothing when running L2.\n\t */\n\tif (!is_guest_mode(vcpu))\n\t\tvmx_set_rvi(max_irr);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_set_rvi",
          "args": [
            "max_irr"
          ],
          "line": 6150
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_rvi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6122-6137",
          "snippet": "static void vmx_set_rvi(int vector)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (vector == -1)\n\t\tvector = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = (u8)status & 0xff;\n\tif ((u8)vector != old) {\n\t\tstatus &= ~0xff;\n\t\tstatus |= (u8)vector;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_set_rvi(int vector)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (vector == -1)\n\t\tvector = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = (u8)status & 0xff;\n\tif ((u8)vector != old) {\n\t\tstatus &= ~0xff;\n\t\tstatus |= (u8)vector;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 6149
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n\t/*\n\t * When running L2, updating RVI is only relevant when\n\t * vmcs12 virtual-interrupt-delivery enabled.\n\t * However, it can be enabled only when L1 also\n\t * intercepts external-interrupts and in that case\n\t * we should not update vmcs02 RVI but instead intercept\n\t * interrupt. Therefore, do nothing when running L2.\n\t */\n\tif (!is_guest_mode(vcpu))\n\t\tvmx_set_rvi(max_irr);\n}"
  },
  {
    "function_name": "vmx_set_rvi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6122-6137",
    "snippet": "static void vmx_set_rvi(int vector)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (vector == -1)\n\t\tvector = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = (u8)status & 0xff;\n\tif ((u8)vector != old) {\n\t\tstatus &= ~0xff;\n\t\tstatus |= (u8)vector;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write16",
          "args": [
            "GUEST_INTR_STATUS",
            "status"
          ],
          "line": 6135
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "175-182",
          "snippet": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read16",
          "args": [
            "GUEST_INTR_STATUS"
          ],
          "line": 6130
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "104-110",
          "snippet": "static __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_set_rvi(int vector)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (vector == -1)\n\t\tvector = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = (u8)status & 0xff;\n\tif ((u8)vector != old) {\n\t\tstatus &= ~0xff;\n\t\tstatus |= (u8)vector;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}"
  },
  {
    "function_name": "vmx_hwapic_isr_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6105-6120",
    "snippet": "static void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (max_isr == -1)\n\t\tmax_isr = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = status >> 8;\n\tif (max_isr != old) {\n\t\tstatus &= 0xff;\n\t\tstatus |= max_isr << 8;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write16",
          "args": [
            "GUEST_INTR_STATUS",
            "status"
          ],
          "line": 6118
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "175-182",
          "snippet": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read16",
          "args": [
            "GUEST_INTR_STATUS"
          ],
          "line": 6113
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "104-110",
          "snippet": "static __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)\n{\n\tu16 status;\n\tu8 old;\n\n\tif (max_isr == -1)\n\t\tmax_isr = 0;\n\n\tstatus = vmcs_read16(GUEST_INTR_STATUS);\n\told = status >> 8;\n\tif (max_isr != old) {\n\t\tstatus &= 0xff;\n\t\tstatus |= max_isr << 8;\n\t\tvmcs_write16(GUEST_INTR_STATUS, status);\n\t}\n}"
  },
  {
    "function_name": "vmx_set_apic_access_page_addr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6097-6103",
    "snippet": "static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu, hpa_t hpa)\n{\n\tif (!is_guest_mode(vcpu)) {\n\t\tvmcs_write64(APIC_ACCESS_ADDR, hpa);\n\t\tvmx_flush_tlb(vcpu, true);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_flush_tlb",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 6101
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_flush_tlb_gva",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2845-2857",
          "snippet": "static void vmx_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\tint vpid = to_vmx(vcpu)->vpid;\n\n\tif (!vpid_sync_vcpu_addr(vpid, addr))\n\t\tvpid_sync_context(vpid);\n\n\t/*\n\t * If VPIDs are not supported or enabled, then the above is a no-op.\n\t * But we don't really need a TLB flush in that case anyway, because\n\t * each VM entry/exit includes an implicit flush when VPID is 0.\n\t */\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\tint vpid = to_vmx(vcpu)->vpid;\n\n\tif (!vpid_sync_vcpu_addr(vpid, addr))\n\t\tvpid_sync_context(vpid);\n\n\t/*\n\t * If VPIDs are not supported or enabled, then the above is a no-op.\n\t * But we don't really need a TLB flush in that case anyway, because\n\t * each VM entry/exit includes an implicit flush when VPID is 0.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write64",
          "args": [
            "APIC_ACCESS_ADDR",
            "hpa"
          ],
          "line": 6100
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "193-203",
          "snippet": "static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 6099
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu, hpa_t hpa)\n{\n\tif (!is_guest_mode(vcpu)) {\n\t\tvmcs_write64(APIC_ACCESS_ADDR, hpa);\n\t\tvmx_flush_tlb(vcpu, true);\n\t}\n}"
  },
  {
    "function_name": "vmx_set_virtual_apic_mode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6052-6095",
    "snippet": "void vmx_set_virtual_apic_mode(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 sec_exec_control;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (!flexpriority_enabled &&\n\t    !cpu_has_vmx_virtualize_x2apic_mode())\n\t\treturn;\n\n\t/* Postpone execution until vmcs01 is the current VMCS. */\n\tif (is_guest_mode(vcpu)) {\n\t\tvmx->nested.change_vmcs01_virtual_apic_mode = true;\n\t\treturn;\n\t}\n\n\tsec_exec_control = secondary_exec_controls_get(vmx);\n\tsec_exec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\t      SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);\n\n\tswitch (kvm_get_apic_mode(vcpu)) {\n\tcase LAPIC_MODE_INVALID:\n\t\tWARN_ONCE(true, \"Invalid local APIC state\");\n\tcase LAPIC_MODE_DISABLED:\n\t\tbreak;\n\tcase LAPIC_MODE_XAPIC:\n\t\tif (flexpriority_enabled) {\n\t\t\tsec_exec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\tvmx_flush_tlb(vcpu, true);\n\t\t}\n\t\tbreak;\n\tcase LAPIC_MODE_X2APIC:\n\t\tif (cpu_has_vmx_virtualize_x2apic_mode())\n\t\t\tsec_exec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t\tbreak;\n\t}\n\tsecondary_exec_controls_set(vmx, sec_exec_control);\n\n\tvmx_update_msr_bitmap(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_update_msr_bitmap",
          "args": [
            "vcpu"
          ],
          "line": 6094
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_update_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3716-3730",
          "snippet": "void vmx_update_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tu8 mode = vmx_msr_bitmap_mode(vcpu);\n\tu8 changed = mode ^ vmx->msr_bitmap_mode;\n\n\tif (!changed)\n\t\treturn;\n\n\tif (changed & (MSR_BITMAP_MODE_X2APIC | MSR_BITMAP_MODE_X2APIC_APICV))\n\t\tvmx_update_msr_bitmap_x2apic(msr_bitmap, mode);\n\n\tvmx->msr_bitmap_mode = mode;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define MSR_BITMAP_MODE_X2APIC_APICV\t2",
            "#define MSR_BITMAP_MODE_X2APIC\t\t1"
          ],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define MSR_BITMAP_MODE_X2APIC_APICV\t2\n#define MSR_BITMAP_MODE_X2APIC\t\t1\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_update_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tu8 mode = vmx_msr_bitmap_mode(vcpu);\n\tu8 changed = mode ^ vmx->msr_bitmap_mode;\n\n\tif (!changed)\n\t\treturn;\n\n\tif (changed & (MSR_BITMAP_MODE_X2APIC | MSR_BITMAP_MODE_X2APIC_APICV))\n\t\tvmx_update_msr_bitmap_x2apic(msr_bitmap, mode);\n\n\tvmx->msr_bitmap_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "secondary_exec_controls_set",
          "args": [
            "vmx",
            "sec_exec_control"
          ],
          "line": 6092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_virtualize_x2apic_mode",
          "args": [],
          "line": 6087
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_virtualize_x2apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "155-159",
          "snippet": "static inline bool cpu_has_vmx_virtualize_x2apic_mode(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_virtualize_x2apic_mode(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_flush_tlb",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 6083
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_flush_tlb_gva",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2845-2857",
          "snippet": "static void vmx_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\tint vpid = to_vmx(vcpu)->vpid;\n\n\tif (!vpid_sync_vcpu_addr(vpid, addr))\n\t\tvpid_sync_context(vpid);\n\n\t/*\n\t * If VPIDs are not supported or enabled, then the above is a no-op.\n\t * But we don't really need a TLB flush in that case anyway, because\n\t * each VM entry/exit includes an implicit flush when VPID is 0.\n\t */\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\tint vpid = to_vmx(vcpu)->vpid;\n\n\tif (!vpid_sync_vcpu_addr(vpid, addr))\n\t\tvpid_sync_context(vpid);\n\n\t/*\n\t * If VPIDs are not supported or enabled, then the above is a no-op.\n\t * But we don't really need a TLB flush in that case anyway, because\n\t * each VM entry/exit includes an implicit flush when VPID is 0.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "true",
            "\"Invalid local APIC state\""
          ],
          "line": 6076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_apic_mode",
          "args": [
            "vcpu"
          ],
          "line": 6074
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_apic_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "356-359",
          "snippet": "enum lapic_mode kvm_get_apic_mode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_apic_mode(kvm_get_apic_base(vcpu));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nenum lapic_mode kvm_get_apic_mode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_apic_mode(kvm_get_apic_base(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "secondary_exec_controls_get",
          "args": [
            "vmx"
          ],
          "line": 6070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 6065
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 6057
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 6054
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_virtual_apic_mode(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 sec_exec_control;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tif (!flexpriority_enabled &&\n\t    !cpu_has_vmx_virtualize_x2apic_mode())\n\t\treturn;\n\n\t/* Postpone execution until vmcs01 is the current VMCS. */\n\tif (is_guest_mode(vcpu)) {\n\t\tvmx->nested.change_vmcs01_virtual_apic_mode = true;\n\t\treturn;\n\t}\n\n\tsec_exec_control = secondary_exec_controls_get(vmx);\n\tsec_exec_control &= ~(SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES |\n\t\t\t      SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);\n\n\tswitch (kvm_get_apic_mode(vcpu)) {\n\tcase LAPIC_MODE_INVALID:\n\t\tWARN_ONCE(true, \"Invalid local APIC state\");\n\tcase LAPIC_MODE_DISABLED:\n\t\tbreak;\n\tcase LAPIC_MODE_XAPIC:\n\t\tif (flexpriority_enabled) {\n\t\t\tsec_exec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\t\tvmx_flush_tlb(vcpu, true);\n\t\t}\n\t\tbreak;\n\tcase LAPIC_MODE_X2APIC:\n\t\tif (cpu_has_vmx_virtualize_x2apic_mode())\n\t\t\tsec_exec_control |=\n\t\t\t\tSECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\t\tbreak;\n\t}\n\tsecondary_exec_controls_set(vmx, sec_exec_control);\n\n\tvmx_update_msr_bitmap(vcpu);\n}"
  },
  {
    "function_name": "update_cr8_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "6036-6050",
    "snippet": "static void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tint tpr_threshold;\n\n\tif (is_guest_mode(vcpu) &&\n\t\tnested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn;\n\n\ttpr_threshold = (irr == -1 || tpr < irr) ? 0 : irr;\n\tif (is_guest_mode(vcpu))\n\t\tto_vmx(vcpu)->nested.l1_tpr_threshold = tpr_threshold;\n\telse\n\t\tvmcs_write32(TPR_THRESHOLD, tpr_threshold);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "TPR_THRESHOLD",
            "tpr_threshold"
          ],
          "line": 6049
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 6047
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 6046
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_cpu_has",
          "args": [
            "vmcs12",
            "CPU_BASED_TPR_SHADOW"
          ],
          "line": 6042
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 6038
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tint tpr_threshold;\n\n\tif (is_guest_mode(vcpu) &&\n\t\tnested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW))\n\t\treturn;\n\n\ttpr_threshold = (irr == -1 || tpr < irr) ? 0 : irr;\n\tif (is_guest_mode(vcpu))\n\t\tto_vmx(vcpu)->nested.l1_tpr_threshold = tpr_threshold;\n\telse\n\t\tvmcs_write32(TPR_THRESHOLD, tpr_threshold);\n}"
  },
  {
    "function_name": "vmx_l1d_flush",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5976-6034",
    "snippet": "static void vmx_l1d_flush(struct kvm_vcpu *vcpu)\n{\n\tint size = PAGE_SIZE << L1D_CACHE_ORDER;\n\n\t/*\n\t * This code is only executed when the the flush mode is 'cond' or\n\t * 'always'\n\t */\n\tif (static_branch_likely(&vmx_l1d_flush_cond)) {\n\t\tbool flush_l1d;\n\n\t\t/*\n\t\t * Clear the per-vcpu flush bit, it gets set again\n\t\t * either from vcpu_run() or from one of the unsafe\n\t\t * VMEXIT handlers.\n\t\t */\n\t\tflush_l1d = vcpu->arch.l1tf_flush_l1d;\n\t\tvcpu->arch.l1tf_flush_l1d = false;\n\n\t\t/*\n\t\t * Clear the per-cpu flush bit, it gets set again from\n\t\t * the interrupt handlers.\n\t\t */\n\t\tflush_l1d |= kvm_get_cpu_l1tf_flush_l1d();\n\t\tkvm_clear_cpu_l1tf_flush_l1d();\n\n\t\tif (!flush_l1d)\n\t\t\treturn;\n\t}\n\n\tvcpu->stat.l1d_flush++;\n\n\tif (static_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\twrmsrl(MSR_IA32_FLUSH_CMD, L1D_FLUSH);\n\t\treturn;\n\t}\n\n\tasm volatile(\n\t\t/* First ensure the pages are in the TLB */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lpopulate_tlb:\\n\\t\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$4096, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lpopulate_tlb\\n\\t\"\n\t\t\"xorl\t%%eax, %%eax\\n\\t\"\n\t\t\"cpuid\\n\\t\"\n\t\t/* Now fill the cache */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lfill_cache:\\n\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$64, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lfill_cache\\n\\t\"\n\t\t\"lfence\\n\"\n\t\t:: [flush_pages] \"r\" (vmx_l1d_flush_pages),\n\t\t    [size] \"r\" (size)\n\t\t: \"eax\", \"ebx\", \"ecx\", \"edx\");\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define L1D_CACHE_ORDER 4"
    ],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);",
      "static void *vmx_l1d_flush_pages;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_FLUSH_CMD",
            "L1D_FLUSH"
          ],
          "line": 6009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_FLUSH_L1D"
          ],
          "line": 6008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_clear_cpu_l1tf_flush_l1d",
          "args": [],
          "line": 6000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_cpu_l1tf_flush_l1d",
          "args": [],
          "line": 5999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&vmx_l1d_flush_cond"
          ],
          "line": 5984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define L1D_CACHE_ORDER 4\n\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);\nstatic void *vmx_l1d_flush_pages;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_l1d_flush(struct kvm_vcpu *vcpu)\n{\n\tint size = PAGE_SIZE << L1D_CACHE_ORDER;\n\n\t/*\n\t * This code is only executed when the the flush mode is 'cond' or\n\t * 'always'\n\t */\n\tif (static_branch_likely(&vmx_l1d_flush_cond)) {\n\t\tbool flush_l1d;\n\n\t\t/*\n\t\t * Clear the per-vcpu flush bit, it gets set again\n\t\t * either from vcpu_run() or from one of the unsafe\n\t\t * VMEXIT handlers.\n\t\t */\n\t\tflush_l1d = vcpu->arch.l1tf_flush_l1d;\n\t\tvcpu->arch.l1tf_flush_l1d = false;\n\n\t\t/*\n\t\t * Clear the per-cpu flush bit, it gets set again from\n\t\t * the interrupt handlers.\n\t\t */\n\t\tflush_l1d |= kvm_get_cpu_l1tf_flush_l1d();\n\t\tkvm_clear_cpu_l1tf_flush_l1d();\n\n\t\tif (!flush_l1d)\n\t\t\treturn;\n\t}\n\n\tvcpu->stat.l1d_flush++;\n\n\tif (static_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\twrmsrl(MSR_IA32_FLUSH_CMD, L1D_FLUSH);\n\t\treturn;\n\t}\n\n\tasm volatile(\n\t\t/* First ensure the pages are in the TLB */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lpopulate_tlb:\\n\\t\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$4096, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lpopulate_tlb\\n\\t\"\n\t\t\"xorl\t%%eax, %%eax\\n\\t\"\n\t\t\"cpuid\\n\\t\"\n\t\t/* Now fill the cache */\n\t\t\"xorl\t%%eax, %%eax\\n\"\n\t\t\".Lfill_cache:\\n\"\n\t\t\"movzbl\t(%[flush_pages], %%\" _ASM_AX \"), %%ecx\\n\\t\"\n\t\t\"addl\t$64, %%eax\\n\\t\"\n\t\t\"cmpl\t%%eax, %[size]\\n\\t\"\n\t\t\"jne\t.Lfill_cache\\n\\t\"\n\t\t\"lfence\\n\"\n\t\t:: [flush_pages] \"r\" (vmx_l1d_flush_pages),\n\t\t    [size] \"r\" (size)\n\t\t: \"eax\", \"ebx\", \"ecx\", \"edx\");\n}"
  },
  {
    "function_name": "vmx_handle_exit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5824-5964",
    "snippet": "static int vmx_handle_exit(struct kvm_vcpu *vcpu,\n\tenum exit_fastpath_completion exit_fastpath)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\n\ttrace_kvm_exit(exit_reason, vcpu, KVM_ISA_VMX);\n\n\t/*\n\t * Flush logged GPAs PML buffer, this will make dirty_bitmap more\n\t * updated. Another good is, in kvm_vm_ioctl_get_dirty_log, before\n\t * querying dirty_bitmap, we only need to kick all vcpus out of guest\n\t * mode as if vcpus is in root mode, the PML buffer must has been\n\t * flushed already.\n\t */\n\tif (enable_pml)\n\t\tvmx_flush_pml_buffer(vcpu);\n\n\t/* If guest state is invalid, start emulating */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * The host physical addresses of some pages of guest memory\n\t\t * are loaded into the vmcs02 (e.g. vmcs12's Virtual APIC\n\t\t * Page). The CPU may write to these pages via their host\n\t\t * physical address while L2 is running, bypassing any\n\t\t * address-translation-based dirty tracking (e.g. EPT write\n\t\t * protection).\n\t\t *\n\t\t * Mark them dirty on every exit from L2 to prevent them from\n\t\t * getting out of sync with dirty tracking.\n\t\t */\n\t\tnested_mark_vmcs12_pages_dirty(vcpu);\n\n\t\tif (nested_vmx_exit_reflected(vcpu, exit_reason))\n\t\t\treturn nested_vmx_reflect_vmexit(vcpu, exit_reason);\n\t}\n\n\tif (exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY) {\n\t\tdump_vmcs();\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tdump_vmcs();\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\t(exit_reason != EXIT_REASON_EXCEPTION_NMI &&\n\t\t\texit_reason != EXIT_REASON_EPT_VIOLATION &&\n\t\t\texit_reason != EXIT_REASON_PML_FULL &&\n\t\t\texit_reason != EXIT_REASON_TASK_SWITCH)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason;\n\t\tvcpu->run->internal.data[2] = vcpu->arch.exit_qualification;\n\t\tif (exit_reason == EXIT_REASON_EPT_MISCONFIG) {\n\t\t\tvcpu->run->internal.ndata++;\n\t\t\tvcpu->run->internal.data[3] =\n\t\t\t\tvmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked)) {\n\t\tif (vmx_interrupt_allowed(vcpu)) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->loaded_vmcs->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_fastpath == EXIT_FASTPATH_SKIP_EMUL_INS) {\n\t\tkvm_skip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (exit_reason >= kvm_vmx_max_exit_handlers)\n\t\tgoto unexpected_vmexit;\n#ifdef CONFIG_RETPOLINE\n\tif (exit_reason == EXIT_REASON_MSR_WRITE)\n\t\treturn kvm_emulate_wrmsr(vcpu);\n\telse if (exit_reason == EXIT_REASON_PREEMPTION_TIMER)\n\t\treturn handle_preemption_timer(vcpu);\n\telse if (exit_reason == EXIT_REASON_INTERRUPT_WINDOW)\n\t\treturn handle_interrupt_window(vcpu);\n\telse if (exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t\treturn handle_external_interrupt(vcpu);\n\telse if (exit_reason == EXIT_REASON_HLT)\n\t\treturn kvm_emulate_halt(vcpu);\n\telse if (exit_reason == EXIT_REASON_EPT_MISCONFIG)\n\t\treturn handle_ept_misconfig(vcpu);\n#endif\n\n\texit_reason = array_index_nospec(exit_reason,\n\t\t\t\t\t kvm_vmx_max_exit_handlers);\n\tif (!kvm_vmx_exit_handlers[exit_reason])\n\t\tgoto unexpected_vmexit;\n\n\treturn kvm_vmx_exit_handlers[exit_reason](vcpu);\n\nunexpected_vmexit:\n\tvcpu_unimpl(vcpu, \"vmx: unexpected exit reason 0x%x\\n\", exit_reason);\n\tdump_vmcs();\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror =\n\t\t\tKVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;\n\tvcpu->run->internal.ndata = 1;\n\tvcpu->run->internal.data[0] = exit_reason;\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_vmcs",
          "args": [],
          "line": 5957
        },
        "resolved": true,
        "details": {
          "function_name": "dump_vmcs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5661-5818",
          "snippet": "void dump_vmcs(void)\n{\n\tu32 vmentry_ctl, vmexit_ctl;\n\tu32 cpu_based_exec_ctrl, pin_based_exec_ctrl, secondary_exec_control;\n\tunsigned long cr4;\n\tu64 efer;\n\tint i, n;\n\n\tif (!dump_invalid_vmcs) {\n\t\tpr_warn_ratelimited(\"set kvm_intel.dump_invalid_vmcs=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tvmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);\n\tvmexit_ctl = vmcs_read32(VM_EXIT_CONTROLS);\n\tcpu_based_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tpin_based_exec_ctrl = vmcs_read32(PIN_BASED_VM_EXEC_CONTROL);\n\tcr4 = vmcs_readl(GUEST_CR4);\n\tefer = vmcs_read64(GUEST_IA32_EFER);\n\tsecondary_exec_control = 0;\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tpr_err(\"*** Guest State ***\\n\");\n\tpr_err(\"CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       vmcs_readl(GUEST_CR0), vmcs_readl(CR0_READ_SHADOW),\n\t       vmcs_readl(CR0_GUEST_HOST_MASK));\n\tpr_err(\"CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       cr4, vmcs_readl(CR4_READ_SHADOW), vmcs_readl(CR4_GUEST_HOST_MASK));\n\tpr_err(\"CR3 = 0x%016lx\\n\", vmcs_readl(GUEST_CR3));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT) &&\n\t    (cr4 & X86_CR4_PAE) && !(efer & EFER_LMA))\n\t{\n\t\tpr_err(\"PDPTR0 = 0x%016llx  PDPTR1 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR0), vmcs_read64(GUEST_PDPTR1));\n\t\tpr_err(\"PDPTR2 = 0x%016llx  PDPTR3 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR2), vmcs_read64(GUEST_PDPTR3));\n\t}\n\tpr_err(\"RSP = 0x%016lx  RIP = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RSP), vmcs_readl(GUEST_RIP));\n\tpr_err(\"RFLAGS=0x%08lx         DR7 = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RFLAGS), vmcs_readl(GUEST_DR7));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(GUEST_SYSENTER_ESP),\n\t       vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP));\n\tvmx_dump_sel(\"CS:  \", GUEST_CS_SELECTOR);\n\tvmx_dump_sel(\"DS:  \", GUEST_DS_SELECTOR);\n\tvmx_dump_sel(\"SS:  \", GUEST_SS_SELECTOR);\n\tvmx_dump_sel(\"ES:  \", GUEST_ES_SELECTOR);\n\tvmx_dump_sel(\"FS:  \", GUEST_FS_SELECTOR);\n\tvmx_dump_sel(\"GS:  \", GUEST_GS_SELECTOR);\n\tvmx_dump_dtsel(\"GDTR:\", GUEST_GDTR_LIMIT);\n\tvmx_dump_sel(\"LDTR:\", GUEST_LDTR_SELECTOR);\n\tvmx_dump_dtsel(\"IDTR:\", GUEST_IDTR_LIMIT);\n\tvmx_dump_sel(\"TR:  \", GUEST_TR_SELECTOR);\n\tif ((vmexit_ctl & (VM_EXIT_SAVE_IA32_PAT | VM_EXIT_SAVE_IA32_EFER)) ||\n\t    (vmentry_ctl & (VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_IA32_EFER)))\n\t\tpr_err(\"EFER =     0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       efer, vmcs_read64(GUEST_IA32_PAT));\n\tpr_err(\"DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\\n\",\n\t       vmcs_read64(GUEST_IA32_DEBUGCTL),\n\t       vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmentry_ctl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_BNDCFGS)\n\t\tpr_err(\"BndCfgS = 0x%016llx\\n\", vmcs_read64(GUEST_BNDCFGS));\n\tpr_err(\"Interruptibility = %08x  ActivityState = %08x\\n\",\n\t       vmcs_read32(GUEST_INTERRUPTIBILITY_INFO),\n\t       vmcs_read32(GUEST_ACTIVITY_STATE));\n\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)\n\t\tpr_err(\"InterruptStatus = %04x\\n\",\n\t\t       vmcs_read16(GUEST_INTR_STATUS));\n\n\tpr_err(\"*** Host State ***\\n\");\n\tpr_err(\"RIP = 0x%016lx  RSP = 0x%016lx\\n\",\n\t       vmcs_readl(HOST_RIP), vmcs_readl(HOST_RSP));\n\tpr_err(\"CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\\n\",\n\t       vmcs_read16(HOST_CS_SELECTOR), vmcs_read16(HOST_SS_SELECTOR),\n\t       vmcs_read16(HOST_DS_SELECTOR), vmcs_read16(HOST_ES_SELECTOR),\n\t       vmcs_read16(HOST_FS_SELECTOR), vmcs_read16(HOST_GS_SELECTOR),\n\t       vmcs_read16(HOST_TR_SELECTOR));\n\tpr_err(\"FSBase=%016lx GSBase=%016lx TRBase=%016lx\\n\",\n\t       vmcs_readl(HOST_FS_BASE), vmcs_readl(HOST_GS_BASE),\n\t       vmcs_readl(HOST_TR_BASE));\n\tpr_err(\"GDTBase=%016lx IDTBase=%016lx\\n\",\n\t       vmcs_readl(HOST_GDTR_BASE), vmcs_readl(HOST_IDTR_BASE));\n\tpr_err(\"CR0=%016lx CR3=%016lx CR4=%016lx\\n\",\n\t       vmcs_readl(HOST_CR0), vmcs_readl(HOST_CR3),\n\t       vmcs_readl(HOST_CR4));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(HOST_IA32_SYSENTER_ESP),\n\t       vmcs_read32(HOST_IA32_SYSENTER_CS),\n\t       vmcs_readl(HOST_IA32_SYSENTER_EIP));\n\tif (vmexit_ctl & (VM_EXIT_LOAD_IA32_PAT | VM_EXIT_LOAD_IA32_EFER))\n\t\tpr_err(\"EFER = 0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_EFER),\n\t\t       vmcs_read64(HOST_IA32_PAT));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmexit_ctl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_PERF_GLOBAL_CTRL));\n\n\tpr_err(\"*** Control State ***\\n\");\n\tpr_err(\"PinBased=%08x CPUBased=%08x SecondaryExec=%08x\\n\",\n\t       pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);\n\tpr_err(\"EntryControls=%08x ExitControls=%08x\\n\", vmentry_ctl, vmexit_ctl);\n\tpr_err(\"ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\\n\",\n\t       vmcs_read32(EXCEPTION_BITMAP),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH));\n\tpr_err(\"VMEntry: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),\n\t       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));\n\tpr_err(\"VMExit: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_EXIT_INTR_INFO),\n\t       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));\n\tpr_err(\"        reason=%08x qualification=%016lx\\n\",\n\t       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));\n\tpr_err(\"IDTVectoring: info=%08x errcode=%08x\\n\",\n\t       vmcs_read32(IDT_VECTORING_INFO_FIELD),\n\t       vmcs_read32(IDT_VECTORING_ERROR_CODE));\n\tpr_err(\"TSC Offset = 0x%016llx\\n\", vmcs_read64(TSC_OFFSET));\n\tif (secondary_exec_control & SECONDARY_EXEC_TSC_SCALING)\n\t\tpr_err(\"TSC Multiplier = 0x%016llx\\n\",\n\t\t       vmcs_read64(TSC_MULTIPLIER));\n\tif (cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW) {\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {\n\t\t\tu16 status = vmcs_read16(GUEST_INTR_STATUS);\n\t\t\tpr_err(\"SVI|RVI = %02x|%02x \", status >> 8, status & 0xff);\n\t\t}\n\t\tpr_cont(\"TPR Threshold = 0x%02x\\n\", vmcs_read32(TPR_THRESHOLD));\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)\n\t\t\tpr_err(\"APIC-access addr = 0x%016llx \", vmcs_read64(APIC_ACCESS_ADDR));\n\t\tpr_cont(\"virt-APIC addr = 0x%016llx\\n\", vmcs_read64(VIRTUAL_APIC_PAGE_ADDR));\n\t}\n\tif (pin_based_exec_ctrl & PIN_BASED_POSTED_INTR)\n\t\tpr_err(\"PostedIntrVec = 0x%02x\\n\", vmcs_read16(POSTED_INTR_NV));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT))\n\t\tpr_err(\"EPT pointer = 0x%016llx\\n\", vmcs_read64(EPT_POINTER));\n\tn = vmcs_read32(CR3_TARGET_COUNT);\n\tfor (i = 0; i + 1 < n; i += 4)\n\t\tpr_err(\"CR3 target%u=%016lx target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2),\n\t\t       i + 1, vmcs_readl(CR3_TARGET_VALUE0 + i * 2 + 2));\n\tif (i < n)\n\t\tpr_err(\"CR3 target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2));\n\tif (secondary_exec_control & SECONDARY_EXEC_PAUSE_LOOP_EXITING)\n\t\tpr_err(\"PLE Gap=%08x Window=%08x\\n\",\n\t\t       vmcs_read32(PLE_GAP), vmcs_read32(PLE_WINDOW));\n\tif (secondary_exec_control & SECONDARY_EXEC_ENABLE_VPID)\n\t\tpr_err(\"Virtual processor ID = 0x%04x\\n\",\n\t\t       vmcs_read16(VIRTUAL_PROCESSOR_ID));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid dump_vmcs(void)\n{\n\tu32 vmentry_ctl, vmexit_ctl;\n\tu32 cpu_based_exec_ctrl, pin_based_exec_ctrl, secondary_exec_control;\n\tunsigned long cr4;\n\tu64 efer;\n\tint i, n;\n\n\tif (!dump_invalid_vmcs) {\n\t\tpr_warn_ratelimited(\"set kvm_intel.dump_invalid_vmcs=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tvmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);\n\tvmexit_ctl = vmcs_read32(VM_EXIT_CONTROLS);\n\tcpu_based_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tpin_based_exec_ctrl = vmcs_read32(PIN_BASED_VM_EXEC_CONTROL);\n\tcr4 = vmcs_readl(GUEST_CR4);\n\tefer = vmcs_read64(GUEST_IA32_EFER);\n\tsecondary_exec_control = 0;\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tpr_err(\"*** Guest State ***\\n\");\n\tpr_err(\"CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       vmcs_readl(GUEST_CR0), vmcs_readl(CR0_READ_SHADOW),\n\t       vmcs_readl(CR0_GUEST_HOST_MASK));\n\tpr_err(\"CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       cr4, vmcs_readl(CR4_READ_SHADOW), vmcs_readl(CR4_GUEST_HOST_MASK));\n\tpr_err(\"CR3 = 0x%016lx\\n\", vmcs_readl(GUEST_CR3));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT) &&\n\t    (cr4 & X86_CR4_PAE) && !(efer & EFER_LMA))\n\t{\n\t\tpr_err(\"PDPTR0 = 0x%016llx  PDPTR1 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR0), vmcs_read64(GUEST_PDPTR1));\n\t\tpr_err(\"PDPTR2 = 0x%016llx  PDPTR3 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR2), vmcs_read64(GUEST_PDPTR3));\n\t}\n\tpr_err(\"RSP = 0x%016lx  RIP = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RSP), vmcs_readl(GUEST_RIP));\n\tpr_err(\"RFLAGS=0x%08lx         DR7 = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RFLAGS), vmcs_readl(GUEST_DR7));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(GUEST_SYSENTER_ESP),\n\t       vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP));\n\tvmx_dump_sel(\"CS:  \", GUEST_CS_SELECTOR);\n\tvmx_dump_sel(\"DS:  \", GUEST_DS_SELECTOR);\n\tvmx_dump_sel(\"SS:  \", GUEST_SS_SELECTOR);\n\tvmx_dump_sel(\"ES:  \", GUEST_ES_SELECTOR);\n\tvmx_dump_sel(\"FS:  \", GUEST_FS_SELECTOR);\n\tvmx_dump_sel(\"GS:  \", GUEST_GS_SELECTOR);\n\tvmx_dump_dtsel(\"GDTR:\", GUEST_GDTR_LIMIT);\n\tvmx_dump_sel(\"LDTR:\", GUEST_LDTR_SELECTOR);\n\tvmx_dump_dtsel(\"IDTR:\", GUEST_IDTR_LIMIT);\n\tvmx_dump_sel(\"TR:  \", GUEST_TR_SELECTOR);\n\tif ((vmexit_ctl & (VM_EXIT_SAVE_IA32_PAT | VM_EXIT_SAVE_IA32_EFER)) ||\n\t    (vmentry_ctl & (VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_IA32_EFER)))\n\t\tpr_err(\"EFER =     0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       efer, vmcs_read64(GUEST_IA32_PAT));\n\tpr_err(\"DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\\n\",\n\t       vmcs_read64(GUEST_IA32_DEBUGCTL),\n\t       vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmentry_ctl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_BNDCFGS)\n\t\tpr_err(\"BndCfgS = 0x%016llx\\n\", vmcs_read64(GUEST_BNDCFGS));\n\tpr_err(\"Interruptibility = %08x  ActivityState = %08x\\n\",\n\t       vmcs_read32(GUEST_INTERRUPTIBILITY_INFO),\n\t       vmcs_read32(GUEST_ACTIVITY_STATE));\n\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)\n\t\tpr_err(\"InterruptStatus = %04x\\n\",\n\t\t       vmcs_read16(GUEST_INTR_STATUS));\n\n\tpr_err(\"*** Host State ***\\n\");\n\tpr_err(\"RIP = 0x%016lx  RSP = 0x%016lx\\n\",\n\t       vmcs_readl(HOST_RIP), vmcs_readl(HOST_RSP));\n\tpr_err(\"CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\\n\",\n\t       vmcs_read16(HOST_CS_SELECTOR), vmcs_read16(HOST_SS_SELECTOR),\n\t       vmcs_read16(HOST_DS_SELECTOR), vmcs_read16(HOST_ES_SELECTOR),\n\t       vmcs_read16(HOST_FS_SELECTOR), vmcs_read16(HOST_GS_SELECTOR),\n\t       vmcs_read16(HOST_TR_SELECTOR));\n\tpr_err(\"FSBase=%016lx GSBase=%016lx TRBase=%016lx\\n\",\n\t       vmcs_readl(HOST_FS_BASE), vmcs_readl(HOST_GS_BASE),\n\t       vmcs_readl(HOST_TR_BASE));\n\tpr_err(\"GDTBase=%016lx IDTBase=%016lx\\n\",\n\t       vmcs_readl(HOST_GDTR_BASE), vmcs_readl(HOST_IDTR_BASE));\n\tpr_err(\"CR0=%016lx CR3=%016lx CR4=%016lx\\n\",\n\t       vmcs_readl(HOST_CR0), vmcs_readl(HOST_CR3),\n\t       vmcs_readl(HOST_CR4));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(HOST_IA32_SYSENTER_ESP),\n\t       vmcs_read32(HOST_IA32_SYSENTER_CS),\n\t       vmcs_readl(HOST_IA32_SYSENTER_EIP));\n\tif (vmexit_ctl & (VM_EXIT_LOAD_IA32_PAT | VM_EXIT_LOAD_IA32_EFER))\n\t\tpr_err(\"EFER = 0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_EFER),\n\t\t       vmcs_read64(HOST_IA32_PAT));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmexit_ctl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_PERF_GLOBAL_CTRL));\n\n\tpr_err(\"*** Control State ***\\n\");\n\tpr_err(\"PinBased=%08x CPUBased=%08x SecondaryExec=%08x\\n\",\n\t       pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);\n\tpr_err(\"EntryControls=%08x ExitControls=%08x\\n\", vmentry_ctl, vmexit_ctl);\n\tpr_err(\"ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\\n\",\n\t       vmcs_read32(EXCEPTION_BITMAP),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH));\n\tpr_err(\"VMEntry: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),\n\t       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));\n\tpr_err(\"VMExit: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_EXIT_INTR_INFO),\n\t       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));\n\tpr_err(\"        reason=%08x qualification=%016lx\\n\",\n\t       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));\n\tpr_err(\"IDTVectoring: info=%08x errcode=%08x\\n\",\n\t       vmcs_read32(IDT_VECTORING_INFO_FIELD),\n\t       vmcs_read32(IDT_VECTORING_ERROR_CODE));\n\tpr_err(\"TSC Offset = 0x%016llx\\n\", vmcs_read64(TSC_OFFSET));\n\tif (secondary_exec_control & SECONDARY_EXEC_TSC_SCALING)\n\t\tpr_err(\"TSC Multiplier = 0x%016llx\\n\",\n\t\t       vmcs_read64(TSC_MULTIPLIER));\n\tif (cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW) {\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {\n\t\t\tu16 status = vmcs_read16(GUEST_INTR_STATUS);\n\t\t\tpr_err(\"SVI|RVI = %02x|%02x \", status >> 8, status & 0xff);\n\t\t}\n\t\tpr_cont(\"TPR Threshold = 0x%02x\\n\", vmcs_read32(TPR_THRESHOLD));\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)\n\t\t\tpr_err(\"APIC-access addr = 0x%016llx \", vmcs_read64(APIC_ACCESS_ADDR));\n\t\tpr_cont(\"virt-APIC addr = 0x%016llx\\n\", vmcs_read64(VIRTUAL_APIC_PAGE_ADDR));\n\t}\n\tif (pin_based_exec_ctrl & PIN_BASED_POSTED_INTR)\n\t\tpr_err(\"PostedIntrVec = 0x%02x\\n\", vmcs_read16(POSTED_INTR_NV));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT))\n\t\tpr_err(\"EPT pointer = 0x%016llx\\n\", vmcs_read64(EPT_POINTER));\n\tn = vmcs_read32(CR3_TARGET_COUNT);\n\tfor (i = 0; i + 1 < n; i += 4)\n\t\tpr_err(\"CR3 target%u=%016lx target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2),\n\t\t       i + 1, vmcs_readl(CR3_TARGET_VALUE0 + i * 2 + 2));\n\tif (i < n)\n\t\tpr_err(\"CR3 target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2));\n\tif (secondary_exec_control & SECONDARY_EXEC_PAUSE_LOOP_EXITING)\n\t\tpr_err(\"PLE Gap=%08x Window=%08x\\n\",\n\t\t       vmcs_read32(PLE_GAP), vmcs_read32(PLE_WINDOW));\n\tif (secondary_exec_control & SECONDARY_EXEC_ENABLE_VPID)\n\t\tpr_err(\"Virtual processor ID = 0x%04x\\n\",\n\t\t       vmcs_read16(VIRTUAL_PROCESSOR_ID));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"vmx: unexpected exit reason 0x%x\\n\"",
            "exit_reason"
          ],
          "line": 5956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vmx_exit_handlers[exit_reason]",
          "args": [
            "vcpu"
          ],
          "line": 5953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "exit_reason",
            "kvm_vmx_max_exit_handlers"
          ],
          "line": 5948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_ept_misconfig",
          "args": [
            "vcpu"
          ],
          "line": 5945
        },
        "resolved": true,
        "details": {
          "function_name": "handle_ept_misconfig",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5172-5188",
          "snippet": "static int handle_ept_misconfig(struct kvm_vcpu *vcpu)\n{\n\tgpa_t gpa;\n\n\t/*\n\t * A nested guest cannot optimize MMIO vmexits, because we have an\n\t * nGPA here instead of the required GPA.\n\t */\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\tif (!is_guest_mode(vcpu) &&\n\t    !kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {\n\t\ttrace_kvm_fast_mmio(gpa);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, PFERR_RSVD_MASK, NULL, 0);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_ept_misconfig(struct kvm_vcpu *vcpu)\n{\n\tgpa_t gpa;\n\n\t/*\n\t * A nested guest cannot optimize MMIO vmexits, because we have an\n\t * nGPA here instead of the required GPA.\n\t */\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\tif (!is_guest_mode(vcpu) &&\n\t    !kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {\n\t\ttrace_kvm_fast_mmio(gpa);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, PFERR_RSVD_MASK, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_emulate_halt",
          "args": [
            "vcpu"
          ],
          "line": 5943
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_halt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7435-7443",
          "snippet": "int kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\tint ret = kvm_skip_emulated_instruction(vcpu);\n\t/*\n\t * TODO: we might be squashing a GUESTDBG_SINGLESTEP-triggered\n\t * KVM_EXIT_DEBUG here.\n\t */\n\treturn kvm_vcpu_halt(vcpu) && ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\tint ret = kvm_skip_emulated_instruction(vcpu);\n\t/*\n\t * TODO: we might be squashing a GUESTDBG_SINGLESTEP-triggered\n\t * KVM_EXIT_DEBUG here.\n\t */\n\treturn kvm_vcpu_halt(vcpu) && ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_external_interrupt",
          "args": [
            "vcpu"
          ],
          "line": 5941
        },
        "resolved": true,
        "details": {
          "function_name": "handle_external_interrupt_irqoff",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "6236-6279",
          "snippet": "static void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n{\n\tunsigned int vector;\n\tunsigned long entry;\n#ifdef CONFIG_X86_64\n\tunsigned long tmp;\n#endif\n\tgate_desc *desc;\n\tu32 intr_info;\n\n\tintr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tif (WARN_ONCE(!is_external_intr(intr_info),\n\t    \"KVM: unexpected VM-Exit interrupt info: 0x%x\", intr_info))\n\t\treturn;\n\n\tvector = intr_info & INTR_INFO_VECTOR_MASK;\n\tdesc = (gate_desc *)host_idt_base + vector;\n\tentry = gate_offset(desc);\n\n\tkvm_before_interrupt(vcpu);\n\n\tasm volatile(\n#ifdef CONFIG_X86_64\n\t\t\"mov %%\" _ASM_SP \", %[sp]\\n\\t\"\n\t\t\"and $0xfffffffffffffff0, %%\" _ASM_SP \"\\n\\t\"\n\t\t\"push $%c[ss]\\n\\t\"\n\t\t\"push %[sp]\\n\\t\"\n#endif\n\t\t\"pushf\\n\\t\"\n\t\t__ASM_SIZE(push) \" $%c[cs]\\n\\t\"\n\t\tCALL_NOSPEC\n\t\t:\n#ifdef CONFIG_X86_64\n\t\t[sp]\"=&r\"(tmp),\n#endif\n\t\tASM_CALL_CONSTRAINT\n\t\t:\n\t\t[thunk_target]\"r\"(entry),\n\t\t[ss]\"i\"(__KERNEL_DS),\n\t\t[cs]\"i\"(__KERNEL_CS)\n\t);\n\n\tkvm_after_interrupt(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static unsigned long host_idt_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic unsigned long host_idt_base;\n\nstatic void handle_external_interrupt_irqoff(struct kvm_vcpu *vcpu)\n{\n\tunsigned int vector;\n\tunsigned long entry;\n#ifdef CONFIG_X86_64\n\tunsigned long tmp;\n#endif\n\tgate_desc *desc;\n\tu32 intr_info;\n\n\tintr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tif (WARN_ONCE(!is_external_intr(intr_info),\n\t    \"KVM: unexpected VM-Exit interrupt info: 0x%x\", intr_info))\n\t\treturn;\n\n\tvector = intr_info & INTR_INFO_VECTOR_MASK;\n\tdesc = (gate_desc *)host_idt_base + vector;\n\tentry = gate_offset(desc);\n\n\tkvm_before_interrupt(vcpu);\n\n\tasm volatile(\n#ifdef CONFIG_X86_64\n\t\t\"mov %%\" _ASM_SP \", %[sp]\\n\\t\"\n\t\t\"and $0xfffffffffffffff0, %%\" _ASM_SP \"\\n\\t\"\n\t\t\"push $%c[ss]\\n\\t\"\n\t\t\"push %[sp]\\n\\t\"\n#endif\n\t\t\"pushf\\n\\t\"\n\t\t__ASM_SIZE(push) \" $%c[cs]\\n\\t\"\n\t\tCALL_NOSPEC\n\t\t:\n#ifdef CONFIG_X86_64\n\t\t[sp]\"=&r\"(tmp),\n#endif\n\t\tASM_CALL_CONSTRAINT\n\t\t:\n\t\t[thunk_target]\"r\"(entry),\n\t\t[ss]\"i\"(__KERNEL_DS),\n\t\t[cs]\"i\"(__KERNEL_CS)\n\t);\n\n\tkvm_after_interrupt(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_interrupt_window",
          "args": [
            "vcpu"
          ],
          "line": 5939
        },
        "resolved": true,
        "details": {
          "function_name": "handle_interrupt_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4978-4986",
          "snippet": "static int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_preemption_timer",
          "args": [
            "vcpu"
          ],
          "line": 5937
        },
        "resolved": true,
        "details": {
          "function_name": "handle_preemption_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5489-5498",
          "snippet": "static int handle_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!vmx->req_immediate_exit &&\n\t    !unlikely(vmx->loaded_vmcs->hv_timer_soft_disabled))\n\t\tkvm_lapic_expired_hv_timer(vcpu);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!vmx->req_immediate_exit &&\n\t    !unlikely(vmx->loaded_vmcs->hv_timer_soft_disabled))\n\t\tkvm_lapic_expired_hv_timer(vcpu);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_emulate_wrmsr",
          "args": [
            "vcpu"
          ],
          "line": 5935
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_wrmsr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1559-1572",
          "snippet": "int kvm_emulate_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data = kvm_read_edx_eax(vcpu);\n\n\tif (kvm_set_msr(vcpu, ecx, data)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_write(ecx, data);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data = kvm_read_edx_eax(vcpu);\n\n\tif (kvm_set_msr(vcpu, ecx, data)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_write(ecx, data);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 5927
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\"",
            "__func__",
            "vcpu->vcpu_id"
          ],
          "line": 5919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_interrupt_allowed",
          "args": [
            "vcpu"
          ],
          "line": 5909
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_interrupt_allowed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4475-4486",
          "snippet": "static int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn false;\n\n\tif (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn true;\n\n\treturn (vmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn false;\n\n\tif (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn true;\n\n\treturn (vmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked"
          ],
          "line": 5907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_read64",
          "args": [
            "GUEST_PHYSICAL_ADDRESS"
          ],
          "line": 5902
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "120-130",
          "snippet": "static __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "VM_INSTRUCTION_ERROR"
          ],
          "line": 5877
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vmx->fail"
          ],
          "line": 5873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_vmx_reflect_vmexit",
          "args": [
            "vcpu",
            "exit_reason"
          ],
          "line": 5862
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_reflect_vmexit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "79-102",
          "snippet": "static inline int nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    u32 exit_reason)\n{\n\tu32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\t/*\n\t * At this point, the exit interruption info in exit_intr_info\n\t * is only valid for EXCEPTION_NMI exits.  For EXTERNAL_INTERRUPT\n\t * we need to query the in-kernel LAPIC.\n\t */\n\tWARN_ON(exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT);\n\tif ((exit_intr_info &\n\t     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==\n\t    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\t\tvmcs12->vm_exit_intr_error_code =\n\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\t}\n\n\tnested_vmx_vmexit(vcpu, exit_reason, exit_intr_info,\n\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\treturn 1;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline int nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    u32 exit_reason)\n{\n\tu32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\t/*\n\t * At this point, the exit interruption info in exit_intr_info\n\t * is only valid for EXCEPTION_NMI exits.  For EXTERNAL_INTERRUPT\n\t * we need to query the in-kernel LAPIC.\n\t */\n\tWARN_ON(exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT);\n\tif ((exit_intr_info &\n\t     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==\n\t    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\t\tvmcs12->vm_exit_intr_error_code =\n\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\t}\n\n\tnested_vmx_vmexit(vcpu, exit_reason, exit_intr_info,\n\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_exit_reflected",
          "args": [
            "vcpu",
            "exit_reason"
          ],
          "line": 5861
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_exit_reflected",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "5540-5705",
          "snippet": "bool nested_vmx_exit_reflected(struct kvm_vcpu *vcpu, u32 exit_reason)\n{\n\tu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\tif (unlikely(vmx->fail)) {\n\t\ttrace_kvm_nested_vmenter_failed(\n\t\t\t\"hardware VM-instruction error: \",\n\t\t\tvmcs_read32(VM_INSTRUCTION_ERROR));\n\t\treturn true;\n\t}\n\n\ttrace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason,\n\t\t\t\tvmcs_readl(EXIT_QUALIFICATION),\n\t\t\t\tvmx->idt_vectoring_info,\n\t\t\t\tintr_info,\n\t\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t\t\t\tKVM_ISA_VMX);\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_EXCEPTION_NMI:\n\t\tif (is_nmi(intr_info))\n\t\t\treturn false;\n\t\telse if (is_page_fault(intr_info))\n\t\t\treturn !vmx->vcpu.arch.apf.host_apf_reason && enable_ept;\n\t\telse if (is_debug(intr_info) &&\n\t\t\t vcpu->guest_debug &\n\t\t\t (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\telse if (is_breakpoint(intr_info) &&\n\t\t\t vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\treturn vmcs12->exception_bitmap &\n\t\t\t\t(1u << (intr_info & INTR_INFO_VECTOR_MASK));\n\tcase EXIT_REASON_EXTERNAL_INTERRUPT:\n\t\treturn false;\n\tcase EXIT_REASON_TRIPLE_FAULT:\n\t\treturn true;\n\tcase EXIT_REASON_INTERRUPT_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INTR_WINDOW_EXITING);\n\tcase EXIT_REASON_NMI_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_NMI_WINDOW_EXITING);\n\tcase EXIT_REASON_TASK_SWITCH:\n\t\treturn true;\n\tcase EXIT_REASON_CPUID:\n\t\treturn true;\n\tcase EXIT_REASON_HLT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\n\tcase EXIT_REASON_INVD:\n\t\treturn true;\n\tcase EXIT_REASON_INVLPG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_RDPMC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\n\tcase EXIT_REASON_RDRAND:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDRAND_EXITING);\n\tcase EXIT_REASON_RDSEED:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDSEED_EXITING);\n\tcase EXIT_REASON_RDTSC: case EXIT_REASON_RDTSCP:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\n\tcase EXIT_REASON_VMREAD:\n\t\treturn nested_vmx_exit_handled_vmcs_access(vcpu, vmcs12,\n\t\t\tvmcs12->vmread_bitmap);\n\tcase EXIT_REASON_VMWRITE:\n\t\treturn nested_vmx_exit_handled_vmcs_access(vcpu, vmcs12,\n\t\t\tvmcs12->vmwrite_bitmap);\n\tcase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\n\tcase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\n\tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMRESUME:\n\tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n\tcase EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:\n\t\t/*\n\t\t * VMX instructions trap unconditionally. This allows L1 to\n\t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n\t\t */\n\t\treturn true;\n\tcase EXIT_REASON_CR_ACCESS:\n\t\treturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\n\tcase EXIT_REASON_DR_ACCESS:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\treturn nested_vmx_exit_handled_io(vcpu, vmcs12);\n\tcase EXIT_REASON_GDTR_IDTR: case EXIT_REASON_LDTR_TR:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC);\n\tcase EXIT_REASON_MSR_READ:\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\n\tcase EXIT_REASON_INVALID_STATE:\n\t\treturn true;\n\tcase EXIT_REASON_MWAIT_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\n\tcase EXIT_REASON_MONITOR_TRAP_FLAG:\n\t\treturn nested_cpu_has_mtf(vmcs12);\n\tcase EXIT_REASON_MONITOR_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\n\tcase EXIT_REASON_PAUSE_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\n\t\t\tnested_cpu_has2(vmcs12,\n\t\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING);\n\tcase EXIT_REASON_MCE_DURING_VMENTRY:\n\t\treturn false;\n\tcase EXIT_REASON_TPR_BELOW_THRESHOLD:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW);\n\tcase EXIT_REASON_APIC_ACCESS:\n\tcase EXIT_REASON_APIC_WRITE:\n\tcase EXIT_REASON_EOI_INDUCED:\n\t\t/*\n\t\t * The controls for \"virtualize APIC accesses,\" \"APIC-\n\t\t * register virtualization,\" and \"virtual-interrupt\n\t\t * delivery\" only come from vmcs12.\n\t\t */\n\t\treturn true;\n\tcase EXIT_REASON_EPT_VIOLATION:\n\t\t/*\n\t\t * L0 always deals with the EPT violation. If nested EPT is\n\t\t * used, and the nested mmu code discovers that the address is\n\t\t * missing in the guest EPT table (EPT12), the EPT violation\n\t\t * will be injected with nested_ept_inject_page_fault()\n\t\t */\n\t\treturn false;\n\tcase EXIT_REASON_EPT_MISCONFIG:\n\t\t/*\n\t\t * L2 never uses directly L1's EPT, but rather L0's own EPT\n\t\t * table (shadow on EPT) or a merged EPT table that L0 built\n\t\t * (EPT on EPT). So any problems with the structure of the\n\t\t * table is L0's fault.\n\t\t */\n\t\treturn false;\n\tcase EXIT_REASON_INVPCID:\n\t\treturn\n\t\t\tnested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_INVPCID) &&\n\t\t\tnested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_WBINVD:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\n\tcase EXIT_REASON_XSETBV:\n\t\treturn true;\n\tcase EXIT_REASON_XSAVES: case EXIT_REASON_XRSTORS:\n\t\t/*\n\t\t * This should never happen, since it is not possible to\n\t\t * set XSS to a non-zero value---neither in L1 nor in L2.\n\t\t * If if it were, XSS would have to be checked against\n\t\t * the XSS exit bitmap in vmcs12.\n\t\t */\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);\n\tcase EXIT_REASON_PREEMPTION_TIMER:\n\t\treturn false;\n\tcase EXIT_REASON_PML_FULL:\n\t\t/* We emulate PML support to L1. */\n\t\treturn false;\n\tcase EXIT_REASON_VMFUNC:\n\t\t/* VM functions are emulated through L2->L0 vmexits. */\n\t\treturn false;\n\tcase EXIT_REASON_ENCLS:\n\t\t/* SGX is never exposed to L1 */\n\t\treturn false;\n\tcase EXIT_REASON_UMWAIT:\n\tcase EXIT_REASON_TPAUSE:\n\t\treturn nested_cpu_has2(vmcs12,\n\t\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE);\n\tdefault:\n\t\treturn true;\n\t}\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nstatic void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);\n\nbool nested_vmx_exit_reflected(struct kvm_vcpu *vcpu, u32 exit_reason)\n{\n\tu32 intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\tif (unlikely(vmx->fail)) {\n\t\ttrace_kvm_nested_vmenter_failed(\n\t\t\t\"hardware VM-instruction error: \",\n\t\t\tvmcs_read32(VM_INSTRUCTION_ERROR));\n\t\treturn true;\n\t}\n\n\ttrace_kvm_nested_vmexit(kvm_rip_read(vcpu), exit_reason,\n\t\t\t\tvmcs_readl(EXIT_QUALIFICATION),\n\t\t\t\tvmx->idt_vectoring_info,\n\t\t\t\tintr_info,\n\t\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t\t\t\tKVM_ISA_VMX);\n\n\tswitch (exit_reason) {\n\tcase EXIT_REASON_EXCEPTION_NMI:\n\t\tif (is_nmi(intr_info))\n\t\t\treturn false;\n\t\telse if (is_page_fault(intr_info))\n\t\t\treturn !vmx->vcpu.arch.apf.host_apf_reason && enable_ept;\n\t\telse if (is_debug(intr_info) &&\n\t\t\t vcpu->guest_debug &\n\t\t\t (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\telse if (is_breakpoint(intr_info) &&\n\t\t\t vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\treturn vmcs12->exception_bitmap &\n\t\t\t\t(1u << (intr_info & INTR_INFO_VECTOR_MASK));\n\tcase EXIT_REASON_EXTERNAL_INTERRUPT:\n\t\treturn false;\n\tcase EXIT_REASON_TRIPLE_FAULT:\n\t\treturn true;\n\tcase EXIT_REASON_INTERRUPT_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INTR_WINDOW_EXITING);\n\tcase EXIT_REASON_NMI_WINDOW:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_NMI_WINDOW_EXITING);\n\tcase EXIT_REASON_TASK_SWITCH:\n\t\treturn true;\n\tcase EXIT_REASON_CPUID:\n\t\treturn true;\n\tcase EXIT_REASON_HLT:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_HLT_EXITING);\n\tcase EXIT_REASON_INVD:\n\t\treturn true;\n\tcase EXIT_REASON_INVLPG:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_RDPMC:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDPMC_EXITING);\n\tcase EXIT_REASON_RDRAND:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDRAND_EXITING);\n\tcase EXIT_REASON_RDSEED:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_RDSEED_EXITING);\n\tcase EXIT_REASON_RDTSC: case EXIT_REASON_RDTSCP:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_RDTSC_EXITING);\n\tcase EXIT_REASON_VMREAD:\n\t\treturn nested_vmx_exit_handled_vmcs_access(vcpu, vmcs12,\n\t\t\tvmcs12->vmread_bitmap);\n\tcase EXIT_REASON_VMWRITE:\n\t\treturn nested_vmx_exit_handled_vmcs_access(vcpu, vmcs12,\n\t\t\tvmcs12->vmwrite_bitmap);\n\tcase EXIT_REASON_VMCALL: case EXIT_REASON_VMCLEAR:\n\tcase EXIT_REASON_VMLAUNCH: case EXIT_REASON_VMPTRLD:\n\tcase EXIT_REASON_VMPTRST: case EXIT_REASON_VMRESUME:\n\tcase EXIT_REASON_VMOFF: case EXIT_REASON_VMON:\n\tcase EXIT_REASON_INVEPT: case EXIT_REASON_INVVPID:\n\t\t/*\n\t\t * VMX instructions trap unconditionally. This allows L1 to\n\t\t * emulate them for its L2 guest, i.e., allows 3-level nesting!\n\t\t */\n\t\treturn true;\n\tcase EXIT_REASON_CR_ACCESS:\n\t\treturn nested_vmx_exit_handled_cr(vcpu, vmcs12);\n\tcase EXIT_REASON_DR_ACCESS:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MOV_DR_EXITING);\n\tcase EXIT_REASON_IO_INSTRUCTION:\n\t\treturn nested_vmx_exit_handled_io(vcpu, vmcs12);\n\tcase EXIT_REASON_GDTR_IDTR: case EXIT_REASON_LDTR_TR:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_DESC);\n\tcase EXIT_REASON_MSR_READ:\n\tcase EXIT_REASON_MSR_WRITE:\n\t\treturn nested_vmx_exit_handled_msr(vcpu, vmcs12, exit_reason);\n\tcase EXIT_REASON_INVALID_STATE:\n\t\treturn true;\n\tcase EXIT_REASON_MWAIT_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MWAIT_EXITING);\n\tcase EXIT_REASON_MONITOR_TRAP_FLAG:\n\t\treturn nested_cpu_has_mtf(vmcs12);\n\tcase EXIT_REASON_MONITOR_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_EXITING);\n\tcase EXIT_REASON_PAUSE_INSTRUCTION:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_PAUSE_EXITING) ||\n\t\t\tnested_cpu_has2(vmcs12,\n\t\t\t\tSECONDARY_EXEC_PAUSE_LOOP_EXITING);\n\tcase EXIT_REASON_MCE_DURING_VMENTRY:\n\t\treturn false;\n\tcase EXIT_REASON_TPR_BELOW_THRESHOLD:\n\t\treturn nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW);\n\tcase EXIT_REASON_APIC_ACCESS:\n\tcase EXIT_REASON_APIC_WRITE:\n\tcase EXIT_REASON_EOI_INDUCED:\n\t\t/*\n\t\t * The controls for \"virtualize APIC accesses,\" \"APIC-\n\t\t * register virtualization,\" and \"virtual-interrupt\n\t\t * delivery\" only come from vmcs12.\n\t\t */\n\t\treturn true;\n\tcase EXIT_REASON_EPT_VIOLATION:\n\t\t/*\n\t\t * L0 always deals with the EPT violation. If nested EPT is\n\t\t * used, and the nested mmu code discovers that the address is\n\t\t * missing in the guest EPT table (EPT12), the EPT violation\n\t\t * will be injected with nested_ept_inject_page_fault()\n\t\t */\n\t\treturn false;\n\tcase EXIT_REASON_EPT_MISCONFIG:\n\t\t/*\n\t\t * L2 never uses directly L1's EPT, but rather L0's own EPT\n\t\t * table (shadow on EPT) or a merged EPT table that L0 built\n\t\t * (EPT on EPT). So any problems with the structure of the\n\t\t * table is L0's fault.\n\t\t */\n\t\treturn false;\n\tcase EXIT_REASON_INVPCID:\n\t\treturn\n\t\t\tnested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_INVPCID) &&\n\t\t\tnested_cpu_has(vmcs12, CPU_BASED_INVLPG_EXITING);\n\tcase EXIT_REASON_WBINVD:\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_WBINVD_EXITING);\n\tcase EXIT_REASON_XSETBV:\n\t\treturn true;\n\tcase EXIT_REASON_XSAVES: case EXIT_REASON_XRSTORS:\n\t\t/*\n\t\t * This should never happen, since it is not possible to\n\t\t * set XSS to a non-zero value---neither in L1 nor in L2.\n\t\t * If if it were, XSS would have to be checked against\n\t\t * the XSS exit bitmap in vmcs12.\n\t\t */\n\t\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);\n\tcase EXIT_REASON_PREEMPTION_TIMER:\n\t\treturn false;\n\tcase EXIT_REASON_PML_FULL:\n\t\t/* We emulate PML support to L1. */\n\t\treturn false;\n\tcase EXIT_REASON_VMFUNC:\n\t\t/* VM functions are emulated through L2->L0 vmexits. */\n\t\treturn false;\n\tcase EXIT_REASON_ENCLS:\n\t\t/* SGX is never exposed to L1 */\n\t\treturn false;\n\tcase EXIT_REASON_UMWAIT:\n\tcase EXIT_REASON_TPAUSE:\n\t\treturn nested_cpu_has2(vmcs12,\n\t\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE);\n\tdefault:\n\t\treturn true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_mark_vmcs12_pages_dirty",
          "args": [
            "vcpu"
          ],
          "line": 5859
        },
        "resolved": true,
        "details": {
          "function_name": "nested_mark_vmcs12_pages_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "3530-3549",
          "snippet": "void nested_mark_vmcs12_pages_dirty(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tgfn_t gfn;\n\n\t/*\n\t * Don't need to mark the APIC access page dirty; it is never\n\t * written to by the CPU during APIC virtualization.\n\t */\n\n\tif (nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW)) {\n\t\tgfn = vmcs12->virtual_apic_page_addr >> PAGE_SHIFT;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n\n\tif (nested_cpu_has_posted_intr(vmcs12)) {\n\t\tgfn = vmcs12->posted_intr_desc_addr >> PAGE_SHIFT;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nstatic void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);\n\nvoid nested_mark_vmcs12_pages_dirty(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tgfn_t gfn;\n\n\t/*\n\t * Don't need to mark the APIC access page dirty; it is never\n\t * written to by the CPU during APIC virtualization.\n\t */\n\n\tif (nested_cpu_has(vmcs12, CPU_BASED_TPR_SHADOW)) {\n\t\tgfn = vmcs12->virtual_apic_page_addr >> PAGE_SHIFT;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n\n\tif (nested_cpu_has_posted_intr(vmcs12)) {\n\t\tgfn = vmcs12->posted_intr_desc_addr >> PAGE_SHIFT;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 5847
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_invalid_guest_state",
          "args": [
            "vcpu"
          ],
          "line": 5845
        },
        "resolved": true,
        "details": {
          "function_name": "handle_invalid_guest_state",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5200-5252",
          "snippet": "static int handle_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool intr_window_requested;\n\tunsigned count = 130;\n\n\t/*\n\t * We should never reach the point where we are emulating L2\n\t * due to invalid guest state as that means we incorrectly\n\t * allowed a nested VMEntry with an invalid vmcs12.\n\t */\n\tWARN_ON_ONCE(vmx->emulation_required && vmx->nested.nested_run_pending);\n\n\tintr_window_requested = exec_controls_get(vmx) &\n\t\t\t\tCPU_BASED_INTR_WINDOW_EXITING;\n\n\twhile (vmx->emulation_required && count-- != 0) {\n\t\tif (intr_window_requested && vmx_interrupt_allowed(vcpu))\n\t\t\treturn handle_interrupt_window(&vmx->vcpu);\n\n\t\tif (kvm_test_request(KVM_REQ_EVENT, vcpu))\n\t\t\treturn 1;\n\n\t\tif (!kvm_emulate_instruction(vcpu, 0))\n\t\t\treturn 0;\n\n\t\tif (vmx->emulation_required && !vmx->rmode.vm86_active &&\n\t\t    vcpu->arch.exception.pending) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\t\tvcpu->run->internal.suberror =\n\t\t\t\t\t\tKVM_INTERNAL_ERROR_EMULATION;\n\t\t\tvcpu->run->internal.ndata = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (vcpu->arch.halt_request) {\n\t\t\tvcpu->arch.halt_request = 0;\n\t\t\treturn kvm_vcpu_halt(vcpu);\n\t\t}\n\n\t\t/*\n\t\t * Note, return 1 and not 0, vcpu_run() is responsible for\n\t\t * morphing the pending signal into the proper return code.\n\t\t */\n\t\tif (signal_pending(current))\n\t\t\treturn 1;\n\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool intr_window_requested;\n\tunsigned count = 130;\n\n\t/*\n\t * We should never reach the point where we are emulating L2\n\t * due to invalid guest state as that means we incorrectly\n\t * allowed a nested VMEntry with an invalid vmcs12.\n\t */\n\tWARN_ON_ONCE(vmx->emulation_required && vmx->nested.nested_run_pending);\n\n\tintr_window_requested = exec_controls_get(vmx) &\n\t\t\t\tCPU_BASED_INTR_WINDOW_EXITING;\n\n\twhile (vmx->emulation_required && count-- != 0) {\n\t\tif (intr_window_requested && vmx_interrupt_allowed(vcpu))\n\t\t\treturn handle_interrupt_window(&vmx->vcpu);\n\n\t\tif (kvm_test_request(KVM_REQ_EVENT, vcpu))\n\t\t\treturn 1;\n\n\t\tif (!kvm_emulate_instruction(vcpu, 0))\n\t\t\treturn 0;\n\n\t\tif (vmx->emulation_required && !vmx->rmode.vm86_active &&\n\t\t    vcpu->arch.exception.pending) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\t\tvcpu->run->internal.suberror =\n\t\t\t\t\t\tKVM_INTERNAL_ERROR_EMULATION;\n\t\t\tvcpu->run->internal.ndata = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (vcpu->arch.halt_request) {\n\t\t\tvcpu->arch.halt_request = 0;\n\t\t\treturn kvm_vcpu_halt(vcpu);\n\t\t}\n\n\t\t/*\n\t\t * Note, return 1 and not 0, vcpu_run() is responsible for\n\t\t * morphing the pending signal into the proper return code.\n\t\t */\n\t\tif (signal_pending(current))\n\t\t\treturn 1;\n\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_flush_pml_buffer",
          "args": [
            "vcpu"
          ],
          "line": 5841
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_flush_pml_buffer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5596-5625",
          "snippet": "static void vmx_flush_pml_buffer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 *pml_buf;\n\tu16 pml_idx;\n\n\tpml_idx = vmcs_read16(GUEST_PML_INDEX);\n\n\t/* Do nothing if PML buffer is empty */\n\tif (pml_idx == (PML_ENTITY_NUM - 1))\n\t\treturn;\n\n\t/* PML index always points to next available PML buffer entity */\n\tif (pml_idx >= PML_ENTITY_NUM)\n\t\tpml_idx = 0;\n\telse\n\t\tpml_idx++;\n\n\tpml_buf = page_address(vmx->pml_pg);\n\tfor (; pml_idx < PML_ENTITY_NUM; pml_idx++) {\n\t\tu64 gpa;\n\n\t\tgpa = pml_buf[pml_idx];\n\t\tWARN_ON(gpa & (PAGE_SIZE - 1));\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\t}\n\n\t/* reset PML index */\n\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_flush_pml_buffer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 *pml_buf;\n\tu16 pml_idx;\n\n\tpml_idx = vmcs_read16(GUEST_PML_INDEX);\n\n\t/* Do nothing if PML buffer is empty */\n\tif (pml_idx == (PML_ENTITY_NUM - 1))\n\t\treturn;\n\n\t/* PML index always points to next available PML buffer entity */\n\tif (pml_idx >= PML_ENTITY_NUM)\n\t\tpml_idx = 0;\n\telse\n\t\tpml_idx++;\n\n\tpml_buf = page_address(vmx->pml_pg);\n\tfor (; pml_idx < PML_ENTITY_NUM; pml_idx++) {\n\t\tu64 gpa;\n\n\t\tgpa = pml_buf[pml_idx];\n\t\tWARN_ON(gpa & (PAGE_SIZE - 1));\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\t}\n\n\t/* reset PML index */\n\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_exit",
          "args": [
            "exit_reason",
            "vcpu",
            "KVM_ISA_VMX"
          ],
          "line": 5831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 5827
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_handle_exit(struct kvm_vcpu *vcpu,\n\tenum exit_fastpath_completion exit_fastpath)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\n\ttrace_kvm_exit(exit_reason, vcpu, KVM_ISA_VMX);\n\n\t/*\n\t * Flush logged GPAs PML buffer, this will make dirty_bitmap more\n\t * updated. Another good is, in kvm_vm_ioctl_get_dirty_log, before\n\t * querying dirty_bitmap, we only need to kick all vcpus out of guest\n\t * mode as if vcpus is in root mode, the PML buffer must has been\n\t * flushed already.\n\t */\n\tif (enable_pml)\n\t\tvmx_flush_pml_buffer(vcpu);\n\n\t/* If guest state is invalid, start emulating */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * The host physical addresses of some pages of guest memory\n\t\t * are loaded into the vmcs02 (e.g. vmcs12's Virtual APIC\n\t\t * Page). The CPU may write to these pages via their host\n\t\t * physical address while L2 is running, bypassing any\n\t\t * address-translation-based dirty tracking (e.g. EPT write\n\t\t * protection).\n\t\t *\n\t\t * Mark them dirty on every exit from L2 to prevent them from\n\t\t * getting out of sync with dirty tracking.\n\t\t */\n\t\tnested_mark_vmcs12_pages_dirty(vcpu);\n\n\t\tif (nested_vmx_exit_reflected(vcpu, exit_reason))\n\t\t\treturn nested_vmx_reflect_vmexit(vcpu, exit_reason);\n\t}\n\n\tif (exit_reason & VMX_EXIT_REASONS_FAILED_VMENTRY) {\n\t\tdump_vmcs();\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tdump_vmcs();\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\t(exit_reason != EXIT_REASON_EXCEPTION_NMI &&\n\t\t\texit_reason != EXIT_REASON_EPT_VIOLATION &&\n\t\t\texit_reason != EXIT_REASON_PML_FULL &&\n\t\t\texit_reason != EXIT_REASON_TASK_SWITCH)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason;\n\t\tvcpu->run->internal.data[2] = vcpu->arch.exit_qualification;\n\t\tif (exit_reason == EXIT_REASON_EPT_MISCONFIG) {\n\t\t\tvcpu->run->internal.ndata++;\n\t\t\tvcpu->run->internal.data[3] =\n\t\t\t\tvmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked)) {\n\t\tif (vmx_interrupt_allowed(vcpu)) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->loaded_vmcs->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_fastpath == EXIT_FASTPATH_SKIP_EMUL_INS) {\n\t\tkvm_skip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t}\n\n\tif (exit_reason >= kvm_vmx_max_exit_handlers)\n\t\tgoto unexpected_vmexit;\n#ifdef CONFIG_RETPOLINE\n\tif (exit_reason == EXIT_REASON_MSR_WRITE)\n\t\treturn kvm_emulate_wrmsr(vcpu);\n\telse if (exit_reason == EXIT_REASON_PREEMPTION_TIMER)\n\t\treturn handle_preemption_timer(vcpu);\n\telse if (exit_reason == EXIT_REASON_INTERRUPT_WINDOW)\n\t\treturn handle_interrupt_window(vcpu);\n\telse if (exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t\treturn handle_external_interrupt(vcpu);\n\telse if (exit_reason == EXIT_REASON_HLT)\n\t\treturn kvm_emulate_halt(vcpu);\n\telse if (exit_reason == EXIT_REASON_EPT_MISCONFIG)\n\t\treturn handle_ept_misconfig(vcpu);\n#endif\n\n\texit_reason = array_index_nospec(exit_reason,\n\t\t\t\t\t kvm_vmx_max_exit_handlers);\n\tif (!kvm_vmx_exit_handlers[exit_reason])\n\t\tgoto unexpected_vmexit;\n\n\treturn kvm_vmx_exit_handlers[exit_reason](vcpu);\n\nunexpected_vmexit:\n\tvcpu_unimpl(vcpu, \"vmx: unexpected exit reason 0x%x\\n\", exit_reason);\n\tdump_vmcs();\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror =\n\t\t\tKVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;\n\tvcpu->run->internal.ndata = 1;\n\tvcpu->run->internal.data[0] = exit_reason;\n\treturn 0;\n}"
  },
  {
    "function_name": "dump_vmcs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5661-5818",
    "snippet": "void dump_vmcs(void)\n{\n\tu32 vmentry_ctl, vmexit_ctl;\n\tu32 cpu_based_exec_ctrl, pin_based_exec_ctrl, secondary_exec_control;\n\tunsigned long cr4;\n\tu64 efer;\n\tint i, n;\n\n\tif (!dump_invalid_vmcs) {\n\t\tpr_warn_ratelimited(\"set kvm_intel.dump_invalid_vmcs=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tvmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);\n\tvmexit_ctl = vmcs_read32(VM_EXIT_CONTROLS);\n\tcpu_based_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tpin_based_exec_ctrl = vmcs_read32(PIN_BASED_VM_EXEC_CONTROL);\n\tcr4 = vmcs_readl(GUEST_CR4);\n\tefer = vmcs_read64(GUEST_IA32_EFER);\n\tsecondary_exec_control = 0;\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tpr_err(\"*** Guest State ***\\n\");\n\tpr_err(\"CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       vmcs_readl(GUEST_CR0), vmcs_readl(CR0_READ_SHADOW),\n\t       vmcs_readl(CR0_GUEST_HOST_MASK));\n\tpr_err(\"CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       cr4, vmcs_readl(CR4_READ_SHADOW), vmcs_readl(CR4_GUEST_HOST_MASK));\n\tpr_err(\"CR3 = 0x%016lx\\n\", vmcs_readl(GUEST_CR3));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT) &&\n\t    (cr4 & X86_CR4_PAE) && !(efer & EFER_LMA))\n\t{\n\t\tpr_err(\"PDPTR0 = 0x%016llx  PDPTR1 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR0), vmcs_read64(GUEST_PDPTR1));\n\t\tpr_err(\"PDPTR2 = 0x%016llx  PDPTR3 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR2), vmcs_read64(GUEST_PDPTR3));\n\t}\n\tpr_err(\"RSP = 0x%016lx  RIP = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RSP), vmcs_readl(GUEST_RIP));\n\tpr_err(\"RFLAGS=0x%08lx         DR7 = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RFLAGS), vmcs_readl(GUEST_DR7));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(GUEST_SYSENTER_ESP),\n\t       vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP));\n\tvmx_dump_sel(\"CS:  \", GUEST_CS_SELECTOR);\n\tvmx_dump_sel(\"DS:  \", GUEST_DS_SELECTOR);\n\tvmx_dump_sel(\"SS:  \", GUEST_SS_SELECTOR);\n\tvmx_dump_sel(\"ES:  \", GUEST_ES_SELECTOR);\n\tvmx_dump_sel(\"FS:  \", GUEST_FS_SELECTOR);\n\tvmx_dump_sel(\"GS:  \", GUEST_GS_SELECTOR);\n\tvmx_dump_dtsel(\"GDTR:\", GUEST_GDTR_LIMIT);\n\tvmx_dump_sel(\"LDTR:\", GUEST_LDTR_SELECTOR);\n\tvmx_dump_dtsel(\"IDTR:\", GUEST_IDTR_LIMIT);\n\tvmx_dump_sel(\"TR:  \", GUEST_TR_SELECTOR);\n\tif ((vmexit_ctl & (VM_EXIT_SAVE_IA32_PAT | VM_EXIT_SAVE_IA32_EFER)) ||\n\t    (vmentry_ctl & (VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_IA32_EFER)))\n\t\tpr_err(\"EFER =     0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       efer, vmcs_read64(GUEST_IA32_PAT));\n\tpr_err(\"DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\\n\",\n\t       vmcs_read64(GUEST_IA32_DEBUGCTL),\n\t       vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmentry_ctl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_BNDCFGS)\n\t\tpr_err(\"BndCfgS = 0x%016llx\\n\", vmcs_read64(GUEST_BNDCFGS));\n\tpr_err(\"Interruptibility = %08x  ActivityState = %08x\\n\",\n\t       vmcs_read32(GUEST_INTERRUPTIBILITY_INFO),\n\t       vmcs_read32(GUEST_ACTIVITY_STATE));\n\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)\n\t\tpr_err(\"InterruptStatus = %04x\\n\",\n\t\t       vmcs_read16(GUEST_INTR_STATUS));\n\n\tpr_err(\"*** Host State ***\\n\");\n\tpr_err(\"RIP = 0x%016lx  RSP = 0x%016lx\\n\",\n\t       vmcs_readl(HOST_RIP), vmcs_readl(HOST_RSP));\n\tpr_err(\"CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\\n\",\n\t       vmcs_read16(HOST_CS_SELECTOR), vmcs_read16(HOST_SS_SELECTOR),\n\t       vmcs_read16(HOST_DS_SELECTOR), vmcs_read16(HOST_ES_SELECTOR),\n\t       vmcs_read16(HOST_FS_SELECTOR), vmcs_read16(HOST_GS_SELECTOR),\n\t       vmcs_read16(HOST_TR_SELECTOR));\n\tpr_err(\"FSBase=%016lx GSBase=%016lx TRBase=%016lx\\n\",\n\t       vmcs_readl(HOST_FS_BASE), vmcs_readl(HOST_GS_BASE),\n\t       vmcs_readl(HOST_TR_BASE));\n\tpr_err(\"GDTBase=%016lx IDTBase=%016lx\\n\",\n\t       vmcs_readl(HOST_GDTR_BASE), vmcs_readl(HOST_IDTR_BASE));\n\tpr_err(\"CR0=%016lx CR3=%016lx CR4=%016lx\\n\",\n\t       vmcs_readl(HOST_CR0), vmcs_readl(HOST_CR3),\n\t       vmcs_readl(HOST_CR4));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(HOST_IA32_SYSENTER_ESP),\n\t       vmcs_read32(HOST_IA32_SYSENTER_CS),\n\t       vmcs_readl(HOST_IA32_SYSENTER_EIP));\n\tif (vmexit_ctl & (VM_EXIT_LOAD_IA32_PAT | VM_EXIT_LOAD_IA32_EFER))\n\t\tpr_err(\"EFER = 0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_EFER),\n\t\t       vmcs_read64(HOST_IA32_PAT));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmexit_ctl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_PERF_GLOBAL_CTRL));\n\n\tpr_err(\"*** Control State ***\\n\");\n\tpr_err(\"PinBased=%08x CPUBased=%08x SecondaryExec=%08x\\n\",\n\t       pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);\n\tpr_err(\"EntryControls=%08x ExitControls=%08x\\n\", vmentry_ctl, vmexit_ctl);\n\tpr_err(\"ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\\n\",\n\t       vmcs_read32(EXCEPTION_BITMAP),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH));\n\tpr_err(\"VMEntry: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),\n\t       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));\n\tpr_err(\"VMExit: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_EXIT_INTR_INFO),\n\t       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));\n\tpr_err(\"        reason=%08x qualification=%016lx\\n\",\n\t       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));\n\tpr_err(\"IDTVectoring: info=%08x errcode=%08x\\n\",\n\t       vmcs_read32(IDT_VECTORING_INFO_FIELD),\n\t       vmcs_read32(IDT_VECTORING_ERROR_CODE));\n\tpr_err(\"TSC Offset = 0x%016llx\\n\", vmcs_read64(TSC_OFFSET));\n\tif (secondary_exec_control & SECONDARY_EXEC_TSC_SCALING)\n\t\tpr_err(\"TSC Multiplier = 0x%016llx\\n\",\n\t\t       vmcs_read64(TSC_MULTIPLIER));\n\tif (cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW) {\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {\n\t\t\tu16 status = vmcs_read16(GUEST_INTR_STATUS);\n\t\t\tpr_err(\"SVI|RVI = %02x|%02x \", status >> 8, status & 0xff);\n\t\t}\n\t\tpr_cont(\"TPR Threshold = 0x%02x\\n\", vmcs_read32(TPR_THRESHOLD));\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)\n\t\t\tpr_err(\"APIC-access addr = 0x%016llx \", vmcs_read64(APIC_ACCESS_ADDR));\n\t\tpr_cont(\"virt-APIC addr = 0x%016llx\\n\", vmcs_read64(VIRTUAL_APIC_PAGE_ADDR));\n\t}\n\tif (pin_based_exec_ctrl & PIN_BASED_POSTED_INTR)\n\t\tpr_err(\"PostedIntrVec = 0x%02x\\n\", vmcs_read16(POSTED_INTR_NV));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT))\n\t\tpr_err(\"EPT pointer = 0x%016llx\\n\", vmcs_read64(EPT_POINTER));\n\tn = vmcs_read32(CR3_TARGET_COUNT);\n\tfor (i = 0; i + 1 < n; i += 4)\n\t\tpr_err(\"CR3 target%u=%016lx target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2),\n\t\t       i + 1, vmcs_readl(CR3_TARGET_VALUE0 + i * 2 + 2));\n\tif (i < n)\n\t\tpr_err(\"CR3 target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2));\n\tif (secondary_exec_control & SECONDARY_EXEC_PAUSE_LOOP_EXITING)\n\t\tpr_err(\"PLE Gap=%08x Window=%08x\\n\",\n\t\t       vmcs_read32(PLE_GAP), vmcs_read32(PLE_WINDOW));\n\tif (secondary_exec_control & SECONDARY_EXEC_ENABLE_VPID)\n\t\tpr_err(\"Virtual processor ID = 0x%04x\\n\",\n\t\t       vmcs_read16(VIRTUAL_PROCESSOR_ID));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Virtual processor ID = 0x%04x\\n\"",
            "vmcs_read16(VIRTUAL_PROCESSOR_ID)"
          ],
          "line": 5816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_read16",
          "args": [
            "VIRTUAL_PROCESSOR_ID"
          ],
          "line": 5817
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "104-110",
          "snippet": "static __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"PLE Gap=%08x Window=%08x\\n\"",
            "vmcs_read32(PLE_GAP)",
            "vmcs_read32(PLE_WINDOW)"
          ],
          "line": 5813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "PLE_WINDOW"
          ],
          "line": 5814
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"CR3 target%u=%016lx\\n\"",
            "i",
            "vmcs_readl(CR3_TARGET_VALUE0 + i * 2)"
          ],
          "line": 5810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "CR3_TARGET_VALUE0 + i * 2"
          ],
          "line": 5811
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"CR3 target%u=%016lx target%u=%016lx\\n\"",
            "i",
            "vmcs_readl(CR3_TARGET_VALUE0 + i * 2)",
            "i + 1",
            "vmcs_readl(CR3_TARGET_VALUE0 + i * 2 + 2)"
          ],
          "line": 5806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EPT pointer = 0x%016llx\\n\"",
            "vmcs_read64(EPT_POINTER)"
          ],
          "line": 5803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_read64",
          "args": [
            "EPT_POINTER"
          ],
          "line": 5803
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "120-130",
          "snippet": "static __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"PostedIntrVec = 0x%02x\\n\"",
            "vmcs_read16(POSTED_INTR_NV)"
          ],
          "line": 5801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"virt-APIC addr = 0x%016llx\\n\"",
            "vmcs_read64(VIRTUAL_APIC_PAGE_ADDR)"
          ],
          "line": 5798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"APIC-access addr = 0x%016llx \"",
            "vmcs_read64(APIC_ACCESS_ADDR)"
          ],
          "line": 5797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"TPR Threshold = 0x%02x\\n\"",
            "vmcs_read32(TPR_THRESHOLD)"
          ],
          "line": 5795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SVI|RVI = %02x|%02x \"",
            "status >> 8",
            "status & 0xff"
          ],
          "line": 5793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"TSC Multiplier = 0x%016llx\\n\"",
            "vmcs_read64(TSC_MULTIPLIER)"
          ],
          "line": 5788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"TSC Offset = 0x%016llx\\n\"",
            "vmcs_read64(TSC_OFFSET)"
          ],
          "line": 5786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"IDTVectoring: info=%08x errcode=%08x\\n\"",
            "vmcs_read32(IDT_VECTORING_INFO_FIELD)",
            "vmcs_read32(IDT_VECTORING_ERROR_CODE)"
          ],
          "line": 5783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"        reason=%08x qualification=%016lx\\n\"",
            "vmcs_read32(VM_EXIT_REASON)",
            "vmcs_readl(EXIT_QUALIFICATION)"
          ],
          "line": 5781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"VMExit: intr_info=%08x errcode=%08x ilen=%08x\\n\"",
            "vmcs_read32(VM_EXIT_INTR_INFO)",
            "vmcs_read32(VM_EXIT_INTR_ERROR_CODE)",
            "vmcs_read32(VM_EXIT_INSTRUCTION_LEN)"
          ],
          "line": 5777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"VMEntry: intr_info=%08x errcode=%08x ilen=%08x\\n\"",
            "vmcs_read32(VM_ENTRY_INTR_INFO_FIELD)",
            "vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE)",
            "vmcs_read32(VM_ENTRY_INSTRUCTION_LEN)"
          ],
          "line": 5773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\\n\"",
            "vmcs_read32(EXCEPTION_BITMAP)",
            "vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK)",
            "vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH)"
          ],
          "line": 5769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EntryControls=%08x ExitControls=%08x\\n\"",
            "vmentry_ctl",
            "vmexit_ctl"
          ],
          "line": 5768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"PinBased=%08x CPUBased=%08x SecondaryExec=%08x\\n\"",
            "pin_based_exec_ctrl",
            "cpu_based_exec_ctrl",
            "secondary_exec_control"
          ],
          "line": 5766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"*** Control State ***\\n\""
          ],
          "line": 5765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"PerfGlobCtl = 0x%016llx\\n\"",
            "vmcs_read64(HOST_IA32_PERF_GLOBAL_CTRL)"
          ],
          "line": 5762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_load_perf_global_ctrl",
          "args": [],
          "line": 5760
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_load_perf_global_ctrl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "98-102",
          "snippet": "static inline bool cpu_has_load_perf_global_ctrl(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_load_perf_global_ctrl(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EFER = 0x%016llx  PAT = 0x%016llx\\n\"",
            "vmcs_read64(HOST_IA32_EFER)",
            "vmcs_read64(HOST_IA32_PAT)"
          ],
          "line": 5757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\"",
            "vmcs_readl(HOST_IA32_SYSENTER_ESP)",
            "vmcs_read32(HOST_IA32_SYSENTER_CS)",
            "vmcs_readl(HOST_IA32_SYSENTER_EIP)"
          ],
          "line": 5752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"CR0=%016lx CR3=%016lx CR4=%016lx\\n\"",
            "vmcs_readl(HOST_CR0)",
            "vmcs_readl(HOST_CR3)",
            "vmcs_readl(HOST_CR4)"
          ],
          "line": 5749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"GDTBase=%016lx IDTBase=%016lx\\n\"",
            "vmcs_readl(HOST_GDTR_BASE)",
            "vmcs_readl(HOST_IDTR_BASE)"
          ],
          "line": 5747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"FSBase=%016lx GSBase=%016lx TRBase=%016lx\\n\"",
            "vmcs_readl(HOST_FS_BASE)",
            "vmcs_readl(HOST_GS_BASE)",
            "vmcs_readl(HOST_TR_BASE)"
          ],
          "line": 5744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\\n\"",
            "vmcs_read16(HOST_CS_SELECTOR)",
            "vmcs_read16(HOST_SS_SELECTOR)",
            "vmcs_read16(HOST_DS_SELECTOR)",
            "vmcs_read16(HOST_ES_SELECTOR)",
            "vmcs_read16(HOST_FS_SELECTOR)",
            "vmcs_read16(HOST_GS_SELECTOR)",
            "vmcs_read16(HOST_TR_SELECTOR)"
          ],
          "line": 5739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"RIP = 0x%016lx  RSP = 0x%016lx\\n\"",
            "vmcs_readl(HOST_RIP)",
            "vmcs_readl(HOST_RSP)"
          ],
          "line": 5737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"*** Host State ***\\n\""
          ],
          "line": 5736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"InterruptStatus = %04x\\n\"",
            "vmcs_read16(GUEST_INTR_STATUS)"
          ],
          "line": 5733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Interruptibility = %08x  ActivityState = %08x\\n\"",
            "vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)",
            "vmcs_read32(GUEST_ACTIVITY_STATE)"
          ],
          "line": 5729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"BndCfgS = 0x%016llx\\n\"",
            "vmcs_read64(GUEST_BNDCFGS)"
          ],
          "line": 5728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"PerfGlobCtl = 0x%016llx\\n\"",
            "vmcs_read64(GUEST_IA32_PERF_GLOBAL_CTRL)"
          ],
          "line": 5725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\\n\"",
            "vmcs_read64(GUEST_IA32_DEBUGCTL)",
            "vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS)"
          ],
          "line": 5720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"EFER =     0x%016llx  PAT = 0x%016llx\\n\"",
            "efer",
            "vmcs_read64(GUEST_IA32_PAT)"
          ],
          "line": 5718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_dump_sel",
          "args": [
            "\"TR:  \"",
            "GUEST_TR_SELECTOR"
          ],
          "line": 5715
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_dump_sel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5645-5652",
          "snippet": "static void vmx_dump_sel(char *name, uint32_t sel)\n{\n\tpr_err(\"%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read16(sel),\n\t       vmcs_read32(sel + GUEST_ES_AR_BYTES - GUEST_ES_SELECTOR),\n\t       vmcs_read32(sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR),\n\t       vmcs_readl(sel + GUEST_ES_BASE - GUEST_ES_SELECTOR));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_dump_sel(char *name, uint32_t sel)\n{\n\tpr_err(\"%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read16(sel),\n\t       vmcs_read32(sel + GUEST_ES_AR_BYTES - GUEST_ES_SELECTOR),\n\t       vmcs_read32(sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR),\n\t       vmcs_readl(sel + GUEST_ES_BASE - GUEST_ES_SELECTOR));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_dump_dtsel",
          "args": [
            "\"IDTR:\"",
            "GUEST_IDTR_LIMIT"
          ],
          "line": 5714
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_dump_dtsel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5654-5659",
          "snippet": "static void vmx_dump_dtsel(char *name, uint32_t limit)\n{\n\tpr_err(\"%s                           limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read32(limit),\n\t       vmcs_readl(limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_dump_dtsel(char *name, uint32_t limit)\n{\n\tpr_err(\"%s                           limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read32(limit),\n\t       vmcs_readl(limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\"",
            "vmcs_readl(GUEST_SYSENTER_ESP)",
            "vmcs_read32(GUEST_SYSENTER_CS)",
            "vmcs_readl(GUEST_SYSENTER_EIP)"
          ],
          "line": 5703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"RFLAGS=0x%08lx         DR7 = 0x%016lx\\n\"",
            "vmcs_readl(GUEST_RFLAGS)",
            "vmcs_readl(GUEST_DR7)"
          ],
          "line": 5701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"RSP = 0x%016lx  RIP = 0x%016lx\\n\"",
            "vmcs_readl(GUEST_RSP)",
            "vmcs_readl(GUEST_RIP)"
          ],
          "line": 5699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"PDPTR2 = 0x%016llx  PDPTR3 = 0x%016llx\\n\"",
            "vmcs_read64(GUEST_PDPTR2)",
            "vmcs_read64(GUEST_PDPTR3)"
          ],
          "line": 5696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"PDPTR0 = 0x%016llx  PDPTR1 = 0x%016llx\\n\"",
            "vmcs_read64(GUEST_PDPTR0)",
            "vmcs_read64(GUEST_PDPTR1)"
          ],
          "line": 5694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"CR3 = 0x%016lx\\n\"",
            "vmcs_readl(GUEST_CR3)"
          ],
          "line": 5690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\"",
            "cr4",
            "vmcs_readl(CR4_READ_SHADOW)",
            "vmcs_readl(CR4_GUEST_HOST_MASK)"
          ],
          "line": 5688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\"",
            "vmcs_readl(GUEST_CR0)",
            "vmcs_readl(CR0_READ_SHADOW)",
            "vmcs_readl(CR0_GUEST_HOST_MASK)"
          ],
          "line": 5685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"*** Guest State ***\\n\""
          ],
          "line": 5684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_secondary_exec_ctrls",
          "args": [],
          "line": 5681
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_secondary_exec_ctrls",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "125-129",
          "snippet": "static inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"set kvm_intel.dump_invalid_vmcs=1 to dump internal KVM state.\\n\""
          ],
          "line": 5670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid dump_vmcs(void)\n{\n\tu32 vmentry_ctl, vmexit_ctl;\n\tu32 cpu_based_exec_ctrl, pin_based_exec_ctrl, secondary_exec_control;\n\tunsigned long cr4;\n\tu64 efer;\n\tint i, n;\n\n\tif (!dump_invalid_vmcs) {\n\t\tpr_warn_ratelimited(\"set kvm_intel.dump_invalid_vmcs=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tvmentry_ctl = vmcs_read32(VM_ENTRY_CONTROLS);\n\tvmexit_ctl = vmcs_read32(VM_EXIT_CONTROLS);\n\tcpu_based_exec_ctrl = vmcs_read32(CPU_BASED_VM_EXEC_CONTROL);\n\tpin_based_exec_ctrl = vmcs_read32(PIN_BASED_VM_EXEC_CONTROL);\n\tcr4 = vmcs_readl(GUEST_CR4);\n\tefer = vmcs_read64(GUEST_IA32_EFER);\n\tsecondary_exec_control = 0;\n\tif (cpu_has_secondary_exec_ctrls())\n\t\tsecondary_exec_control = vmcs_read32(SECONDARY_VM_EXEC_CONTROL);\n\n\tpr_err(\"*** Guest State ***\\n\");\n\tpr_err(\"CR0: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       vmcs_readl(GUEST_CR0), vmcs_readl(CR0_READ_SHADOW),\n\t       vmcs_readl(CR0_GUEST_HOST_MASK));\n\tpr_err(\"CR4: actual=0x%016lx, shadow=0x%016lx, gh_mask=%016lx\\n\",\n\t       cr4, vmcs_readl(CR4_READ_SHADOW), vmcs_readl(CR4_GUEST_HOST_MASK));\n\tpr_err(\"CR3 = 0x%016lx\\n\", vmcs_readl(GUEST_CR3));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT) &&\n\t    (cr4 & X86_CR4_PAE) && !(efer & EFER_LMA))\n\t{\n\t\tpr_err(\"PDPTR0 = 0x%016llx  PDPTR1 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR0), vmcs_read64(GUEST_PDPTR1));\n\t\tpr_err(\"PDPTR2 = 0x%016llx  PDPTR3 = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_PDPTR2), vmcs_read64(GUEST_PDPTR3));\n\t}\n\tpr_err(\"RSP = 0x%016lx  RIP = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RSP), vmcs_readl(GUEST_RIP));\n\tpr_err(\"RFLAGS=0x%08lx         DR7 = 0x%016lx\\n\",\n\t       vmcs_readl(GUEST_RFLAGS), vmcs_readl(GUEST_DR7));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(GUEST_SYSENTER_ESP),\n\t       vmcs_read32(GUEST_SYSENTER_CS), vmcs_readl(GUEST_SYSENTER_EIP));\n\tvmx_dump_sel(\"CS:  \", GUEST_CS_SELECTOR);\n\tvmx_dump_sel(\"DS:  \", GUEST_DS_SELECTOR);\n\tvmx_dump_sel(\"SS:  \", GUEST_SS_SELECTOR);\n\tvmx_dump_sel(\"ES:  \", GUEST_ES_SELECTOR);\n\tvmx_dump_sel(\"FS:  \", GUEST_FS_SELECTOR);\n\tvmx_dump_sel(\"GS:  \", GUEST_GS_SELECTOR);\n\tvmx_dump_dtsel(\"GDTR:\", GUEST_GDTR_LIMIT);\n\tvmx_dump_sel(\"LDTR:\", GUEST_LDTR_SELECTOR);\n\tvmx_dump_dtsel(\"IDTR:\", GUEST_IDTR_LIMIT);\n\tvmx_dump_sel(\"TR:  \", GUEST_TR_SELECTOR);\n\tif ((vmexit_ctl & (VM_EXIT_SAVE_IA32_PAT | VM_EXIT_SAVE_IA32_EFER)) ||\n\t    (vmentry_ctl & (VM_ENTRY_LOAD_IA32_PAT | VM_ENTRY_LOAD_IA32_EFER)))\n\t\tpr_err(\"EFER =     0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       efer, vmcs_read64(GUEST_IA32_PAT));\n\tpr_err(\"DebugCtl = 0x%016llx  DebugExceptions = 0x%016lx\\n\",\n\t       vmcs_read64(GUEST_IA32_DEBUGCTL),\n\t       vmcs_readl(GUEST_PENDING_DBG_EXCEPTIONS));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmentry_ctl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(GUEST_IA32_PERF_GLOBAL_CTRL));\n\tif (vmentry_ctl & VM_ENTRY_LOAD_BNDCFGS)\n\t\tpr_err(\"BndCfgS = 0x%016llx\\n\", vmcs_read64(GUEST_BNDCFGS));\n\tpr_err(\"Interruptibility = %08x  ActivityState = %08x\\n\",\n\t       vmcs_read32(GUEST_INTERRUPTIBILITY_INFO),\n\t       vmcs_read32(GUEST_ACTIVITY_STATE));\n\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY)\n\t\tpr_err(\"InterruptStatus = %04x\\n\",\n\t\t       vmcs_read16(GUEST_INTR_STATUS));\n\n\tpr_err(\"*** Host State ***\\n\");\n\tpr_err(\"RIP = 0x%016lx  RSP = 0x%016lx\\n\",\n\t       vmcs_readl(HOST_RIP), vmcs_readl(HOST_RSP));\n\tpr_err(\"CS=%04x SS=%04x DS=%04x ES=%04x FS=%04x GS=%04x TR=%04x\\n\",\n\t       vmcs_read16(HOST_CS_SELECTOR), vmcs_read16(HOST_SS_SELECTOR),\n\t       vmcs_read16(HOST_DS_SELECTOR), vmcs_read16(HOST_ES_SELECTOR),\n\t       vmcs_read16(HOST_FS_SELECTOR), vmcs_read16(HOST_GS_SELECTOR),\n\t       vmcs_read16(HOST_TR_SELECTOR));\n\tpr_err(\"FSBase=%016lx GSBase=%016lx TRBase=%016lx\\n\",\n\t       vmcs_readl(HOST_FS_BASE), vmcs_readl(HOST_GS_BASE),\n\t       vmcs_readl(HOST_TR_BASE));\n\tpr_err(\"GDTBase=%016lx IDTBase=%016lx\\n\",\n\t       vmcs_readl(HOST_GDTR_BASE), vmcs_readl(HOST_IDTR_BASE));\n\tpr_err(\"CR0=%016lx CR3=%016lx CR4=%016lx\\n\",\n\t       vmcs_readl(HOST_CR0), vmcs_readl(HOST_CR3),\n\t       vmcs_readl(HOST_CR4));\n\tpr_err(\"Sysenter RSP=%016lx CS:RIP=%04x:%016lx\\n\",\n\t       vmcs_readl(HOST_IA32_SYSENTER_ESP),\n\t       vmcs_read32(HOST_IA32_SYSENTER_CS),\n\t       vmcs_readl(HOST_IA32_SYSENTER_EIP));\n\tif (vmexit_ctl & (VM_EXIT_LOAD_IA32_PAT | VM_EXIT_LOAD_IA32_EFER))\n\t\tpr_err(\"EFER = 0x%016llx  PAT = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_EFER),\n\t\t       vmcs_read64(HOST_IA32_PAT));\n\tif (cpu_has_load_perf_global_ctrl() &&\n\t    vmexit_ctl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL)\n\t\tpr_err(\"PerfGlobCtl = 0x%016llx\\n\",\n\t\t       vmcs_read64(HOST_IA32_PERF_GLOBAL_CTRL));\n\n\tpr_err(\"*** Control State ***\\n\");\n\tpr_err(\"PinBased=%08x CPUBased=%08x SecondaryExec=%08x\\n\",\n\t       pin_based_exec_ctrl, cpu_based_exec_ctrl, secondary_exec_control);\n\tpr_err(\"EntryControls=%08x ExitControls=%08x\\n\", vmentry_ctl, vmexit_ctl);\n\tpr_err(\"ExceptionBitmap=%08x PFECmask=%08x PFECmatch=%08x\\n\",\n\t       vmcs_read32(EXCEPTION_BITMAP),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MASK),\n\t       vmcs_read32(PAGE_FAULT_ERROR_CODE_MATCH));\n\tpr_err(\"VMEntry: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_ENTRY_INTR_INFO_FIELD),\n\t       vmcs_read32(VM_ENTRY_EXCEPTION_ERROR_CODE),\n\t       vmcs_read32(VM_ENTRY_INSTRUCTION_LEN));\n\tpr_err(\"VMExit: intr_info=%08x errcode=%08x ilen=%08x\\n\",\n\t       vmcs_read32(VM_EXIT_INTR_INFO),\n\t       vmcs_read32(VM_EXIT_INTR_ERROR_CODE),\n\t       vmcs_read32(VM_EXIT_INSTRUCTION_LEN));\n\tpr_err(\"        reason=%08x qualification=%016lx\\n\",\n\t       vmcs_read32(VM_EXIT_REASON), vmcs_readl(EXIT_QUALIFICATION));\n\tpr_err(\"IDTVectoring: info=%08x errcode=%08x\\n\",\n\t       vmcs_read32(IDT_VECTORING_INFO_FIELD),\n\t       vmcs_read32(IDT_VECTORING_ERROR_CODE));\n\tpr_err(\"TSC Offset = 0x%016llx\\n\", vmcs_read64(TSC_OFFSET));\n\tif (secondary_exec_control & SECONDARY_EXEC_TSC_SCALING)\n\t\tpr_err(\"TSC Multiplier = 0x%016llx\\n\",\n\t\t       vmcs_read64(TSC_MULTIPLIER));\n\tif (cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW) {\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY) {\n\t\t\tu16 status = vmcs_read16(GUEST_INTR_STATUS);\n\t\t\tpr_err(\"SVI|RVI = %02x|%02x \", status >> 8, status & 0xff);\n\t\t}\n\t\tpr_cont(\"TPR Threshold = 0x%02x\\n\", vmcs_read32(TPR_THRESHOLD));\n\t\tif (secondary_exec_control & SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)\n\t\t\tpr_err(\"APIC-access addr = 0x%016llx \", vmcs_read64(APIC_ACCESS_ADDR));\n\t\tpr_cont(\"virt-APIC addr = 0x%016llx\\n\", vmcs_read64(VIRTUAL_APIC_PAGE_ADDR));\n\t}\n\tif (pin_based_exec_ctrl & PIN_BASED_POSTED_INTR)\n\t\tpr_err(\"PostedIntrVec = 0x%02x\\n\", vmcs_read16(POSTED_INTR_NV));\n\tif ((secondary_exec_control & SECONDARY_EXEC_ENABLE_EPT))\n\t\tpr_err(\"EPT pointer = 0x%016llx\\n\", vmcs_read64(EPT_POINTER));\n\tn = vmcs_read32(CR3_TARGET_COUNT);\n\tfor (i = 0; i + 1 < n; i += 4)\n\t\tpr_err(\"CR3 target%u=%016lx target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2),\n\t\t       i + 1, vmcs_readl(CR3_TARGET_VALUE0 + i * 2 + 2));\n\tif (i < n)\n\t\tpr_err(\"CR3 target%u=%016lx\\n\",\n\t\t       i, vmcs_readl(CR3_TARGET_VALUE0 + i * 2));\n\tif (secondary_exec_control & SECONDARY_EXEC_PAUSE_LOOP_EXITING)\n\t\tpr_err(\"PLE Gap=%08x Window=%08x\\n\",\n\t\t       vmcs_read32(PLE_GAP), vmcs_read32(PLE_WINDOW));\n\tif (secondary_exec_control & SECONDARY_EXEC_ENABLE_VPID)\n\t\tpr_err(\"Virtual processor ID = 0x%04x\\n\",\n\t\t       vmcs_read16(VIRTUAL_PROCESSOR_ID));\n}"
  },
  {
    "function_name": "vmx_dump_dtsel",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5654-5659",
    "snippet": "static void vmx_dump_dtsel(char *name, uint32_t limit)\n{\n\tpr_err(\"%s                           limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read32(limit),\n\t       vmcs_readl(limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s                           limit=0x%08x, base=0x%016lx\\n\"",
            "name",
            "vmcs_read32(limit)",
            "vmcs_readl(limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT)"
          ],
          "line": 5656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT"
          ],
          "line": 5658
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "limit"
          ],
          "line": 5657
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_dump_dtsel(char *name, uint32_t limit)\n{\n\tpr_err(\"%s                           limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read32(limit),\n\t       vmcs_readl(limit + GUEST_GDTR_BASE - GUEST_GDTR_LIMIT));\n}"
  },
  {
    "function_name": "vmx_dump_sel",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5645-5652",
    "snippet": "static void vmx_dump_sel(char *name, uint32_t sel)\n{\n\tpr_err(\"%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read16(sel),\n\t       vmcs_read32(sel + GUEST_ES_AR_BYTES - GUEST_ES_SELECTOR),\n\t       vmcs_read32(sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR),\n\t       vmcs_readl(sel + GUEST_ES_BASE - GUEST_ES_SELECTOR));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\\n\"",
            "name",
            "vmcs_read16(sel)",
            "vmcs_read32(sel + GUEST_ES_AR_BYTES - GUEST_ES_SELECTOR)",
            "vmcs_read32(sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR)",
            "vmcs_readl(sel + GUEST_ES_BASE - GUEST_ES_SELECTOR)"
          ],
          "line": 5647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "sel + GUEST_ES_BASE - GUEST_ES_SELECTOR"
          ],
          "line": 5651
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR"
          ],
          "line": 5650
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read16",
          "args": [
            "sel"
          ],
          "line": 5648
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "104-110",
          "snippet": "static __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_dump_sel(char *name, uint32_t sel)\n{\n\tpr_err(\"%s sel=0x%04x, attr=0x%05x, limit=0x%08x, base=0x%016lx\\n\",\n\t       name, vmcs_read16(sel),\n\t       vmcs_read32(sel + GUEST_ES_AR_BYTES - GUEST_ES_SELECTOR),\n\t       vmcs_read32(sel + GUEST_ES_LIMIT - GUEST_ES_SELECTOR),\n\t       vmcs_readl(sel + GUEST_ES_BASE - GUEST_ES_SELECTOR));\n}"
  },
  {
    "function_name": "kvm_flush_pml_buffers",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5631-5643",
    "snippet": "static void kvm_flush_pml_buffers(struct kvm *kvm)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\t/*\n\t * We only need to kick vcpu out of guest mode here, as PML buffer\n\t * is flushed at beginning of all VMEXITs, and it's obvious that only\n\t * vcpus running in guest are possible to have unflushed GPAs in PML\n\t * buffer.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_vcpu_kick(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 5642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 5641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void kvm_flush_pml_buffers(struct kvm *kvm)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\t/*\n\t * We only need to kick vcpu out of guest mode here, as PML buffer\n\t * is flushed at beginning of all VMEXITs, and it's obvious that only\n\t * vcpus running in guest are possible to have unflushed GPAs in PML\n\t * buffer.\n\t */\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tkvm_vcpu_kick(vcpu);\n}"
  },
  {
    "function_name": "vmx_flush_pml_buffer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5596-5625",
    "snippet": "static void vmx_flush_pml_buffer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 *pml_buf;\n\tu16 pml_idx;\n\n\tpml_idx = vmcs_read16(GUEST_PML_INDEX);\n\n\t/* Do nothing if PML buffer is empty */\n\tif (pml_idx == (PML_ENTITY_NUM - 1))\n\t\treturn;\n\n\t/* PML index always points to next available PML buffer entity */\n\tif (pml_idx >= PML_ENTITY_NUM)\n\t\tpml_idx = 0;\n\telse\n\t\tpml_idx++;\n\n\tpml_buf = page_address(vmx->pml_pg);\n\tfor (; pml_idx < PML_ENTITY_NUM; pml_idx++) {\n\t\tu64 gpa;\n\n\t\tgpa = pml_buf[pml_idx];\n\t\tWARN_ON(gpa & (PAGE_SIZE - 1));\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\t}\n\n\t/* reset PML index */\n\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write16",
          "args": [
            "GUEST_PML_INDEX",
            "PML_ENTITY_NUM - 1"
          ],
          "line": 5624
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "175-182",
          "snippet": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_mark_page_dirty",
          "args": [
            "vcpu",
            "gpa >> PAGE_SHIFT"
          ],
          "line": 5620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "gpa & (PAGE_SIZE - 1)"
          ],
          "line": 5619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "vmx->pml_pg"
          ],
          "line": 5614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_read16",
          "args": [
            "GUEST_PML_INDEX"
          ],
          "line": 5602
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "104-110",
          "snippet": "static __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 5598
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_flush_pml_buffer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu64 *pml_buf;\n\tu16 pml_idx;\n\n\tpml_idx = vmcs_read16(GUEST_PML_INDEX);\n\n\t/* Do nothing if PML buffer is empty */\n\tif (pml_idx == (PML_ENTITY_NUM - 1))\n\t\treturn;\n\n\t/* PML index always points to next available PML buffer entity */\n\tif (pml_idx >= PML_ENTITY_NUM)\n\t\tpml_idx = 0;\n\telse\n\t\tpml_idx++;\n\n\tpml_buf = page_address(vmx->pml_pg);\n\tfor (; pml_idx < PML_ENTITY_NUM; pml_idx++) {\n\t\tu64 gpa;\n\n\t\tgpa = pml_buf[pml_idx];\n\t\tWARN_ON(gpa & (PAGE_SIZE - 1));\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gpa >> PAGE_SHIFT);\n\t}\n\n\t/* reset PML index */\n\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n}"
  },
  {
    "function_name": "vmx_destroy_pml_buffer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5588-5594",
    "snippet": "static void vmx_destroy_pml_buffer(struct vcpu_vmx *vmx)\n{\n\tif (vmx->pml_pg) {\n\t\t__free_page(vmx->pml_pg);\n\t\tvmx->pml_pg = NULL;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "vmx->pml_pg"
          ],
          "line": 5591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_destroy_pml_buffer(struct vcpu_vmx *vmx)\n{\n\tif (vmx->pml_pg) {\n\t\t__free_page(vmx->pml_pg);\n\t\tvmx->pml_pg = NULL;\n\t}\n}"
  },
  {
    "function_name": "vmx_get_exit_info",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5582-5586",
    "snippet": "static void vmx_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\t*info1 = vmcs_readl(EXIT_QUALIFICATION);\n\t*info2 = vmcs_read32(VM_EXIT_INTR_INFO);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "VM_EXIT_INTR_INFO"
          ],
          "line": 5585
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 5584
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\t*info1 = vmcs_readl(EXIT_QUALIFICATION);\n\t*info2 = vmcs_read32(VM_EXIT_INTR_INFO);\n}"
  },
  {
    "function_name": "handle_encls",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5510-5519",
    "snippet": "static int handle_encls(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * SGX virtualization is not yet supported.  There is no software\n\t * enable bit for SGX, so we have to trap ENCLS and inject a #UD\n\t * to prevent the guest from executing ENCLS.\n\t */\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "UD_VECTOR"
          ],
          "line": 5517
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_encls(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * SGX virtualization is not yet supported.  There is no software\n\t * enable bit for SGX, so we have to trap ENCLS and inject a #UD\n\t * to prevent the guest from executing ENCLS.\n\t */\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_vmx_instruction",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5504-5508",
    "snippet": "static int handle_vmx_instruction(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "UD_VECTOR"
          ],
          "line": 5506
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_vmx_instruction(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_preemption_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5489-5498",
    "snippet": "static int handle_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!vmx->req_immediate_exit &&\n\t    !unlikely(vmx->loaded_vmcs->hv_timer_soft_disabled))\n\t\tkvm_lapic_expired_hv_timer(vcpu);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_expired_hv_timer",
          "args": [
            "vcpu"
          ],
          "line": 5495
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_expired_hv_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1831-1849",
          "snippet": "void kvm_lapic_expired_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tpreempt_disable();\n\t/* If the preempt notifier has already run, it also called apic_timer_expired */\n\tif (!apic->lapic_timer.hv_timer_in_use)\n\t\tgoto out;\n\tWARN_ON(swait_active(&vcpu->wq));\n\tcancel_hv_timer(apic);\n\tapic_timer_expired(apic);\n\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\tadvance_periodic_target_expiration(apic);\n\t\trestart_apic_timer(apic);\n\t}\nout:\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_expired_hv_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tpreempt_disable();\n\t/* If the preempt notifier has already run, it also called apic_timer_expired */\n\tif (!apic->lapic_timer.hv_timer_in_use)\n\t\tgoto out;\n\tWARN_ON(swait_active(&vcpu->wq));\n\tcancel_hv_timer(apic);\n\tapic_timer_expired(apic);\n\n\tif (apic_lvtt_period(apic) && apic->lapic_timer.period) {\n\t\tadvance_periodic_target_expiration(apic);\n\t\trestart_apic_timer(apic);\n\t}\nout:\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vmx->loaded_vmcs->hv_timer_soft_disabled"
          ],
          "line": 5494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 5491
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_preemption_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!vmx->req_immediate_exit &&\n\t    !unlikely(vmx->loaded_vmcs->hv_timer_soft_disabled))\n\t\tkvm_lapic_expired_hv_timer(vcpu);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_pml_full",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5464-5487",
    "snippet": "static int handle_pml_full(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\n\ttrace_kvm_pml_full(vcpu->vcpu_id);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\t/*\n\t * PML buffer FULL happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tenable_vnmi &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\tGUEST_INTR_STATE_NMI);\n\n\t/*\n\t * PML buffer already flushed at beginning of VMEXIT. Nothing to do\n\t * here.., and there's no userspace involvement needed for PML.\n\t */\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_set_bits",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO",
            "GUEST_INTR_STATE_NMI"
          ],
          "line": 5479
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "224-232",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 5476
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 5470
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_pml_full",
          "args": [
            "vcpu->vcpu_id"
          ],
          "line": 5468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_pml_full(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\n\ttrace_kvm_pml_full(vcpu->vcpu_id);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\t/*\n\t * PML buffer FULL happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tenable_vnmi &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\tGUEST_INTR_STATE_NMI);\n\n\t/*\n\t * PML buffer already flushed at beginning of VMEXIT. Nothing to do\n\t * here.., and there's no userspace involvement needed for PML.\n\t */\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_invpcid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5364-5462",
    "snippet": "static int handle_invpcid(struct kvm_vcpu *vcpu)\n{\n\tu32 vmx_instruction_info;\n\tunsigned long type;\n\tbool pcid_enabled;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tunsigned i;\n\tunsigned long roots_to_free = 0;\n\tstruct {\n\t\tu64 pcid;\n\t\tu64 gla;\n\t} operand;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_INVPCID)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\n\tif (type > 3) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\t/* According to the Intel instruction reference, the memory operand\n\t * is read even if it isn't needed (e.g., for type==all)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\t\tvmx_instruction_info, false,\n\t\t\t\tsizeof(operand), &gva))\n\t\treturn 1;\n\n\tif (kvm_read_guest_virt(vcpu, gva, &operand, sizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tif (operand.pcid >> 12 != 0) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tpcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);\n\n\tswitch (type) {\n\tcase INVPCID_TYPE_INDIV_ADDR:\n\t\tif ((!pcid_enabled && (operand.pcid != 0)) ||\n\t\t    is_noncanonical_address(operand.gla, vcpu)) {\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_mmu_invpcid_gva(vcpu, operand.gla, operand.pcid);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tcase INVPCID_TYPE_SINGLE_CTXT:\n\t\tif (!pcid_enabled && (operand.pcid != 0)) {\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (kvm_get_active_pcid(vcpu) == operand.pcid) {\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tif (kvm_get_pcid(vcpu, vcpu->arch.mmu->prev_roots[i].cr3)\n\t\t\t    == operand.pcid)\n\t\t\t\troots_to_free |= KVM_MMU_ROOT_PREVIOUS(i);\n\n\t\tkvm_mmu_free_roots(vcpu, vcpu->arch.mmu, roots_to_free);\n\t\t/*\n\t\t * If neither the current cr3 nor any of the prev_roots use the\n\t\t * given PCID, then nothing needs to be done here because a\n\t\t * resync will happen anyway before switching to any other CR3.\n\t\t */\n\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tcase INVPCID_TYPE_ALL_NON_GLOBAL:\n\t\t/*\n\t\t * Currently, KVM doesn't mark global entries in the shadow\n\t\t * page tables, so a non-global flush just degenerates to a\n\t\t * global flush. If needed, we could optimize this later by\n\t\t * keeping track of global entries in shadow page tables.\n\t\t */\n\n\t\t/* fall-through */\n\tcase INVPCID_TYPE_ALL_INCL_GLOBAL:\n\t\tkvm_mmu_unload(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tdefault:\n\t\tBUG(); /* We have already checked above that type <= 3 */\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 5460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 5457
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unload",
          "args": [
            "vcpu"
          ],
          "line": 5456
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unload",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5192-5198",
          "snippet": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.root_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.root_mmu.root_hpa));\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.guest_mmu.root_hpa));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.root_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.root_mmu.root_hpa));\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.guest_mmu.root_hpa));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_free_roots",
          "args": [
            "vcpu",
            "vcpu->arch.mmu",
            "roots_to_free"
          ],
          "line": 5437
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_roots",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3629-3674",
          "snippet": "void kvm_mmu_free_roots(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\tulong roots_to_free)\n{\n\tint i;\n\tLIST_HEAD(invalid_list);\n\tbool free_active_root = roots_to_free & KVM_MMU_ROOT_CURRENT;\n\n\tBUILD_BUG_ON(KVM_MMU_NUM_PREV_ROOTS >= BITS_PER_LONG);\n\n\t/* Before acquiring the MMU lock, see if we need to do any real work. */\n\tif (!(free_active_root && VALID_PAGE(mmu->root_hpa))) {\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tif ((roots_to_free & KVM_MMU_ROOT_PREVIOUS(i)) &&\n\t\t\t    VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\t\tbreak;\n\n\t\tif (i == KVM_MMU_NUM_PREV_ROOTS)\n\t\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (roots_to_free & KVM_MMU_ROOT_PREVIOUS(i))\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->prev_roots[i].hpa,\n\t\t\t\t\t   &invalid_list);\n\n\tif (free_active_root) {\n\t\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t\t    (mmu->root_level >= PT64_ROOT_4LEVEL || mmu->direct_map)) {\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->root_hpa,\n\t\t\t\t\t   &invalid_list);\n\t\t} else {\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tif (mmu->pae_root[i] != 0)\n\t\t\t\t\tmmu_free_root_page(vcpu->kvm,\n\t\t\t\t\t\t\t   &mmu->pae_root[i],\n\t\t\t\t\t\t\t   &invalid_list);\n\t\t\tmmu->root_hpa = INVALID_PAGE;\n\t\t}\n\t\tmmu->root_cr3 = 0;\n\t}\n\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nvoid kvm_mmu_free_roots(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\tulong roots_to_free)\n{\n\tint i;\n\tLIST_HEAD(invalid_list);\n\tbool free_active_root = roots_to_free & KVM_MMU_ROOT_CURRENT;\n\n\tBUILD_BUG_ON(KVM_MMU_NUM_PREV_ROOTS >= BITS_PER_LONG);\n\n\t/* Before acquiring the MMU lock, see if we need to do any real work. */\n\tif (!(free_active_root && VALID_PAGE(mmu->root_hpa))) {\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tif ((roots_to_free & KVM_MMU_ROOT_PREVIOUS(i)) &&\n\t\t\t    VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\t\tbreak;\n\n\t\tif (i == KVM_MMU_NUM_PREV_ROOTS)\n\t\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (roots_to_free & KVM_MMU_ROOT_PREVIOUS(i))\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->prev_roots[i].hpa,\n\t\t\t\t\t   &invalid_list);\n\n\tif (free_active_root) {\n\t\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t\t    (mmu->root_level >= PT64_ROOT_4LEVEL || mmu->direct_map)) {\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->root_hpa,\n\t\t\t\t\t   &invalid_list);\n\t\t} else {\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tif (mmu->pae_root[i] != 0)\n\t\t\t\t\tmmu_free_root_page(vcpu->kvm,\n\t\t\t\t\t\t\t   &mmu->pae_root[i],\n\t\t\t\t\t\t\t   &invalid_list);\n\t\t\tmmu->root_hpa = INVALID_PAGE;\n\t\t}\n\t\tmmu->root_cr3 = 0;\n\t}\n\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_MMU_ROOT_PREVIOUS",
          "args": [
            "i"
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_pcid",
          "args": [
            "vcpu",
            "vcpu->arch.mmu->prev_roots[i].cr3"
          ],
          "line": 5433
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_pcid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "84-91",
          "snippet": "static inline unsigned long kvm_get_pcid(struct kvm_vcpu *vcpu, gpa_t cr3)\n{\n\tBUILD_BUG_ON((X86_CR3_PCID_MASK & PAGE_MASK) != 0);\n\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)\n\t       ? cr3 & X86_CR3_PCID_MASK\n\t       : 0;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_get_pcid(struct kvm_vcpu *vcpu, gpa_t cr3)\n{\n\tBUILD_BUG_ON((X86_CR3_PCID_MASK & PAGE_MASK) != 0);\n\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)\n\t       ? cr3 & X86_CR3_PCID_MASK\n\t       : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 5429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_sync_roots",
          "args": [
            "vcpu"
          ],
          "line": 5428
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_sync_roots",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3845-3901",
          "snippet": "void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\treturn;\n\n\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\t\tsp = page_header(root);\n\n\t\t/*\n\t\t * Even if another CPU was marking the SP as unsync-ed\n\t\t * simultaneously, any guest page table changes are not\n\t\t * guaranteed to be visible anyway until this VCPU issues a TLB\n\t\t * flush strictly after those changes are made. We only need to\n\t\t * ensure that the other CPU sets these flags before any actual\n\t\t * changes to the page tables are made. The comments in\n\t\t * mmu_need_write_protect() describe what could go wrong if this\n\t\t * requirement isn't satisfied.\n\t\t */\n\t\tif (!smp_load_acquire(&sp->unsync) &&\n\t\t    !smp_load_acquire(&sp->unsync_children))\n\t\t\treturn;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\t\tmmu_sync_children(vcpu, sp);\n\n\t\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\tmmu_sync_children(vcpu, sp);\n\t\t}\n\t}\n\n\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\treturn;\n\n\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\t\tsp = page_header(root);\n\n\t\t/*\n\t\t * Even if another CPU was marking the SP as unsync-ed\n\t\t * simultaneously, any guest page table changes are not\n\t\t * guaranteed to be visible anyway until this VCPU issues a TLB\n\t\t * flush strictly after those changes are made. We only need to\n\t\t * ensure that the other CPU sets these flags before any actual\n\t\t * changes to the page tables are made. The comments in\n\t\t * mmu_need_write_protect() describe what could go wrong if this\n\t\t * requirement isn't satisfied.\n\t\t */\n\t\tif (!smp_load_acquire(&sp->unsync) &&\n\t\t    !smp_load_acquire(&sp->unsync_children))\n\t\t\treturn;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\t\tmmu_sync_children(vcpu, sp);\n\n\t\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\tmmu_sync_children(vcpu, sp);\n\t\t}\n\t}\n\n\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_active_pcid",
          "args": [
            "vcpu"
          ],
          "line": 5427
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_active_pcid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "93-96",
          "snippet": "static inline unsigned long kvm_get_active_pcid(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_get_pcid(vcpu, kvm_read_cr3(vcpu));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_get_active_pcid(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_get_pcid(vcpu, kvm_read_cr3(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 5423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_invpcid_gva",
          "args": [
            "vcpu",
            "operand.gla",
            "operand.pcid"
          ],
          "line": 5418
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_invpcid_gva",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5531-5560",
          "snippet": "void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\t\ttlb_flush = true;\n\t}\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].cr3)) {\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\n\tif (tlb_flush)\n\t\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\n\t++vcpu->stat.invlpg;\n\n\t/*\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\t\ttlb_flush = true;\n\t}\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].cr3)) {\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\n\tif (tlb_flush)\n\t\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\n\t++vcpu->stat.invlpg;\n\n\t/*\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 5415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_noncanonical_address",
          "args": [
            "operand.gla",
            "vcpu"
          ],
          "line": 5414
        },
        "resolved": true,
        "details": {
          "function_name": "emul_is_noncanonical_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/emulate.c",
          "lines": "673-677",
          "snippet": "static inline bool emul_is_noncanonical_address(u64 la,\n\t\t\t\t\t\tstruct x86_emulate_ctxt *ctxt)\n{\n\treturn get_canonical(la, ctxt_virt_addr_bits(ctxt)) != la;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"mmu.h\"",
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/nospec-branch.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/fpu/api.h>",
            "#include <linux/stringify.h>",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"mmu.h\"\n#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/nospec-branch.h>\n#include <asm/debugreg.h>\n#include <asm/fpu/api.h>\n#include <linux/stringify.h>\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool emul_is_noncanonical_address(u64 la,\n\t\t\t\t\t\tstruct x86_emulate_ctxt *ctxt)\n{\n\treturn get_canonical(la, ctxt_virt_addr_bits(ctxt)) != la;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_PCIDE"
          ],
          "line": 5409
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "129-135",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 5405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_inject_page_fault",
          "args": [
            "vcpu",
            "&e"
          ],
          "line": 5400
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_inject_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "599-611",
          "snippet": "void kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.exception.nested_apf =\n\t\tis_guest_mode(vcpu) && fault->async_page_fault;\n\tif (vcpu->arch.exception.nested_apf) {\n\t\tvcpu->arch.apf.nested_apf_token = fault->address;\n\t\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n\t} else {\n\t\tkvm_queue_exception_e_p(vcpu, PF_VECTOR, fault->error_code,\n\t\t\t\t\tfault->address);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_inject_page_fault(struct kvm_vcpu *vcpu, struct x86_exception *fault)\n{\n\t++vcpu->stat.pf_guest;\n\tvcpu->arch.exception.nested_apf =\n\t\tis_guest_mode(vcpu) && fault->async_page_fault;\n\tif (vcpu->arch.exception.nested_apf) {\n\t\tvcpu->arch.apf.nested_apf_token = fault->address;\n\t\tkvm_queue_exception_e(vcpu, PF_VECTOR, fault->error_code);\n\t} else {\n\t\tkvm_queue_exception_e_p(vcpu, PF_VECTOR, fault->error_code,\n\t\t\t\t\tfault->address);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_guest_virt",
          "args": [
            "vcpu",
            "gva",
            "&operand",
            "sizeof(operand)",
            "&e"
          ],
          "line": 5399
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_guest_virt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "5447-5462",
          "snippet": "int kvm_read_guest_virt(struct kvm_vcpu *vcpu,\n\t\t\t       gva_t addr, void *val, unsigned int bytes,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops.get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\t/*\n\t * FIXME: this should call handle_emulation_failure if X86EMUL_IO_NEEDED\n\t * is returned, but our callers are not ready for that and they blindly\n\t * call kvm_inject_page_fault.  Ensure that they at least do not leak\n\t * uninitialized kernel stack memory into cr2 and error code.\n\t */\n\tmemset(exception, 0, sizeof(*exception));\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,\n\t\t\t\t\t  exception);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_read_guest_virt(struct kvm_vcpu *vcpu,\n\t\t\t       gva_t addr, void *val, unsigned int bytes,\n\t\t\t       struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops.get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\n\t/*\n\t * FIXME: this should call handle_emulation_failure if X86EMUL_IO_NEEDED\n\t * is returned, but our callers are not ready for that and they blindly\n\t * call kvm_inject_page_fault.  Ensure that they at least do not leak\n\t * uninitialized kernel stack memory into cr2 and error code.\n\t */\n\tmemset(exception, 0, sizeof(*exception));\n\treturn kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access,\n\t\t\t\t\t  exception);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmx_mem_address",
          "args": [
            "vcpu",
            "vmcs_readl(EXIT_QUALIFICATION)",
            "vmx_instruction_info",
            "false",
            "sizeof(operand)",
            "&gva"
          ],
          "line": 5394
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmx_mem_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "4406-4528",
          "snippet": "int get_vmx_mem_address(struct kvm_vcpu *vcpu, unsigned long exit_qualification,\n\t\t\tu32 vmx_instruction_info, bool wr, int len, gva_t *ret)\n{\n\tgva_t off;\n\tbool exn;\n\tstruct kvm_segment s;\n\n\t/*\n\t * According to Vol. 3B, \"Information for VM Exits Due to Instruction\n\t * Execution\", on an exit, vmx_instruction_info holds most of the\n\t * addressing components of the operand. Only the displacement part\n\t * is put in exit_qualification (see 3B, \"Basic VM-Exit Information\").\n\t * For how an actual address is calculated from all these components,\n\t * refer to Vol. 1, \"Operand Addressing\".\n\t */\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\t/* Addr = segment_base + offset */\n\t/* offset = base + [index * scale] + displacement */\n\toff = exit_qualification; /* holds the displacement */\n\tif (addr_size == 1)\n\t\toff = (gva_t)sign_extend64(off, 31);\n\telse if (addr_size == 0)\n\t\toff = (gva_t)sign_extend64(off, 15);\n\tif (base_is_valid)\n\t\toff += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\toff += kvm_register_read(vcpu, index_reg) << scaling;\n\tvmx_get_segment(vcpu, &s, seg_reg);\n\n\t/*\n\t * The effective address, i.e. @off, of a memory operand is truncated\n\t * based on the address size of the instruction.  Note that this is\n\t * the *effective address*, i.e. the address prior to accounting for\n\t * the segment's base.\n\t */\n\tif (addr_size == 1) /* 32 bit */\n\t\toff &= 0xffffffff;\n\telse if (addr_size == 0) /* 16 bit */\n\t\toff &= 0xffff;\n\n\t/* Checks for #GP/#SS exceptions. */\n\texn = false;\n\tif (is_long_mode(vcpu)) {\n\t\t/*\n\t\t * The virtual/linear address is never truncated in 64-bit\n\t\t * mode, e.g. a 32-bit address size can yield a 64-bit virtual\n\t\t * address when using FS/GS with a non-zero base.\n\t\t */\n\t\tif (seg_reg == VCPU_SREG_FS || seg_reg == VCPU_SREG_GS)\n\t\t\t*ret = s.base + off;\n\t\telse\n\t\t\t*ret = off;\n\n\t\t/* Long mode: #GP(0)/#SS(0) if the memory address is in a\n\t\t * non-canonical form. This is the only check on the memory\n\t\t * destination for long mode!\n\t\t */\n\t\texn = is_noncanonical_address(*ret, vcpu);\n\t} else {\n\t\t/*\n\t\t * When not in long mode, the virtual/linear address is\n\t\t * unconditionally truncated to 32 bits regardless of the\n\t\t * address size.\n\t\t */\n\t\t*ret = (s.base + off) & 0xffffffff;\n\n\t\t/* Protected mode: apply checks for segment validity in the\n\t\t * following order:\n\t\t * - segment type check (#GP(0) may be thrown)\n\t\t * - usability check (#GP(0)/#SS(0))\n\t\t * - limit check (#GP(0)/#SS(0))\n\t\t */\n\t\tif (wr)\n\t\t\t/* #GP(0) if the destination operand is located in a\n\t\t\t * read-only data segment or any code segment.\n\t\t\t */\n\t\t\texn = ((s.type & 0xa) == 0 || (s.type & 8));\n\t\telse\n\t\t\t/* #GP(0) if the source operand is located in an\n\t\t\t * execute-only code segment\n\t\t\t */\n\t\t\texn = ((s.type & 0xa) == 8);\n\t\tif (exn) {\n\t\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Protected mode: #GP(0)/#SS(0) if the segment is unusable.\n\t\t */\n\t\texn = (s.unusable != 0);\n\n\t\t/*\n\t\t * Protected mode: #GP(0)/#SS(0) if the memory operand is\n\t\t * outside the segment limit.  All CPUs that support VMX ignore\n\t\t * limit checks for flat segments, i.e. segments with base==0,\n\t\t * limit==0xffffffff and of type expand-up data or code.\n\t\t */\n\t\tif (!(s.base == 0 && s.limit == 0xffffffff &&\n\t\t     ((s.type & 8) || !(s.type & 4))))\n\t\t\texn = exn || ((u64)off + len - 1 > s.limit);\n\t}\n\tif (exn) {\n\t\tkvm_queue_exception_e(vcpu,\n\t\t\t\t      seg_reg == VCPU_SREG_SS ?\n\t\t\t\t\t\tSS_VECTOR : GP_VECTOR,\n\t\t\t\t      0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nint get_vmx_mem_address(struct kvm_vcpu *vcpu, unsigned long exit_qualification,\n\t\t\tu32 vmx_instruction_info, bool wr, int len, gva_t *ret)\n{\n\tgva_t off;\n\tbool exn;\n\tstruct kvm_segment s;\n\n\t/*\n\t * According to Vol. 3B, \"Information for VM Exits Due to Instruction\n\t * Execution\", on an exit, vmx_instruction_info holds most of the\n\t * addressing components of the operand. Only the displacement part\n\t * is put in exit_qualification (see 3B, \"Basic VM-Exit Information\").\n\t * For how an actual address is calculated from all these components,\n\t * refer to Vol. 1, \"Operand Addressing\".\n\t */\n\tint  scaling = vmx_instruction_info & 3;\n\tint  addr_size = (vmx_instruction_info >> 7) & 7;\n\tbool is_reg = vmx_instruction_info & (1u << 10);\n\tint  seg_reg = (vmx_instruction_info >> 15) & 7;\n\tint  index_reg = (vmx_instruction_info >> 18) & 0xf;\n\tbool index_is_valid = !(vmx_instruction_info & (1u << 22));\n\tint  base_reg       = (vmx_instruction_info >> 23) & 0xf;\n\tbool base_is_valid  = !(vmx_instruction_info & (1u << 27));\n\n\tif (is_reg) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\t/* Addr = segment_base + offset */\n\t/* offset = base + [index * scale] + displacement */\n\toff = exit_qualification; /* holds the displacement */\n\tif (addr_size == 1)\n\t\toff = (gva_t)sign_extend64(off, 31);\n\telse if (addr_size == 0)\n\t\toff = (gva_t)sign_extend64(off, 15);\n\tif (base_is_valid)\n\t\toff += kvm_register_read(vcpu, base_reg);\n\tif (index_is_valid)\n\t\toff += kvm_register_read(vcpu, index_reg) << scaling;\n\tvmx_get_segment(vcpu, &s, seg_reg);\n\n\t/*\n\t * The effective address, i.e. @off, of a memory operand is truncated\n\t * based on the address size of the instruction.  Note that this is\n\t * the *effective address*, i.e. the address prior to accounting for\n\t * the segment's base.\n\t */\n\tif (addr_size == 1) /* 32 bit */\n\t\toff &= 0xffffffff;\n\telse if (addr_size == 0) /* 16 bit */\n\t\toff &= 0xffff;\n\n\t/* Checks for #GP/#SS exceptions. */\n\texn = false;\n\tif (is_long_mode(vcpu)) {\n\t\t/*\n\t\t * The virtual/linear address is never truncated in 64-bit\n\t\t * mode, e.g. a 32-bit address size can yield a 64-bit virtual\n\t\t * address when using FS/GS with a non-zero base.\n\t\t */\n\t\tif (seg_reg == VCPU_SREG_FS || seg_reg == VCPU_SREG_GS)\n\t\t\t*ret = s.base + off;\n\t\telse\n\t\t\t*ret = off;\n\n\t\t/* Long mode: #GP(0)/#SS(0) if the memory address is in a\n\t\t * non-canonical form. This is the only check on the memory\n\t\t * destination for long mode!\n\t\t */\n\t\texn = is_noncanonical_address(*ret, vcpu);\n\t} else {\n\t\t/*\n\t\t * When not in long mode, the virtual/linear address is\n\t\t * unconditionally truncated to 32 bits regardless of the\n\t\t * address size.\n\t\t */\n\t\t*ret = (s.base + off) & 0xffffffff;\n\n\t\t/* Protected mode: apply checks for segment validity in the\n\t\t * following order:\n\t\t * - segment type check (#GP(0) may be thrown)\n\t\t * - usability check (#GP(0)/#SS(0))\n\t\t * - limit check (#GP(0)/#SS(0))\n\t\t */\n\t\tif (wr)\n\t\t\t/* #GP(0) if the destination operand is located in a\n\t\t\t * read-only data segment or any code segment.\n\t\t\t */\n\t\t\texn = ((s.type & 0xa) == 0 || (s.type & 8));\n\t\telse\n\t\t\t/* #GP(0) if the source operand is located in an\n\t\t\t * execute-only code segment\n\t\t\t */\n\t\t\texn = ((s.type & 0xa) == 8);\n\t\tif (exn) {\n\t\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\t\treturn 1;\n\t\t}\n\t\t/* Protected mode: #GP(0)/#SS(0) if the segment is unusable.\n\t\t */\n\t\texn = (s.unusable != 0);\n\n\t\t/*\n\t\t * Protected mode: #GP(0)/#SS(0) if the memory operand is\n\t\t * outside the segment limit.  All CPUs that support VMX ignore\n\t\t * limit checks for flat segments, i.e. segments with base==0,\n\t\t * limit==0xffffffff and of type expand-up data or code.\n\t\t */\n\t\tif (!(s.base == 0 && s.limit == 0xffffffff &&\n\t\t     ((s.type & 8) || !(s.type & 4))))\n\t\t\texn = exn || ((u64)off + len - 1 > s.limit);\n\t}\n\tif (exn) {\n\t\tkvm_queue_exception_e(vcpu,\n\t\t\t\t      seg_reg == VCPU_SREG_SS ?\n\t\t\t\t\t\tSS_VECTOR : GP_VECTOR,\n\t\t\t\t      0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 5394
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 5387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_register_readl",
          "args": [
            "vcpu",
            "(vmx_instruction_info >> 28) & 0xf"
          ],
          "line": 5384
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "218-223",
          "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu, int reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu, int reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "VMX_INSTRUCTION_INFO"
          ],
          "line": 5383
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "UD_VECTOR"
          ],
          "line": 5379
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_INVPCID"
          ],
          "line": 5378
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic int handle_invpcid(struct kvm_vcpu *vcpu)\n{\n\tu32 vmx_instruction_info;\n\tunsigned long type;\n\tbool pcid_enabled;\n\tgva_t gva;\n\tstruct x86_exception e;\n\tunsigned i;\n\tunsigned long roots_to_free = 0;\n\tstruct {\n\t\tu64 pcid;\n\t\tu64 gla;\n\t} operand;\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_INVPCID)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tvmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n\ttype = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n\n\tif (type > 3) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\t/* According to the Intel instruction reference, the memory operand\n\t * is read even if it isn't needed (e.g., for type==all)\n\t */\n\tif (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n\t\t\t\tvmx_instruction_info, false,\n\t\t\t\tsizeof(operand), &gva))\n\t\treturn 1;\n\n\tif (kvm_read_guest_virt(vcpu, gva, &operand, sizeof(operand), &e)) {\n\t\tkvm_inject_page_fault(vcpu, &e);\n\t\treturn 1;\n\t}\n\n\tif (operand.pcid >> 12 != 0) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tpcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);\n\n\tswitch (type) {\n\tcase INVPCID_TYPE_INDIV_ADDR:\n\t\tif ((!pcid_enabled && (operand.pcid != 0)) ||\n\t\t    is_noncanonical_address(operand.gla, vcpu)) {\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_mmu_invpcid_gva(vcpu, operand.gla, operand.pcid);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tcase INVPCID_TYPE_SINGLE_CTXT:\n\t\tif (!pcid_enabled && (operand.pcid != 0)) {\n\t\t\tkvm_inject_gp(vcpu, 0);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (kvm_get_active_pcid(vcpu) == operand.pcid) {\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tif (kvm_get_pcid(vcpu, vcpu->arch.mmu->prev_roots[i].cr3)\n\t\t\t    == operand.pcid)\n\t\t\t\troots_to_free |= KVM_MMU_ROOT_PREVIOUS(i);\n\n\t\tkvm_mmu_free_roots(vcpu, vcpu->arch.mmu, roots_to_free);\n\t\t/*\n\t\t * If neither the current cr3 nor any of the prev_roots use the\n\t\t * given PCID, then nothing needs to be done here because a\n\t\t * resync will happen anyway before switching to any other CR3.\n\t\t */\n\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tcase INVPCID_TYPE_ALL_NON_GLOBAL:\n\t\t/*\n\t\t * Currently, KVM doesn't mark global entries in the shadow\n\t\t * page tables, so a non-global flush just degenerates to a\n\t\t * global flush. If needed, we could optimize this later by\n\t\t * keeping track of global entries in shadow page tables.\n\t\t */\n\n\t\t/* fall-through */\n\tcase INVPCID_TYPE_ALL_INCL_GLOBAL:\n\t\tkvm_mmu_unload(vcpu);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\tdefault:\n\t\tBUG(); /* We have already checked above that type <= 3 */\n\t}\n}"
  },
  {
    "function_name": "handle_monitor",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5358-5362",
    "snippet": "static int handle_monitor(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_nop",
          "args": [
            "vcpu"
          ],
          "line": 5361
        },
        "resolved": true,
        "details": {
          "function_name": "handle_nop",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5336-5339",
          "snippet": "static int handle_nop(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_nop(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\""
          ],
          "line": 5360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_monitor(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}"
  },
  {
    "function_name": "handle_monitor_trap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5353-5356",
    "snippet": "static int handle_monitor_trap(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_monitor_trap(struct kvm_vcpu *vcpu)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_invalid_op",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5347-5351",
    "snippet": "static int handle_invalid_op(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "UD_VECTOR"
          ],
          "line": 5349
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_invalid_op(struct kvm_vcpu *vcpu)\n{\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_mwait",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5341-5345",
    "snippet": "static int handle_mwait(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_nop",
          "args": [
            "vcpu"
          ],
          "line": 5344
        },
        "resolved": true,
        "details": {
          "function_name": "handle_nop",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5336-5339",
          "snippet": "static int handle_nop(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_nop(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\""
          ],
          "line": 5343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_mwait(struct kvm_vcpu *vcpu)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn handle_nop(vcpu);\n}"
  },
  {
    "function_name": "handle_nop",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5336-5339",
    "snippet": "static int handle_nop(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 5338
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_nop(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
  },
  {
    "function_name": "handle_pause",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5321-5334",
    "snippet": "static int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_pause_in_guest(vcpu->kvm))\n\t\tgrow_ple_window(vcpu);\n\n\t/*\n\t * Intel sdm vol3 ch-25.1.3 says: The \"PAUSE-loop exiting\"\n\t * VM-execution control is ignored if CPL > 0. OTOH, KVM\n\t * never set PAUSE_EXITING and just set PLE if supported,\n\t * so the vcpu must be CPL=0 if it gets a PAUSE exit.\n\t */\n\tkvm_vcpu_on_spin(vcpu, true);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 5333
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_on_spin",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 5332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grow_ple_window",
          "args": [
            "vcpu"
          ],
          "line": 5324
        },
        "resolved": true,
        "details": {
          "function_name": "grow_ple_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "5254-5268",
          "snippet": "static void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __grow_ple_window(old, ple_window,\n\t\t\t\t\t    ple_window_grow,\n\t\t\t\t\t    ple_window_max);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;",
            "static unsigned int ple_window_grow = KVM_DEFAULT_PLE_WINDOW_GROW;",
            "static unsigned int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nstatic unsigned int ple_window_grow = KVM_DEFAULT_PLE_WINDOW_GROW;\nstatic unsigned int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __grow_ple_window(old, ple_window,\n\t\t\t\t\t    ple_window_grow,\n\t\t\t\t\t    ple_window_max);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pause_in_guest",
          "args": [
            "vcpu->kvm"
          ],
          "line": 5323
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pause_in_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "321-324",
          "snippet": "static inline bool kvm_pause_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.pause_in_guest;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_pause_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.pause_in_guest;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_pause(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_pause_in_guest(vcpu->kvm))\n\t\tgrow_ple_window(vcpu);\n\n\t/*\n\t * Intel sdm vol3 ch-25.1.3 says: The \"PAUSE-loop exiting\"\n\t * VM-execution control is ignored if CPL > 0. OTOH, KVM\n\t * never set PAUSE_EXITING and just set PLE if supported,\n\t * so the vcpu must be CPL=0 if it gets a PAUSE exit.\n\t */\n\tkvm_vcpu_on_spin(vcpu, true);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
  },
  {
    "function_name": "vmx_enable_tdp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5305-5315",
    "snippet": "static void vmx_enable_tdp(void)\n{\n\tkvm_mmu_set_mask_ptes(VMX_EPT_READABLE_MASK,\n\t\tenable_ept_ad_bits ? VMX_EPT_ACCESS_BIT : 0ull,\n\t\tenable_ept_ad_bits ? VMX_EPT_DIRTY_BIT : 0ull,\n\t\t0ull, VMX_EPT_EXECUTABLE_MASK,\n\t\tcpu_has_vmx_ept_execute_only() ? 0ull : VMX_EPT_READABLE_MASK,\n\t\tVMX_EPT_RWX_MASK, 0ull);\n\n\tept_set_mmio_spte_mask();\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ept_set_mmio_spte_mask",
          "args": [],
          "line": 5314
        },
        "resolved": true,
        "details": {
          "function_name": "ept_set_mmio_spte_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4149-4157",
          "snippet": "static void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t */\n\tkvm_mmu_set_mmio_spte_mask(VMX_EPT_RWX_MASK,\n\t\t\t\t   VMX_EPT_MISCONFIG_WX_VALUE, 0);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t */\n\tkvm_mmu_set_mmio_spte_mask(VMX_EPT_RWX_MASK,\n\t\t\t\t   VMX_EPT_MISCONFIG_WX_VALUE, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_set_mask_ptes",
          "args": [
            "VMX_EPT_READABLE_MASK",
            "enable_ept_ad_bits ? VMX_EPT_ACCESS_BIT : 0ull",
            "enable_ept_ad_bits ? VMX_EPT_DIRTY_BIT : 0ull",
            "0ull",
            "VMX_EPT_EXECUTABLE_MASK",
            "cpu_has_vmx_ept_execute_only() ? 0ull : VMX_EPT_READABLE_MASK",
            "VMX_EPT_RWX_MASK",
            "0ull"
          ],
          "line": 5307
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_set_mask_ptes",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "522-538",
          "snippet": "void kvm_mmu_set_mask_ptes(u64 user_mask, u64 accessed_mask,\n\t\tu64 dirty_mask, u64 nx_mask, u64 x_mask, u64 p_mask,\n\t\tu64 acc_track_mask, u64 me_mask)\n{\n\tBUG_ON(!dirty_mask != !accessed_mask);\n\tBUG_ON(!accessed_mask && !acc_track_mask);\n\tBUG_ON(acc_track_mask & SPTE_SPECIAL_MASK);\n\n\tshadow_user_mask = user_mask;\n\tshadow_accessed_mask = accessed_mask;\n\tshadow_dirty_mask = dirty_mask;\n\tshadow_nx_mask = nx_mask;\n\tshadow_x_mask = x_mask;\n\tshadow_present_mask = p_mask;\n\tshadow_acc_track_mask = acc_track_mask;\n\tshadow_me_mask = me_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nvoid kvm_mmu_set_mask_ptes(u64 user_mask, u64 accessed_mask,\n\t\tu64 dirty_mask, u64 nx_mask, u64 x_mask, u64 p_mask,\n\t\tu64 acc_track_mask, u64 me_mask)\n{\n\tBUG_ON(!dirty_mask != !accessed_mask);\n\tBUG_ON(!accessed_mask && !acc_track_mask);\n\tBUG_ON(acc_track_mask & SPTE_SPECIAL_MASK);\n\n\tshadow_user_mask = user_mask;\n\tshadow_accessed_mask = accessed_mask;\n\tshadow_dirty_mask = dirty_mask;\n\tshadow_nx_mask = nx_mask;\n\tshadow_x_mask = x_mask;\n\tshadow_present_mask = p_mask;\n\tshadow_acc_track_mask = acc_track_mask;\n\tshadow_me_mask = me_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_ept_execute_only",
          "args": [],
          "line": 5311
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_ept_execute_only",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "276-279",
          "snippet": "static inline bool cpu_has_vmx_ept_execute_only(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXECUTE_ONLY_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_ept_execute_only(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXECUTE_ONLY_BIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_enable_tdp(void)\n{\n\tkvm_mmu_set_mask_ptes(VMX_EPT_READABLE_MASK,\n\t\tenable_ept_ad_bits ? VMX_EPT_ACCESS_BIT : 0ull,\n\t\tenable_ept_ad_bits ? VMX_EPT_DIRTY_BIT : 0ull,\n\t\t0ull, VMX_EPT_EXECUTABLE_MASK,\n\t\tcpu_has_vmx_ept_execute_only() ? 0ull : VMX_EPT_READABLE_MASK,\n\t\tVMX_EPT_RWX_MASK, 0ull);\n\n\tept_set_mmio_spte_mask();\n}"
  },
  {
    "function_name": "wakeup_handler",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5289-5303",
    "snippet": "static void wakeup_handler(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint cpu = smp_processor_id();\n\n\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n\tlist_for_each_entry(vcpu, &per_cpu(blocked_vcpu_on_cpu, cpu),\n\t\t\tblocked_vcpu_list) {\n\t\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\t\tif (pi_test_on(pi_desc) == 1)\n\t\t\tkvm_vcpu_kick(vcpu);\n\t}\n\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);",
      "static DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&per_cpu(blocked_vcpu_on_cpu_lock, cpu)"
          ],
          "line": 5302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "blocked_vcpu_on_cpu_lock",
            "cpu"
          ],
          "line": 5302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 5300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pi_test_on",
          "args": [
            "pi_desc"
          ],
          "line": 5299
        },
        "resolved": true,
        "details": {
          "function_name": "pi_test_on",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "401-405",
          "snippet": "static inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_ON  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_ON  0\n\nstatic inline int pi_test_on(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pi_desc",
          "args": [
            "vcpu"
          ],
          "line": 5297
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_pi_desc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "484-487",
          "snippet": "static inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "vcpu",
            "&per_cpu(blocked_vcpu_on_cpu, cpu)",
            "blocked_vcpu_list"
          ],
          "line": 5295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "blocked_vcpu_on_cpu",
            "cpu"
          ],
          "line": 5295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&per_cpu(blocked_vcpu_on_cpu_lock, cpu)"
          ],
          "line": 5294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "blocked_vcpu_on_cpu_lock",
            "cpu"
          ],
          "line": 5294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 5292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);\nstatic DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);\n\nstatic void wakeup_handler(void)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint cpu = smp_processor_id();\n\n\tspin_lock(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n\tlist_for_each_entry(vcpu, &per_cpu(blocked_vcpu_on_cpu, cpu),\n\t\t\tblocked_vcpu_list) {\n\t\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\t\tif (pi_test_on(pi_desc) == 1)\n\t\t\tkvm_vcpu_kick(vcpu);\n\t}\n\tspin_unlock(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n}"
  },
  {
    "function_name": "shrink_ple_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5270-5284",
    "snippet": "static void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old, ple_window,\n\t\t\t\t\t      ple_window_shrink,\n\t\t\t\t\t      ple_window);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;",
      "static unsigned int ple_window_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_ple_window_update",
          "args": [
            "vcpu->vcpu_id",
            "vmx->ple_window",
            "old"
          ],
          "line": 5281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__shrink_ple_window",
          "args": [
            "old",
            "ple_window",
            "ple_window_shrink",
            "ple_window"
          ],
          "line": 5275
        },
        "resolved": true,
        "details": {
          "function_name": "__shrink_ple_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "34-46",
          "snippet": "static inline unsigned int __shrink_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int min)\n{\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tval /= modifier;\n\telse\n\t\tval -= modifier;\n\n\treturn max(val, min);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline unsigned int __shrink_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int min)\n{\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tval /= modifier;\n\telse\n\t\tval -= modifier;\n\n\treturn max(val, min);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 5272
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nstatic unsigned int ple_window_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __shrink_ple_window(old, ple_window,\n\t\t\t\t\t      ple_window_shrink,\n\t\t\t\t\t      ple_window);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}"
  },
  {
    "function_name": "grow_ple_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5254-5268",
    "snippet": "static void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __grow_ple_window(old, ple_window,\n\t\t\t\t\t    ple_window_grow,\n\t\t\t\t\t    ple_window_max);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;",
      "static unsigned int ple_window_grow = KVM_DEFAULT_PLE_WINDOW_GROW;",
      "static unsigned int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_ple_window_update",
          "args": [
            "vcpu->vcpu_id",
            "vmx->ple_window",
            "old"
          ],
          "line": 5265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__grow_ple_window",
          "args": [
            "old",
            "ple_window",
            "ple_window_grow",
            "ple_window_max"
          ],
          "line": 5259
        },
        "resolved": true,
        "details": {
          "function_name": "__grow_ple_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "18-32",
          "snippet": "static inline unsigned int __grow_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int max)\n{\n\tu64 ret = val;\n\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tret *= modifier;\n\telse\n\t\tret += modifier;\n\n\treturn min(ret, (u64)max);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline unsigned int __grow_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int max)\n{\n\tu64 ret = val;\n\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tret *= modifier;\n\telse\n\t\tret += modifier;\n\n\treturn min(ret, (u64)max);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 5256
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nstatic unsigned int ple_window_grow = KVM_DEFAULT_PLE_WINDOW_GROW;\nstatic unsigned int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned int old = vmx->ple_window;\n\n\tvmx->ple_window = __grow_ple_window(old, ple_window,\n\t\t\t\t\t    ple_window_grow,\n\t\t\t\t\t    ple_window_max);\n\n\tif (vmx->ple_window != old) {\n\t\tvmx->ple_window_dirty = true;\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    vmx->ple_window, old);\n\t}\n}"
  },
  {
    "function_name": "handle_invalid_guest_state",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5200-5252",
    "snippet": "static int handle_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool intr_window_requested;\n\tunsigned count = 130;\n\n\t/*\n\t * We should never reach the point where we are emulating L2\n\t * due to invalid guest state as that means we incorrectly\n\t * allowed a nested VMEntry with an invalid vmcs12.\n\t */\n\tWARN_ON_ONCE(vmx->emulation_required && vmx->nested.nested_run_pending);\n\n\tintr_window_requested = exec_controls_get(vmx) &\n\t\t\t\tCPU_BASED_INTR_WINDOW_EXITING;\n\n\twhile (vmx->emulation_required && count-- != 0) {\n\t\tif (intr_window_requested && vmx_interrupt_allowed(vcpu))\n\t\t\treturn handle_interrupt_window(&vmx->vcpu);\n\n\t\tif (kvm_test_request(KVM_REQ_EVENT, vcpu))\n\t\t\treturn 1;\n\n\t\tif (!kvm_emulate_instruction(vcpu, 0))\n\t\t\treturn 0;\n\n\t\tif (vmx->emulation_required && !vmx->rmode.vm86_active &&\n\t\t    vcpu->arch.exception.pending) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\t\tvcpu->run->internal.suberror =\n\t\t\t\t\t\tKVM_INTERNAL_ERROR_EMULATION;\n\t\t\tvcpu->run->internal.ndata = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (vcpu->arch.halt_request) {\n\t\t\tvcpu->arch.halt_request = 0;\n\t\t\treturn kvm_vcpu_halt(vcpu);\n\t\t}\n\n\t\t/*\n\t\t * Note, return 1 and not 0, vcpu_run() is responsible for\n\t\t * morphing the pending signal into the proper return code.\n\t\t */\n\t\tif (signal_pending(current))\n\t\t\treturn 1;\n\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 5248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 5247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 5244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_halt",
          "args": [
            "vcpu"
          ],
          "line": 5237
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_halt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7422-7432",
          "snippet": "int kvm_vcpu_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (lapic_in_kernel(vcpu)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_vcpu_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (lapic_in_kernel(vcpu)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 5223
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_test_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 5220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_interrupt_window",
          "args": [
            "&vmx->vcpu"
          ],
          "line": 5218
        },
        "resolved": true,
        "details": {
          "function_name": "handle_interrupt_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4978-4986",
          "snippet": "static int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_interrupt_allowed",
          "args": [
            "vcpu"
          ],
          "line": 5217
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_interrupt_allowed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4475-4486",
          "snippet": "static int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn false;\n\n\tif (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn true;\n\n\treturn (vmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn false;\n\n\tif (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn true;\n\n\treturn (vmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "exec_controls_get",
          "args": [
            "vmx"
          ],
          "line": 5213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "vmx->emulation_required && vmx->nested.nested_run_pending"
          ],
          "line": 5211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 5202
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_invalid_guest_state(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool intr_window_requested;\n\tunsigned count = 130;\n\n\t/*\n\t * We should never reach the point where we are emulating L2\n\t * due to invalid guest state as that means we incorrectly\n\t * allowed a nested VMEntry with an invalid vmcs12.\n\t */\n\tWARN_ON_ONCE(vmx->emulation_required && vmx->nested.nested_run_pending);\n\n\tintr_window_requested = exec_controls_get(vmx) &\n\t\t\t\tCPU_BASED_INTR_WINDOW_EXITING;\n\n\twhile (vmx->emulation_required && count-- != 0) {\n\t\tif (intr_window_requested && vmx_interrupt_allowed(vcpu))\n\t\t\treturn handle_interrupt_window(&vmx->vcpu);\n\n\t\tif (kvm_test_request(KVM_REQ_EVENT, vcpu))\n\t\t\treturn 1;\n\n\t\tif (!kvm_emulate_instruction(vcpu, 0))\n\t\t\treturn 0;\n\n\t\tif (vmx->emulation_required && !vmx->rmode.vm86_active &&\n\t\t    vcpu->arch.exception.pending) {\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\t\tvcpu->run->internal.suberror =\n\t\t\t\t\t\tKVM_INTERNAL_ERROR_EMULATION;\n\t\t\tvcpu->run->internal.ndata = 0;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (vcpu->arch.halt_request) {\n\t\t\tvcpu->arch.halt_request = 0;\n\t\t\treturn kvm_vcpu_halt(vcpu);\n\t\t}\n\n\t\t/*\n\t\t * Note, return 1 and not 0, vcpu_run() is responsible for\n\t\t * morphing the pending signal into the proper return code.\n\t\t */\n\t\tif (signal_pending(current))\n\t\t\treturn 1;\n\n\t\tif (need_resched())\n\t\t\tschedule();\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_nmi_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5190-5198",
    "snippet": "static int handle_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON_ONCE(!enable_vnmi);\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_NMI_WINDOW_EXITING);\n\t++vcpu->stat.nmi_window_exits;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 5195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exec_controls_clearbit",
          "args": [
            "to_vmx(vcpu)",
            "CPU_BASED_NMI_WINDOW_EXITING"
          ],
          "line": 5193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 5193
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!enable_vnmi"
          ],
          "line": 5192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON_ONCE(!enable_vnmi);\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_NMI_WINDOW_EXITING);\n\t++vcpu->stat.nmi_window_exits;\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_ept_misconfig",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5172-5188",
    "snippet": "static int handle_ept_misconfig(struct kvm_vcpu *vcpu)\n{\n\tgpa_t gpa;\n\n\t/*\n\t * A nested guest cannot optimize MMIO vmexits, because we have an\n\t * nGPA here instead of the required GPA.\n\t */\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\tif (!is_guest_mode(vcpu) &&\n\t    !kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {\n\t\ttrace_kvm_fast_mmio(gpa);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, PFERR_RSVD_MASK, NULL, 0);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_page_fault",
          "args": [
            "vcpu",
            "gpa",
            "PFERR_RSVD_MASK",
            "NULL",
            "0"
          ],
          "line": 5187
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5429-5497",
          "snippet": "int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_PF;\n\tbool direct = vcpu->arch.mmu->direct_map;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tr = RET_PF_INVALID;\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);\n\t\tif (r == RET_PF_EMULATE)\n\t\t\tgoto emulate;\n\t}\n\n\tif (r == RET_PF_INVALID) {\n\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,\n\t\t\t\t\t  lower_32_bits(error_code), false);\n\t\tWARN_ON(r == RET_PF_INVALID);\n\t}\n\n\tif (r == RET_PF_RETRY)\n\t\treturn 1;\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * Before emulating the instruction, check if the error code\n\t * was due to a RO violation while translating the guest page.\n\t * This can occur when using nested virtualization with nested\n\t * paging in both guests. If true, we simply unprotect the page\n\t * and resume the guest.\n\t */\n\tif (vcpu->arch.mmu->direct_map &&\n\t    (error_code & PFERR_NESTED_GUEST_PAGE) == PFERR_NESTED_GUEST_PAGE) {\n\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(cr2_or_gpa));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * vcpu->arch.mmu.page_fault returned RET_PF_EMULATE, but we can still\n\t * optimistically try to just unprotect the page and let the processor\n\t * re-execute the instruction that caused the page fault.  Do not allow\n\t * retrying MMIO emulation, as it's not only pointless but could also\n\t * cause us to enter an infinite loop because the processor will keep\n\t * faulting on the non-existent MMIO address.  Retrying an instruction\n\t * from a nested guest is also pointless and dangerous as we are only\n\t * explicitly shadowing L1's page tables, i.e. unprotecting something\n\t * for L1 isn't going to magically fix whatever issue cause L2 to fail.\n\t */\n\tif (!mmio_info_in_cache(vcpu, cr2_or_gpa, direct) && !is_guest_mode(vcpu))\n\t\temulation_type |= EMULTYPE_ALLOW_RETRY_PF;\nemulate:\n\t/*\n\t * On AMD platforms, under certain conditions insn_len may be zero on #NPF.\n\t * This can happen if a guest gets a page-fault on data access but the HW\n\t * table walker is not able to read the instruction page (e.g instruction\n\t * page is not present in memory). In those cases we simply restart the\n\t * guest, with the exception of AMD Erratum 1096 which is unrecoverable.\n\t */\n\tif (unlikely(insn && !insn_len)) {\n\t\tif (!kvm_x86_ops.need_emulation_on_page_fault(vcpu))\n\t\t\treturn 1;\n\t}\n\n\treturn x86_emulate_instruction(vcpu, cr2_or_gpa, emulation_type, insn,\n\t\t\t\t       insn_len);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_PF;\n\tbool direct = vcpu->arch.mmu->direct_map;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tr = RET_PF_INVALID;\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);\n\t\tif (r == RET_PF_EMULATE)\n\t\t\tgoto emulate;\n\t}\n\n\tif (r == RET_PF_INVALID) {\n\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,\n\t\t\t\t\t  lower_32_bits(error_code), false);\n\t\tWARN_ON(r == RET_PF_INVALID);\n\t}\n\n\tif (r == RET_PF_RETRY)\n\t\treturn 1;\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * Before emulating the instruction, check if the error code\n\t * was due to a RO violation while translating the guest page.\n\t * This can occur when using nested virtualization with nested\n\t * paging in both guests. If true, we simply unprotect the page\n\t * and resume the guest.\n\t */\n\tif (vcpu->arch.mmu->direct_map &&\n\t    (error_code & PFERR_NESTED_GUEST_PAGE) == PFERR_NESTED_GUEST_PAGE) {\n\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(cr2_or_gpa));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * vcpu->arch.mmu.page_fault returned RET_PF_EMULATE, but we can still\n\t * optimistically try to just unprotect the page and let the processor\n\t * re-execute the instruction that caused the page fault.  Do not allow\n\t * retrying MMIO emulation, as it's not only pointless but could also\n\t * cause us to enter an infinite loop because the processor will keep\n\t * faulting on the non-existent MMIO address.  Retrying an instruction\n\t * from a nested guest is also pointless and dangerous as we are only\n\t * explicitly shadowing L1's page tables, i.e. unprotecting something\n\t * for L1 isn't going to magically fix whatever issue cause L2 to fail.\n\t */\n\tif (!mmio_info_in_cache(vcpu, cr2_or_gpa, direct) && !is_guest_mode(vcpu))\n\t\temulation_type |= EMULTYPE_ALLOW_RETRY_PF;\nemulate:\n\t/*\n\t * On AMD platforms, under certain conditions insn_len may be zero on #NPF.\n\t * This can happen if a guest gets a page-fault on data access but the HW\n\t * table walker is not able to read the instruction page (e.g instruction\n\t * page is not present in memory). In those cases we simply restart the\n\t * guest, with the exception of AMD Erratum 1096 which is unrecoverable.\n\t */\n\tif (unlikely(insn && !insn_len)) {\n\t\tif (!kvm_x86_ops.need_emulation_on_page_fault(vcpu))\n\t\t\treturn 1;\n\t}\n\n\treturn x86_emulate_instruction(vcpu, cr2_or_gpa, emulation_type, insn,\n\t\t\t\t       insn_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 5184
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_fast_mmio",
          "args": [
            "gpa"
          ],
          "line": 5183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_write",
          "args": [
            "vcpu",
            "KVM_FAST_MMIO_BUS",
            "gpa",
            "0",
            "NULL"
          ],
          "line": 5182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 5181
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read64",
          "args": [
            "GUEST_PHYSICAL_ADDRESS"
          ],
          "line": 5180
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "120-130",
          "snippet": "static __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_ept_misconfig(struct kvm_vcpu *vcpu)\n{\n\tgpa_t gpa;\n\n\t/*\n\t * A nested guest cannot optimize MMIO vmexits, because we have an\n\t * nGPA here instead of the required GPA.\n\t */\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\tif (!is_guest_mode(vcpu) &&\n\t    !kvm_io_bus_write(vcpu, KVM_FAST_MMIO_BUS, gpa, 0, NULL)) {\n\t\ttrace_kvm_fast_mmio(gpa);\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t}\n\n\treturn kvm_mmu_page_fault(vcpu, gpa, PFERR_RSVD_MASK, NULL, 0);\n}"
  },
  {
    "function_name": "handle_ept_violation",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5128-5170",
    "snippet": "static int handle_ept_violation(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tgpa_t gpa;\n\tu64 error_code;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\t/*\n\t * EPT violation happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t * There are errata that may cause this bit to not be set:\n\t * AAK134, BY25.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tenable_vnmi &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\ttrace_kvm_page_fault(gpa, exit_qualification);\n\n\t/* Is it a read fault? */\n\terror_code = (exit_qualification & EPT_VIOLATION_ACC_READ)\n\t\t     ? PFERR_USER_MASK : 0;\n\t/* Is it a write fault? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_ACC_WRITE)\n\t\t      ? PFERR_WRITE_MASK : 0;\n\t/* Is it a fetch fault? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_ACC_INSTR)\n\t\t      ? PFERR_FETCH_MASK : 0;\n\t/* ept page table entry is present? */\n\terror_code |= (exit_qualification &\n\t\t       (EPT_VIOLATION_READABLE | EPT_VIOLATION_WRITABLE |\n\t\t\tEPT_VIOLATION_EXECUTABLE))\n\t\t      ? PFERR_PRESENT_MASK : 0;\n\n\terror_code |= (exit_qualification & 0x100) != 0 ?\n\t       PFERR_GUEST_FINAL_MASK : PFERR_GUEST_PAGE_MASK;\n\n\tvcpu->arch.exit_qualification = exit_qualification;\n\treturn kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_page_fault",
          "args": [
            "vcpu",
            "gpa",
            "error_code",
            "NULL",
            "0"
          ],
          "line": 5169
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5429-5497",
          "snippet": "int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_PF;\n\tbool direct = vcpu->arch.mmu->direct_map;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tr = RET_PF_INVALID;\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);\n\t\tif (r == RET_PF_EMULATE)\n\t\t\tgoto emulate;\n\t}\n\n\tif (r == RET_PF_INVALID) {\n\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,\n\t\t\t\t\t  lower_32_bits(error_code), false);\n\t\tWARN_ON(r == RET_PF_INVALID);\n\t}\n\n\tif (r == RET_PF_RETRY)\n\t\treturn 1;\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * Before emulating the instruction, check if the error code\n\t * was due to a RO violation while translating the guest page.\n\t * This can occur when using nested virtualization with nested\n\t * paging in both guests. If true, we simply unprotect the page\n\t * and resume the guest.\n\t */\n\tif (vcpu->arch.mmu->direct_map &&\n\t    (error_code & PFERR_NESTED_GUEST_PAGE) == PFERR_NESTED_GUEST_PAGE) {\n\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(cr2_or_gpa));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * vcpu->arch.mmu.page_fault returned RET_PF_EMULATE, but we can still\n\t * optimistically try to just unprotect the page and let the processor\n\t * re-execute the instruction that caused the page fault.  Do not allow\n\t * retrying MMIO emulation, as it's not only pointless but could also\n\t * cause us to enter an infinite loop because the processor will keep\n\t * faulting on the non-existent MMIO address.  Retrying an instruction\n\t * from a nested guest is also pointless and dangerous as we are only\n\t * explicitly shadowing L1's page tables, i.e. unprotecting something\n\t * for L1 isn't going to magically fix whatever issue cause L2 to fail.\n\t */\n\tif (!mmio_info_in_cache(vcpu, cr2_or_gpa, direct) && !is_guest_mode(vcpu))\n\t\temulation_type |= EMULTYPE_ALLOW_RETRY_PF;\nemulate:\n\t/*\n\t * On AMD platforms, under certain conditions insn_len may be zero on #NPF.\n\t * This can happen if a guest gets a page-fault on data access but the HW\n\t * table walker is not able to read the instruction page (e.g instruction\n\t * page is not present in memory). In those cases we simply restart the\n\t * guest, with the exception of AMD Erratum 1096 which is unrecoverable.\n\t */\n\tif (unlikely(insn && !insn_len)) {\n\t\tif (!kvm_x86_ops.need_emulation_on_page_fault(vcpu))\n\t\t\treturn 1;\n\t}\n\n\treturn x86_emulate_instruction(vcpu, cr2_or_gpa, emulation_type, insn,\n\t\t\t\t       insn_len);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_PF;\n\tbool direct = vcpu->arch.mmu->direct_map;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tr = RET_PF_INVALID;\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);\n\t\tif (r == RET_PF_EMULATE)\n\t\t\tgoto emulate;\n\t}\n\n\tif (r == RET_PF_INVALID) {\n\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,\n\t\t\t\t\t  lower_32_bits(error_code), false);\n\t\tWARN_ON(r == RET_PF_INVALID);\n\t}\n\n\tif (r == RET_PF_RETRY)\n\t\treturn 1;\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * Before emulating the instruction, check if the error code\n\t * was due to a RO violation while translating the guest page.\n\t * This can occur when using nested virtualization with nested\n\t * paging in both guests. If true, we simply unprotect the page\n\t * and resume the guest.\n\t */\n\tif (vcpu->arch.mmu->direct_map &&\n\t    (error_code & PFERR_NESTED_GUEST_PAGE) == PFERR_NESTED_GUEST_PAGE) {\n\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(cr2_or_gpa));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * vcpu->arch.mmu.page_fault returned RET_PF_EMULATE, but we can still\n\t * optimistically try to just unprotect the page and let the processor\n\t * re-execute the instruction that caused the page fault.  Do not allow\n\t * retrying MMIO emulation, as it's not only pointless but could also\n\t * cause us to enter an infinite loop because the processor will keep\n\t * faulting on the non-existent MMIO address.  Retrying an instruction\n\t * from a nested guest is also pointless and dangerous as we are only\n\t * explicitly shadowing L1's page tables, i.e. unprotecting something\n\t * for L1 isn't going to magically fix whatever issue cause L2 to fail.\n\t */\n\tif (!mmio_info_in_cache(vcpu, cr2_or_gpa, direct) && !is_guest_mode(vcpu))\n\t\temulation_type |= EMULTYPE_ALLOW_RETRY_PF;\nemulate:\n\t/*\n\t * On AMD platforms, under certain conditions insn_len may be zero on #NPF.\n\t * This can happen if a guest gets a page-fault on data access but the HW\n\t * table walker is not able to read the instruction page (e.g instruction\n\t * page is not present in memory). In those cases we simply restart the\n\t * guest, with the exception of AMD Erratum 1096 which is unrecoverable.\n\t */\n\tif (unlikely(insn && !insn_len)) {\n\t\tif (!kvm_x86_ops.need_emulation_on_page_fault(vcpu))\n\t\t\treturn 1;\n\t}\n\n\treturn x86_emulate_instruction(vcpu, cr2_or_gpa, emulation_type, insn,\n\t\t\t\t       insn_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_page_fault",
          "args": [
            "gpa",
            "exit_qualification"
          ],
          "line": 5148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_read64",
          "args": [
            "GUEST_PHYSICAL_ADDRESS"
          ],
          "line": 5147
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "120-130",
          "snippet": "static __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_set_bits",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO",
            "GUEST_INTR_STATE_NMI"
          ],
          "line": 5145
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "224-232",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 5142
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 5134
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_ept_violation(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tgpa_t gpa;\n\tu64 error_code;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\t/*\n\t * EPT violation happened while executing iret from NMI,\n\t * \"blocked by NMI\" bit has to be set before next VM entry.\n\t * There are errata that may cause this bit to not be set:\n\t * AAK134, BY25.\n\t */\n\tif (!(to_vmx(vcpu)->idt_vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t\t\tenable_vnmi &&\n\t\t\t(exit_qualification & INTR_INFO_UNBLOCK_NMI))\n\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO, GUEST_INTR_STATE_NMI);\n\n\tgpa = vmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\ttrace_kvm_page_fault(gpa, exit_qualification);\n\n\t/* Is it a read fault? */\n\terror_code = (exit_qualification & EPT_VIOLATION_ACC_READ)\n\t\t     ? PFERR_USER_MASK : 0;\n\t/* Is it a write fault? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_ACC_WRITE)\n\t\t      ? PFERR_WRITE_MASK : 0;\n\t/* Is it a fetch fault? */\n\terror_code |= (exit_qualification & EPT_VIOLATION_ACC_INSTR)\n\t\t      ? PFERR_FETCH_MASK : 0;\n\t/* ept page table entry is present? */\n\terror_code |= (exit_qualification &\n\t\t       (EPT_VIOLATION_READABLE | EPT_VIOLATION_WRITABLE |\n\t\t\tEPT_VIOLATION_EXECUTABLE))\n\t\t      ? PFERR_PRESENT_MASK : 0;\n\n\terror_code |= (exit_qualification & 0x100) != 0 ?\n\t       PFERR_GUEST_FINAL_MASK : PFERR_GUEST_PAGE_MASK;\n\n\tvcpu->arch.exit_qualification = exit_qualification;\n\treturn kvm_mmu_page_fault(vcpu, gpa, error_code, NULL, 0);\n}"
  },
  {
    "function_name": "handle_task_switch",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5071-5126",
    "snippet": "static int handle_task_switch(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qualification;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\tu16 tss_selector;\n\tint reason, type, idt_v, idt_index;\n\n\tidt_v = (vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK);\n\tidt_index = (vmx->idt_vectoring_info & VECTORING_INFO_VECTOR_MASK);\n\ttype = (vmx->idt_vectoring_info & VECTORING_INFO_TYPE_MASK);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\treason = (u32)exit_qualification >> 30;\n\tif (reason == TASK_SWITCH_GATE && idt_v) {\n\t\tswitch (type) {\n\t\tcase INTR_TYPE_NMI_INTR:\n\t\t\tvcpu->arch.nmi_injected = false;\n\t\t\tvmx_set_nmi_mask(vcpu, true);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_EXT_INTR:\n\t\tcase INTR_TYPE_SOFT_INTR:\n\t\t\tkvm_clear_interrupt_queue(vcpu);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\t\tif (vmx->idt_vectoring_info &\n\t\t\t    VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\tvmcs_read32(IDT_VECTORING_ERROR_CODE);\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\t\tkvm_clear_exception_queue(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ttss_selector = exit_qualification;\n\n\tif (!idt_v || (type != INTR_TYPE_HARD_EXCEPTION &&\n\t\t       type != INTR_TYPE_EXT_INTR &&\n\t\t       type != INTR_TYPE_NMI_INTR))\n\t\tWARN_ON(!skip_emulated_instruction(vcpu));\n\n\t/*\n\t * TODO: What about debug traps on tss switch?\n\t *       Are we supposed to inject them and update dr6?\n\t */\n\treturn kvm_task_switch(vcpu, tss_selector,\n\t\t\t       type == INTR_TYPE_SOFT_INTR ? idt_index : -1,\n\t\t\t       reason, has_error_code, error_code);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_task_switch",
          "args": [
            "vcpu",
            "tss_selector",
            "type == INTR_TYPE_SOFT_INTR ? idt_index : -1",
            "reason",
            "has_error_code",
            "error_code"
          ],
          "line": 5123
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_task_switch",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8961-8981",
          "snippet": "int kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\tif (ret) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\tif (ret) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!skip_emulated_instruction(vcpu)"
          ],
          "line": 5117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 5117
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1604-1608",
          "snippet": "static int vmx_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tvmx_update_emulated_instruction(vcpu);\n\treturn skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tvmx_update_emulated_instruction(vcpu);\n\treturn skip_emulated_instruction(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_exception_queue",
          "args": [
            "vcpu"
          ],
          "line": 5106
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_exception_queue",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "50-54",
          "snippet": "static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n\tvcpu->arch.exception.injected = false;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n\tvcpu->arch.exception.injected = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "IDT_VECTORING_ERROR_CODE"
          ],
          "line": 5102
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_interrupt_queue",
          "args": [
            "vcpu"
          ],
          "line": 5095
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_interrupt_queue",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "64-67",
          "snippet": "static inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.injected = false;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.injected = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_set_nmi_mask",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 5091
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_nmi_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4441-4459",
          "snippet": "void vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->soft_vnmi_blocked != masked) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = masked;\n\t\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->soft_vnmi_blocked != masked) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = masked;\n\t\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 5084
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 5073
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic int handle_task_switch(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long exit_qualification;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\tu16 tss_selector;\n\tint reason, type, idt_v, idt_index;\n\n\tidt_v = (vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK);\n\tidt_index = (vmx->idt_vectoring_info & VECTORING_INFO_VECTOR_MASK);\n\ttype = (vmx->idt_vectoring_info & VECTORING_INFO_TYPE_MASK);\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\treason = (u32)exit_qualification >> 30;\n\tif (reason == TASK_SWITCH_GATE && idt_v) {\n\t\tswitch (type) {\n\t\tcase INTR_TYPE_NMI_INTR:\n\t\t\tvcpu->arch.nmi_injected = false;\n\t\t\tvmx_set_nmi_mask(vcpu, true);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_EXT_INTR:\n\t\tcase INTR_TYPE_SOFT_INTR:\n\t\t\tkvm_clear_interrupt_queue(vcpu);\n\t\t\tbreak;\n\t\tcase INTR_TYPE_HARD_EXCEPTION:\n\t\t\tif (vmx->idt_vectoring_info &\n\t\t\t    VECTORING_INFO_DELIVER_CODE_MASK) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\tvmcs_read32(IDT_VECTORING_ERROR_CODE);\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase INTR_TYPE_SOFT_EXCEPTION:\n\t\t\tkvm_clear_exception_queue(vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\ttss_selector = exit_qualification;\n\n\tif (!idt_v || (type != INTR_TYPE_HARD_EXCEPTION &&\n\t\t       type != INTR_TYPE_EXT_INTR &&\n\t\t       type != INTR_TYPE_NMI_INTR))\n\t\tWARN_ON(!skip_emulated_instruction(vcpu));\n\n\t/*\n\t * TODO: What about debug traps on tss switch?\n\t *       Are we supposed to inject them and update dr6?\n\t */\n\treturn kvm_task_switch(vcpu, tss_selector,\n\t\t\t       type == INTR_TYPE_SOFT_INTR ? idt_index : -1,\n\t\t\t       reason, has_error_code, error_code);\n}"
  },
  {
    "function_name": "handle_apic_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5061-5069",
    "snippet": "static int handle_apic_write(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 offset = exit_qualification & 0xfff;\n\n\t/* APIC-write VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_write_nodecode(vcpu, offset);\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_write_nodecode",
          "args": [
            "vcpu",
            "offset"
          ],
          "line": 5067
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_write_nodecode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2087-2098",
          "snippet": "void kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)\n{\n\tu32 val = 0;\n\n\t/* hw has done the conditional check and inst decode */\n\toffset &= 0xff0;\n\n\tkvm_lapic_reg_read(vcpu->arch.apic, offset, 4, &val);\n\n\t/* TODO: optimize to just emulate side effect w/o one more write */\n\tkvm_lapic_reg_write(vcpu->arch.apic, offset, val);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_write_nodecode(struct kvm_vcpu *vcpu, u32 offset)\n{\n\tu32 val = 0;\n\n\t/* hw has done the conditional check and inst decode */\n\toffset &= 0xff0;\n\n\tkvm_lapic_reg_read(vcpu->arch.apic, offset, 4, &val);\n\n\t/* TODO: optimize to just emulate side effect w/o one more write */\n\tkvm_lapic_reg_write(vcpu->arch.apic, offset, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 5063
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_apic_write(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tu32 offset = exit_qualification & 0xfff;\n\n\t/* APIC-write VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_write_nodecode(vcpu, offset);\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_apic_eoi_induced",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5051-5059",
    "snippet": "static int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint vector = exit_qualification & 0xff;\n\n\t/* EOI-induced VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_set_eoi_accelerated(vcpu, vector);\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_set_eoi_accelerated",
          "args": [
            "vcpu",
            "vector"
          ],
          "line": 5057
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_eoi_accelerated",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1233-1241",
          "snippet": "void kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\ttrace_kvm_eoi(apic, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_set_eoi_accelerated(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\ttrace_kvm_eoi(apic, vector);\n\n\tkvm_ioapic_send_eoi(apic, vector);\n\tkvm_make_request(KVM_REQ_EVENT, apic->vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 5053
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_apic_eoi_induced(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tint vector = exit_qualification & 0xff;\n\n\t/* EOI-induced VM exit is trap-like and thus no need to adjust IP */\n\tkvm_apic_set_eoi_accelerated(vcpu, vector);\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_apic_access",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5029-5049",
    "snippet": "static int handle_apic_access(struct kvm_vcpu *vcpu)\n{\n\tif (likely(fasteoi)) {\n\t\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\t\tint access_type, offset;\n\n\t\taccess_type = exit_qualification & APIC_ACCESS_TYPE;\n\t\toffset = exit_qualification & APIC_ACCESS_OFFSET;\n\t\t/*\n\t\t * Sane guest uses MOV to write EOI, with written value\n\t\t * not cared. So make a short-circuit here by avoiding\n\t\t * heavy instruction emulation.\n\t\t */\n\t\tif ((access_type == TYPE_LINEAR_APIC_INST_WRITE) &&\n\t\t    (offset == APIC_EOI)) {\n\t\t\tkvm_lapic_set_eoi(vcpu);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t}\n\treturn kvm_emulate_instruction(vcpu, 0);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly fasteoi = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 5048
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 5045
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_eoi",
          "args": [
            "vcpu"
          ],
          "line": 5044
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2080-2083",
          "snippet": "void kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_lapic_set_eoi(struct kvm_vcpu *vcpu)\n{\n\tkvm_lapic_reg_write(vcpu->arch.apic, APIC_EOI, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 5032
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "fasteoi"
          ],
          "line": 5031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly fasteoi = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_apic_access(struct kvm_vcpu *vcpu)\n{\n\tif (likely(fasteoi)) {\n\t\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\t\tint access_type, offset;\n\n\t\taccess_type = exit_qualification & APIC_ACCESS_TYPE;\n\t\toffset = exit_qualification & APIC_ACCESS_OFFSET;\n\t\t/*\n\t\t * Sane guest uses MOV to write EOI, with written value\n\t\t * not cared. So make a short-circuit here by avoiding\n\t\t * heavy instruction emulation.\n\t\t */\n\t\tif ((access_type == TYPE_LINEAR_APIC_INST_WRITE) &&\n\t\t    (offset == APIC_EOI)) {\n\t\t\tkvm_lapic_set_eoi(vcpu);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t}\n\treturn kvm_emulate_instruction(vcpu, 0);\n}"
  },
  {
    "function_name": "handle_xsetbv",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5019-5027",
    "snippet": "static int handle_xsetbv(struct kvm_vcpu *vcpu)\n{\n\tu64 new_bv = kvm_read_edx_eax(vcpu);\n\tu32 index = kvm_rcx_read(vcpu);\n\n\tif (kvm_set_xcr(vcpu, index, new_bv) == 0)\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 5025
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_xcr",
          "args": [
            "vcpu",
            "index",
            "new_bv"
          ],
          "line": 5024
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_xcr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "897-905",
          "snippet": "int kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops.get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops.get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rcx_read",
          "args": [
            "vcpu"
          ],
          "line": 5022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_edx_eax",
          "args": [
            "vcpu"
          ],
          "line": 5021
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_edx_eax",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "149-153",
          "snippet": "static inline u64 kvm_read_edx_eax(struct kvm_vcpu *vcpu)\n{\n\treturn (kvm_rax_read(vcpu) & -1u)\n\t\t| ((u64)(kvm_rdx_read(vcpu) & -1u) << 32);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline u64 kvm_read_edx_eax(struct kvm_vcpu *vcpu)\n{\n\treturn (kvm_rax_read(vcpu) & -1u)\n\t\t| ((u64)(kvm_rdx_read(vcpu) & -1u) << 32);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_xsetbv(struct kvm_vcpu *vcpu)\n{\n\tu64 new_bv = kvm_read_edx_eax(vcpu);\n\tu32 index = kvm_rcx_read(vcpu);\n\n\tif (kvm_set_xcr(vcpu, index, new_bv) == 0)\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_wbinvd",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5014-5017",
    "snippet": "static int handle_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_wbinvd(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_wbinvd",
          "args": [
            "vcpu"
          ],
          "line": 5016
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_wbinvd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6012-6016",
          "snippet": "int kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tkvm_emulate_wbinvd_noskip(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tkvm_emulate_wbinvd_noskip(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_wbinvd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_wbinvd(vcpu);\n}"
  },
  {
    "function_name": "handle_rdpmc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "5006-5012",
    "snippet": "static int handle_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\n\terr = kvm_rdpmc(vcpu);\n\treturn kvm_complete_insn_gp(vcpu, err);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_complete_insn_gp",
          "args": [
            "vcpu",
            "err"
          ],
          "line": 5011
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_complete_insn_gp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "588-596",
          "snippet": "int kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rdpmc",
          "args": [
            "vcpu"
          ],
          "line": 5010
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rdpmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1157-1169",
          "snippet": "bool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_rdpmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_rax_write(vcpu, (u32)data);\n\tkvm_rdx_write(vcpu, data >> 32);\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_rdpmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_rax_write(vcpu, (u32)data);\n\tkvm_rdx_write(vcpu, data >> 32);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tint err;\n\n\terr = kvm_rdpmc(vcpu);\n\treturn kvm_complete_insn_gp(vcpu, err);\n}"
  },
  {
    "function_name": "handle_invlpg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4998-5004",
    "snippet": "static int handle_invlpg(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tkvm_mmu_invlpg(vcpu, exit_qualification);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 5003
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_invlpg",
          "args": [
            "vcpu",
            "exit_qualification"
          ],
          "line": 5002
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_invlpg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5500-5528",
          "snippet": "void kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tint i;\n\n\t/* INVLPG on a * non-canonical address is a NOP according to the SDM.  */\n\tif (is_noncanonical_address(gva, vcpu))\n\t\treturn;\n\n\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\n\t/*\n\t * INVLPG is required to invalidate any global mappings for the VA,\n\t * irrespective of PCID. Since it would take us roughly similar amount\n\t * of work to determine whether any of the prev_root mappings of the VA\n\t * is marked global, or to just sync it blindly, so we might as well\n\t * just always sync it.\n\t *\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\n\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tint i;\n\n\t/* INVLPG on a * non-canonical address is a NOP according to the SDM.  */\n\tif (is_noncanonical_address(gva, vcpu))\n\t\treturn;\n\n\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\n\t/*\n\t * INVLPG is required to invalidate any global mappings for the VA,\n\t * irrespective of PCID. Since it would take us roughly similar amount\n\t * of work to determine whether any of the prev_root mappings of the VA\n\t * is marked global, or to just sync it blindly, so we might as well\n\t * just always sync it.\n\t *\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\n\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 5000
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_invlpg(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\n\tkvm_mmu_invlpg(vcpu, exit_qualification);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
  },
  {
    "function_name": "handle_invd",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4993-4996",
    "snippet": "static int handle_invd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_instruction(vcpu, 0);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 4995
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_invd(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_instruction(vcpu, 0);\n}"
  },
  {
    "function_name": "handle_vmcall",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4988-4991",
    "snippet": "static int handle_vmcall(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_hypercall(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_hypercall",
          "args": [
            "vcpu"
          ],
          "line": 4990
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_hypercall",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7529-7591",
          "snippet": "int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit;\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_rax_read(vcpu);\n\ta0 = kvm_rbx_read(vcpu);\n\ta1 = kvm_rcx_read(vcpu);\n\ta2 = kvm_rdx_read(vcpu);\n\ta3 = kvm_rsi_read(vcpu);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_mode(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops.get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tkvm_sched_yield(vcpu->kvm, a1);\n\t\tret = 0;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase KVM_HC_CLOCK_PAIRING:\n\t\tret = kvm_pv_clock_pairing(vcpu, a0, a1);\n\t\tbreak;\n#endif\n\tcase KVM_HC_SEND_IPI:\n\t\tret = kvm_pv_send_ipi(vcpu->kvm, a0, a1, a2, a3, op_64_bit);\n\t\tbreak;\n\tcase KVM_HC_SCHED_YIELD:\n\t\tkvm_sched_yield(vcpu->kvm, a0);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_rax_write(vcpu, ret);\n\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit;\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_rax_read(vcpu);\n\ta0 = kvm_rbx_read(vcpu);\n\ta1 = kvm_rcx_read(vcpu);\n\ta2 = kvm_rdx_read(vcpu);\n\ta3 = kvm_rsi_read(vcpu);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_mode(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops.get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tkvm_sched_yield(vcpu->kvm, a1);\n\t\tret = 0;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase KVM_HC_CLOCK_PAIRING:\n\t\tret = kvm_pv_clock_pairing(vcpu, a0, a1);\n\t\tbreak;\n#endif\n\tcase KVM_HC_SEND_IPI:\n\t\tret = kvm_pv_send_ipi(vcpu->kvm, a0, a1, a2, a3, op_64_bit);\n\t\tbreak;\n\tcase KVM_HC_SCHED_YIELD:\n\t\tkvm_sched_yield(vcpu->kvm, a0);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_rax_write(vcpu, ret);\n\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_vmcall(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_emulate_hypercall(vcpu);\n}"
  },
  {
    "function_name": "handle_interrupt_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4978-4986",
    "snippet": "static int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 4982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exec_controls_clearbit",
          "args": [
            "to_vmx(vcpu)",
            "CPU_BASED_INTR_WINDOW_EXITING"
          ],
          "line": 4980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4980
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_interrupt_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\n\t++vcpu->stat.irq_window_exits;\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_tpr_below_threshold",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4972-4976",
    "snippet": "static int handle_tpr_below_threshold(struct kvm_vcpu *vcpu)\n{\n\tkvm_apic_update_ppr(vcpu);\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_update_ppr",
          "args": [
            "vcpu"
          ],
          "line": 4974
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_update_ppr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "716-719",
          "snippet": "void kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_apic_update_ppr(struct kvm_vcpu *vcpu)\n{\n\tapic_update_ppr(vcpu->arch.apic);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_tpr_below_threshold(struct kvm_vcpu *vcpu)\n{\n\tkvm_apic_update_ppr(vcpu);\n\treturn 1;\n}"
  },
  {
    "function_name": "vmx_set_dr7",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4967-4970",
    "snippet": "static void vmx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tvmcs_writel(GUEST_DR7, val);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "GUEST_DR7",
            "val"
          ],
          "line": 4969
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_set_dr7(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tvmcs_writel(GUEST_DR7, val);\n}"
  },
  {
    "function_name": "vmx_sync_dirty_debug_regs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4954-4965",
    "snippet": "static void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tget_debugreg(vcpu->arch.dr6, 6);\n\tvcpu->arch.dr7 = vmcs_readl(GUEST_DR7);\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_MOV_DR_EXITING);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exec_controls_setbit",
          "args": [
            "to_vmx(vcpu)",
            "CPU_BASED_MOV_DR_EXITING"
          ],
          "line": 4964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4964
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_DR7"
          ],
          "line": 4961
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_debugreg",
          "args": [
            "vcpu->arch.dr6",
            "6"
          ],
          "line": 4960
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_get_debugregs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "3985-3996",
          "snippet": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tget_debugreg(vcpu->arch.dr6, 6);\n\tvcpu->arch.dr7 = vmcs_readl(GUEST_DR7);\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_MOV_DR_EXITING);\n}"
  },
  {
    "function_name": "vmx_set_dr6",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4950-4952",
    "snippet": "static void vmx_set_dr6(struct kvm_vcpu *vcpu, unsigned long val)\n{\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_set_dr6(struct kvm_vcpu *vcpu, unsigned long val)\n{\n}"
  },
  {
    "function_name": "vmx_get_dr6",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4945-4948",
    "snippet": "static u64 vmx_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.dr6;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic u64 vmx_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.dr6;\n}"
  },
  {
    "function_name": "handle_dr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4882-4943",
    "snippet": "static int handle_dr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint dr, dr7, reg;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tdr = exit_qualification & DEBUG_REG_ACCESS_NUM;\n\n\t/* First, if DR does not exist, trigger UD */\n\tif (!kvm_require_dr(vcpu, dr))\n\t\treturn 1;\n\n\t/* Do not handle if the CPL > 0, will trigger GP on re-entry */\n\tif (!kvm_require_cpl(vcpu, 0))\n\t\treturn 1;\n\tdr7 = vmcs_readl(GUEST_DR7);\n\tif (dr7 & DR7_GD) {\n\t\t/*\n\t\t * As the vm-exit takes precedence over the debug trap, we\n\t\t * need to emulate the latter, either for the host or the\n\t\t * guest debugging itself.\n\t\t */\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\t\tvcpu->run->debug.arch.dr6 = vcpu->arch.dr6;\n\t\t\tvcpu->run->debug.arch.dr7 = dr7;\n\t\t\tvcpu->run->debug.arch.pc = kvm_get_linear_rip(vcpu);\n\t\t\tvcpu->run->debug.arch.exception = DB_VECTOR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvcpu->arch.dr6 &= ~DR_TRAP_BITS;\n\t\t\tvcpu->arch.dr6 |= DR6_BD | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (vcpu->guest_debug == 0) {\n\t\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_MOV_DR_EXITING);\n\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\treg = DEBUG_REG_ACCESS_REG(exit_qualification);\n\tif (exit_qualification & TYPE_MOV_FROM_DR) {\n\t\tunsigned long val;\n\n\t\tif (kvm_get_dr(vcpu, dr, &val))\n\t\t\treturn 1;\n\t\tkvm_register_write(vcpu, reg, val);\n\t} else\n\t\tif (kvm_set_dr(vcpu, dr, kvm_register_readl(vcpu, reg)))\n\t\t\treturn 1;\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 4942
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_dr",
          "args": [
            "vcpu",
            "dr",
            "kvm_register_readl(vcpu, reg)"
          ],
          "line": 4939
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_dr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1121-1128",
          "snippet": "int kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tif (__kvm_set_dr(vcpu, dr, val)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tif (__kvm_set_dr(vcpu, dr, val)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_readl",
          "args": [
            "vcpu",
            "reg"
          ],
          "line": 4939
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "218-223",
          "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu, int reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu, int reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "vcpu",
            "reg",
            "val"
          ],
          "line": 4937
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-84",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu, int reg,\n\t\t\t\t      unsigned long val)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn;\n\n\tvcpu->arch.regs[reg] = val;\n\tkvm_register_mark_dirty(vcpu, reg);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_write(struct kvm_vcpu *vcpu, int reg,\n\t\t\t\t      unsigned long val)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn;\n\n\tvcpu->arch.regs[reg] = val;\n\tkvm_register_mark_dirty(vcpu, reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_dr",
          "args": [
            "vcpu",
            "dr",
            "&val"
          ],
          "line": 4935
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_dr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1131-1154",
          "snippet": "int kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tsize_t size = ARRAY_SIZE(vcpu->arch.db);\n\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[array_index_nospec(dr, size)];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops.get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tsize_t size = ARRAY_SIZE(vcpu->arch.db);\n\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[array_index_nospec(dr, size)];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops.get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "DEBUG_REG_ACCESS_REG",
          "args": [
            "exit_qualification"
          ],
          "line": 4931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exec_controls_clearbit",
          "args": [
            "to_vmx(vcpu)",
            "CPU_BASED_MOV_DR_EXITING"
          ],
          "line": 4920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4920
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "DB_VECTOR"
          ],
          "line": 4914
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_linear_rip",
          "args": [
            "vcpu"
          ],
          "line": 4907
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_linear_rip",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10206-10212",
          "snippet": "unsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)\n{\n\tif (is_64_bit_mode(vcpu))\n\t\treturn kvm_rip_read(vcpu);\n\treturn (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +\n\t\t     kvm_rip_read(vcpu));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_linear_rip(struct kvm_vcpu *vcpu)\n{\n\tif (is_64_bit_mode(vcpu))\n\t\treturn kvm_rip_read(vcpu);\n\treturn (u32)(get_segment_base(vcpu, VCPU_SREG_CS) +\n\t\t     kvm_rip_read(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_DR7"
          ],
          "line": 4897
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_require_cpl",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 4895
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_require_cpl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "647-653",
          "snippet": "bool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)\n{\n\tif (kvm_x86_ops.get_cpl(vcpu) <= required_cpl)\n\t\treturn true;\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_require_cpl(struct kvm_vcpu *vcpu, int required_cpl)\n{\n\tif (kvm_x86_ops.get_cpl(vcpu) <= required_cpl)\n\t\treturn true;\n\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_require_dr",
          "args": [
            "vcpu",
            "dr"
          ],
          "line": 4891
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_require_dr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "656-663",
          "snippet": "bool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)\n{\n\tif ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\treturn true;\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)\n{\n\tif ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\treturn true;\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_dr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint dr, dr7, reg;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tdr = exit_qualification & DEBUG_REG_ACCESS_NUM;\n\n\t/* First, if DR does not exist, trigger UD */\n\tif (!kvm_require_dr(vcpu, dr))\n\t\treturn 1;\n\n\t/* Do not handle if the CPL > 0, will trigger GP on re-entry */\n\tif (!kvm_require_cpl(vcpu, 0))\n\t\treturn 1;\n\tdr7 = vmcs_readl(GUEST_DR7);\n\tif (dr7 & DR7_GD) {\n\t\t/*\n\t\t * As the vm-exit takes precedence over the debug trap, we\n\t\t * need to emulate the latter, either for the host or the\n\t\t * guest debugging itself.\n\t\t */\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP) {\n\t\t\tvcpu->run->debug.arch.dr6 = vcpu->arch.dr6;\n\t\t\tvcpu->run->debug.arch.dr7 = dr7;\n\t\t\tvcpu->run->debug.arch.pc = kvm_get_linear_rip(vcpu);\n\t\t\tvcpu->run->debug.arch.exception = DB_VECTOR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_DEBUG;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvcpu->arch.dr6 &= ~DR_TRAP_BITS;\n\t\t\tvcpu->arch.dr6 |= DR6_BD | DR6_RTM;\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tif (vcpu->guest_debug == 0) {\n\t\texec_controls_clearbit(to_vmx(vcpu), CPU_BASED_MOV_DR_EXITING);\n\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tvcpu->arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\treg = DEBUG_REG_ACCESS_REG(exit_qualification);\n\tif (exit_qualification & TYPE_MOV_FROM_DR) {\n\t\tunsigned long val;\n\n\t\tif (kvm_get_dr(vcpu, dr, &val))\n\t\t\treturn 1;\n\t\tkvm_register_write(vcpu, reg, val);\n\t} else\n\t\tif (kvm_set_dr(vcpu, dr, kvm_register_readl(vcpu, reg)))\n\t\t\treturn 1;\n\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
  },
  {
    "function_name": "handle_cr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4802-4880",
    "snippet": "static int handle_cr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification, val;\n\tint cr;\n\tint reg;\n\tint err;\n\tint ret;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tcr = exit_qualification & 15;\n\treg = (exit_qualification >> 8) & 15;\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tval = kvm_register_readl(vcpu, reg);\n\t\ttrace_kvm_cr_write(cr, val);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\terr = handle_set_cr0(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 3:\n\t\t\tWARN_ON_ONCE(enable_unrestricted_guest);\n\t\t\terr = kvm_set_cr3(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 4:\n\t\t\terr = handle_set_cr4(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 8: {\n\t\t\t\tu8 cr8_prev = kvm_get_cr8(vcpu);\n\t\t\t\tu8 cr8 = (u8)val;\n\t\t\t\terr = kvm_set_cr8(vcpu, cr8);\n\t\t\t\tret = kvm_complete_insn_gp(vcpu, err);\n\t\t\t\tif (lapic_in_kernel(vcpu))\n\t\t\t\t\treturn ret;\n\t\t\t\tif (cr8_prev <= cr8)\n\t\t\t\t\treturn ret;\n\t\t\t\t/*\n\t\t\t\t * TODO: we might be squashing a\n\t\t\t\t * KVM_GUESTDBG_SINGLESTEP-triggered\n\t\t\t\t * KVM_EXIT_DEBUG here.\n\t\t\t\t */\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_SET_TPR;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\tWARN_ONCE(1, \"Guest should always own CR0.TS\");\n\t\tvmx_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~X86_CR0_TS));\n\t\ttrace_kvm_cr_write(0, kvm_read_cr0(vcpu));\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tcase 1: /*mov from cr*/\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tWARN_ON_ONCE(enable_unrestricted_guest);\n\t\t\tval = kvm_read_cr3(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\tval = (exit_qualification >> LMSW_SOURCE_DATA_SHIFT) & 0x0f;\n\t\ttrace_kvm_cr_write(0, (kvm_read_cr0(vcpu) & ~0xful) | val);\n\t\tkvm_lmsw(vcpu, val);\n\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tdefault:\n\t\tbreak;\n\t}\n\tvcpu->run->exit_reason = 0;\n\tvcpu_unimpl(vcpu, \"unhandled control register: op %d cr %d\\n\",\n\t       (int)(exit_qualification >> 4) & 3, cr);\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"unhandled control register: op %d cr %d\\n\"",
            "(int)(exit_qualification >> 4) & 3",
            "cr"
          ],
          "line": 4877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 4872
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lmsw",
          "args": [
            "vcpu",
            "val"
          ],
          "line": 4870
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lmsw",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "822-825",
          "snippet": "void kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_lmsw(struct kvm_vcpu *vcpu, unsigned long msw)\n{\n\t(void)kvm_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~0x0eul) | (msw & 0x0f));\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_cr_write",
          "args": [
            "0",
            "(kvm_read_cr0(vcpu) & ~0xful) | val"
          ],
          "line": 4869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "vcpu"
          ],
          "line": 4869
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "124-127",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_cr_read",
          "args": [
            "cr",
            "val"
          ],
          "line": 4863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "vcpu",
            "reg",
            "val"
          ],
          "line": 4862
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-84",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu, int reg,\n\t\t\t\t      unsigned long val)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn;\n\n\tvcpu->arch.regs[reg] = val;\n\tkvm_register_mark_dirty(vcpu, reg);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_write(struct kvm_vcpu *vcpu, int reg,\n\t\t\t\t      unsigned long val)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn;\n\n\tvcpu->arch.regs[reg] = val;\n\tkvm_register_mark_dirty(vcpu, reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_cr8",
          "args": [
            "vcpu"
          ],
          "line": 4861
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_cr8",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1041-1047",
          "snippet": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_cr_read",
          "args": [
            "cr",
            "val"
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 4856
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "137-142",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tkvm_x86_ops.cache_reg(vcpu, VCPU_EXREG_CR3);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tkvm_x86_ops.cache_reg(vcpu, VCPU_EXREG_CR3);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "enable_unrestricted_guest"
          ],
          "line": 4855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_cr_write",
          "args": [
            "0",
            "kvm_read_cr0(vcpu)"
          ],
          "line": 4850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_set_cr0",
          "args": [
            "vcpu",
            "kvm_read_cr0_bits(vcpu, ~X86_CR0_TS)"
          ],
          "line": 4849
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_cr0",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2930-2966",
          "snippet": "void vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0;\n\n\thw_cr0 = (cr0 & ~KVM_VM_CR0_ALWAYS_OFF);\n\tif (enable_unrestricted_guest)\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept && !enable_unrestricted_guest)\n\t\tept_update_paging_mode_cr0(&hw_cr0, cr0, vcpu);\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = emulation_required(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | \t\\\n\t X86_CR0_WP | X86_CR0_PG | X86_CR0_PE)",
            "#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR0_NE",
            "#define KVM_VM_CR0_ALWAYS_OFF (X86_CR0_NW | X86_CR0_CD)"
          ],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | \t\\\n\t X86_CR0_WP | X86_CR0_PG | X86_CR0_PE)\n#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR0_NE\n#define KVM_VM_CR0_ALWAYS_OFF (X86_CR0_NW | X86_CR0_CD)\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0;\n\n\thw_cr0 = (cr0 & ~KVM_VM_CR0_ALWAYS_OFF);\n\tif (enable_unrestricted_guest)\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept && !enable_unrestricted_guest)\n\t\tept_update_paging_mode_cr0(&hw_cr0, cr0, vcpu);\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = emulation_required(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0_bits",
          "args": [
            "vcpu",
            "~X86_CR0_TS"
          ],
          "line": 4849
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "116-122",
          "snippet": "static inline ulong kvm_read_cr0_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR0_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr0_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr0_guest_bits(vcpu);\n\treturn vcpu->arch.cr0 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR0_GUEST_BITS X86_CR0_TS"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR0_GUEST_BITS X86_CR0_TS\n\nstatic inline ulong kvm_read_cr0_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR0_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr0_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr0_guest_bits(vcpu);\n\treturn vcpu->arch.cr0 & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Guest should always own CR0.TS\""
          ],
          "line": 4848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 4833
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_complete_insn_gp",
          "args": [
            "vcpu",
            "err"
          ],
          "line": 4832
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_complete_insn_gp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "588-596",
          "snippet": "int kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr8",
          "args": [
            "vcpu",
            "cr8"
          ],
          "line": 4831
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr8",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1029-1038",
          "snippet": "int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_set_cr4",
          "args": [
            "vcpu",
            "val"
          ],
          "line": 4826
        },
        "resolved": true,
        "details": {
          "function_name": "handle_set_cr4",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4779-4794",
          "snippet": "static int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/* analogously to handle_set_cr0 */\n\t\tval = (val & ~vmcs12->cr4_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask);\n\t\tif (kvm_set_cr4(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR4_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else\n\t\treturn kvm_set_cr4(vcpu, val);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/* analogously to handle_set_cr0 */\n\t\tval = (val & ~vmcs12->cr4_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask);\n\t\tif (kvm_set_cr4(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR4_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else\n\t\treturn kvm_set_cr4(vcpu, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr3",
          "args": [
            "vcpu",
            "val"
          ],
          "line": 4823
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr3",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "994-1026",
          "snippet": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tbool skip_tlb_flush = false;\n#ifdef CONFIG_X86_64\n\tbool pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);\n\n\tif (pcid_enabled) {\n\t\tskip_tlb_flush = cr3 & X86_CR3_PCID_NOFLUSH;\n\t\tcr3 &= ~X86_CR3_PCID_NOFLUSH;\n\t}\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tif (!skip_tlb_flush) {\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu) &&\n\t    (cr3 & rsvd_bits(cpuid_maxphyaddr(vcpu), 63)))\n\t\treturn 1;\n\telse if (is_pae_paging(vcpu) &&\n\t\t !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tkvm_mmu_new_cr3(vcpu, cr3, skip_tlb_flush);\n\tvcpu->arch.cr3 = cr3;\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_CR3);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tbool skip_tlb_flush = false;\n#ifdef CONFIG_X86_64\n\tbool pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);\n\n\tif (pcid_enabled) {\n\t\tskip_tlb_flush = cr3 & X86_CR3_PCID_NOFLUSH;\n\t\tcr3 &= ~X86_CR3_PCID_NOFLUSH;\n\t}\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tif (!skip_tlb_flush) {\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu) &&\n\t    (cr3 & rsvd_bits(cpuid_maxphyaddr(vcpu), 63)))\n\t\treturn 1;\n\telse if (is_pae_paging(vcpu) &&\n\t\t !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tkvm_mmu_new_cr3(vcpu, cr3, skip_tlb_flush);\n\tvcpu->arch.cr3 = cr3;\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_CR3);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "enable_unrestricted_guest"
          ],
          "line": 4822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_set_cr0",
          "args": [
            "vcpu",
            "val"
          ],
          "line": 4819
        },
        "resolved": true,
        "details": {
          "function_name": "handle_set_cr0",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4746-4777",
          "snippet": "static int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_guest_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    !nested_host_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_guest_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    !nested_host_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_cr_write",
          "args": [
            "cr",
            "val"
          ],
          "line": 4816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_register_readl",
          "args": [
            "vcpu",
            "reg"
          ],
          "line": 4815
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "218-223",
          "snippet": "static inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu, int reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_readl(struct kvm_vcpu *vcpu, int reg)\n{\n\tunsigned long val = kvm_register_read(vcpu, reg);\n\n\treturn is_64_bit_mode(vcpu) ? val : (u32)val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 4810
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_cr(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification, val;\n\tint cr;\n\tint reg;\n\tint err;\n\tint ret;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tcr = exit_qualification & 15;\n\treg = (exit_qualification >> 8) & 15;\n\tswitch ((exit_qualification >> 4) & 3) {\n\tcase 0: /* mov to cr */\n\t\tval = kvm_register_readl(vcpu, reg);\n\t\ttrace_kvm_cr_write(cr, val);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\terr = handle_set_cr0(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 3:\n\t\t\tWARN_ON_ONCE(enable_unrestricted_guest);\n\t\t\terr = kvm_set_cr3(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 4:\n\t\t\terr = handle_set_cr4(vcpu, val);\n\t\t\treturn kvm_complete_insn_gp(vcpu, err);\n\t\tcase 8: {\n\t\t\t\tu8 cr8_prev = kvm_get_cr8(vcpu);\n\t\t\t\tu8 cr8 = (u8)val;\n\t\t\t\terr = kvm_set_cr8(vcpu, cr8);\n\t\t\t\tret = kvm_complete_insn_gp(vcpu, err);\n\t\t\t\tif (lapic_in_kernel(vcpu))\n\t\t\t\t\treturn ret;\n\t\t\t\tif (cr8_prev <= cr8)\n\t\t\t\t\treturn ret;\n\t\t\t\t/*\n\t\t\t\t * TODO: we might be squashing a\n\t\t\t\t * KVM_GUESTDBG_SINGLESTEP-triggered\n\t\t\t\t * KVM_EXIT_DEBUG here.\n\t\t\t\t */\n\t\t\t\tvcpu->run->exit_reason = KVM_EXIT_SET_TPR;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 2: /* clts */\n\t\tWARN_ONCE(1, \"Guest should always own CR0.TS\");\n\t\tvmx_set_cr0(vcpu, kvm_read_cr0_bits(vcpu, ~X86_CR0_TS));\n\t\ttrace_kvm_cr_write(0, kvm_read_cr0(vcpu));\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tcase 1: /*mov from cr*/\n\t\tswitch (cr) {\n\t\tcase 3:\n\t\t\tWARN_ON_ONCE(enable_unrestricted_guest);\n\t\t\tval = kvm_read_cr3(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(vcpu);\n\t\t\tkvm_register_write(vcpu, reg, val);\n\t\t\ttrace_kvm_cr_read(cr, val);\n\t\t\treturn kvm_skip_emulated_instruction(vcpu);\n\t\t}\n\t\tbreak;\n\tcase 3: /* lmsw */\n\t\tval = (exit_qualification >> LMSW_SOURCE_DATA_SHIFT) & 0x0f;\n\t\ttrace_kvm_cr_write(0, (kvm_read_cr0(vcpu) & ~0xful) | val);\n\t\tkvm_lmsw(vcpu, val);\n\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\tdefault:\n\t\tbreak;\n\t}\n\tvcpu->run->exit_reason = 0;\n\tvcpu_unimpl(vcpu, \"unhandled control register: op %d cr %d\\n\",\n\t       (int)(exit_qualification >> 4) & 3, cr);\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_desc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4796-4800",
    "snippet": "static int handle_desc(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON(!(vcpu->arch.cr4 & X86_CR4_UMIP));\n\treturn kvm_emulate_instruction(vcpu, 0);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 4799
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!(vcpu->arch.cr4 & X86_CR4_UMIP)"
          ],
          "line": 4798
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_desc(struct kvm_vcpu *vcpu)\n{\n\tWARN_ON(!(vcpu->arch.cr4 & X86_CR4_UMIP));\n\treturn kvm_emulate_instruction(vcpu, 0);\n}"
  },
  {
    "function_name": "handle_set_cr4",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4779-4794",
    "snippet": "static int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/* analogously to handle_set_cr0 */\n\t\tval = (val & ~vmcs12->cr4_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask);\n\t\tif (kvm_set_cr4(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR4_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else\n\t\treturn kvm_set_cr4(vcpu, val);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_cr4",
          "args": [
            "vcpu",
            "val"
          ],
          "line": 4793
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr4",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "953-991",
          "snippet": "int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |\n\t\t\t\t   X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE;\n\n\tif (kvm_valid_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_PCID))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops.set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |\n\t\t\t\t   X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE;\n\n\tif (kvm_valid_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_PCID))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops.set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "CR4_READ_SHADOW",
            "orig_val"
          ],
          "line": 4790
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 4782
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 4781
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_set_cr4(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/* analogously to handle_set_cr0 */\n\t\tval = (val & ~vmcs12->cr4_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr4 & vmcs12->cr4_guest_host_mask);\n\t\tif (kvm_set_cr4(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR4_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else\n\t\treturn kvm_set_cr4(vcpu, val);\n}"
  },
  {
    "function_name": "handle_set_cr0",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4746-4777",
    "snippet": "static int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_guest_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    !nested_host_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_cr0",
          "args": [
            "vcpu",
            "val"
          ],
          "line": 4775
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr0",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "763-819",
          "snippet": "int kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops.set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops.set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_host_cr0_valid",
          "args": [
            "vcpu",
            "val"
          ],
          "line": 4772
        },
        "resolved": true,
        "details": {
          "function_name": "nested_host_cr0_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "282-288",
          "snippet": "static inline bool nested_host_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr0_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_host_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr0_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4771
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "CR0_READ_SHADOW",
            "orig_val"
          ],
          "line": 4768
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_guest_cr0_valid",
          "args": [
            "vcpu",
            "val"
          ],
          "line": 4763
        },
        "resolved": true,
        "details": {
          "function_name": "nested_guest_cr0_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "268-280",
          "snippet": "static inline bool nested_guest_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr0_fixed1;\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (to_vmx(vcpu)->nested.msrs.secondary_ctls_high &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))\n\t\tfixed0 &= ~(X86_CR0_PE | X86_CR0_PG);\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_guest_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr0_fixed1;\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (to_vmx(vcpu)->nested.msrs.secondary_ctls_high &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))\n\t\tfixed0 &= ~(X86_CR0_PE | X86_CR0_PG);\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 4749
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 4748
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_set_cr0(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\t\tunsigned long orig_val = val;\n\n\t\t/*\n\t\t * We get here when L2 changed cr0 in a way that did not change\n\t\t * any of L1's shadowed bits (see nested_vmx_exit_handled_cr),\n\t\t * but did change L0 shadowed bits. So we first calculate the\n\t\t * effective cr0 value that L1 would like to write into the\n\t\t * hardware. It consists of the L2-owned bits from the new\n\t\t * value combined with the L1-owned bits from L1's guest_cr0.\n\t\t */\n\t\tval = (val & ~vmcs12->cr0_guest_host_mask) |\n\t\t\t(vmcs12->guest_cr0 & vmcs12->cr0_guest_host_mask);\n\n\t\tif (!nested_guest_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\tif (kvm_set_cr0(vcpu, val))\n\t\t\treturn 1;\n\t\tvmcs_writel(CR0_READ_SHADOW, orig_val);\n\t\treturn 0;\n\t} else {\n\t\tif (to_vmx(vcpu)->nested.vmxon &&\n\t\t    !nested_host_cr0_valid(vcpu, val))\n\t\t\treturn 1;\n\n\t\treturn kvm_set_cr0(vcpu, val);\n\t}\n}"
  },
  {
    "function_name": "vmx_patch_hypercall",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4734-4743",
    "snippet": "static void\nvmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void\nvmx_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xc1;\n}"
  },
  {
    "function_name": "handle_io",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4713-4732",
    "snippet": "static int handle_io(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint size, in, string;\n\tunsigned port;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tstring = (exit_qualification & 16) != 0;\n\n\t++vcpu->stat.io_exits;\n\n\tif (string)\n\t\treturn kvm_emulate_instruction(vcpu, 0);\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\tin = (exit_qualification & 8) != 0;\n\n\treturn kvm_fast_pio(vcpu, size, port, in);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_fast_pio",
          "args": [
            "vcpu",
            "size",
            "port",
            "in"
          ],
          "line": 4731
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_fast_pio",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7022-7031",
          "snippet": "int kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in)\n{\n\tint ret;\n\n\tif (in)\n\t\tret = kvm_fast_pio_in(vcpu, size, port);\n\telse\n\t\tret = kvm_fast_pio_out(vcpu, size, port);\n\treturn ret && kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in)\n{\n\tint ret;\n\n\tif (in)\n\t\tret = kvm_fast_pio_in(vcpu, size, port);\n\telse\n\t\tret = kvm_fast_pio_out(vcpu, size, port);\n\treturn ret && kvm_skip_emulated_instruction(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 4725
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 4719
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_io(struct kvm_vcpu *vcpu)\n{\n\tunsigned long exit_qualification;\n\tint size, in, string;\n\tunsigned port;\n\n\texit_qualification = vmcs_readl(EXIT_QUALIFICATION);\n\tstring = (exit_qualification & 16) != 0;\n\n\t++vcpu->stat.io_exits;\n\n\tif (string)\n\t\treturn kvm_emulate_instruction(vcpu, 0);\n\n\tport = exit_qualification >> 16;\n\tsize = (exit_qualification & 7) + 1;\n\tin = (exit_qualification & 8) != 0;\n\n\treturn kvm_fast_pio(vcpu, size, port, in);\n}"
  },
  {
    "function_name": "handle_triple_fault",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4706-4711",
    "snippet": "static int handle_triple_fault(struct kvm_vcpu *vcpu)\n{\n\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\tvcpu->mmio_needed = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_triple_fault(struct kvm_vcpu *vcpu)\n{\n\tvcpu->run->exit_reason = KVM_EXIT_SHUTDOWN;\n\tvcpu->mmio_needed = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_external_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4700-4704",
    "snippet": "static __always_inline int handle_external_interrupt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.irq_exits;\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic __always_inline int handle_external_interrupt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.irq_exits;\n\treturn 1;\n}"
  },
  {
    "function_name": "handle_exception_nmi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4595-4698",
    "snippet": "static int handle_exception_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, rip, dr6;\n\tu32 vect_info;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx->exit_intr_info;\n\n\tif (is_machine_check(intr_info) || is_nmi(intr_info))\n\t\treturn 1; /* handled by handle_exception_nmi_irqoff() */\n\n\tif (is_invalid_opcode(intr_info))\n\t\treturn handle_ud(vcpu);\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\tif (!vmx->rmode.vm86_active && is_gp_fault(intr_info)) {\n\t\tWARN_ON_ONCE(!enable_vmware_backdoor);\n\n\t\t/*\n\t\t * VMware backdoor emulation on #GP interception only handles\n\t\t * IN{S}, OUT{S}, and RDPMC, none of which generate a non-zero\n\t\t * error code on #GP.\n\t\t */\n\t\tif (error_code) {\n\t\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n\t\t\treturn 1;\n\t\t}\n\t\treturn kvm_emulate_instruction(vcpu, EMULTYPE_VMWARE_GP);\n\t}\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\tvcpu->run->internal.data[2] = error_code;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\tcr2 = vmcs_readl(EXIT_QUALIFICATION);\n\t\t/* EPT won't cause page fault directly */\n\t\tWARN_ON_ONCE(!vcpu->arch.apf.host_apf_reason && enable_ept);\n\t\treturn kvm_handle_page_fault(vcpu, error_code, cr2, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase AC_VECTOR:\n\t\tkvm_queue_exception_e(vcpu, AC_VECTOR, error_code);\n\t\treturn 1;\n\tcase DB_VECTOR:\n\t\tdr6 = vmcs_readl(EXIT_QUALIFICATION);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\tvcpu->arch.dr6 &= ~DR_TRAP_BITS;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tif (is_icebp(intr_info))\n\t\t\t\tWARN_ON(!skip_emulated_instruction(vcpu));\n\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\t/* fall through */\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\trip = kvm_rip_read(vcpu);\n\t\tkvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_CS_BASE"
          ],
          "line": 4688
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 4687
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "86-89",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "VM_EXIT_INSTRUCTION_LEN"
          ],
          "line": 4685
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "DB_VECTOR"
          ],
          "line": 4672
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!skip_emulated_instruction(vcpu)"
          ],
          "line": 4670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 4670
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1604-1608",
          "snippet": "static int vmx_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tvmx_update_emulated_instruction(vcpu);\n\treturn skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tvmx_update_emulated_instruction(vcpu);\n\treturn skip_emulated_instruction(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_icebp",
          "args": [
            "intr_info"
          ],
          "line": 4669
        },
        "resolved": true,
        "details": {
          "function_name": "is_icebp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmcs.h",
          "lines": "115-119",
          "snippet": "static inline bool is_icebp(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_PRIV_SW_EXCEPTION | INTR_INFO_VALID_MASK);\n}",
          "includes": [
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm.h>",
            "#include <linux/nospec.h>",
            "#include <linux/list.h>",
            "#include <linux/ktime.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/kvm.h>\n#include <linux/nospec.h>\n#include <linux/list.h>\n#include <linux/ktime.h>\n\nstatic inline bool is_icebp(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_PRIV_SW_EXCEPTION | INTR_INFO_VALID_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception_e",
          "args": [
            "vcpu",
            "AC_VECTOR",
            "error_code"
          ],
          "line": 4661
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception_e",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "631-634",
          "snippet": "void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_rmode_exception",
          "args": [
            "vcpu",
            "ex_no",
            "error_code"
          ],
          "line": 4657
        },
        "resolved": true,
        "details": {
          "function_name": "handle_rmode_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4543-4568",
          "snippet": "static int handle_rmode_exception(struct kvm_vcpu *vcpu,\n\t\t\t\t  int vec, u32 err_code)\n{\n\t/*\n\t * Instruction with address size override prefix opcode 0x67\n\t * Cause the #SS fault with 0 error code in VM86 mode.\n\t */\n\tif (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {\n\t\tif (kvm_emulate_instruction(vcpu, 0)) {\n\t\t\tif (vcpu->arch.halt_request) {\n\t\t\t\tvcpu->arch.halt_request = 0;\n\t\t\t\treturn kvm_vcpu_halt(vcpu);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Forward all other exceptions that are valid in real mode.\n\t * FIXME: Breaks guest debugging in real mode, needs to be fixed with\n\t *        the required debugging infrastructure rework.\n\t */\n\tkvm_queue_exception(vcpu, vec);\n\treturn 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_rmode_exception(struct kvm_vcpu *vcpu,\n\t\t\t\t  int vec, u32 err_code)\n{\n\t/*\n\t * Instruction with address size override prefix opcode 0x67\n\t * Cause the #SS fault with 0 error code in VM86 mode.\n\t */\n\tif (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {\n\t\tif (kvm_emulate_instruction(vcpu, 0)) {\n\t\t\tif (vcpu->arch.halt_request) {\n\t\t\t\tvcpu->arch.halt_request = 0;\n\t\t\t\treturn kvm_vcpu_halt(vcpu);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Forward all other exceptions that are valid in real mode.\n\t * FIXME: Breaks guest debugging in real mode, needs to be fixed with\n\t *        the required debugging infrastructure rework.\n\t */\n\tkvm_queue_exception(vcpu, vec);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmode_exception",
          "args": [
            "vcpu",
            "ex_no"
          ],
          "line": 4656
        },
        "resolved": true,
        "details": {
          "function_name": "rmode_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4512-4541",
          "snippet": "static bool rmode_exception(struct kvm_vcpu *vcpu, int vec)\n{\n\tswitch (vec) {\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject the exception\n\t\t * from user space while in guest debugging mode.\n\t\t */\n\t\tto_vmx(vcpu)->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DB_VECTOR:\n\t\tif (vcpu->guest_debug &\n\t\t\t(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DE_VECTOR:\n\tcase OF_VECTOR:\n\tcase BR_VECTOR:\n\tcase UD_VECTOR:\n\tcase DF_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\tcase MF_VECTOR:\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool rmode_exception(struct kvm_vcpu *vcpu, int vec)\n{\n\tswitch (vec) {\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject the exception\n\t\t * from user space while in guest debugging mode.\n\t\t */\n\t\tto_vmx(vcpu)->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DB_VECTOR:\n\t\tif (vcpu->guest_debug &\n\t\t\t(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DE_VECTOR:\n\tcase OF_VECTOR:\n\tcase BR_VECTOR:\n\tcase UD_VECTOR:\n\tcase DF_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\tcase MF_VECTOR:\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_handle_page_fault",
          "args": [
            "vcpu",
            "error_code",
            "cr2",
            "NULL",
            "0"
          ],
          "line": 4651
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4177-4212",
          "snippet": "int kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code,\n\t\t\t\tu64 fault_address, char *insn, int insn_len)\n{\n\tint r = 1;\n\n#ifndef CONFIG_X86_64\n\t/* A 64-bit CR2 should be impossible on 32-bit KVM. */\n\tif (WARN_ON_ONCE(fault_address >> 32))\n\t\treturn -EFAULT;\n#endif\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tswitch (vcpu->arch.apf.host_apf_reason) {\n\tdefault:\n\t\ttrace_kvm_page_fault(fault_address, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, fault_address);\n\t\tr = kvm_mmu_page_fault(vcpu, fault_address, error_code, insn,\n\t\t\t\tinsn_len);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_NOT_PRESENT:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wait(fault_address, 0);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_READY:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wake(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code,\n\t\t\t\tu64 fault_address, char *insn, int insn_len)\n{\n\tint r = 1;\n\n#ifndef CONFIG_X86_64\n\t/* A 64-bit CR2 should be impossible on 32-bit KVM. */\n\tif (WARN_ON_ONCE(fault_address >> 32))\n\t\treturn -EFAULT;\n#endif\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tswitch (vcpu->arch.apf.host_apf_reason) {\n\tdefault:\n\t\ttrace_kvm_page_fault(fault_address, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, fault_address);\n\t\tr = kvm_mmu_page_fault(vcpu, fault_address, error_code, insn,\n\t\t\t\tinsn_len);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_NOT_PRESENT:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wait(fault_address, 0);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_READY:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wake(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!vcpu->arch.apf.host_apf_reason && enable_ept"
          ],
          "line": 4650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_page_fault",
          "args": [
            "intr_info"
          ],
          "line": 4647
        },
        "resolved": true,
        "details": {
          "function_name": "is_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmcs.h",
          "lines": "92-95",
          "snippet": "static inline bool is_page_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, PF_VECTOR);\n}",
          "includes": [
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm.h>",
            "#include <linux/nospec.h>",
            "#include <linux/list.h>",
            "#include <linux/ktime.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/kvm.h>\n#include <linux/nospec.h>\n#include <linux/list.h>\n#include <linux/ktime.h>\n\nstatic inline bool is_page_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, PF_VECTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "vcpu",
            "EMULTYPE_VMWARE_GP"
          ],
          "line": 4628
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!enable_vmware_backdoor"
          ],
          "line": 4617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_gp_fault",
          "args": [
            "intr_info"
          ],
          "line": 4616
        },
        "resolved": true,
        "details": {
          "function_name": "is_gp_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmcs.h",
          "lines": "102-105",
          "snippet": "static inline bool is_gp_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, GP_VECTOR);\n}",
          "includes": [
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm.h>",
            "#include <linux/nospec.h>",
            "#include <linux/list.h>",
            "#include <linux/ktime.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/kvm.h>\n#include <linux/nospec.h>\n#include <linux/list.h>\n#include <linux/ktime.h>\n\nstatic inline bool is_gp_fault(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, GP_VECTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_ud",
          "args": [
            "vcpu"
          ],
          "line": 4610
        },
        "resolved": true,
        "details": {
          "function_name": "handle_ud",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "5550-5566",
          "snippet": "int handle_ud(struct kvm_vcpu *vcpu)\n{\n\tstatic const char kvm_emulate_prefix[] = { __KVM_EMULATE_PREFIX };\n\tint emul_type = EMULTYPE_TRAP_UD;\n\tchar sig[5]; /* ud2; .ascii \"kvm\" */\n\tstruct x86_exception e;\n\n\tif (force_emulation_prefix &&\n\t    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),\n\t\t\t\tsig, sizeof(sig), &e) == 0 &&\n\t    memcmp(sig, kvm_emulate_prefix, sizeof(sig)) == 0) {\n\t\tkvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig));\n\t\temul_type = EMULTYPE_TRAP_UD_FORCED;\n\t}\n\n\treturn kvm_emulate_instruction(vcpu, emul_type);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint handle_ud(struct kvm_vcpu *vcpu)\n{\n\tstatic const char kvm_emulate_prefix[] = { __KVM_EMULATE_PREFIX };\n\tint emul_type = EMULTYPE_TRAP_UD;\n\tchar sig[5]; /* ud2; .ascii \"kvm\" */\n\tstruct x86_exception e;\n\n\tif (force_emulation_prefix &&\n\t    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),\n\t\t\t\tsig, sizeof(sig), &e) == 0 &&\n\t    memcmp(sig, kvm_emulate_prefix, sizeof(sig)) == 0) {\n\t\tkvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig));\n\t\temul_type = EMULTYPE_TRAP_UD_FORCED;\n\t}\n\n\treturn kvm_emulate_instruction(vcpu, emul_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_invalid_opcode",
          "args": [
            "intr_info"
          ],
          "line": 4609
        },
        "resolved": true,
        "details": {
          "function_name": "is_invalid_opcode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmcs.h",
          "lines": "97-100",
          "snippet": "static inline bool is_invalid_opcode(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, UD_VECTOR);\n}",
          "includes": [
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm.h>",
            "#include <linux/nospec.h>",
            "#include <linux/list.h>",
            "#include <linux/ktime.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/kvm.h>\n#include <linux/nospec.h>\n#include <linux/list.h>\n#include <linux/ktime.h>\n\nstatic inline bool is_invalid_opcode(u32 intr_info)\n{\n\treturn is_exception_n(intr_info, UD_VECTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nmi",
          "args": [
            "intr_info"
          ],
          "line": 4606
        },
        "resolved": true,
        "details": {
          "function_name": "is_nmi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmcs.h",
          "lines": "121-125",
          "snippet": "static inline bool is_nmi(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);\n}",
          "includes": [
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm.h>",
            "#include <linux/nospec.h>",
            "#include <linux/list.h>",
            "#include <linux/ktime.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/kvm.h>\n#include <linux/nospec.h>\n#include <linux/list.h>\n#include <linux/ktime.h>\n\nstatic inline bool is_nmi(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VALID_MASK))\n\t\t== (INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_machine_check",
          "args": [
            "intr_info"
          ],
          "line": 4606
        },
        "resolved": true,
        "details": {
          "function_name": "is_machine_check",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmcs.h",
          "lines": "107-112",
          "snippet": "static inline bool is_machine_check(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | MC_VECTOR | INTR_INFO_VALID_MASK);\n}",
          "includes": [
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm.h>",
            "#include <linux/nospec.h>",
            "#include <linux/list.h>",
            "#include <linux/ktime.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/kvm.h>\n#include <linux/nospec.h>\n#include <linux/list.h>\n#include <linux/ktime.h>\n\nstatic inline bool is_machine_check(u32 intr_info)\n{\n\treturn (intr_info & (INTR_INFO_INTR_TYPE_MASK | INTR_INFO_VECTOR_MASK |\n\t\t\t     INTR_INFO_VALID_MASK)) ==\n\t\t(INTR_TYPE_HARD_EXCEPTION | MC_VECTOR | INTR_INFO_VALID_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4597
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_exception_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 intr_info, ex_no, error_code;\n\tunsigned long cr2, rip, dr6;\n\tu32 vect_info;\n\n\tvect_info = vmx->idt_vectoring_info;\n\tintr_info = vmx->exit_intr_info;\n\n\tif (is_machine_check(intr_info) || is_nmi(intr_info))\n\t\treturn 1; /* handled by handle_exception_nmi_irqoff() */\n\n\tif (is_invalid_opcode(intr_info))\n\t\treturn handle_ud(vcpu);\n\n\terror_code = 0;\n\tif (intr_info & INTR_INFO_DELIVER_CODE_MASK)\n\t\terror_code = vmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\n\tif (!vmx->rmode.vm86_active && is_gp_fault(intr_info)) {\n\t\tWARN_ON_ONCE(!enable_vmware_backdoor);\n\n\t\t/*\n\t\t * VMware backdoor emulation on #GP interception only handles\n\t\t * IN{S}, OUT{S}, and RDPMC, none of which generate a non-zero\n\t\t * error code on #GP.\n\t\t */\n\t\tif (error_code) {\n\t\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n\t\t\treturn 1;\n\t\t}\n\t\treturn kvm_emulate_instruction(vcpu, EMULTYPE_VMWARE_GP);\n\t}\n\n\t/*\n\t * The #PF with PFEC.RSVD = 1 indicates the guest is accessing\n\t * MMIO, it is better to report an internal error.\n\t * See the comments in vmx_handle_exit.\n\t */\n\tif ((vect_info & VECTORING_INFO_VALID_MASK) &&\n\t    !(is_page_fault(intr_info) && !(error_code & PFERR_RSVD_MASK))) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_SIMUL_EX;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vect_info;\n\t\tvcpu->run->internal.data[1] = intr_info;\n\t\tvcpu->run->internal.data[2] = error_code;\n\t\treturn 0;\n\t}\n\n\tif (is_page_fault(intr_info)) {\n\t\tcr2 = vmcs_readl(EXIT_QUALIFICATION);\n\t\t/* EPT won't cause page fault directly */\n\t\tWARN_ON_ONCE(!vcpu->arch.apf.host_apf_reason && enable_ept);\n\t\treturn kvm_handle_page_fault(vcpu, error_code, cr2, NULL, 0);\n\t}\n\n\tex_no = intr_info & INTR_INFO_VECTOR_MASK;\n\n\tif (vmx->rmode.vm86_active && rmode_exception(vcpu, ex_no))\n\t\treturn handle_rmode_exception(vcpu, ex_no, error_code);\n\n\tswitch (ex_no) {\n\tcase AC_VECTOR:\n\t\tkvm_queue_exception_e(vcpu, AC_VECTOR, error_code);\n\t\treturn 1;\n\tcase DB_VECTOR:\n\t\tdr6 = vmcs_readl(EXIT_QUALIFICATION);\n\t\tif (!(vcpu->guest_debug &\n\t\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))) {\n\t\t\tvcpu->arch.dr6 &= ~DR_TRAP_BITS;\n\t\t\tvcpu->arch.dr6 |= dr6 | DR6_RTM;\n\t\t\tif (is_icebp(intr_info))\n\t\t\t\tWARN_ON(!skip_emulated_instruction(vcpu));\n\n\t\t\tkvm_queue_exception(vcpu, DB_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_run->debug.arch.dr6 = dr6 | DR6_FIXED_1;\n\t\tkvm_run->debug.arch.dr7 = vmcs_readl(GUEST_DR7);\n\t\t/* fall through */\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject #BP from\n\t\t * user space while in guest debugging mode. Reading it for\n\t\t * #DB as well causes no harm, it is not used in that case.\n\t\t */\n\t\tvmx->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\trip = kvm_rip_read(vcpu);\n\t\tkvm_run->debug.arch.pc = vmcs_readl(GUEST_CS_BASE) + rip;\n\t\tkvm_run->debug.arch.exception = ex_no;\n\t\tbreak;\n\tdefault:\n\t\tkvm_run->exit_reason = KVM_EXIT_EXCEPTION;\n\t\tkvm_run->ex.exception = ex_no;\n\t\tkvm_run->ex.error_code = error_code;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_machine_check",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4589-4593",
    "snippet": "static int handle_machine_check(struct kvm_vcpu *vcpu)\n{\n\t/* handled by vmx_vcpu_run() */\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_machine_check(struct kvm_vcpu *vcpu)\n{\n\t/* handled by vmx_vcpu_run() */\n\treturn 1;\n}"
  },
  {
    "function_name": "kvm_machine_check",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4577-4587",
    "snippet": "static void kvm_machine_check(void)\n{\n#if defined(CONFIG_X86_MCE) && defined(CONFIG_X86_64)\n\tstruct pt_regs regs = {\n\t\t.cs = 3, /* Fake ring 3 no matter what the guest ran on */\n\t\t.flags = X86_EFLAGS_IF,\n\t};\n\n\tdo_machine_check(&regs, 0);\n#endif\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_machine_check",
          "args": [
            "&regs",
            "0"
          ],
          "line": 4585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void kvm_machine_check(void)\n{\n#if defined(CONFIG_X86_MCE) && defined(CONFIG_X86_64)\n\tstruct pt_regs regs = {\n\t\t.cs = 3, /* Fake ring 3 no matter what the guest ran on */\n\t\t.flags = X86_EFLAGS_IF,\n\t};\n\n\tdo_machine_check(&regs, 0);\n#endif\n}"
  },
  {
    "function_name": "handle_rmode_exception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4543-4568",
    "snippet": "static int handle_rmode_exception(struct kvm_vcpu *vcpu,\n\t\t\t\t  int vec, u32 err_code)\n{\n\t/*\n\t * Instruction with address size override prefix opcode 0x67\n\t * Cause the #SS fault with 0 error code in VM86 mode.\n\t */\n\tif (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {\n\t\tif (kvm_emulate_instruction(vcpu, 0)) {\n\t\t\tif (vcpu->arch.halt_request) {\n\t\t\t\tvcpu->arch.halt_request = 0;\n\t\t\t\treturn kvm_vcpu_halt(vcpu);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Forward all other exceptions that are valid in real mode.\n\t * FIXME: Breaks guest debugging in real mode, needs to be fixed with\n\t *        the required debugging infrastructure rework.\n\t */\n\tkvm_queue_exception(vcpu, vec);\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "vec"
          ],
          "line": 4566
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_halt",
          "args": [
            "vcpu"
          ],
          "line": 4554
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_halt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7422-7432",
          "snippet": "int kvm_vcpu_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (lapic_in_kernel(vcpu)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_vcpu_halt(struct kvm_vcpu *vcpu)\n{\n\t++vcpu->stat.halt_exits;\n\tif (lapic_in_kernel(vcpu)) {\n\t\tvcpu->arch.mp_state = KVM_MP_STATE_HALTED;\n\t\treturn 1;\n\t} else {\n\t\tvcpu->run->exit_reason = KVM_EXIT_HLT;\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 4551
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int handle_rmode_exception(struct kvm_vcpu *vcpu,\n\t\t\t\t  int vec, u32 err_code)\n{\n\t/*\n\t * Instruction with address size override prefix opcode 0x67\n\t * Cause the #SS fault with 0 error code in VM86 mode.\n\t */\n\tif (((vec == GP_VECTOR) || (vec == SS_VECTOR)) && err_code == 0) {\n\t\tif (kvm_emulate_instruction(vcpu, 0)) {\n\t\t\tif (vcpu->arch.halt_request) {\n\t\t\t\tvcpu->arch.halt_request = 0;\n\t\t\t\treturn kvm_vcpu_halt(vcpu);\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Forward all other exceptions that are valid in real mode.\n\t * FIXME: Breaks guest debugging in real mode, needs to be fixed with\n\t *        the required debugging infrastructure rework.\n\t */\n\tkvm_queue_exception(vcpu, vec);\n\treturn 1;\n}"
  },
  {
    "function_name": "rmode_exception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4512-4541",
    "snippet": "static bool rmode_exception(struct kvm_vcpu *vcpu, int vec)\n{\n\tswitch (vec) {\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject the exception\n\t\t * from user space while in guest debugging mode.\n\t\t */\n\t\tto_vmx(vcpu)->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DB_VECTOR:\n\t\tif (vcpu->guest_debug &\n\t\t\t(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DE_VECTOR:\n\tcase OF_VECTOR:\n\tcase BR_VECTOR:\n\tcase UD_VECTOR:\n\tcase DF_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\tcase MF_VECTOR:\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "VM_EXIT_INSTRUCTION_LEN"
          ],
          "line": 4521
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4520
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool rmode_exception(struct kvm_vcpu *vcpu, int vec)\n{\n\tswitch (vec) {\n\tcase BP_VECTOR:\n\t\t/*\n\t\t * Update instruction length as we may reinject the exception\n\t\t * from user space while in guest debugging mode.\n\t\t */\n\t\tto_vmx(vcpu)->vcpu.arch.event_exit_inst_len =\n\t\t\tvmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DB_VECTOR:\n\t\tif (vcpu->guest_debug &\n\t\t\t(KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))\n\t\t\treturn false;\n\t\t/* fall through */\n\tcase DE_VECTOR:\n\tcase OF_VECTOR:\n\tcase BR_VECTOR:\n\tcase UD_VECTOR:\n\tcase DF_VECTOR:\n\tcase SS_VECTOR:\n\tcase GP_VECTOR:\n\tcase MF_VECTOR:\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "vmx_set_identity_map_addr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4506-4510",
    "snippet": "static int vmx_set_identity_map_addr(struct kvm *kvm, u64 ident_addr)\n{\n\tto_kvm_vmx(kvm)->ept_identity_map_addr = ident_addr;\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_kvm_vmx",
          "args": [
            "kvm"
          ],
          "line": 4508
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "474-477",
          "snippet": "static inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int vmx_set_identity_map_addr(struct kvm *kvm, u64 ident_addr)\n{\n\tto_kvm_vmx(kvm)->ept_identity_map_addr = ident_addr;\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_set_tss_addr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4488-4504",
    "snippet": "static int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\tint ret;\n\n\tif (enable_unrestricted_guest)\n\t\treturn 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tret = __x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, addr,\n\t\t\t\t      PAGE_SIZE * 3);\n\tmutex_unlock(&kvm->slots_lock);\n\n\tif (ret)\n\t\treturn ret;\n\tto_kvm_vmx(kvm)->tss_addr = addr;\n\treturn init_rmode_tss(kvm);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_rmode_tss",
          "args": [
            "kvm"
          ],
          "line": 4503
        },
        "resolved": true,
        "details": {
          "function_name": "init_rmode_tss",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3449-3478",
          "snippet": "static int init_rmode_tss(struct kvm *kvm)\n{\n\tgfn_t fn;\n\tu16 data = 0;\n\tint idx, r;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tfn = to_kvm_vmx(kvm)->tss_addr >> PAGE_SHIFT;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;\n\tr = kvm_write_guest_page(kvm, fn++, &data,\n\t\t\tTSS_IOPB_BASE_OFFSET, sizeof(u16));\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn++, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = ~0;\n\tr = kvm_write_guest_page(kvm, fn, &data,\n\t\t\t\t RMODE_TSS_SIZE - 2 * PAGE_SIZE - 1,\n\t\t\t\t sizeof(u8));\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int init_rmode_tss(struct kvm *kvm)\n{\n\tgfn_t fn;\n\tu16 data = 0;\n\tint idx, r;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tfn = to_kvm_vmx(kvm)->tss_addr >> PAGE_SHIFT;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;\n\tr = kvm_write_guest_page(kvm, fn++, &data,\n\t\t\tTSS_IOPB_BASE_OFFSET, sizeof(u16));\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn++, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = ~0;\n\tr = kvm_write_guest_page(kvm, fn, &data,\n\t\t\t\t RMODE_TSS_SIZE - 2 * PAGE_SIZE - 1,\n\t\t\t\t sizeof(u8));\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kvm_vmx",
          "args": [
            "kvm"
          ],
          "line": 4502
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "474-477",
          "snippet": "static inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 4498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__x86_set_memory_region",
          "args": [
            "kvm",
            "TSS_PRIVATE_MEMSLOT",
            "addr",
            "PAGE_SIZE * 3"
          ],
          "line": 4496
        },
        "resolved": true,
        "details": {
          "function_name": "__x86_set_memory_region",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9800-9854",
          "snippet": "int __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva, uninitialized_var(old_npages);\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (slot && slot->npages)\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot || !slot->npages)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Stuff a non-canonical value to catch use-after-delete.  This\n\t\t * ends up being 0 on 32-bit KVM, but there's no better\n\t\t * alternative.\n\t\t */\n\t\thva = (unsigned long)(0xdeadull << 48);\n\t\told_npages = slot->npages;\n\t}\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size)\n\t\tvm_munmap(hva, old_npages * PAGE_SIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva, uninitialized_var(old_npages);\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (slot && slot->npages)\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot || !slot->npages)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Stuff a non-canonical value to catch use-after-delete.  This\n\t\t * ends up being 0 on 32-bit KVM, but there's no better\n\t\t * alternative.\n\t\t */\n\t\thva = (unsigned long)(0xdeadull << 48);\n\t\told_npages = slot->npages;\n\t}\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size)\n\t\tvm_munmap(hva, old_npages * PAGE_SIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 4495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int vmx_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\tint ret;\n\n\tif (enable_unrestricted_guest)\n\t\treturn 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tret = __x86_set_memory_region(kvm, TSS_PRIVATE_MEMSLOT, addr,\n\t\t\t\t      PAGE_SIZE * 3);\n\tmutex_unlock(&kvm->slots_lock);\n\n\tif (ret)\n\t\treturn ret;\n\tto_kvm_vmx(kvm)->tss_addr = addr;\n\treturn init_rmode_tss(kvm);\n}"
  },
  {
    "function_name": "vmx_interrupt_allowed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4475-4486",
    "snippet": "static int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn false;\n\n\tif (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn true;\n\n\treturn (vmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO"
          ],
          "line": 4484
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_RFLAGS"
          ],
          "line": 4483
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_exit_on_intr",
          "args": [
            "vcpu"
          ],
          "line": 4480
        },
        "resolved": true,
        "details": {
          "function_name": "nested_exit_on_intr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "253-257",
          "snippet": "static inline bool nested_exit_on_intr(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_EXT_INTR_MASK;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_exit_on_intr(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_EXT_INTR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 4480
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4477
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn false;\n\n\tif (is_guest_mode(vcpu) && nested_exit_on_intr(vcpu))\n\t\treturn true;\n\n\treturn (vmcs_readl(GUEST_RFLAGS) & X86_EFLAGS_IF) &&\n\t\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t\t(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS));\n}"
  },
  {
    "function_name": "vmx_nmi_allowed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4461-4473",
    "snippet": "static int vmx_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (!enable_vnmi &&\n\t    to_vmx(vcpu)->loaded_vmcs->soft_vnmi_blocked)\n\t\treturn 0;\n\n\treturn\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t  (GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI\n\t\t   | GUEST_INTR_STATE_NMI));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO"
          ],
          "line": 4470
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4467
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tif (to_vmx(vcpu)->nested.nested_run_pending)\n\t\treturn 0;\n\n\tif (!enable_vnmi &&\n\t    to_vmx(vcpu)->loaded_vmcs->soft_vnmi_blocked)\n\t\treturn 0;\n\n\treturn\t!(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) &\n\t\t  (GUEST_INTR_STATE_MOV_SS | GUEST_INTR_STATE_STI\n\t\t   | GUEST_INTR_STATE_NMI));\n}"
  },
  {
    "function_name": "vmx_set_nmi_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4441-4459",
    "snippet": "void vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->soft_vnmi_blocked != masked) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = masked;\n\t\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_clear_bits",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO",
            "GUEST_INTR_STATE_NMI"
          ],
          "line": 4456
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "214-222",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_set_bits",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO",
            "GUEST_INTR_STATE_NMI"
          ],
          "line": 4453
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "224-232",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4443
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\tif (vmx->loaded_vmcs->soft_vnmi_blocked != masked) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = masked;\n\t\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t\t}\n\t} else {\n\t\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\t\tif (masked)\n\t\t\tvmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t      GUEST_INTR_STATE_NMI);\n\t\telse\n\t\t\tvmcs_clear_bits(GUEST_INTERRUPTIBILITY_INFO,\n\t\t\t\t\tGUEST_INTR_STATE_NMI);\n\t}\n}"
  },
  {
    "function_name": "vmx_get_nmi_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4427-4439",
    "snippet": "bool vmx_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool masked;\n\n\tif (!enable_vnmi)\n\t\treturn vmx->loaded_vmcs->soft_vnmi_blocked;\n\tif (vmx->loaded_vmcs->nmi_known_unmasked)\n\t\treturn false;\n\tmasked = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_NMI;\n\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\treturn masked;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO"
          ],
          "line": 4436
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4429
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nbool vmx_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool masked;\n\n\tif (!enable_vnmi)\n\t\treturn vmx->loaded_vmcs->soft_vnmi_blocked;\n\tif (vmx->loaded_vmcs->nmi_known_unmasked)\n\t\treturn false;\n\tmasked = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_NMI;\n\tvmx->loaded_vmcs->nmi_known_unmasked = !masked;\n\treturn masked;\n}"
  },
  {
    "function_name": "vmx_inject_nmi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4396-4425",
    "snippet": "static void vmx_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\t/*\n\t\t * Tracking the NMI-blocked state in software is built upon\n\t\t * finding the next open IRQ window. This, in turn, depends on\n\t\t * well-behaving guests: They have to keep IRQs disabled at\n\t\t * least as long as the NMI handler runs. Otherwise we may\n\t\t * cause NMI nesting, maybe breaking the guest. But as this is\n\t\t * highly unlikely, we can live with the residual risk.\n\t\t */\n\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 1;\n\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t}\n\n\t++vcpu->stat.nmi_injections;\n\tvmx->loaded_vmcs->nmi_known_unmasked = false;\n\n\tif (vmx->rmode.vm86_active) {\n\t\tkvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0);\n\t\treturn;\n\t}\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);\n\n\tvmx_clear_hlt(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_clear_hlt",
          "args": [
            "vcpu"
          ],
          "line": 4424
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_clear_hlt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1610-1621",
          "snippet": "static void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "VM_ENTRY_INTR_INFO_FIELD",
            "INTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR"
          ],
          "line": 4421
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_inject_realmode_interrupt",
          "args": [
            "vcpu",
            "NMI_VECTOR",
            "0"
          ],
          "line": 4417
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_inject_realmode_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6435-6454",
          "snippet": "void kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t} else {\n\t\tctxt->eip = ctxt->_eip;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tkvm_set_rflags(vcpu, ctxt->eflags);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t} else {\n\t\tctxt->eip = ctxt->_eip;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tkvm_set_rflags(vcpu, ctxt->eflags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4398
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!enable_vnmi) {\n\t\t/*\n\t\t * Tracking the NMI-blocked state in software is built upon\n\t\t * finding the next open IRQ window. This, in turn, depends on\n\t\t * well-behaving guests: They have to keep IRQs disabled at\n\t\t * least as long as the NMI handler runs. Otherwise we may\n\t\t * cause NMI nesting, maybe breaking the guest. But as this is\n\t\t * highly unlikely, we can live with the residual risk.\n\t\t */\n\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 1;\n\t\tvmx->loaded_vmcs->vnmi_blocked_time = 0;\n\t}\n\n\t++vcpu->stat.nmi_injections;\n\tvmx->loaded_vmcs->nmi_known_unmasked = false;\n\n\tif (vmx->rmode.vm86_active) {\n\t\tkvm_inject_realmode_interrupt(vcpu, NMI_VECTOR, 0);\n\t\treturn;\n\t}\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD,\n\t\t\tINTR_TYPE_NMI_INTR | INTR_INFO_VALID_MASK | NMI_VECTOR);\n\n\tvmx_clear_hlt(vcpu);\n}"
  },
  {
    "function_name": "vmx_inject_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4368-4394",
    "snippet": "static void vmx_inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tuint32_t intr;\n\tint irq = vcpu->arch.interrupt.nr;\n\n\ttrace_kvm_inj_virq(irq);\n\n\t++vcpu->stat.irq_injections;\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (vcpu->arch.interrupt.soft)\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tkvm_inject_realmode_interrupt(vcpu, irq, inc_eip);\n\t\treturn;\n\t}\n\tintr = irq | INTR_INFO_VALID_MASK;\n\tif (vcpu->arch.interrupt.soft) {\n\t\tintr |= INTR_TYPE_SOFT_INTR;\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t} else\n\t\tintr |= INTR_TYPE_EXT_INTR;\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr);\n\n\tvmx_clear_hlt(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_clear_hlt",
          "args": [
            "vcpu"
          ],
          "line": 4393
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_clear_hlt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1610-1621",
          "snippet": "static void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "VM_ENTRY_INTR_INFO_FIELD",
            "intr"
          ],
          "line": 4391
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_inject_realmode_interrupt",
          "args": [
            "vcpu",
            "irq",
            "inc_eip"
          ],
          "line": 4381
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_inject_realmode_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6435-6454",
          "snippet": "void kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t} else {\n\t\tctxt->eip = ctxt->_eip;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tkvm_set_rflags(vcpu, ctxt->eflags);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t} else {\n\t\tctxt->eip = ctxt->_eip;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tkvm_set_rflags(vcpu, ctxt->eflags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_inj_virq",
          "args": [
            "irq"
          ],
          "line": 4374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4370
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_inject_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tuint32_t intr;\n\tint irq = vcpu->arch.interrupt.nr;\n\n\ttrace_kvm_inj_virq(irq);\n\n\t++vcpu->stat.irq_injections;\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (vcpu->arch.interrupt.soft)\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tkvm_inject_realmode_interrupt(vcpu, irq, inc_eip);\n\t\treturn;\n\t}\n\tintr = irq | INTR_INFO_VALID_MASK;\n\tif (vcpu->arch.interrupt.soft) {\n\t\tintr |= INTR_TYPE_SOFT_INTR;\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t} else\n\t\tintr |= INTR_TYPE_EXT_INTR;\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr);\n\n\tvmx_clear_hlt(vcpu);\n}"
  },
  {
    "function_name": "enable_nmi_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4357-4366",
    "snippet": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tif (!enable_vnmi ||\n\t    vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tenable_irq_window(vcpu);\n\t\treturn;\n\t}\n\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_NMI_WINDOW_EXITING);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exec_controls_setbit",
          "args": [
            "to_vmx(vcpu)",
            "CPU_BASED_NMI_WINDOW_EXITING"
          ],
          "line": 4365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4365
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enable_irq_window",
          "args": [
            "vcpu"
          ],
          "line": 4361
        },
        "resolved": true,
        "details": {
          "function_name": "enable_irq_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4352-4355",
          "snippet": "static void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO"
          ],
          "line": 4360
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tif (!enable_vnmi ||\n\t    vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_STI) {\n\t\tenable_irq_window(vcpu);\n\t\treturn;\n\t}\n\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_NMI_WINDOW_EXITING);\n}"
  },
  {
    "function_name": "enable_irq_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4352-4355",
    "snippet": "static void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exec_controls_setbit",
          "args": [
            "to_vmx(vcpu)",
            "CPU_BASED_INTR_WINDOW_EXITING"
          ],
          "line": 4354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4354
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\texec_controls_setbit(to_vmx(vcpu), CPU_BASED_INTR_WINDOW_EXITING);\n}"
  },
  {
    "function_name": "vmx_vcpu_reset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4257-4350",
    "snippet": "static void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct msr_data apic_base_msr;\n\tu64 cr0;\n\n\tvmx->rmode.vm86_active = 0;\n\tvmx->spec_ctrl = 0;\n\n\tvmx->msr_ia32_umwait_control = 0;\n\n\tvmx->vcpu.arch.regs[VCPU_REGS_RDX] = get_rdx_init_val();\n\tvmx->hv_deadline_tsc = -1;\n\tkvm_set_cr8(vcpu, 0);\n\n\tif (!init_event) {\n\t\tapic_base_msr.data = APIC_DEFAULT_PHYS_BASE |\n\t\t\t\t     MSR_IA32_APICBASE_ENABLE;\n\t\tif (kvm_vcpu_is_reset_bsp(vcpu))\n\t\t\tapic_base_msr.data |= MSR_IA32_APICBASE_BSP;\n\t\tapic_base_msr.host_initiated = true;\n\t\tkvm_set_apic_base(vcpu, &apic_base_msr);\n\t}\n\n\tvmx_segment_cache_clear(vmx);\n\n\tseg_setup(VCPU_SREG_CS);\n\tvmcs_write16(GUEST_CS_SELECTOR, 0xf000);\n\tvmcs_writel(GUEST_CS_BASE, 0xffff0000ul);\n\n\tseg_setup(VCPU_SREG_DS);\n\tseg_setup(VCPU_SREG_ES);\n\tseg_setup(VCPU_SREG_FS);\n\tseg_setup(VCPU_SREG_GS);\n\tseg_setup(VCPU_SREG_SS);\n\n\tvmcs_write16(GUEST_TR_SELECTOR, 0);\n\tvmcs_writel(GUEST_TR_BASE, 0);\n\tvmcs_write32(GUEST_TR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tvmcs_write16(GUEST_LDTR_SELECTOR, 0);\n\tvmcs_writel(GUEST_LDTR_BASE, 0);\n\tvmcs_write32(GUEST_LDTR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, 0x00082);\n\n\tif (!init_event) {\n\t\tvmcs_write32(GUEST_SYSENTER_CS, 0);\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, 0);\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, 0);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n\t}\n\n\tkvm_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\tkvm_rip_write(vcpu, 0xfff0);\n\n\tvmcs_writel(GUEST_GDTR_BASE, 0);\n\tvmcs_write32(GUEST_GDTR_LIMIT, 0xffff);\n\n\tvmcs_writel(GUEST_IDTR_BASE, 0);\n\tvmcs_write32(GUEST_IDTR_LIMIT, 0xffff);\n\n\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, 0);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS, 0);\n\tif (kvm_mpx_supported())\n\t\tvmcs_write64(GUEST_BNDCFGS, 0);\n\n\tsetup_msrs(vmx);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);  /* 22.2.1 */\n\n\tif (cpu_has_vmx_tpr_shadow() && !init_event) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR, 0);\n\t\tif (cpu_need_tpr_shadow(vcpu))\n\t\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\t     __pa(vcpu->arch.apic->regs));\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t}\n\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\tcr0 = X86_CR0_NW | X86_CR0_CD | X86_CR0_ET;\n\tvmx->vcpu.arch.cr0 = cr0;\n\tvmx_set_cr0(vcpu, cr0); /* enter rmode */\n\tvmx_set_cr4(vcpu, 0);\n\tvmx_set_efer(vcpu, 0);\n\n\tupdate_exception_bitmap(vcpu);\n\n\tvpid_sync_context(vmx->vpid);\n\tif (init_event)\n\t\tvmx_clear_hlt(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_clear_hlt",
          "args": [
            "vcpu"
          ],
          "line": 4349
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_clear_hlt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1610-1621",
          "snippet": "static void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vpid_sync_context",
          "args": [
            "vmx->vpid"
          ],
          "line": 4347
        },
        "resolved": true,
        "details": {
          "function_name": "vpid_sync_context",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "299-305",
          "snippet": "static inline void vpid_sync_context(int vpid)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vpid);\n\telse\n\t\tvpid_sync_vcpu_global();\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void vpid_sync_context(int vpid)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vpid);\n\telse\n\t\tvpid_sync_vcpu_global();\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_exception_bitmap",
          "args": [
            "vcpu"
          ],
          "line": 4345
        },
        "resolved": true,
        "details": {
          "function_name": "update_exception_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "761-793",
          "snippet": "void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\teb |= (1u << GP_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\teb |= (1u << GP_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_set_efer",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 4343
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_efer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2798-2816",
          "snippet": "void vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_set_cr4",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 4342
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_cr4",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3027-3100",
          "snippet": "int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\t/*\n\t * Pass through host's Machine Check Enable value to hw_cr4, which\n\t * is in force while we are in guest mode.  Do not let guests control\n\t * this bit, even if host CR4.MCE == 0.\n\t */\n\tunsigned long hw_cr4;\n\n\thw_cr4 = (cr4_read_shadow() & X86_CR4_MCE) | (cr4 & ~X86_CR4_MCE);\n\tif (enable_unrestricted_guest)\n\t\thw_cr4 |= KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse if (vmx->rmode.vm86_active)\n\t\thw_cr4 |= KVM_RMODE_VM_CR4_ALWAYS_ON;\n\telse\n\t\thw_cr4 |= KVM_PMODE_VM_CR4_ALWAYS_ON;\n\n\tif (!boot_cpu_has(X86_FEATURE_UMIP) && vmx_umip_emulated()) {\n\t\tif (cr4 & X86_CR4_UMIP) {\n\t\t\tsecondary_exec_controls_setbit(vmx, SECONDARY_EXEC_DESC);\n\t\t\thw_cr4 &= ~X86_CR4_UMIP;\n\t\t} else if (!is_guest_mode(vcpu) ||\n\t\t\t!nested_cpu_has2(get_vmcs12(vcpu), SECONDARY_EXEC_DESC)) {\n\t\t\tsecondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_DESC);\n\t\t}\n\t}\n\n\tif (cr4 & X86_CR4_VMXE) {\n\t\t/*\n\t\t * To use VMXON (and later other VMX instructions), a guest\n\t\t * must first be able to turn on cr4.VMXE (see handle_vmon()).\n\t\t * So basically the check on whether to allow nested VMX\n\t\t * is here.  We operate under the default treatment of SMM,\n\t\t * so VMX cannot be enabled under SMM.\n\t\t */\n\t\tif (!nested_vmx_allowed(vcpu) || is_smm(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (vmx->nested.vmxon && !nested_cr4_valid(vcpu, cr4))\n\t\treturn 1;\n\n\tvcpu->arch.cr4 = cr4;\n\n\tif (!enable_unrestricted_guest) {\n\t\tif (enable_ept) {\n\t\t\tif (!is_paging(vcpu)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in\n\t\t * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs\n\t\t * to be manually disabled when guest switches to non-paging\n\t\t * mode.\n\t\t *\n\t\t * If !enable_unrestricted_guest, the CPU is always running\n\t\t * with CR0.PG=1 and CR4 needs to be modified.\n\t\t * If enable_unrestricted_guest, the CPU automatically\n\t\t * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.\n\t\t */\n\t\tif (!is_paging(vcpu))\n\t\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\t}\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\treturn 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)",
            "#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)",
            "#define KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR4_VMXE"
          ],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR4_VMXE\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nint vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\t/*\n\t * Pass through host's Machine Check Enable value to hw_cr4, which\n\t * is in force while we are in guest mode.  Do not let guests control\n\t * this bit, even if host CR4.MCE == 0.\n\t */\n\tunsigned long hw_cr4;\n\n\thw_cr4 = (cr4_read_shadow() & X86_CR4_MCE) | (cr4 & ~X86_CR4_MCE);\n\tif (enable_unrestricted_guest)\n\t\thw_cr4 |= KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse if (vmx->rmode.vm86_active)\n\t\thw_cr4 |= KVM_RMODE_VM_CR4_ALWAYS_ON;\n\telse\n\t\thw_cr4 |= KVM_PMODE_VM_CR4_ALWAYS_ON;\n\n\tif (!boot_cpu_has(X86_FEATURE_UMIP) && vmx_umip_emulated()) {\n\t\tif (cr4 & X86_CR4_UMIP) {\n\t\t\tsecondary_exec_controls_setbit(vmx, SECONDARY_EXEC_DESC);\n\t\t\thw_cr4 &= ~X86_CR4_UMIP;\n\t\t} else if (!is_guest_mode(vcpu) ||\n\t\t\t!nested_cpu_has2(get_vmcs12(vcpu), SECONDARY_EXEC_DESC)) {\n\t\t\tsecondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_DESC);\n\t\t}\n\t}\n\n\tif (cr4 & X86_CR4_VMXE) {\n\t\t/*\n\t\t * To use VMXON (and later other VMX instructions), a guest\n\t\t * must first be able to turn on cr4.VMXE (see handle_vmon()).\n\t\t * So basically the check on whether to allow nested VMX\n\t\t * is here.  We operate under the default treatment of SMM,\n\t\t * so VMX cannot be enabled under SMM.\n\t\t */\n\t\tif (!nested_vmx_allowed(vcpu) || is_smm(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (vmx->nested.vmxon && !nested_cr4_valid(vcpu, cr4))\n\t\treturn 1;\n\n\tvcpu->arch.cr4 = cr4;\n\n\tif (!enable_unrestricted_guest) {\n\t\tif (enable_ept) {\n\t\t\tif (!is_paging(vcpu)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in\n\t\t * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs\n\t\t * to be manually disabled when guest switches to non-paging\n\t\t * mode.\n\t\t *\n\t\t * If !enable_unrestricted_guest, the CPU is always running\n\t\t * with CR0.PG=1 and CR4 needs to be modified.\n\t\t * If enable_unrestricted_guest, the CPU automatically\n\t\t * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.\n\t\t */\n\t\tif (!is_paging(vcpu))\n\t\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\t}\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_set_cr0",
          "args": [
            "vcpu",
            "cr0"
          ],
          "line": 4341
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_cr0",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2930-2966",
          "snippet": "void vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0;\n\n\thw_cr0 = (cr0 & ~KVM_VM_CR0_ALWAYS_OFF);\n\tif (enable_unrestricted_guest)\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept && !enable_unrestricted_guest)\n\t\tept_update_paging_mode_cr0(&hw_cr0, cr0, vcpu);\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = emulation_required(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | \t\\\n\t X86_CR0_WP | X86_CR0_PG | X86_CR0_PE)",
            "#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR0_NE",
            "#define KVM_VM_CR0_ALWAYS_OFF (X86_CR0_NW | X86_CR0_CD)"
          ],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | \t\\\n\t X86_CR0_WP | X86_CR0_PG | X86_CR0_PE)\n#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR0_NE\n#define KVM_VM_CR0_ALWAYS_OFF (X86_CR0_NW | X86_CR0_CD)\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0;\n\n\thw_cr0 = (cr0 & ~KVM_VM_CR0_ALWAYS_OFF);\n\tif (enable_unrestricted_guest)\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept && !enable_unrestricted_guest)\n\t\tept_update_paging_mode_cr0(&hw_cr0, cr0, vcpu);\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = emulation_required(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_APIC_PAGE_RELOAD",
            "vcpu"
          ],
          "line": 4337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "TPR_THRESHOLD",
            "0"
          ],
          "line": 4334
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write64",
          "args": [
            "VIRTUAL_APIC_PAGE_ADDR",
            "__pa(vcpu->arch.apic->regs)"
          ],
          "line": 4332
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "193-203",
          "snippet": "static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vcpu->arch.apic->regs"
          ],
          "line": 4333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_need_tpr_shadow",
          "args": [
            "vcpu"
          ],
          "line": 4331
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_need_tpr_shadow",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "115-118",
          "snippet": "static inline bool cpu_need_tpr_shadow(struct kvm_vcpu *vcpu)\n{\n\treturn cpu_has_vmx_tpr_shadow() && lapic_in_kernel(vcpu);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_need_tpr_shadow(struct kvm_vcpu *vcpu)\n{\n\treturn cpu_has_vmx_tpr_shadow() && lapic_in_kernel(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_tpr_shadow",
          "args": [],
          "line": 4329
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_tpr_shadow",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "110-113",
          "snippet": "static inline bool cpu_has_vmx_tpr_shadow(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_tpr_shadow(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_TPR_SHADOW;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_msrs",
          "args": [
            "vmx"
          ],
          "line": 4325
        },
        "resolved": true,
        "details": {
          "function_name": "setup_msrs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1677-1714",
          "snippet": "static void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\t/*\n\t * The SYSCALL MSRs are only needed on long mode guests, and only\n\t * when EFER.SCE is set.\n\t */\n\tif (is_long_mode(&vmx->vcpu) && (vmx->vcpu.arch.efer & EFER_SCE)) {\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\tif (index >= 0 && guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_IA32_TSX_CTRL);\n\tif (index >= 0)\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\n\tvmx->save_nmsrs = save_nmsrs;\n\tvmx->guest_msrs_ready = false;\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_update_msr_bitmap(&vmx->vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\t/*\n\t * The SYSCALL MSRs are only needed on long mode guests, and only\n\t * when EFER.SCE is set.\n\t */\n\tif (is_long_mode(&vmx->vcpu) && (vmx->vcpu.arch.efer & EFER_SCE)) {\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\tif (index >= 0 && guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_IA32_TSX_CTRL);\n\tif (index >= 0)\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\n\tvmx->save_nmsrs = save_nmsrs;\n\tvmx->guest_msrs_ready = false;\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_update_msr_bitmap(&vmx->vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mpx_supported",
          "args": [],
          "line": 4322
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mpx_supported",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "277-281",
          "snippet": "static inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "GUEST_PENDING_DBG_EXCEPTIONS",
            "0"
          ],
          "line": 4321
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "vcpu",
            "0xfff0"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "91-94",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_rflags",
          "args": [
            "vcpu",
            "X86_EFLAGS_FIXED"
          ],
          "line": 4310
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_rflags",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10240-10244",
          "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write16",
          "args": [
            "GUEST_LDTR_SELECTOR",
            "0"
          ],
          "line": 4298
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "175-182",
          "snippet": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seg_setup",
          "args": [
            "VCPU_SREG_SS"
          ],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "seg_setup",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3521-3534",
          "snippet": "static void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; /* code segment */\n\n\tvmcs_write32(sf->ar_bytes, ar);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; /* code segment */\n\n\tvmcs_write32(sf->ar_bytes, ar);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_segment_cache_clear",
          "args": [
            "vmx"
          ],
          "line": 4281
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_cache_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "444-447",
          "snippet": "static inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_apic_base",
          "args": [
            "vcpu",
            "&apic_base_msr"
          ],
          "line": 4278
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_apic_base",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "362-381",
          "snippet": "int kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tenum lapic_mode old_mode = kvm_get_apic_mode(vcpu);\n\tenum lapic_mode new_mode = kvm_apic_mode(msr_info->data);\n\tu64 reserved_bits = ((~0ULL) << cpuid_maxphyaddr(vcpu)) | 0x2ff |\n\t\t(guest_cpuid_has(vcpu, X86_FEATURE_X2APIC) ? 0 : X2APIC_ENABLE);\n\n\tif ((msr_info->data & reserved_bits) != 0 || new_mode == LAPIC_MODE_INVALID)\n\t\treturn 1;\n\tif (!msr_info->host_initiated) {\n\t\tif (old_mode == LAPIC_MODE_X2APIC && new_mode == LAPIC_MODE_XAPIC)\n\t\t\treturn 1;\n\t\tif (old_mode == LAPIC_MODE_DISABLED && new_mode == LAPIC_MODE_X2APIC)\n\t\t\treturn 1;\n\t}\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\tkvm_recalculate_apic_map(vcpu->kvm);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_apic_base(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tenum lapic_mode old_mode = kvm_get_apic_mode(vcpu);\n\tenum lapic_mode new_mode = kvm_apic_mode(msr_info->data);\n\tu64 reserved_bits = ((~0ULL) << cpuid_maxphyaddr(vcpu)) | 0x2ff |\n\t\t(guest_cpuid_has(vcpu, X86_FEATURE_X2APIC) ? 0 : X2APIC_ENABLE);\n\n\tif ((msr_info->data & reserved_bits) != 0 || new_mode == LAPIC_MODE_INVALID)\n\t\treturn 1;\n\tif (!msr_info->host_initiated) {\n\t\tif (old_mode == LAPIC_MODE_X2APIC && new_mode == LAPIC_MODE_XAPIC)\n\t\t\treturn 1;\n\t\tif (old_mode == LAPIC_MODE_DISABLED && new_mode == LAPIC_MODE_X2APIC)\n\t\t\treturn 1;\n\t}\n\n\tkvm_lapic_set_base(vcpu, msr_info->data);\n\tkvm_recalculate_apic_map(vcpu->kvm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_is_reset_bsp",
          "args": [
            "vcpu"
          ],
          "line": 4275
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_is_reset_bsp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9688-9691",
          "snippet": "bool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr8",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 4270
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr8",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1029-1038",
          "snippet": "int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_rdx_init_val",
          "args": [],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 4259
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct msr_data apic_base_msr;\n\tu64 cr0;\n\n\tvmx->rmode.vm86_active = 0;\n\tvmx->spec_ctrl = 0;\n\n\tvmx->msr_ia32_umwait_control = 0;\n\n\tvmx->vcpu.arch.regs[VCPU_REGS_RDX] = get_rdx_init_val();\n\tvmx->hv_deadline_tsc = -1;\n\tkvm_set_cr8(vcpu, 0);\n\n\tif (!init_event) {\n\t\tapic_base_msr.data = APIC_DEFAULT_PHYS_BASE |\n\t\t\t\t     MSR_IA32_APICBASE_ENABLE;\n\t\tif (kvm_vcpu_is_reset_bsp(vcpu))\n\t\t\tapic_base_msr.data |= MSR_IA32_APICBASE_BSP;\n\t\tapic_base_msr.host_initiated = true;\n\t\tkvm_set_apic_base(vcpu, &apic_base_msr);\n\t}\n\n\tvmx_segment_cache_clear(vmx);\n\n\tseg_setup(VCPU_SREG_CS);\n\tvmcs_write16(GUEST_CS_SELECTOR, 0xf000);\n\tvmcs_writel(GUEST_CS_BASE, 0xffff0000ul);\n\n\tseg_setup(VCPU_SREG_DS);\n\tseg_setup(VCPU_SREG_ES);\n\tseg_setup(VCPU_SREG_FS);\n\tseg_setup(VCPU_SREG_GS);\n\tseg_setup(VCPU_SREG_SS);\n\n\tvmcs_write16(GUEST_TR_SELECTOR, 0);\n\tvmcs_writel(GUEST_TR_BASE, 0);\n\tvmcs_write32(GUEST_TR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tvmcs_write16(GUEST_LDTR_SELECTOR, 0);\n\tvmcs_writel(GUEST_LDTR_BASE, 0);\n\tvmcs_write32(GUEST_LDTR_LIMIT, 0xffff);\n\tvmcs_write32(GUEST_LDTR_AR_BYTES, 0x00082);\n\n\tif (!init_event) {\n\t\tvmcs_write32(GUEST_SYSENTER_CS, 0);\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, 0);\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, 0);\n\t\tvmcs_write64(GUEST_IA32_DEBUGCTL, 0);\n\t}\n\n\tkvm_set_rflags(vcpu, X86_EFLAGS_FIXED);\n\tkvm_rip_write(vcpu, 0xfff0);\n\n\tvmcs_writel(GUEST_GDTR_BASE, 0);\n\tvmcs_write32(GUEST_GDTR_LIMIT, 0xffff);\n\n\tvmcs_writel(GUEST_IDTR_BASE, 0);\n\tvmcs_write32(GUEST_IDTR_LIMIT, 0xffff);\n\n\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, 0);\n\tvmcs_writel(GUEST_PENDING_DBG_EXCEPTIONS, 0);\n\tif (kvm_mpx_supported())\n\t\tvmcs_write64(GUEST_BNDCFGS, 0);\n\n\tsetup_msrs(vmx);\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, 0);  /* 22.2.1 */\n\n\tif (cpu_has_vmx_tpr_shadow() && !init_event) {\n\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR, 0);\n\t\tif (cpu_need_tpr_shadow(vcpu))\n\t\t\tvmcs_write64(VIRTUAL_APIC_PAGE_ADDR,\n\t\t\t\t     __pa(vcpu->arch.apic->regs));\n\t\tvmcs_write32(TPR_THRESHOLD, 0);\n\t}\n\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\tcr0 = X86_CR0_NW | X86_CR0_CD | X86_CR0_ET;\n\tvmx->vcpu.arch.cr0 = cr0;\n\tvmx_set_cr0(vcpu, cr0); /* enter rmode */\n\tvmx_set_cr4(vcpu, 0);\n\tvmx_set_efer(vcpu, 0);\n\n\tupdate_exception_bitmap(vcpu);\n\n\tvpid_sync_context(vmx->vpid);\n\tif (init_event)\n\t\tvmx_clear_hlt(vcpu);\n}"
  },
  {
    "function_name": "init_vmcs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4165-4255",
    "snippet": "static void init_vmcs(struct vcpu_vmx *vmx)\n{\n\tif (nested)\n\t\tnested_vmx_set_vmcs_shadowing_bitmap();\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx->vmcs01.msr_bitmap));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tpin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));\n\n\texec_controls_set(vmx, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmx_compute_secondary_exec_control(vmx);\n\t\tsecondary_exec_controls_set(vmx, vmx->secondary_exec_control);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&vmx->vcpu)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (!kvm_pause_in_guest(vmx->vcpu.kvm)) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n\n\tif (cpu_has_vmx_vmfunc())\n\t\tvmcs_write64(VM_FUNCTION_CONTROL, 0);\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host.val));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest.val));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\tvm_exit_controls_set(vmx, vmx_vmexit_ctrl());\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_set(vmx, vmx_vmentry_ctrl());\n\n\tvmx->vcpu.arch.cr0_guest_owned_bits = X86_CR0_TS;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~X86_CR0_TS);\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmx->vpid != 0)\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\n\tif (vmx_xsaves_supported())\n\t\tvmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);\n\n\tif (enable_pml) {\n\t\tvmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));\n\t\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n\t}\n\n\tif (cpu_has_vmx_encls_vmexit())\n\t\tvmcs_write64(ENCLS_EXITING_BITMAP, -1ull);\n\n\tif (vmx_pt_mode_is_host_guest()) {\n\t\tmemset(&vmx->pt_desc, 0, sizeof(vmx->pt_desc));\n\t\t/* Bit[6~0] are forced to 1, writes are ignored. */\n\t\tvmx->pt_desc.guest.output_mask = 0x7F;\n\t\tvmcs_write64(GUEST_IA32_RTIT_CTL, 0);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define VMX_XSS_EXIT_BITMAP 0"
    ],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static unsigned int ple_gap = KVM_DEFAULT_PLE_GAP;",
      "static unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "struct vmcs_config vmcs_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write64",
          "args": [
            "GUEST_IA32_RTIT_CTL",
            "0"
          ],
          "line": 4253
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "193-203",
          "snippet": "static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&vmx->pt_desc",
            "0",
            "sizeof(vmx->pt_desc)"
          ],
          "line": 4250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_pt_mode_is_host_guest",
          "args": [],
          "line": 4249
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_pt_mode_is_host_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "365-368",
          "snippet": "static inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [
            "#define PT_MODE_HOST_GUEST\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\n#define PT_MODE_HOST_GUEST\t1\n\nstatic inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_encls_vmexit",
          "args": [],
          "line": 4246
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_encls_vmexit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "228-232",
          "snippet": "static inline bool cpu_has_vmx_encls_vmexit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENCLS_EXITING;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_encls_vmexit(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENCLS_EXITING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write16",
          "args": [
            "GUEST_PML_INDEX",
            "PML_ENTITY_NUM - 1"
          ],
          "line": 4243
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "175-182",
          "snippet": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "vmx->pml_pg"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_xsaves_supported",
          "args": [],
          "line": 4238
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_xsaves_supported",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "245-249",
          "snippet": "static inline bool vmx_xsaves_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_XSAVES;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool vmx_xsaves_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_XSAVES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cr4_guest_host_mask",
          "args": [
            "vmx"
          ],
          "line": 4233
        },
        "resolved": true,
        "details": {
          "function_name": "set_cr4_guest_host_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3928-3937",
          "snippet": "void set_cr4_guest_host_mask(struct vcpu_vmx *vmx)\n{\n\tvmx->vcpu.arch.cr4_guest_owned_bits = KVM_CR4_GUEST_OWNED_BITS;\n\tif (enable_ept)\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits |= X86_CR4_PGE;\n\tif (is_guest_mode(&vmx->vcpu))\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits &=\n\t\t\t~get_vmcs12(&vmx->vcpu)->cr4_guest_host_mask;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr4_guest_owned_bits);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define KVM_CR4_GUEST_OWNED_BITS\t\t\t\t      \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR      \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_TSD)"
          ],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define KVM_CR4_GUEST_OWNED_BITS\t\t\t\t      \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR      \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_TSD)\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid set_cr4_guest_host_mask(struct vcpu_vmx *vmx)\n{\n\tvmx->vcpu.arch.cr4_guest_owned_bits = KVM_CR4_GUEST_OWNED_BITS;\n\tif (enable_ept)\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits |= X86_CR4_PGE;\n\tif (is_guest_mode(&vmx->vcpu))\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits &=\n\t\t\t~get_vmcs12(&vmx->vcpu)->cr4_guest_host_mask;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr4_guest_owned_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "CR0_GUEST_HOST_MASK",
            "~X86_CR0_TS"
          ],
          "line": 4231
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_entry_controls_set",
          "args": [
            "vmx",
            "vmx_vmentry_ctrl()"
          ],
          "line": 4228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_vmentry_ctrl",
          "args": [],
          "line": 4228
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_vmentry_ctrl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "449-458",
          "snippet": "static inline u32 vmx_vmentry_ctrl(void)\n{\n\tu32 vmentry_ctrl = vmcs_config.vmentry_ctrl;\n\tif (vmx_pt_mode_is_system())\n\t\tvmentry_ctrl &= ~(VM_ENTRY_PT_CONCEAL_PIP |\n\t\t\t\t  VM_ENTRY_LOAD_IA32_RTIT_CTL);\n\t/* Loading of EFER and PERF_GLOBAL_CTRL are toggled dynamically */\n\treturn vmentry_ctrl &\n\t\t~(VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL | VM_ENTRY_LOAD_IA32_EFER);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline u32 vmx_vmentry_ctrl(void)\n{\n\tu32 vmentry_ctrl = vmcs_config.vmentry_ctrl;\n\tif (vmx_pt_mode_is_system())\n\t\tvmentry_ctrl &= ~(VM_ENTRY_PT_CONCEAL_PIP |\n\t\t\t\t  VM_ENTRY_LOAD_IA32_RTIT_CTL);\n\t/* Loading of EFER and PERF_GLOBAL_CTRL are toggled dynamically */\n\treturn vmentry_ctrl &\n\t\t~(VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL | VM_ENTRY_LOAD_IA32_EFER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_exit_controls_set",
          "args": [
            "vmx",
            "vmx_vmexit_ctrl()"
          ],
          "line": 4225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_vmexit_ctrl",
          "args": [],
          "line": 4225
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_vmexit_ctrl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "460-469",
          "snippet": "static inline u32 vmx_vmexit_ctrl(void)\n{\n\tu32 vmexit_ctrl = vmcs_config.vmexit_ctrl;\n\tif (vmx_pt_mode_is_system())\n\t\tvmexit_ctrl &= ~(VM_EXIT_PT_CONCEAL_PIP |\n\t\t\t\t VM_EXIT_CLEAR_IA32_RTIT_CTL);\n\t/* Loading of EFER and PERF_GLOBAL_CTRL are toggled dynamically */\n\treturn vmexit_ctrl &\n\t\t~(VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL | VM_EXIT_LOAD_IA32_EFER);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline u32 vmx_vmexit_ctrl(void)\n{\n\tu32 vmexit_ctrl = vmcs_config.vmexit_ctrl;\n\tif (vmx_pt_mode_is_system())\n\t\tvmexit_ctrl &= ~(VM_EXIT_PT_CONCEAL_PIP |\n\t\t\t\t VM_EXIT_CLEAR_IA32_RTIT_CTL);\n\t/* Loading of EFER and PERF_GLOBAL_CTRL are toggled dynamically */\n\treturn vmexit_ctrl &\n\t\t~(VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL | VM_EXIT_LOAD_IA32_EFER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vmx->msr_autoload.guest.val"
          ],
          "line": 4220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "VM_ENTRY_MSR_LOAD_COUNT",
            "0"
          ],
          "line": 4219
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vmx->msr_autoload.host.val"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_vmfunc",
          "args": [],
          "line": 4213
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_vmfunc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "209-213",
          "snippet": "static inline bool cpu_has_vmx_vmfunc(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_VMFUNC;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_vmfunc(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_VMFUNC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_set_constant_host_state",
          "args": [
            "vmx"
          ],
          "line": 4209
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_constant_host_state",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3871-3926",
          "snippet": "void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tunsigned long cr0, cr3, cr4;\n\n\tcr0 = read_cr0();\n\tWARN_ON(cr0 & X86_CR0_TS);\n\tvmcs_writel(HOST_CR0, cr0);  /* 22.2.3 */\n\n\t/*\n\t * Save the most likely value for this task's CR3 in the VMCS.\n\t * We can't use __get_current_cr3_fast() because we're not atomic.\n\t */\n\tcr3 = __read_cr3();\n\tvmcs_writel(HOST_CR3, cr3);\t\t/* 22.2.3  FIXME: shadow tables */\n\tvmx->loaded_vmcs->host_state.cr3 = cr3;\n\n\t/* Save the most likely value for this task's CR4 in the VMCS. */\n\tcr4 = cr4_read_shadow();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t/* 22.2.3, 22.2.5 */\n\tvmx->loaded_vmcs->host_state.cr4 = cr4;\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * vmx_prepare_switch_to_host(), in case userspace uses\n\t * the null selectors too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tvmcs_writel(HOST_IDTR_BASE, host_idt_base);   /* 22.2.4 */\n\n\tvmcs_writel(HOST_RIP, (unsigned long)vmx_vmexit); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n\n\tif (cpu_has_load_ia32_efer())\n\t\tvmcs_write64(HOST_IA32_EFER, host_efer);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void vmx_vmexit(void);",
            "struct vmcs_config vmcs_config;",
            "static unsigned long host_idt_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid vmx_vmexit(void);\nstruct vmcs_config vmcs_config;\nstatic unsigned long host_idt_base;\n\nvoid vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tunsigned long cr0, cr3, cr4;\n\n\tcr0 = read_cr0();\n\tWARN_ON(cr0 & X86_CR0_TS);\n\tvmcs_writel(HOST_CR0, cr0);  /* 22.2.3 */\n\n\t/*\n\t * Save the most likely value for this task's CR3 in the VMCS.\n\t * We can't use __get_current_cr3_fast() because we're not atomic.\n\t */\n\tcr3 = __read_cr3();\n\tvmcs_writel(HOST_CR3, cr3);\t\t/* 22.2.3  FIXME: shadow tables */\n\tvmx->loaded_vmcs->host_state.cr3 = cr3;\n\n\t/* Save the most likely value for this task's CR4 in the VMCS. */\n\tcr4 = cr4_read_shadow();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t/* 22.2.3, 22.2.5 */\n\tvmx->loaded_vmcs->host_state.cr4 = cr4;\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * vmx_prepare_switch_to_host(), in case userspace uses\n\t * the null selectors too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tvmcs_writel(HOST_IDTR_BASE, host_idt_base);   /* 22.2.4 */\n\n\tvmcs_writel(HOST_RIP, (unsigned long)vmx_vmexit); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n\n\tif (cpu_has_load_ia32_efer())\n\t\tvmcs_write64(HOST_IA32_EFER, host_efer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pause_in_guest",
          "args": [
            "vmx->vcpu.kvm"
          ],
          "line": 4197
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pause_in_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "321-324",
          "snippet": "static inline bool kvm_pause_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.pause_in_guest;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_pause_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.pause_in_guest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "(&vmx->pi_desc)"
          ],
          "line": 4194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "&vmx->vcpu"
          ],
          "line": 4185
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "secondary_exec_controls_set",
          "args": [
            "vmx",
            "vmx->secondary_exec_control"
          ],
          "line": 4182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_compute_secondary_exec_control",
          "args": [
            "vmx"
          ],
          "line": 4181
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_compute_secondary_exec_control",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "4002-4147",
          "snippet": "static void vmx_compute_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tstruct kvm_vcpu *vcpu = &vmx->vcpu;\n\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\texec_control &= ~(SECONDARY_EXEC_PT_USE_GPA | SECONDARY_EXEC_PT_CONCEAL_VMX);\n\tif (!cpu_need_virtualize_apic_accesses(vcpu))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (kvm_pause_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\n\t/* SECONDARY_EXEC_DESC is enabled/disabled on writes to CR4.UMIP,\n\t * in vmx_set_cr4.  */\n\texec_control &= ~SECONDARY_EXEC_DESC;\n\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\n\tif (!enable_pml)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_PML;\n\n\tif (vmx_xsaves_supported()) {\n\t\t/* Exposing XSAVES only when XSAVE is exposed */\n\t\tbool xsaves_enabled =\n\t\t\tboot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVES);\n\n\t\tvcpu->arch.xsaves_enabled = xsaves_enabled;\n\n\t\tif (!xsaves_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_XSAVES;\n\n\t\tif (nested) {\n\t\t\tif (xsaves_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_XSAVES;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_XSAVES;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_rdtscp()) {\n\t\tbool rdtscp_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP);\n\t\tif (!rdtscp_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\n\t\tif (nested) {\n\t\t\tif (rdtscp_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDTSCP;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDTSCP;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_invpcid()) {\n\t\t/* Exposing INVPCID only when PCID is exposed */\n\t\tbool invpcid_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_INVPCID) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_PCID);\n\n\t\tif (!invpcid_enabled) {\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\tguest_cpuid_clear(vcpu, X86_FEATURE_INVPCID);\n\t\t}\n\n\t\tif (nested) {\n\t\t\tif (invpcid_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t}\n\t}\n\n\tif (vmx_rdrand_supported()) {\n\t\tbool rdrand_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDRAND);\n\t\tif (rdrand_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDRAND_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdrand_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDRAND_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDRAND_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_rdseed_supported()) {\n\t\tbool rdseed_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDSEED);\n\t\tif (rdseed_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDSEED_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdseed_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDSEED_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDSEED_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_waitpkg_supported()) {\n\t\tbool waitpkg_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_WAITPKG);\n\n\t\tif (!waitpkg_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\n\t\tif (nested) {\n\t\t\tif (waitpkg_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t}\n\t}\n\n\tvmx->secondary_exec_control = exec_control;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "struct vmcs_config vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmcs_config vmcs_config;\n\nstatic void vmx_compute_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tstruct kvm_vcpu *vcpu = &vmx->vcpu;\n\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\texec_control &= ~(SECONDARY_EXEC_PT_USE_GPA | SECONDARY_EXEC_PT_CONCEAL_VMX);\n\tif (!cpu_need_virtualize_apic_accesses(vcpu))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (kvm_pause_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\n\t/* SECONDARY_EXEC_DESC is enabled/disabled on writes to CR4.UMIP,\n\t * in vmx_set_cr4.  */\n\texec_control &= ~SECONDARY_EXEC_DESC;\n\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\n\tif (!enable_pml)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_PML;\n\n\tif (vmx_xsaves_supported()) {\n\t\t/* Exposing XSAVES only when XSAVE is exposed */\n\t\tbool xsaves_enabled =\n\t\t\tboot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVES);\n\n\t\tvcpu->arch.xsaves_enabled = xsaves_enabled;\n\n\t\tif (!xsaves_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_XSAVES;\n\n\t\tif (nested) {\n\t\t\tif (xsaves_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_XSAVES;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_XSAVES;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_rdtscp()) {\n\t\tbool rdtscp_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP);\n\t\tif (!rdtscp_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\n\t\tif (nested) {\n\t\t\tif (rdtscp_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDTSCP;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDTSCP;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_invpcid()) {\n\t\t/* Exposing INVPCID only when PCID is exposed */\n\t\tbool invpcid_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_INVPCID) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_PCID);\n\n\t\tif (!invpcid_enabled) {\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\tguest_cpuid_clear(vcpu, X86_FEATURE_INVPCID);\n\t\t}\n\n\t\tif (nested) {\n\t\t\tif (invpcid_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t}\n\t}\n\n\tif (vmx_rdrand_supported()) {\n\t\tbool rdrand_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDRAND);\n\t\tif (rdrand_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDRAND_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdrand_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDRAND_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDRAND_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_rdseed_supported()) {\n\t\tbool rdseed_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDSEED);\n\t\tif (rdseed_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDSEED_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdseed_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDSEED_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDSEED_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_waitpkg_supported()) {\n\t\tbool waitpkg_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_WAITPKG);\n\n\t\tif (!waitpkg_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\n\t\tif (nested) {\n\t\t\tif (waitpkg_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t}\n\t}\n\n\tvmx->secondary_exec_control = exec_control;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_secondary_exec_ctrls",
          "args": [],
          "line": 4180
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_secondary_exec_ctrls",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "125-129",
          "snippet": "static inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exec_controls_set",
          "args": [
            "vmx",
            "vmx_exec_control(vmx)"
          ],
          "line": 4178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_exec_control",
          "args": [
            "vmx"
          ],
          "line": 4178
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_exec_control",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3975-3999",
          "snippet": "u32 vmx_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_exec_ctrl;\n\n\tif (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)\n\t\texec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\n\tif (!cpu_need_tpr_shadow(&vmx->vcpu)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\tif (kvm_mwait_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~(CPU_BASED_MWAIT_EXITING |\n\t\t\t\tCPU_BASED_MONITOR_EXITING);\n\tif (kvm_hlt_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~CPU_BASED_HLT_EXITING;\n\treturn exec_control;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "struct vmcs_config vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmcs_config vmcs_config;\n\nu32 vmx_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_exec_ctrl;\n\n\tif (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)\n\t\texec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\n\tif (!cpu_need_tpr_shadow(&vmx->vcpu)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\tif (kvm_mwait_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~(CPU_BASED_MWAIT_EXITING |\n\t\t\t\tCPU_BASED_MONITOR_EXITING);\n\tif (kvm_hlt_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~CPU_BASED_HLT_EXITING;\n\treturn exec_control;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_controls_set",
          "args": [
            "vmx",
            "vmx_pin_based_exec_ctrl(vmx)"
          ],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_pin_based_exec_ctrl",
          "args": [
            "vmx"
          ],
          "line": 4176
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_pin_based_exec_ctrl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3939-3953",
          "snippet": "u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\n\tif (!enable_vnmi)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;\n\n\tif (!enable_preemption_timer)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\n\treturn pin_based_exec_ctrl;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "struct vmcs_config vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmcs_config vmcs_config;\n\nu32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\n\tif (!enable_vnmi)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;\n\n\tif (!enable_preemption_timer)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\n\treturn pin_based_exec_ctrl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vmx->vmcs01.msr_bitmap"
          ],
          "line": 4171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_msr_bitmap",
          "args": [],
          "line": 4170
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "120-123",
          "snippet": "static inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_set_vmcs_shadowing_bitmap",
          "args": [],
          "line": 4168
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_set_vmcs_shadowing_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "5985-5991",
          "snippet": "void nested_vmx_set_vmcs_shadowing_bitmap(void)\n{\n\tif (enable_shadow_vmcs) {\n\t\tvmcs_write64(VMREAD_BITMAP, __pa(vmx_vmread_bitmap));\n\t\tvmcs_write64(VMWRITE_BITMAP, __pa(vmx_vmwrite_bitmap));\n\t}\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define vmx_vmwrite_bitmap                   (vmx_bitmap[VMX_VMWRITE_BITMAP])",
            "#define vmx_vmread_bitmap                    (vmx_bitmap[VMX_VMREAD_BITMAP])"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\n#define vmx_vmwrite_bitmap                   (vmx_bitmap[VMX_VMWRITE_BITMAP])\n#define vmx_vmread_bitmap                    (vmx_bitmap[VMX_VMREAD_BITMAP])\n\nvoid nested_vmx_set_vmcs_shadowing_bitmap(void)\n{\n\tif (enable_shadow_vmcs) {\n\t\tvmcs_write64(VMREAD_BITMAP, __pa(vmx_vmread_bitmap));\n\t\tvmcs_write64(VMWRITE_BITMAP, __pa(vmx_vmwrite_bitmap));\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define VMX_XSS_EXIT_BITMAP 0\n\nstatic bool __read_mostly nested = 1;\nstatic unsigned int ple_gap = KVM_DEFAULT_PLE_GAP;\nstatic unsigned int ple_window = KVM_VMX_DEFAULT_PLE_WINDOW;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmcs_config vmcs_config;\n\nstatic void init_vmcs(struct vcpu_vmx *vmx)\n{\n\tif (nested)\n\t\tnested_vmx_set_vmcs_shadowing_bitmap();\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmcs_write64(MSR_BITMAP, __pa(vmx->vmcs01.msr_bitmap));\n\n\tvmcs_write64(VMCS_LINK_POINTER, -1ull); /* 22.3.1.5 */\n\n\t/* Control */\n\tpin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));\n\n\texec_controls_set(vmx, vmx_exec_control(vmx));\n\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tvmx_compute_secondary_exec_control(vmx);\n\t\tsecondary_exec_controls_set(vmx, vmx->secondary_exec_control);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&vmx->vcpu)) {\n\t\tvmcs_write64(EOI_EXIT_BITMAP0, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP1, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP2, 0);\n\t\tvmcs_write64(EOI_EXIT_BITMAP3, 0);\n\n\t\tvmcs_write16(GUEST_INTR_STATUS, 0);\n\n\t\tvmcs_write16(POSTED_INTR_NV, POSTED_INTR_VECTOR);\n\t\tvmcs_write64(POSTED_INTR_DESC_ADDR, __pa((&vmx->pi_desc)));\n\t}\n\n\tif (!kvm_pause_in_guest(vmx->vcpu.kvm)) {\n\t\tvmcs_write32(PLE_GAP, ple_gap);\n\t\tvmx->ple_window = ple_window;\n\t\tvmx->ple_window_dirty = true;\n\t}\n\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MASK, 0);\n\tvmcs_write32(PAGE_FAULT_ERROR_CODE_MATCH, 0);\n\tvmcs_write32(CR3_TARGET_COUNT, 0);           /* 22.2.1 */\n\n\tvmcs_write16(HOST_FS_SELECTOR, 0);            /* 22.2.4 */\n\tvmcs_write16(HOST_GS_SELECTOR, 0);            /* 22.2.4 */\n\tvmx_set_constant_host_state(vmx);\n\tvmcs_writel(HOST_FS_BASE, 0); /* 22.2.4 */\n\tvmcs_writel(HOST_GS_BASE, 0); /* 22.2.4 */\n\n\tif (cpu_has_vmx_vmfunc())\n\t\tvmcs_write64(VM_FUNCTION_CONTROL, 0);\n\n\tvmcs_write32(VM_EXIT_MSR_STORE_COUNT, 0);\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_EXIT_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.host.val));\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, 0);\n\tvmcs_write64(VM_ENTRY_MSR_LOAD_ADDR, __pa(vmx->msr_autoload.guest.val));\n\n\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT)\n\t\tvmcs_write64(GUEST_IA32_PAT, vmx->vcpu.arch.pat);\n\n\tvm_exit_controls_set(vmx, vmx_vmexit_ctrl());\n\n\t/* 22.2.1, 20.8.1 */\n\tvm_entry_controls_set(vmx, vmx_vmentry_ctrl());\n\n\tvmx->vcpu.arch.cr0_guest_owned_bits = X86_CR0_TS;\n\tvmcs_writel(CR0_GUEST_HOST_MASK, ~X86_CR0_TS);\n\n\tset_cr4_guest_host_mask(vmx);\n\n\tif (vmx->vpid != 0)\n\t\tvmcs_write16(VIRTUAL_PROCESSOR_ID, vmx->vpid);\n\n\tif (vmx_xsaves_supported())\n\t\tvmcs_write64(XSS_EXIT_BITMAP, VMX_XSS_EXIT_BITMAP);\n\n\tif (enable_pml) {\n\t\tvmcs_write64(PML_ADDRESS, page_to_phys(vmx->pml_pg));\n\t\tvmcs_write16(GUEST_PML_INDEX, PML_ENTITY_NUM - 1);\n\t}\n\n\tif (cpu_has_vmx_encls_vmexit())\n\t\tvmcs_write64(ENCLS_EXITING_BITMAP, -1ull);\n\n\tif (vmx_pt_mode_is_host_guest()) {\n\t\tmemset(&vmx->pt_desc, 0, sizeof(vmx->pt_desc));\n\t\t/* Bit[6~0] are forced to 1, writes are ignored. */\n\t\tvmx->pt_desc.guest.output_mask = 0x7F;\n\t\tvmcs_write64(GUEST_IA32_RTIT_CTL, 0);\n\t}\n}"
  },
  {
    "function_name": "ept_set_mmio_spte_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4149-4157",
    "snippet": "static void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t */\n\tkvm_mmu_set_mmio_spte_mask(VMX_EPT_RWX_MASK,\n\t\t\t\t   VMX_EPT_MISCONFIG_WX_VALUE, 0);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_set_mmio_spte_mask",
          "args": [
            "VMX_EPT_RWX_MASK",
            "VMX_EPT_MISCONFIG_WX_VALUE",
            "0"
          ],
          "line": 4155
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_set_mmio_spte_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "334-341",
          "snippet": "void kvm_mmu_set_mmio_spte_mask(u64 mmio_mask, u64 mmio_value, u64 access_mask)\n{\n\tBUG_ON((u64)(unsigned)access_mask != access_mask);\n\tBUG_ON((mmio_mask & mmio_value) != mmio_value);\n\tshadow_mmio_value = mmio_value | SPTE_MMIO_MASK;\n\tshadow_mmio_mask = mmio_mask | SPTE_SPECIAL_MASK;\n\tshadow_mmio_access_mask = access_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMIO_MASK (3ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMIO_MASK (3ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nvoid kvm_mmu_set_mmio_spte_mask(u64 mmio_mask, u64 mmio_value, u64 access_mask)\n{\n\tBUG_ON((u64)(unsigned)access_mask != access_mask);\n\tBUG_ON((mmio_mask & mmio_value) != mmio_value);\n\tshadow_mmio_value = mmio_value | SPTE_MMIO_MASK;\n\tshadow_mmio_mask = mmio_mask | SPTE_SPECIAL_MASK;\n\tshadow_mmio_access_mask = access_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void ept_set_mmio_spte_mask(void)\n{\n\t/*\n\t * EPT Misconfigurations can be generated if the value of bits 2:0\n\t * of an EPT paging-structure entry is 110b (write/execute).\n\t */\n\tkvm_mmu_set_mmio_spte_mask(VMX_EPT_RWX_MASK,\n\t\t\t\t   VMX_EPT_MISCONFIG_WX_VALUE, 0);\n}"
  },
  {
    "function_name": "vmx_compute_secondary_exec_control",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "4002-4147",
    "snippet": "static void vmx_compute_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tstruct kvm_vcpu *vcpu = &vmx->vcpu;\n\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\texec_control &= ~(SECONDARY_EXEC_PT_USE_GPA | SECONDARY_EXEC_PT_CONCEAL_VMX);\n\tif (!cpu_need_virtualize_apic_accesses(vcpu))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (kvm_pause_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\n\t/* SECONDARY_EXEC_DESC is enabled/disabled on writes to CR4.UMIP,\n\t * in vmx_set_cr4.  */\n\texec_control &= ~SECONDARY_EXEC_DESC;\n\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\n\tif (!enable_pml)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_PML;\n\n\tif (vmx_xsaves_supported()) {\n\t\t/* Exposing XSAVES only when XSAVE is exposed */\n\t\tbool xsaves_enabled =\n\t\t\tboot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVES);\n\n\t\tvcpu->arch.xsaves_enabled = xsaves_enabled;\n\n\t\tif (!xsaves_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_XSAVES;\n\n\t\tif (nested) {\n\t\t\tif (xsaves_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_XSAVES;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_XSAVES;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_rdtscp()) {\n\t\tbool rdtscp_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP);\n\t\tif (!rdtscp_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\n\t\tif (nested) {\n\t\t\tif (rdtscp_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDTSCP;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDTSCP;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_invpcid()) {\n\t\t/* Exposing INVPCID only when PCID is exposed */\n\t\tbool invpcid_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_INVPCID) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_PCID);\n\n\t\tif (!invpcid_enabled) {\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\tguest_cpuid_clear(vcpu, X86_FEATURE_INVPCID);\n\t\t}\n\n\t\tif (nested) {\n\t\t\tif (invpcid_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t}\n\t}\n\n\tif (vmx_rdrand_supported()) {\n\t\tbool rdrand_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDRAND);\n\t\tif (rdrand_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDRAND_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdrand_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDRAND_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDRAND_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_rdseed_supported()) {\n\t\tbool rdseed_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDSEED);\n\t\tif (rdseed_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDSEED_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdseed_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDSEED_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDSEED_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_waitpkg_supported()) {\n\t\tbool waitpkg_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_WAITPKG);\n\n\t\tif (!waitpkg_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\n\t\tif (nested) {\n\t\t\tif (waitpkg_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t}\n\t}\n\n\tvmx->secondary_exec_control = exec_control;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "struct vmcs_config vmcs_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_WAITPKG"
          ],
          "line": 4131
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_waitpkg_supported",
          "args": [],
          "line": 4129
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_waitpkg_supported",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "251-255",
          "snippet": "static inline bool vmx_waitpkg_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool vmx_waitpkg_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_rdseed_supported",
          "args": [],
          "line": 4114
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_rdseed_supported",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "234-238",
          "snippet": "static inline bool vmx_rdseed_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDSEED_EXITING;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool vmx_rdseed_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDSEED_EXITING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_rdrand_supported",
          "args": [],
          "line": 4099
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_rdrand_supported",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "197-201",
          "snippet": "static inline bool vmx_rdrand_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDRAND_EXITING;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool vmx_rdrand_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDRAND_EXITING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_clear",
          "args": [
            "vcpu",
            "X86_FEATURE_INVPCID"
          ],
          "line": 4086
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "207-215",
          "snippet": "static __always_inline void guest_cpuid_clear(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (reg)\n\t\t*reg &= ~__feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline void guest_cpuid_clear(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (reg)\n\t\t*reg &= ~__feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_invpcid",
          "args": [],
          "line": 4078
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_invpcid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "203-207",
          "snippet": "static inline bool cpu_has_vmx_invpcid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_invpcid(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_rdtscp",
          "args": [],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_rdtscp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "149-153",
          "snippet": "static inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_XSAVE"
          ],
          "line": 4044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_xsaves_supported",
          "args": [],
          "line": 4041
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_xsaves_supported",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "245-249",
          "snippet": "static inline bool vmx_xsaves_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_XSAVES;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool vmx_xsaves_supported(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_XSAVES;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 4022
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pause_in_guest",
          "args": [
            "vmx->vcpu.kvm"
          ],
          "line": 4020
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pause_in_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "321-324",
          "snippet": "static inline bool kvm_pause_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.pause_in_guest;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_pause_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.pause_in_guest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_need_virtualize_apic_accesses",
          "args": [
            "vcpu"
          ],
          "line": 4010
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_need_virtualize_apic_accesses",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "613-616",
          "snippet": "static inline bool cpu_need_virtualize_apic_accesses(struct kvm_vcpu *vcpu)\n{\n\treturn flexpriority_enabled && lapic_in_kernel(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic inline bool cpu_need_virtualize_apic_accesses(struct kvm_vcpu *vcpu)\n{\n\treturn flexpriority_enabled && lapic_in_kernel(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_pt_mode_is_system",
          "args": [],
          "line": 4008
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_pt_mode_is_system",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "361-364",
          "snippet": "static inline bool vmx_pt_mode_is_system(void)\n{\n\treturn pt_mode == PT_MODE_SYSTEM;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [
            "#define PT_MODE_SYSTEM\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\n#define PT_MODE_SYSTEM\t\t0\n\nstatic inline bool vmx_pt_mode_is_system(void)\n{\n\treturn pt_mode == PT_MODE_SYSTEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmcs_config vmcs_config;\n\nstatic void vmx_compute_secondary_exec_control(struct vcpu_vmx *vmx)\n{\n\tstruct kvm_vcpu *vcpu = &vmx->vcpu;\n\n\tu32 exec_control = vmcs_config.cpu_based_2nd_exec_ctrl;\n\n\tif (vmx_pt_mode_is_system())\n\t\texec_control &= ~(SECONDARY_EXEC_PT_USE_GPA | SECONDARY_EXEC_PT_CONCEAL_VMX);\n\tif (!cpu_need_virtualize_apic_accesses(vcpu))\n\t\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\tif (vmx->vpid == 0)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_VPID;\n\tif (!enable_ept) {\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_EPT;\n\t\tenable_unrestricted_guest = 0;\n\t}\n\tif (!enable_unrestricted_guest)\n\t\texec_control &= ~SECONDARY_EXEC_UNRESTRICTED_GUEST;\n\tif (kvm_pause_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~SECONDARY_EXEC_PAUSE_LOOP_EXITING;\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\texec_control &= ~(SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t  SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\texec_control &= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;\n\n\t/* SECONDARY_EXEC_DESC is enabled/disabled on writes to CR4.UMIP,\n\t * in vmx_set_cr4.  */\n\texec_control &= ~SECONDARY_EXEC_DESC;\n\n\t/* SECONDARY_EXEC_SHADOW_VMCS is enabled when L1 executes VMPTRLD\n\t   (handle_vmptrld).\n\t   We can NOT enable shadow_vmcs here because we don't have yet\n\t   a current VMCS12\n\t*/\n\texec_control &= ~SECONDARY_EXEC_SHADOW_VMCS;\n\n\tif (!enable_pml)\n\t\texec_control &= ~SECONDARY_EXEC_ENABLE_PML;\n\n\tif (vmx_xsaves_supported()) {\n\t\t/* Exposing XSAVES only when XSAVE is exposed */\n\t\tbool xsaves_enabled =\n\t\t\tboot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_XSAVES);\n\n\t\tvcpu->arch.xsaves_enabled = xsaves_enabled;\n\n\t\tif (!xsaves_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_XSAVES;\n\n\t\tif (nested) {\n\t\t\tif (xsaves_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_XSAVES;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_XSAVES;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_rdtscp()) {\n\t\tbool rdtscp_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP);\n\t\tif (!rdtscp_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDTSCP;\n\n\t\tif (nested) {\n\t\t\tif (rdtscp_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDTSCP;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDTSCP;\n\t\t}\n\t}\n\n\tif (cpu_has_vmx_invpcid()) {\n\t\t/* Exposing INVPCID only when PCID is exposed */\n\t\tbool invpcid_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_INVPCID) &&\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_PCID);\n\n\t\tif (!invpcid_enabled) {\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\tguest_cpuid_clear(vcpu, X86_FEATURE_INVPCID);\n\t\t}\n\n\t\tif (nested) {\n\t\t\tif (invpcid_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_INVPCID;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_INVPCID;\n\t\t}\n\t}\n\n\tif (vmx_rdrand_supported()) {\n\t\tbool rdrand_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDRAND);\n\t\tif (rdrand_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDRAND_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdrand_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDRAND_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDRAND_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_rdseed_supported()) {\n\t\tbool rdseed_enabled = guest_cpuid_has(vcpu, X86_FEATURE_RDSEED);\n\t\tif (rdseed_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_RDSEED_EXITING;\n\n\t\tif (nested) {\n\t\t\tif (rdseed_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_RDSEED_EXITING;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_RDSEED_EXITING;\n\t\t}\n\t}\n\n\tif (vmx_waitpkg_supported()) {\n\t\tbool waitpkg_enabled =\n\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_WAITPKG);\n\n\t\tif (!waitpkg_enabled)\n\t\t\texec_control &= ~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\n\t\tif (nested) {\n\t\t\tif (waitpkg_enabled)\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high |=\n\t\t\t\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t\telse\n\t\t\t\tvmx->nested.msrs.secondary_ctls_high &=\n\t\t\t\t\t~SECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n\t\t}\n\t}\n\n\tvmx->secondary_exec_control = exec_control;\n}"
  },
  {
    "function_name": "vmx_exec_control",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3975-3999",
    "snippet": "u32 vmx_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_exec_ctrl;\n\n\tif (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)\n\t\texec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\n\tif (!cpu_need_tpr_shadow(&vmx->vcpu)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\tif (kvm_mwait_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~(CPU_BASED_MWAIT_EXITING |\n\t\t\t\tCPU_BASED_MONITOR_EXITING);\n\tif (kvm_hlt_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~CPU_BASED_HLT_EXITING;\n\treturn exec_control;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "struct vmcs_config vmcs_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hlt_in_guest",
          "args": [
            "vmx->vcpu.kvm"
          ],
          "line": 3996
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hlt_in_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "316-319",
          "snippet": "static inline bool kvm_hlt_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.hlt_in_guest;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_hlt_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.hlt_in_guest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mwait_in_guest",
          "args": [
            "vmx->vcpu.kvm"
          ],
          "line": 3993
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mwait_in_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "311-314",
          "snippet": "static inline bool kvm_mwait_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.mwait_in_guest;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_mwait_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.mwait_in_guest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_need_tpr_shadow",
          "args": [
            "&vmx->vcpu"
          ],
          "line": 3982
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_need_tpr_shadow",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "115-118",
          "snippet": "static inline bool cpu_need_tpr_shadow(struct kvm_vcpu *vcpu)\n{\n\treturn cpu_has_vmx_tpr_shadow() && lapic_in_kernel(vcpu);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_need_tpr_shadow(struct kvm_vcpu *vcpu)\n{\n\treturn cpu_has_vmx_tpr_shadow() && lapic_in_kernel(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmcs_config vmcs_config;\n\nu32 vmx_exec_control(struct vcpu_vmx *vmx)\n{\n\tu32 exec_control = vmcs_config.cpu_based_exec_ctrl;\n\n\tif (vmx->vcpu.arch.switch_db_regs & KVM_DEBUGREG_WONT_EXIT)\n\t\texec_control &= ~CPU_BASED_MOV_DR_EXITING;\n\n\tif (!cpu_need_tpr_shadow(&vmx->vcpu)) {\n\t\texec_control &= ~CPU_BASED_TPR_SHADOW;\n#ifdef CONFIG_X86_64\n\t\texec_control |= CPU_BASED_CR8_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR8_LOAD_EXITING;\n#endif\n\t}\n\tif (!enable_ept)\n\t\texec_control |= CPU_BASED_CR3_STORE_EXITING |\n\t\t\t\tCPU_BASED_CR3_LOAD_EXITING  |\n\t\t\t\tCPU_BASED_INVLPG_EXITING;\n\tif (kvm_mwait_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~(CPU_BASED_MWAIT_EXITING |\n\t\t\t\tCPU_BASED_MONITOR_EXITING);\n\tif (kvm_hlt_in_guest(vmx->vcpu.kvm))\n\t\texec_control &= ~CPU_BASED_HLT_EXITING;\n\treturn exec_control;\n}"
  },
  {
    "function_name": "vmx_refresh_apicv_exec_ctrl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3955-3973",
    "snippet": "static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tpin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tsecondary_exec_controls_setbit(vmx,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tsecondary_exec_controls_clearbit(vmx,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_update_msr_bitmap(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_update_msr_bitmap",
          "args": [
            "vcpu"
          ],
          "line": 3972
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_update_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3716-3730",
          "snippet": "void vmx_update_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tu8 mode = vmx_msr_bitmap_mode(vcpu);\n\tu8 changed = mode ^ vmx->msr_bitmap_mode;\n\n\tif (!changed)\n\t\treturn;\n\n\tif (changed & (MSR_BITMAP_MODE_X2APIC | MSR_BITMAP_MODE_X2APIC_APICV))\n\t\tvmx_update_msr_bitmap_x2apic(msr_bitmap, mode);\n\n\tvmx->msr_bitmap_mode = mode;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define MSR_BITMAP_MODE_X2APIC_APICV\t2",
            "#define MSR_BITMAP_MODE_X2APIC\t\t1"
          ],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define MSR_BITMAP_MODE_X2APIC_APICV\t2\n#define MSR_BITMAP_MODE_X2APIC\t\t1\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_update_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tu8 mode = vmx_msr_bitmap_mode(vcpu);\n\tu8 changed = mode ^ vmx->msr_bitmap_mode;\n\n\tif (!changed)\n\t\treturn;\n\n\tif (changed & (MSR_BITMAP_MODE_X2APIC | MSR_BITMAP_MODE_X2APIC_APICV))\n\t\tvmx_update_msr_bitmap_x2apic(msr_bitmap, mode);\n\n\tvmx->msr_bitmap_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_msr_bitmap",
          "args": [],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "120-123",
          "snippet": "static inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "secondary_exec_controls_clearbit",
          "args": [
            "vmx",
            "SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "secondary_exec_controls_setbit",
          "args": [
            "vmx",
            "SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY"
          ],
          "line": 3962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 3961
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_secondary_exec_ctrls",
          "args": [],
          "line": 3960
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_secondary_exec_ctrls",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "125-129",
          "snippet": "static inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pin_controls_set",
          "args": [
            "vmx",
            "vmx_pin_based_exec_ctrl(vmx)"
          ],
          "line": 3959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_pin_based_exec_ctrl",
          "args": [
            "vmx"
          ],
          "line": 3959
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_pin_based_exec_ctrl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3939-3953",
          "snippet": "u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\n\tif (!enable_vnmi)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;\n\n\tif (!enable_preemption_timer)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\n\treturn pin_based_exec_ctrl;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "struct vmcs_config vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmcs_config vmcs_config;\n\nu32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\n\tif (!enable_vnmi)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;\n\n\tif (!enable_preemption_timer)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\n\treturn pin_based_exec_ctrl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3957
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tpin_controls_set(vmx, vmx_pin_based_exec_ctrl(vmx));\n\tif (cpu_has_secondary_exec_ctrls()) {\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tsecondary_exec_controls_setbit(vmx,\n\t\t\t\t      SECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t      SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t\telse\n\t\t\tsecondary_exec_controls_clearbit(vmx,\n\t\t\t\t\tSECONDARY_EXEC_APIC_REGISTER_VIRT |\n\t\t\t\t\tSECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n\t}\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_update_msr_bitmap(vcpu);\n}"
  },
  {
    "function_name": "vmx_pin_based_exec_ctrl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3939-3953",
    "snippet": "u32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\n\tif (!enable_vnmi)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;\n\n\tif (!enable_preemption_timer)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\n\treturn pin_based_exec_ctrl;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "struct vmcs_config vmcs_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "&vmx->vcpu"
          ],
          "line": 3943
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmcs_config vmcs_config;\n\nu32 vmx_pin_based_exec_ctrl(struct vcpu_vmx *vmx)\n{\n\tu32 pin_based_exec_ctrl = vmcs_config.pin_based_exec_ctrl;\n\n\tif (!kvm_vcpu_apicv_active(&vmx->vcpu))\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_POSTED_INTR;\n\n\tif (!enable_vnmi)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VIRTUAL_NMIS;\n\n\tif (!enable_preemption_timer)\n\t\tpin_based_exec_ctrl &= ~PIN_BASED_VMX_PREEMPTION_TIMER;\n\n\treturn pin_based_exec_ctrl;\n}"
  },
  {
    "function_name": "set_cr4_guest_host_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3928-3937",
    "snippet": "void set_cr4_guest_host_mask(struct vcpu_vmx *vmx)\n{\n\tvmx->vcpu.arch.cr4_guest_owned_bits = KVM_CR4_GUEST_OWNED_BITS;\n\tif (enable_ept)\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits |= X86_CR4_PGE;\n\tif (is_guest_mode(&vmx->vcpu))\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits &=\n\t\t\t~get_vmcs12(&vmx->vcpu)->cr4_guest_host_mask;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr4_guest_owned_bits);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define KVM_CR4_GUEST_OWNED_BITS\t\t\t\t      \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR      \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_TSD)"
    ],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "CR4_GUEST_HOST_MASK",
            "~vmx->vcpu.arch.cr4_guest_owned_bits"
          ],
          "line": 3936
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "&vmx->vcpu"
          ],
          "line": 3935
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "&vmx->vcpu"
          ],
          "line": 3933
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define KVM_CR4_GUEST_OWNED_BITS\t\t\t\t      \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR      \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_TSD)\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid set_cr4_guest_host_mask(struct vcpu_vmx *vmx)\n{\n\tvmx->vcpu.arch.cr4_guest_owned_bits = KVM_CR4_GUEST_OWNED_BITS;\n\tif (enable_ept)\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits |= X86_CR4_PGE;\n\tif (is_guest_mode(&vmx->vcpu))\n\t\tvmx->vcpu.arch.cr4_guest_owned_bits &=\n\t\t\t~get_vmcs12(&vmx->vcpu)->cr4_guest_host_mask;\n\tvmcs_writel(CR4_GUEST_HOST_MASK, ~vmx->vcpu.arch.cr4_guest_owned_bits);\n}"
  },
  {
    "function_name": "vmx_set_constant_host_state",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3871-3926",
    "snippet": "void vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tunsigned long cr0, cr3, cr4;\n\n\tcr0 = read_cr0();\n\tWARN_ON(cr0 & X86_CR0_TS);\n\tvmcs_writel(HOST_CR0, cr0);  /* 22.2.3 */\n\n\t/*\n\t * Save the most likely value for this task's CR3 in the VMCS.\n\t * We can't use __get_current_cr3_fast() because we're not atomic.\n\t */\n\tcr3 = __read_cr3();\n\tvmcs_writel(HOST_CR3, cr3);\t\t/* 22.2.3  FIXME: shadow tables */\n\tvmx->loaded_vmcs->host_state.cr3 = cr3;\n\n\t/* Save the most likely value for this task's CR4 in the VMCS. */\n\tcr4 = cr4_read_shadow();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t/* 22.2.3, 22.2.5 */\n\tvmx->loaded_vmcs->host_state.cr4 = cr4;\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * vmx_prepare_switch_to_host(), in case userspace uses\n\t * the null selectors too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tvmcs_writel(HOST_IDTR_BASE, host_idt_base);   /* 22.2.4 */\n\n\tvmcs_writel(HOST_RIP, (unsigned long)vmx_vmexit); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n\n\tif (cpu_has_load_ia32_efer())\n\t\tvmcs_write64(HOST_IA32_EFER, host_efer);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "void vmx_vmexit(void);",
      "struct vmcs_config vmcs_config;",
      "static unsigned long host_idt_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write64",
          "args": [
            "HOST_IA32_EFER",
            "host_efer"
          ],
          "line": 3925
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "193-203",
          "snippet": "static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_load_ia32_efer",
          "args": [],
          "line": 3924
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_load_ia32_efer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "92-96",
          "snippet": "static inline bool cpu_has_load_ia32_efer(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_EFER) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_EFER);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_load_ia32_efer(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_EFER) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_EFER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdmsr",
          "args": [
            "MSR_IA32_CR_PAT",
            "low32",
            "high32"
          ],
          "line": 3920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "HOST_IA32_SYSENTER_EIP",
            "tmpl"
          ],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_SYSENTER_EIP",
            "tmpl"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "HOST_IA32_SYSENTER_CS",
            "low32"
          ],
          "line": 3915
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdmsr",
          "args": [
            "MSR_IA32_SYSENTER_CS",
            "low32",
            "high32"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_write16",
          "args": [
            "HOST_TR_SELECTOR",
            "GDT_ENTRY_TSS*8"
          ],
          "line": 3908
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "175-182",
          "snippet": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cr4_read_shadow",
          "args": [],
          "line": 3890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__read_cr3",
          "args": [],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "cr0 & X86_CR0_TS"
          ],
          "line": 3878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cr0",
          "args": [],
          "line": 3877
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid vmx_vmexit(void);\nstruct vmcs_config vmcs_config;\nstatic unsigned long host_idt_base;\n\nvoid vmx_set_constant_host_state(struct vcpu_vmx *vmx)\n{\n\tu32 low32, high32;\n\tunsigned long tmpl;\n\tunsigned long cr0, cr3, cr4;\n\n\tcr0 = read_cr0();\n\tWARN_ON(cr0 & X86_CR0_TS);\n\tvmcs_writel(HOST_CR0, cr0);  /* 22.2.3 */\n\n\t/*\n\t * Save the most likely value for this task's CR3 in the VMCS.\n\t * We can't use __get_current_cr3_fast() because we're not atomic.\n\t */\n\tcr3 = __read_cr3();\n\tvmcs_writel(HOST_CR3, cr3);\t\t/* 22.2.3  FIXME: shadow tables */\n\tvmx->loaded_vmcs->host_state.cr3 = cr3;\n\n\t/* Save the most likely value for this task's CR4 in the VMCS. */\n\tcr4 = cr4_read_shadow();\n\tvmcs_writel(HOST_CR4, cr4);\t\t\t/* 22.2.3, 22.2.5 */\n\tvmx->loaded_vmcs->host_state.cr4 = cr4;\n\n\tvmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);  /* 22.2.4 */\n#ifdef CONFIG_X86_64\n\t/*\n\t * Load null selectors, so we can avoid reloading them in\n\t * vmx_prepare_switch_to_host(), in case userspace uses\n\t * the null selectors too (the expected case).\n\t */\n\tvmcs_write16(HOST_DS_SELECTOR, 0);\n\tvmcs_write16(HOST_ES_SELECTOR, 0);\n#else\n\tvmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n#endif\n\tvmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);  /* 22.2.4 */\n\tvmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);  /* 22.2.4 */\n\n\tvmcs_writel(HOST_IDTR_BASE, host_idt_base);   /* 22.2.4 */\n\n\tvmcs_writel(HOST_RIP, (unsigned long)vmx_vmexit); /* 22.2.5 */\n\n\trdmsr(MSR_IA32_SYSENTER_CS, low32, high32);\n\tvmcs_write32(HOST_IA32_SYSENTER_CS, low32);\n\trdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);\n\tvmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);   /* 22.2.3 */\n\n\tif (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {\n\t\trdmsr(MSR_IA32_CR_PAT, low32, high32);\n\t\tvmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));\n\t}\n\n\tif (cpu_has_load_ia32_efer())\n\t\tvmcs_write64(HOST_IA32_EFER, host_efer);\n}"
  },
  {
    "function_name": "vmx_deliver_posted_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3840-3863",
    "snippet": "static int vmx_deliver_posted_interrupt(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint r;\n\n\tr = vmx_deliver_nested_posted_interrupt(vcpu, vector);\n\tif (!r)\n\t\treturn 0;\n\n\tif (!vcpu->arch.apicv_active)\n\t\treturn -1;\n\n\tif (pi_test_and_set_pir(vector, &vmx->pi_desc))\n\t\treturn 0;\n\n\t/* If a previous notification has sent the IPI, nothing to do.  */\n\tif (pi_test_and_set_on(&vmx->pi_desc))\n\t\treturn 0;\n\n\tif (!kvm_vcpu_trigger_posted_interrupt(vcpu, false))\n\t\tkvm_vcpu_kick(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 3860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_trigger_posted_interrupt",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 3859
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_trigger_posted_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3774-3811",
          "snippet": "static inline bool kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t     bool nested)\n{\n#ifdef CONFIG_SMP\n\tint pi_vec = nested ? POSTED_INTR_NESTED_VECTOR : POSTED_INTR_VECTOR;\n\n\tif (vcpu->mode == IN_GUEST_MODE) {\n\t\t/*\n\t\t * The vector of interrupt to be delivered to vcpu had\n\t\t * been set in PIR before this function.\n\t\t *\n\t\t * Following cases will be reached in this block, and\n\t\t * we always send a notification event in all cases as\n\t\t * explained below.\n\t\t *\n\t\t * Case 1: vcpu keeps in non-root mode. Sending a\n\t\t * notification event posts the interrupt to vcpu.\n\t\t *\n\t\t * Case 2: vcpu exits to root mode and is still\n\t\t * runnable. PIR will be synced to vIRR before the\n\t\t * next vcpu entry. Sending a notification event in\n\t\t * this case has no effect, as vcpu is not in root\n\t\t * mode.\n\t\t *\n\t\t * Case 3: vcpu exits to root mode and is blocked.\n\t\t * vcpu_block() has already synced PIR to vIRR and\n\t\t * never blocks vcpu if vIRR is not cleared. Therefore,\n\t\t * a blocked vcpu here does not wait for any requested\n\t\t * interrupts in PIR, and sending a notification event\n\t\t * which has no effect is safe here.\n\t\t */\n\n\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu), pi_vec);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic inline bool kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t     bool nested)\n{\n#ifdef CONFIG_SMP\n\tint pi_vec = nested ? POSTED_INTR_NESTED_VECTOR : POSTED_INTR_VECTOR;\n\n\tif (vcpu->mode == IN_GUEST_MODE) {\n\t\t/*\n\t\t * The vector of interrupt to be delivered to vcpu had\n\t\t * been set in PIR before this function.\n\t\t *\n\t\t * Following cases will be reached in this block, and\n\t\t * we always send a notification event in all cases as\n\t\t * explained below.\n\t\t *\n\t\t * Case 1: vcpu keeps in non-root mode. Sending a\n\t\t * notification event posts the interrupt to vcpu.\n\t\t *\n\t\t * Case 2: vcpu exits to root mode and is still\n\t\t * runnable. PIR will be synced to vIRR before the\n\t\t * next vcpu entry. Sending a notification event in\n\t\t * this case has no effect, as vcpu is not in root\n\t\t * mode.\n\t\t *\n\t\t * Case 3: vcpu exits to root mode and is blocked.\n\t\t * vcpu_block() has already synced PIR to vIRR and\n\t\t * never blocks vcpu if vIRR is not cleared. Therefore,\n\t\t * a blocked vcpu here does not wait for any requested\n\t\t * interrupts in PIR, and sending a notification event\n\t\t * which has no effect is safe here.\n\t\t */\n\n\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu), pi_vec);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pi_test_and_set_on",
          "args": [
            "&vmx->pi_desc"
          ],
          "line": 3856
        },
        "resolved": true,
        "details": {
          "function_name": "pi_test_and_set_on",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "355-359",
          "snippet": "static inline bool pi_test_and_set_on(struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_ON  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_ON  0\n\nstatic inline bool pi_test_and_set_on(struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(POSTED_INTR_ON,\n\t\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pi_test_and_set_pir",
          "args": [
            "vector",
            "&vmx->pi_desc"
          ],
          "line": 3852
        },
        "resolved": true,
        "details": {
          "function_name": "pi_test_and_set_pir",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "367-370",
          "snippet": "static inline int pi_test_and_set_pir(int vector, struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(vector, (unsigned long *)pi_desc->pir);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline int pi_test_and_set_pir(int vector, struct pi_desc *pi_desc)\n{\n\treturn test_and_set_bit(vector, (unsigned long *)pi_desc->pir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_deliver_nested_posted_interrupt",
          "args": [
            "vcpu",
            "vector"
          ],
          "line": 3845
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_deliver_nested_posted_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3813-3832",
          "snippet": "static int vmx_deliver_nested_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tint vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    vector == vmx->nested.posted_intr_nv) {\n\t\t/*\n\t\t * If a posted intr is not recognized by hardware,\n\t\t * we will accomplish it in the next vmentry.\n\t\t */\n\t\tvmx->nested.pi_pending = true;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t/* the PIR and ON have been set by L1. */\n\t\tif (!kvm_vcpu_trigger_posted_interrupt(vcpu, true))\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_deliver_nested_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tint vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    vector == vmx->nested.posted_intr_nv) {\n\t\t/*\n\t\t * If a posted intr is not recognized by hardware,\n\t\t * we will accomplish it in the next vmentry.\n\t\t */\n\t\tvmx->nested.pi_pending = true;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t/* the PIR and ON have been set by L1. */\n\t\tif (!kvm_vcpu_trigger_posted_interrupt(vcpu, true))\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3842
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_deliver_posted_interrupt(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tint r;\n\n\tr = vmx_deliver_nested_posted_interrupt(vcpu, vector);\n\tif (!r)\n\t\treturn 0;\n\n\tif (!vcpu->arch.apicv_active)\n\t\treturn -1;\n\n\tif (pi_test_and_set_pir(vector, &vmx->pi_desc))\n\t\treturn 0;\n\n\t/* If a previous notification has sent the IPI, nothing to do.  */\n\tif (pi_test_and_set_on(&vmx->pi_desc))\n\t\treturn 0;\n\n\tif (!kvm_vcpu_trigger_posted_interrupt(vcpu, false))\n\t\tkvm_vcpu_kick(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_deliver_nested_posted_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3813-3832",
    "snippet": "static int vmx_deliver_nested_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tint vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    vector == vmx->nested.posted_intr_nv) {\n\t\t/*\n\t\t * If a posted intr is not recognized by hardware,\n\t\t * we will accomplish it in the next vmentry.\n\t\t */\n\t\tvmx->nested.pi_pending = true;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t/* the PIR and ON have been set by L1. */\n\t\tif (!kvm_vcpu_trigger_posted_interrupt(vcpu, true))\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\treturn 0;\n\t}\n\treturn -1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 3828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_trigger_posted_interrupt",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 3827
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_trigger_posted_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3774-3811",
          "snippet": "static inline bool kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t     bool nested)\n{\n#ifdef CONFIG_SMP\n\tint pi_vec = nested ? POSTED_INTR_NESTED_VECTOR : POSTED_INTR_VECTOR;\n\n\tif (vcpu->mode == IN_GUEST_MODE) {\n\t\t/*\n\t\t * The vector of interrupt to be delivered to vcpu had\n\t\t * been set in PIR before this function.\n\t\t *\n\t\t * Following cases will be reached in this block, and\n\t\t * we always send a notification event in all cases as\n\t\t * explained below.\n\t\t *\n\t\t * Case 1: vcpu keeps in non-root mode. Sending a\n\t\t * notification event posts the interrupt to vcpu.\n\t\t *\n\t\t * Case 2: vcpu exits to root mode and is still\n\t\t * runnable. PIR will be synced to vIRR before the\n\t\t * next vcpu entry. Sending a notification event in\n\t\t * this case has no effect, as vcpu is not in root\n\t\t * mode.\n\t\t *\n\t\t * Case 3: vcpu exits to root mode and is blocked.\n\t\t * vcpu_block() has already synced PIR to vIRR and\n\t\t * never blocks vcpu if vIRR is not cleared. Therefore,\n\t\t * a blocked vcpu here does not wait for any requested\n\t\t * interrupts in PIR, and sending a notification event\n\t\t * which has no effect is safe here.\n\t\t */\n\n\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu), pi_vec);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic inline bool kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t     bool nested)\n{\n#ifdef CONFIG_SMP\n\tint pi_vec = nested ? POSTED_INTR_NESTED_VECTOR : POSTED_INTR_VECTOR;\n\n\tif (vcpu->mode == IN_GUEST_MODE) {\n\t\t/*\n\t\t * The vector of interrupt to be delivered to vcpu had\n\t\t * been set in PIR before this function.\n\t\t *\n\t\t * Following cases will be reached in this block, and\n\t\t * we always send a notification event in all cases as\n\t\t * explained below.\n\t\t *\n\t\t * Case 1: vcpu keeps in non-root mode. Sending a\n\t\t * notification event posts the interrupt to vcpu.\n\t\t *\n\t\t * Case 2: vcpu exits to root mode and is still\n\t\t * runnable. PIR will be synced to vIRR before the\n\t\t * next vcpu entry. Sending a notification event in\n\t\t * this case has no effect, as vcpu is not in root\n\t\t * mode.\n\t\t *\n\t\t * Case 3: vcpu exits to root mode and is blocked.\n\t\t * vcpu_block() has already synced PIR to vIRR and\n\t\t * never blocks vcpu if vIRR is not cleared. Therefore,\n\t\t * a blocked vcpu here does not wait for any requested\n\t\t * interrupts in PIR, and sending a notification event\n\t\t * which has no effect is safe here.\n\t\t */\n\n\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu), pi_vec);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 3818
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3816
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_deliver_nested_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\tint vector)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    vector == vmx->nested.posted_intr_nv) {\n\t\t/*\n\t\t * If a posted intr is not recognized by hardware,\n\t\t * we will accomplish it in the next vmentry.\n\t\t */\n\t\tvmx->nested.pi_pending = true;\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t\t/* the PIR and ON have been set by L1. */\n\t\tif (!kvm_vcpu_trigger_posted_interrupt(vcpu, true))\n\t\t\tkvm_vcpu_kick(vcpu);\n\t\treturn 0;\n\t}\n\treturn -1;\n}"
  },
  {
    "function_name": "kvm_vcpu_trigger_posted_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3774-3811",
    "snippet": "static inline bool kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t     bool nested)\n{\n#ifdef CONFIG_SMP\n\tint pi_vec = nested ? POSTED_INTR_NESTED_VECTOR : POSTED_INTR_VECTOR;\n\n\tif (vcpu->mode == IN_GUEST_MODE) {\n\t\t/*\n\t\t * The vector of interrupt to be delivered to vcpu had\n\t\t * been set in PIR before this function.\n\t\t *\n\t\t * Following cases will be reached in this block, and\n\t\t * we always send a notification event in all cases as\n\t\t * explained below.\n\t\t *\n\t\t * Case 1: vcpu keeps in non-root mode. Sending a\n\t\t * notification event posts the interrupt to vcpu.\n\t\t *\n\t\t * Case 2: vcpu exits to root mode and is still\n\t\t * runnable. PIR will be synced to vIRR before the\n\t\t * next vcpu entry. Sending a notification event in\n\t\t * this case has no effect, as vcpu is not in root\n\t\t * mode.\n\t\t *\n\t\t * Case 3: vcpu exits to root mode and is blocked.\n\t\t * vcpu_block() has already synced PIR to vIRR and\n\t\t * never blocks vcpu if vIRR is not cleared. Therefore,\n\t\t * a blocked vcpu here does not wait for any requested\n\t\t * interrupts in PIR, and sending a notification event\n\t\t * which has no effect is safe here.\n\t\t */\n\n\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu), pi_vec);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic->send_IPI_mask",
          "args": [
            "get_cpu_mask(vcpu->cpu)",
            "pi_vec"
          ],
          "line": 3806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_mask",
          "args": [
            "vcpu->cpu"
          ],
          "line": 3806
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic inline bool kvm_vcpu_trigger_posted_interrupt(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t     bool nested)\n{\n#ifdef CONFIG_SMP\n\tint pi_vec = nested ? POSTED_INTR_NESTED_VECTOR : POSTED_INTR_VECTOR;\n\n\tif (vcpu->mode == IN_GUEST_MODE) {\n\t\t/*\n\t\t * The vector of interrupt to be delivered to vcpu had\n\t\t * been set in PIR before this function.\n\t\t *\n\t\t * Following cases will be reached in this block, and\n\t\t * we always send a notification event in all cases as\n\t\t * explained below.\n\t\t *\n\t\t * Case 1: vcpu keeps in non-root mode. Sending a\n\t\t * notification event posts the interrupt to vcpu.\n\t\t *\n\t\t * Case 2: vcpu exits to root mode and is still\n\t\t * runnable. PIR will be synced to vIRR before the\n\t\t * next vcpu entry. Sending a notification event in\n\t\t * this case has no effect, as vcpu is not in root\n\t\t * mode.\n\t\t *\n\t\t * Case 3: vcpu exits to root mode and is blocked.\n\t\t * vcpu_block() has already synced PIR to vIRR and\n\t\t * never blocks vcpu if vIRR is not cleared. Therefore,\n\t\t * a blocked vcpu here does not wait for any requested\n\t\t * interrupts in PIR, and sending a notification event\n\t\t * which has no effect is safe here.\n\t\t */\n\n\t\tapic->send_IPI_mask(get_cpu_mask(vcpu->cpu), pi_vec);\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}"
  },
  {
    "function_name": "vmx_guest_apic_has_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3754-3772",
    "snippet": "static bool vmx_guest_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tvoid *vapic_page;\n\tu32 vppr;\n\tint rvi;\n\n\tif (WARN_ON_ONCE(!is_guest_mode(vcpu)) ||\n\t\t!nested_cpu_has_vid(get_vmcs12(vcpu)) ||\n\t\tWARN_ON_ONCE(!vmx->nested.virtual_apic_map.gfn))\n\t\treturn false;\n\n\trvi = vmx_get_rvi();\n\n\tvapic_page = vmx->nested.virtual_apic_map.hva;\n\tvppr = *((u32 *)(vapic_page + APIC_PROCPRI));\n\n\treturn ((rvi & 0xf0) > (vppr & 0xf0));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_get_rvi",
          "args": [],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_rvi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "413-416",
          "snippet": "static inline u8 vmx_get_rvi(void)\n{\n\treturn vmcs_read16(GUEST_INTR_STATUS) & 0xff;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline u8 vmx_get_rvi(void)\n{\n\treturn vmcs_read16(GUEST_INTR_STATUS) & 0xff;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!vmx->nested.virtual_apic_map.gfn"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_cpu_has_vid",
          "args": [
            "get_vmcs12(vcpu)"
          ],
          "line": 3762
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has_vid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "216-219",
          "snippet": "static inline bool nested_cpu_has_vid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_vid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 3762
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!is_guest_mode(vcpu)"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 3761
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool vmx_guest_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tvoid *vapic_page;\n\tu32 vppr;\n\tint rvi;\n\n\tif (WARN_ON_ONCE(!is_guest_mode(vcpu)) ||\n\t\t!nested_cpu_has_vid(get_vmcs12(vcpu)) ||\n\t\tWARN_ON_ONCE(!vmx->nested.virtual_apic_map.gfn))\n\t\treturn false;\n\n\trvi = vmx_get_rvi();\n\n\tvapic_page = vmx->nested.virtual_apic_map.hva;\n\tvppr = *((u32 *)(vapic_page + APIC_PROCPRI));\n\n\treturn ((rvi & 0xf0) > (vppr & 0xf0));\n}"
  },
  {
    "function_name": "pt_update_intercept_for_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3732-3752",
    "snippet": "void pt_update_intercept_for_msr(struct vcpu_vmx *vmx)\n{\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tbool flag = !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n\tu32 i;\n\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_STATUS,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_OUTPUT_BASE,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_OUTPUT_MASK,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_CR3_MATCH,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tfor (i = 0; i < vmx->pt_desc.addr_range; i++) {\n\t\tvmx_set_intercept_for_msr(msr_bitmap,\n\t\t\tMSR_IA32_RTIT_ADDR0_A + i * 2, MSR_TYPE_RW, flag);\n\t\tvmx_set_intercept_for_msr(msr_bitmap,\n\t\t\tMSR_IA32_RTIT_ADDR0_B + i * 2, MSR_TYPE_RW, flag);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_set_intercept_for_msr",
          "args": [
            "msr_bitmap",
            "MSR_IA32_RTIT_ADDR0_B + i * 2",
            "MSR_TYPE_RW",
            "flag"
          ],
          "line": 3749
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_intercept_for_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3667-3674",
          "snippet": "static __always_inline void vmx_set_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t     \t\t\t      u32 msr, int type, bool value)\n{\n\tif (value)\n\t\tvmx_enable_intercept_for_msr(msr_bitmap, msr, type);\n\telse\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, msr, type);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic __always_inline void vmx_set_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t     \t\t\t      u32 msr, int type, bool value)\n{\n\tif (value)\n\t\tvmx_enable_intercept_for_msr(msr_bitmap, msr, type);\n\telse\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, msr, type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid pt_update_intercept_for_msr(struct vcpu_vmx *vmx)\n{\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tbool flag = !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n\tu32 i;\n\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_STATUS,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_OUTPUT_BASE,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_OUTPUT_MASK,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_CR3_MATCH,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tfor (i = 0; i < vmx->pt_desc.addr_range; i++) {\n\t\tvmx_set_intercept_for_msr(msr_bitmap,\n\t\t\tMSR_IA32_RTIT_ADDR0_A + i * 2, MSR_TYPE_RW, flag);\n\t\tvmx_set_intercept_for_msr(msr_bitmap,\n\t\t\tMSR_IA32_RTIT_ADDR0_B + i * 2, MSR_TYPE_RW, flag);\n\t}\n}"
  },
  {
    "function_name": "vmx_update_msr_bitmap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3716-3730",
    "snippet": "void vmx_update_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tu8 mode = vmx_msr_bitmap_mode(vcpu);\n\tu8 changed = mode ^ vmx->msr_bitmap_mode;\n\n\tif (!changed)\n\t\treturn;\n\n\tif (changed & (MSR_BITMAP_MODE_X2APIC | MSR_BITMAP_MODE_X2APIC_APICV))\n\t\tvmx_update_msr_bitmap_x2apic(msr_bitmap, mode);\n\n\tvmx->msr_bitmap_mode = mode;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define MSR_BITMAP_MODE_X2APIC_APICV\t2",
      "#define MSR_BITMAP_MODE_X2APIC\t\t1"
    ],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_update_msr_bitmap_x2apic",
          "args": [
            "msr_bitmap",
            "mode"
          ],
          "line": 3727
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_update_msr_bitmap_x2apic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3691-3714",
          "snippet": "static void vmx_update_msr_bitmap_x2apic(unsigned long *msr_bitmap,\n\t\t\t\t\t u8 mode)\n{\n\tint msr;\n\n\tfor (msr = 0x800; msr <= 0x8ff; msr += BITS_PER_LONG) {\n\t\tunsigned word = msr / BITS_PER_LONG;\n\t\tmsr_bitmap[word] = (mode & MSR_BITMAP_MODE_X2APIC_APICV) ? 0 : ~0;\n\t\tmsr_bitmap[word + (0x800 / sizeof(long))] = ~0;\n\t}\n\n\tif (mode & MSR_BITMAP_MODE_X2APIC) {\n\t\t/*\n\t\t * TPR reads and writes can be virtualized even if virtual interrupt\n\t\t * delivery is not in use.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_TASKPRI), MSR_TYPE_RW);\n\t\tif (mode & MSR_BITMAP_MODE_X2APIC_APICV) {\n\t\t\tvmx_enable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_TMCCT), MSR_TYPE_R);\n\t\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_EOI), MSR_TYPE_W);\n\t\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_SELF_IPI), MSR_TYPE_W);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define MSR_BITMAP_MODE_X2APIC_APICV\t2",
            "#define MSR_BITMAP_MODE_X2APIC\t\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define MSR_BITMAP_MODE_X2APIC_APICV\t2\n#define MSR_BITMAP_MODE_X2APIC\t\t1\n\nstatic void vmx_update_msr_bitmap_x2apic(unsigned long *msr_bitmap,\n\t\t\t\t\t u8 mode)\n{\n\tint msr;\n\n\tfor (msr = 0x800; msr <= 0x8ff; msr += BITS_PER_LONG) {\n\t\tunsigned word = msr / BITS_PER_LONG;\n\t\tmsr_bitmap[word] = (mode & MSR_BITMAP_MODE_X2APIC_APICV) ? 0 : ~0;\n\t\tmsr_bitmap[word + (0x800 / sizeof(long))] = ~0;\n\t}\n\n\tif (mode & MSR_BITMAP_MODE_X2APIC) {\n\t\t/*\n\t\t * TPR reads and writes can be virtualized even if virtual interrupt\n\t\t * delivery is not in use.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_TASKPRI), MSR_TYPE_RW);\n\t\tif (mode & MSR_BITMAP_MODE_X2APIC_APICV) {\n\t\t\tvmx_enable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_TMCCT), MSR_TYPE_R);\n\t\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_EOI), MSR_TYPE_W);\n\t\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_SELF_IPI), MSR_TYPE_W);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_msr_bitmap_mode",
          "args": [
            "vcpu"
          ],
          "line": 3720
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_msr_bitmap_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3676-3689",
          "snippet": "static u8 vmx_msr_bitmap_mode(struct kvm_vcpu *vcpu)\n{\n\tu8 mode = 0;\n\n\tif (cpu_has_secondary_exec_ctrls() &&\n\t    (secondary_exec_controls_get(to_vmx(vcpu)) &\n\t     SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tmode |= MSR_BITMAP_MODE_X2APIC;\n\t\tif (enable_apicv && kvm_vcpu_apicv_active(vcpu))\n\t\t\tmode |= MSR_BITMAP_MODE_X2APIC_APICV;\n\t}\n\n\treturn mode;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define MSR_BITMAP_MODE_X2APIC_APICV\t2",
            "#define MSR_BITMAP_MODE_X2APIC\t\t1"
          ],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define MSR_BITMAP_MODE_X2APIC_APICV\t2\n#define MSR_BITMAP_MODE_X2APIC\t\t1\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic u8 vmx_msr_bitmap_mode(struct kvm_vcpu *vcpu)\n{\n\tu8 mode = 0;\n\n\tif (cpu_has_secondary_exec_ctrls() &&\n\t    (secondary_exec_controls_get(to_vmx(vcpu)) &\n\t     SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tmode |= MSR_BITMAP_MODE_X2APIC;\n\t\tif (enable_apicv && kvm_vcpu_apicv_active(vcpu))\n\t\t\tmode |= MSR_BITMAP_MODE_X2APIC_APICV;\n\t}\n\n\treturn mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3718
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define MSR_BITMAP_MODE_X2APIC_APICV\t2\n#define MSR_BITMAP_MODE_X2APIC\t\t1\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_update_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tu8 mode = vmx_msr_bitmap_mode(vcpu);\n\tu8 changed = mode ^ vmx->msr_bitmap_mode;\n\n\tif (!changed)\n\t\treturn;\n\n\tif (changed & (MSR_BITMAP_MODE_X2APIC | MSR_BITMAP_MODE_X2APIC_APICV))\n\t\tvmx_update_msr_bitmap_x2apic(msr_bitmap, mode);\n\n\tvmx->msr_bitmap_mode = mode;\n}"
  },
  {
    "function_name": "vmx_update_msr_bitmap_x2apic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3691-3714",
    "snippet": "static void vmx_update_msr_bitmap_x2apic(unsigned long *msr_bitmap,\n\t\t\t\t\t u8 mode)\n{\n\tint msr;\n\n\tfor (msr = 0x800; msr <= 0x8ff; msr += BITS_PER_LONG) {\n\t\tunsigned word = msr / BITS_PER_LONG;\n\t\tmsr_bitmap[word] = (mode & MSR_BITMAP_MODE_X2APIC_APICV) ? 0 : ~0;\n\t\tmsr_bitmap[word + (0x800 / sizeof(long))] = ~0;\n\t}\n\n\tif (mode & MSR_BITMAP_MODE_X2APIC) {\n\t\t/*\n\t\t * TPR reads and writes can be virtualized even if virtual interrupt\n\t\t * delivery is not in use.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_TASKPRI), MSR_TYPE_RW);\n\t\tif (mode & MSR_BITMAP_MODE_X2APIC_APICV) {\n\t\t\tvmx_enable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_TMCCT), MSR_TYPE_R);\n\t\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_EOI), MSR_TYPE_W);\n\t\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_SELF_IPI), MSR_TYPE_W);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define MSR_BITMAP_MODE_X2APIC_APICV\t2",
      "#define MSR_BITMAP_MODE_X2APIC\t\t1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_disable_intercept_for_msr",
          "args": [
            "msr_bitmap",
            "X2APIC_MSR(APIC_SELF_IPI)",
            "MSR_TYPE_W"
          ],
          "line": 3711
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_disable_intercept_for_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3591-3627",
          "snippet": "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "X2APIC_MSR",
          "args": [
            "APIC_SELF_IPI"
          ],
          "line": 3711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X2APIC_MSR",
          "args": [
            "APIC_EOI"
          ],
          "line": 3710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_enable_intercept_for_msr",
          "args": [
            "msr_bitmap",
            "X2APIC_MSR(APIC_TMCCT)",
            "MSR_TYPE_R"
          ],
          "line": 3709
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_enable_intercept_for_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3629-3665",
          "snippet": "static __always_inline void vmx_enable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic __always_inline void vmx_enable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "X2APIC_MSR",
          "args": [
            "APIC_TMCCT"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "X2APIC_MSR",
          "args": [
            "APIC_TASKPRI"
          ],
          "line": 3707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define MSR_BITMAP_MODE_X2APIC_APICV\t2\n#define MSR_BITMAP_MODE_X2APIC\t\t1\n\nstatic void vmx_update_msr_bitmap_x2apic(unsigned long *msr_bitmap,\n\t\t\t\t\t u8 mode)\n{\n\tint msr;\n\n\tfor (msr = 0x800; msr <= 0x8ff; msr += BITS_PER_LONG) {\n\t\tunsigned word = msr / BITS_PER_LONG;\n\t\tmsr_bitmap[word] = (mode & MSR_BITMAP_MODE_X2APIC_APICV) ? 0 : ~0;\n\t\tmsr_bitmap[word + (0x800 / sizeof(long))] = ~0;\n\t}\n\n\tif (mode & MSR_BITMAP_MODE_X2APIC) {\n\t\t/*\n\t\t * TPR reads and writes can be virtualized even if virtual interrupt\n\t\t * delivery is not in use.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_TASKPRI), MSR_TYPE_RW);\n\t\tif (mode & MSR_BITMAP_MODE_X2APIC_APICV) {\n\t\t\tvmx_enable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_TMCCT), MSR_TYPE_R);\n\t\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_EOI), MSR_TYPE_W);\n\t\t\tvmx_disable_intercept_for_msr(msr_bitmap, X2APIC_MSR(APIC_SELF_IPI), MSR_TYPE_W);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "vmx_msr_bitmap_mode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3676-3689",
    "snippet": "static u8 vmx_msr_bitmap_mode(struct kvm_vcpu *vcpu)\n{\n\tu8 mode = 0;\n\n\tif (cpu_has_secondary_exec_ctrls() &&\n\t    (secondary_exec_controls_get(to_vmx(vcpu)) &\n\t     SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tmode |= MSR_BITMAP_MODE_X2APIC;\n\t\tif (enable_apicv && kvm_vcpu_apicv_active(vcpu))\n\t\t\tmode |= MSR_BITMAP_MODE_X2APIC_APICV;\n\t}\n\n\treturn mode;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define MSR_BITMAP_MODE_X2APIC_APICV\t2",
      "#define MSR_BITMAP_MODE_X2APIC\t\t1"
    ],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 3684
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "secondary_exec_controls_get",
          "args": [
            "to_vmx(vcpu)"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3681
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_secondary_exec_ctrls",
          "args": [],
          "line": 3680
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_secondary_exec_ctrls",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "125-129",
          "snippet": "static inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_secondary_exec_ctrls(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl &\n\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define MSR_BITMAP_MODE_X2APIC_APICV\t2\n#define MSR_BITMAP_MODE_X2APIC\t\t1\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic u8 vmx_msr_bitmap_mode(struct kvm_vcpu *vcpu)\n{\n\tu8 mode = 0;\n\n\tif (cpu_has_secondary_exec_ctrls() &&\n\t    (secondary_exec_controls_get(to_vmx(vcpu)) &\n\t     SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE)) {\n\t\tmode |= MSR_BITMAP_MODE_X2APIC;\n\t\tif (enable_apicv && kvm_vcpu_apicv_active(vcpu))\n\t\t\tmode |= MSR_BITMAP_MODE_X2APIC_APICV;\n\t}\n\n\treturn mode;\n}"
  },
  {
    "function_name": "vmx_set_intercept_for_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3667-3674",
    "snippet": "static __always_inline void vmx_set_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t     \t\t\t      u32 msr, int type, bool value)\n{\n\tif (value)\n\t\tvmx_enable_intercept_for_msr(msr_bitmap, msr, type);\n\telse\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, msr, type);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_disable_intercept_for_msr",
          "args": [
            "msr_bitmap",
            "msr",
            "type"
          ],
          "line": 3673
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_disable_intercept_for_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3591-3627",
          "snippet": "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_enable_intercept_for_msr",
          "args": [
            "msr_bitmap",
            "msr",
            "type"
          ],
          "line": 3671
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_enable_intercept_for_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3629-3665",
          "snippet": "static __always_inline void vmx_enable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic __always_inline void vmx_enable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic __always_inline void vmx_set_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t     \t\t\t      u32 msr, int type, bool value)\n{\n\tif (value)\n\t\tvmx_enable_intercept_for_msr(msr_bitmap, msr, type);\n\telse\n\t\tvmx_disable_intercept_for_msr(msr_bitmap, msr, type);\n}"
  },
  {
    "function_name": "vmx_enable_intercept_for_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3629-3665",
    "snippet": "static __always_inline void vmx_enable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "msr",
            "msr_bitmap + 0xc00 / f"
          ],
          "line": 3662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "msr",
            "msr_bitmap + 0x400 / f"
          ],
          "line": 3658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "msr",
            "msr_bitmap + 0x800 / f"
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "msr",
            "msr_bitmap + 0x000 / f"
          ],
          "line": 3648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evmcs_touch_msr_bitmap",
          "args": [],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_touch_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "198-198",
          "snippet": "static inline void evmcs_touch_msr_bitmap(void) {}",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline void evmcs_touch_msr_bitmap(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 3637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_msr_bitmap",
          "args": [],
          "line": 3634
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "120-123",
          "snippet": "static inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic __always_inline void vmx_enable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__set_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__set_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}"
  },
  {
    "function_name": "vmx_disable_intercept_for_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3591-3627",
    "snippet": "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "msr",
            "msr_bitmap + 0xc00 / f"
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "msr",
            "msr_bitmap + 0x400 / f"
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "msr",
            "msr_bitmap + 0x800 / f"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "msr",
            "msr_bitmap + 0x000 / f"
          ],
          "line": 3610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evmcs_touch_msr_bitmap",
          "args": [],
          "line": 3600
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_touch_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "198-198",
          "snippet": "static inline void evmcs_touch_msr_bitmap(void) {}",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline void evmcs_touch_msr_bitmap(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 3599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_msr_bitmap",
          "args": [],
          "line": 3596
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "120-123",
          "snippet": "static inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}"
  },
  {
    "function_name": "free_vpid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3582-3589",
    "snippet": "void free_vpid(int vpid)\n{\n\tif (!enable_vpid || vpid == 0)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\t__clear_bit(vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(vmx_vpid_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmx_vpid_lock"
          ],
          "line": 3588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "vpid",
            "vmx_vpid_bitmap"
          ],
          "line": 3587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmx_vpid_lock"
          ],
          "line": 3586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic DEFINE_SPINLOCK(vmx_vpid_lock);\n\nvoid free_vpid(int vpid)\n{\n\tif (!enable_vpid || vpid == 0)\n\t\treturn;\n\tspin_lock(&vmx_vpid_lock);\n\t__clear_bit(vpid, vmx_vpid_bitmap);\n\tspin_unlock(&vmx_vpid_lock);\n}"
  },
  {
    "function_name": "allocate_vpid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3566-3580",
    "snippet": "int allocate_vpid(void)\n{\n\tint vpid;\n\n\tif (!enable_vpid)\n\t\treturn 0;\n\tspin_lock(&vmx_vpid_lock);\n\tvpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);\n\tif (vpid < VMX_NR_VPIDS)\n\t\t__set_bit(vpid, vmx_vpid_bitmap);\n\telse\n\t\tvpid = 0;\n\tspin_unlock(&vmx_vpid_lock);\n\treturn vpid;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_BITMAP(vmx_vpid_bitmap, VMX_NR_VPIDS);",
      "static DEFINE_SPINLOCK(vmx_vpid_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vmx_vpid_lock"
          ],
          "line": 3578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "vpid",
            "vmx_vpid_bitmap"
          ],
          "line": 3575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_zero_bit",
          "args": [
            "vmx_vpid_bitmap",
            "VMX_NR_VPIDS"
          ],
          "line": 3573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vmx_vpid_lock"
          ],
          "line": 3572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic DECLARE_BITMAP(vmx_vpid_bitmap, VMX_NR_VPIDS);\nstatic DEFINE_SPINLOCK(vmx_vpid_lock);\n\nint allocate_vpid(void)\n{\n\tint vpid;\n\n\tif (!enable_vpid)\n\t\treturn 0;\n\tspin_lock(&vmx_vpid_lock);\n\tvpid = find_first_zero_bit(vmx_vpid_bitmap, VMX_NR_VPIDS);\n\tif (vpid < VMX_NR_VPIDS)\n\t\t__set_bit(vpid, vmx_vpid_bitmap);\n\telse\n\t\tvpid = 0;\n\tspin_unlock(&vmx_vpid_lock);\n\treturn vpid;\n}"
  },
  {
    "function_name": "alloc_apic_access_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3536-3564",
    "snippet": "static int alloc_apic_access_page(struct kvm *kvm)\n{\n\tstruct page *page;\n\tint r = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tif (kvm->arch.apic_access_page_done)\n\t\tgoto out;\n\tr = __x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t    APIC_DEFAULT_PHYS_BASE, PAGE_SIZE);\n\tif (r)\n\t\tgoto out;\n\n\tpage = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not pin the page in memory, so that memory hot-unplug\n\t * is able to migrate it.\n\t */\n\tput_page(page);\n\tkvm->arch.apic_access_page_done = true;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 3559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_page",
          "args": [
            "page"
          ],
          "line": 3550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_page",
          "args": [
            "kvm",
            "APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT"
          ],
          "line": 3549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__x86_set_memory_region",
          "args": [
            "kvm",
            "APIC_ACCESS_PAGE_PRIVATE_MEMSLOT",
            "APIC_DEFAULT_PHYS_BASE",
            "PAGE_SIZE"
          ],
          "line": 3544
        },
        "resolved": true,
        "details": {
          "function_name": "__x86_set_memory_region",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9800-9854",
          "snippet": "int __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva, uninitialized_var(old_npages);\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (slot && slot->npages)\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot || !slot->npages)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Stuff a non-canonical value to catch use-after-delete.  This\n\t\t * ends up being 0 on 32-bit KVM, but there's no better\n\t\t * alternative.\n\t\t */\n\t\thva = (unsigned long)(0xdeadull << 48);\n\t\told_npages = slot->npages;\n\t}\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size)\n\t\tvm_munmap(hva, old_npages * PAGE_SIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva, uninitialized_var(old_npages);\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (slot && slot->npages)\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot || !slot->npages)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Stuff a non-canonical value to catch use-after-delete.  This\n\t\t * ends up being 0 on 32-bit KVM, but there's no better\n\t\t * alternative.\n\t\t */\n\t\thva = (unsigned long)(0xdeadull << 48);\n\t\told_npages = slot->npages;\n\t}\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size)\n\t\tvm_munmap(hva, old_npages * PAGE_SIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int alloc_apic_access_page(struct kvm *kvm)\n{\n\tstruct page *page;\n\tint r = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\tif (kvm->arch.apic_access_page_done)\n\t\tgoto out;\n\tr = __x86_set_memory_region(kvm, APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t    APIC_DEFAULT_PHYS_BASE, PAGE_SIZE);\n\tif (r)\n\t\tgoto out;\n\n\tpage = gfn_to_page(kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n\tif (is_error_page(page)) {\n\t\tr = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Do not pin the page in memory, so that memory hot-unplug\n\t * is able to migrate it.\n\t */\n\tput_page(page);\n\tkvm->arch.apic_access_page_done = true;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}"
  },
  {
    "function_name": "seg_setup",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3521-3534",
    "snippet": "static void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; /* code segment */\n\n\tvmcs_write32(sf->ar_bytes, ar);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "sf->ar_bytes",
            "ar"
          ],
          "line": 3533
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "sf->base",
            "0"
          ],
          "line": 3527
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write16",
          "args": [
            "sf->selector",
            "0"
          ],
          "line": 3526
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "175-182",
          "snippet": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic void seg_setup(int seg)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tunsigned int ar;\n\n\tvmcs_write16(sf->selector, 0);\n\tvmcs_writel(sf->base, 0);\n\tvmcs_write32(sf->limit, 0xffff);\n\tar = 0x93;\n\tif (seg == VCPU_SREG_CS)\n\t\tar |= 0x08; /* code segment */\n\n\tvmcs_write32(sf->ar_bytes, ar);\n}"
  },
  {
    "function_name": "init_rmode_identity_map",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3480-3519",
    "snippet": "static int init_rmode_identity_map(struct kvm *kvm)\n{\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(kvm);\n\tint i, r = 0;\n\tkvm_pfn_t identity_map_pfn;\n\tu32 tmp;\n\n\t/* Protect kvm_vmx->ept_identity_pagetable_done. */\n\tmutex_lock(&kvm->slots_lock);\n\n\tif (likely(kvm_vmx->ept_identity_pagetable_done))\n\t\tgoto out;\n\n\tif (!kvm_vmx->ept_identity_map_addr)\n\t\tkvm_vmx->ept_identity_map_addr = VMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\tidentity_map_pfn = kvm_vmx->ept_identity_map_addr >> PAGE_SHIFT;\n\n\tr = __x86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,\n\t\t\t\t    kvm_vmx->ept_identity_map_addr, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = kvm_clear_guest_page(kvm, identity_map_pfn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\t/* Set up identity-mapping pagetable for EPT in real mode */\n\tfor (i = 0; i < PT32_ENT_PER_PAGE; i++) {\n\t\ttmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |\n\t\t\t_PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_PSE);\n\t\tr = kvm_write_guest_page(kvm, identity_map_pfn,\n\t\t\t\t&tmp, i * sizeof(tmp), sizeof(tmp));\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\tkvm_vmx->ept_identity_pagetable_done = true;\n\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest_page",
          "args": [
            "kvm",
            "identity_map_pfn",
            "&tmp",
            "i * sizeof(tmp)",
            "sizeof(tmp)"
          ],
          "line": 3509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_clear_guest_page",
          "args": [
            "kvm",
            "identity_map_pfn",
            "0",
            "PAGE_SIZE"
          ],
          "line": 3502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__x86_set_memory_region",
          "args": [
            "kvm",
            "IDENTITY_PAGETABLE_PRIVATE_MEMSLOT",
            "kvm_vmx->ept_identity_map_addr",
            "PAGE_SIZE"
          ],
          "line": 3497
        },
        "resolved": true,
        "details": {
          "function_name": "__x86_set_memory_region",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9800-9854",
          "snippet": "int __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva, uninitialized_var(old_npages);\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (slot && slot->npages)\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot || !slot->npages)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Stuff a non-canonical value to catch use-after-delete.  This\n\t\t * ends up being 0 on 32-bit KVM, but there's no better\n\t\t * alternative.\n\t\t */\n\t\thva = (unsigned long)(0xdeadull << 48);\n\t\told_npages = slot->npages;\n\t}\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size)\n\t\tvm_munmap(hva, old_npages * PAGE_SIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva, uninitialized_var(old_npages);\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (slot && slot->npages)\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot || !slot->npages)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Stuff a non-canonical value to catch use-after-delete.  This\n\t\t * ends up being 0 on 32-bit KVM, but there's no better\n\t\t * alternative.\n\t\t */\n\t\thva = (unsigned long)(0xdeadull << 48);\n\t\told_npages = slot->npages;\n\t}\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size)\n\t\tvm_munmap(hva, old_npages * PAGE_SIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "kvm_vmx->ept_identity_pagetable_done"
          ],
          "line": 3490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_vmx",
          "args": [
            "kvm"
          ],
          "line": 3482
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "474-477",
          "snippet": "static inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int init_rmode_identity_map(struct kvm *kvm)\n{\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(kvm);\n\tint i, r = 0;\n\tkvm_pfn_t identity_map_pfn;\n\tu32 tmp;\n\n\t/* Protect kvm_vmx->ept_identity_pagetable_done. */\n\tmutex_lock(&kvm->slots_lock);\n\n\tif (likely(kvm_vmx->ept_identity_pagetable_done))\n\t\tgoto out;\n\n\tif (!kvm_vmx->ept_identity_map_addr)\n\t\tkvm_vmx->ept_identity_map_addr = VMX_EPT_IDENTITY_PAGETABLE_ADDR;\n\tidentity_map_pfn = kvm_vmx->ept_identity_map_addr >> PAGE_SHIFT;\n\n\tr = __x86_set_memory_region(kvm, IDENTITY_PAGETABLE_PRIVATE_MEMSLOT,\n\t\t\t\t    kvm_vmx->ept_identity_map_addr, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\n\tr = kvm_clear_guest_page(kvm, identity_map_pfn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\t/* Set up identity-mapping pagetable for EPT in real mode */\n\tfor (i = 0; i < PT32_ENT_PER_PAGE; i++) {\n\t\ttmp = (i << 22) + (_PAGE_PRESENT | _PAGE_RW | _PAGE_USER |\n\t\t\t_PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_PSE);\n\t\tr = kvm_write_guest_page(kvm, identity_map_pfn,\n\t\t\t\t&tmp, i * sizeof(tmp), sizeof(tmp));\n\t\tif (r < 0)\n\t\t\tgoto out;\n\t}\n\tkvm_vmx->ept_identity_pagetable_done = true;\n\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn r;\n}"
  },
  {
    "function_name": "init_rmode_tss",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3449-3478",
    "snippet": "static int init_rmode_tss(struct kvm *kvm)\n{\n\tgfn_t fn;\n\tu16 data = 0;\n\tint idx, r;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tfn = to_kvm_vmx(kvm)->tss_addr >> PAGE_SHIFT;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;\n\tr = kvm_write_guest_page(kvm, fn++, &data,\n\t\t\tTSS_IOPB_BASE_OFFSET, sizeof(u16));\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn++, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = ~0;\n\tr = kvm_write_guest_page(kvm, fn, &data,\n\t\t\t\t RMODE_TSS_SIZE - 2 * PAGE_SIZE - 1,\n\t\t\t\t sizeof(u8));\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn r;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->srcu",
            "idx"
          ],
          "line": 3476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest_page",
          "args": [
            "kvm",
            "fn",
            "&data",
            "RMODE_TSS_SIZE - 2 * PAGE_SIZE - 1",
            "sizeof(u8)"
          ],
          "line": 3472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_clear_guest_page",
          "args": [
            "kvm",
            "fn",
            "0",
            "PAGE_SIZE"
          ],
          "line": 3468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_clear_guest_page",
          "args": [
            "kvm",
            "fn++",
            "0",
            "PAGE_SIZE"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest_page",
          "args": [
            "kvm",
            "fn++",
            "&data",
            "TSS_IOPB_BASE_OFFSET",
            "sizeof(u16)"
          ],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_clear_guest_page",
          "args": [
            "kvm",
            "fn",
            "0",
            "PAGE_SIZE"
          ],
          "line": 3457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_vmx",
          "args": [
            "kvm"
          ],
          "line": 3456
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "474-477",
          "snippet": "static inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->srcu"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int init_rmode_tss(struct kvm *kvm)\n{\n\tgfn_t fn;\n\tu16 data = 0;\n\tint idx, r;\n\n\tidx = srcu_read_lock(&kvm->srcu);\n\tfn = to_kvm_vmx(kvm)->tss_addr >> PAGE_SHIFT;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = TSS_BASE_SIZE + TSS_REDIRECTION_SIZE;\n\tr = kvm_write_guest_page(kvm, fn++, &data,\n\t\t\tTSS_IOPB_BASE_OFFSET, sizeof(u16));\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn++, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tr = kvm_clear_guest_page(kvm, fn, 0, PAGE_SIZE);\n\tif (r < 0)\n\t\tgoto out;\n\tdata = ~0;\n\tr = kvm_write_guest_page(kvm, fn, &data,\n\t\t\t\t RMODE_TSS_SIZE - 2 * PAGE_SIZE - 1,\n\t\t\t\t sizeof(u8));\nout:\n\tsrcu_read_unlock(&kvm->srcu, idx);\n\treturn r;\n}"
  },
  {
    "function_name": "guest_state_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3401-3447",
    "snippet": "static bool guest_state_valid(struct kvm_vcpu *vcpu)\n{\n\tif (enable_unrestricted_guest)\n\t\treturn true;\n\n\t/* real mode guest state checks */\n\tif (!is_protmode(vcpu) || (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_CS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_SS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t} else {\n\t/* protected mode guest state checks */\n\t\tif (!cs_ss_rpl_check(vcpu))\n\t\t\treturn false;\n\t\tif (!code_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!stack_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t\tif (!tr_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!ldtr_valid(vcpu))\n\t\t\treturn false;\n\t}\n\t/* TODO:\n\t * - Add checks on RIP\n\t * - Add checks on RFLAGS\n\t */\n\n\treturn true;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ldtr_valid",
          "args": [
            "vcpu"
          ],
          "line": 3438
        },
        "resolved": true,
        "details": {
          "function_name": "ldtr_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3367-3383",
          "snippet": "static bool ldtr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ldtr;\n\n\tvmx_get_segment(vcpu, &ldtr, VCPU_SREG_LDTR);\n\n\tif (ldtr.unusable)\n\t\treturn true;\n\tif (ldtr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (ldtr.type != 2)\n\t\treturn false;\n\tif (!ldtr.present)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic bool ldtr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ldtr;\n\n\tvmx_get_segment(vcpu, &ldtr, VCPU_SREG_LDTR);\n\n\tif (ldtr.unusable)\n\t\treturn true;\n\tif (ldtr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (ldtr.type != 2)\n\t\treturn false;\n\tif (!ldtr.present)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data_segment_valid",
          "args": [
            "vcpu",
            "VCPU_SREG_GS"
          ],
          "line": 3434
        },
        "resolved": true,
        "details": {
          "function_name": "data_segment_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3324-3347",
          "snippet": "static bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tunsigned int rpl;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\trpl = var.selector & SEGMENT_RPL_MASK;\n\n\tif (var.unusable)\n\t\treturn true;\n\tif (!var.s)\n\t\treturn false;\n\tif (!var.present)\n\t\treturn false;\n\tif (~var.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_WRITEABLE_MASK)) {\n\t\tif (var.dpl < rpl) /* DPL < RPL */\n\t\t\treturn false;\n\t}\n\n\t/* TODO: Add other members to kvm_segment_field to allow checking for other access\n\t * rights flags\n\t */\n\treturn true;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tunsigned int rpl;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\trpl = var.selector & SEGMENT_RPL_MASK;\n\n\tif (var.unusable)\n\t\treturn true;\n\tif (!var.s)\n\t\treturn false;\n\tif (!var.present)\n\t\treturn false;\n\tif (~var.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_WRITEABLE_MASK)) {\n\t\tif (var.dpl < rpl) /* DPL < RPL */\n\t\t\treturn false;\n\t}\n\n\t/* TODO: Add other members to kvm_segment_field to allow checking for other access\n\t * rights flags\n\t */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stack_segment_valid",
          "args": [
            "vcpu"
          ],
          "line": 3426
        },
        "resolved": true,
        "details": {
          "function_name": "stack_segment_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3302-3322",
          "snippet": "static bool stack_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ss;\n\tunsigned int ss_rpl;\n\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\tss_rpl = ss.selector & SEGMENT_RPL_MASK;\n\n\tif (ss.unusable)\n\t\treturn true;\n\tif (ss.type != 3 && ss.type != 7)\n\t\treturn false;\n\tif (!ss.s)\n\t\treturn false;\n\tif (ss.dpl != ss_rpl) /* DPL != RPL */\n\t\treturn false;\n\tif (!ss.present)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic bool stack_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ss;\n\tunsigned int ss_rpl;\n\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\tss_rpl = ss.selector & SEGMENT_RPL_MASK;\n\n\tif (ss.unusable)\n\t\treturn true;\n\tif (ss.type != 3 && ss.type != 7)\n\t\treturn false;\n\tif (!ss.s)\n\t\treturn false;\n\tif (ss.dpl != ss_rpl) /* DPL != RPL */\n\t\treturn false;\n\tif (!ss.present)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "code_segment_valid",
          "args": [
            "vcpu"
          ],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "code_segment_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3274-3300",
          "snippet": "static bool code_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tunsigned int cs_rpl;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs_rpl = cs.selector & SEGMENT_RPL_MASK;\n\n\tif (cs.unusable)\n\t\treturn false;\n\tif (~cs.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_ACCESSES_MASK))\n\t\treturn false;\n\tif (!cs.s)\n\t\treturn false;\n\tif (cs.type & VMX_AR_TYPE_WRITEABLE_MASK) {\n\t\tif (cs.dpl > cs_rpl)\n\t\t\treturn false;\n\t} else {\n\t\tif (cs.dpl != cs_rpl)\n\t\t\treturn false;\n\t}\n\tif (!cs.present)\n\t\treturn false;\n\n\t/* TODO: Add Reserved field check, this'll require a new member in the kvm_segment_field structure */\n\treturn true;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic bool code_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tunsigned int cs_rpl;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs_rpl = cs.selector & SEGMENT_RPL_MASK;\n\n\tif (cs.unusable)\n\t\treturn false;\n\tif (~cs.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_ACCESSES_MASK))\n\t\treturn false;\n\tif (!cs.s)\n\t\treturn false;\n\tif (cs.type & VMX_AR_TYPE_WRITEABLE_MASK) {\n\t\tif (cs.dpl > cs_rpl)\n\t\t\treturn false;\n\t} else {\n\t\tif (cs.dpl != cs_rpl)\n\t\t\treturn false;\n\t}\n\tif (!cs.present)\n\t\treturn false;\n\n\t/* TODO: Add Reserved field check, this'll require a new member in the kvm_segment_field structure */\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cs_ss_rpl_check",
          "args": [
            "vcpu"
          ],
          "line": 3422
        },
        "resolved": true,
        "details": {
          "function_name": "cs_ss_rpl_check",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3385-3394",
          "snippet": "static bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ss;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\n\treturn ((cs.selector & SEGMENT_RPL_MASK) ==\n\t\t (ss.selector & SEGMENT_RPL_MASK));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ss;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\n\treturn ((cs.selector & SEGMENT_RPL_MASK) ==\n\t\t (ss.selector & SEGMENT_RPL_MASK));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmode_segment_valid",
          "args": [
            "vcpu",
            "VCPU_SREG_GS"
          ],
          "line": 3418
        },
        "resolved": true,
        "details": {
          "function_name": "rmode_segment_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3253-3272",
          "snippet": "static bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tu32 ar;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\tar = vmx_segment_access_rights(&var);\n\n\tif (var.base != (var.selector << 4))\n\t\treturn false;\n\tif (var.limit != 0xffff)\n\t\treturn false;\n\tif (ar != 0xf3)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tu32 ar;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\tar = vmx_segment_access_rights(&var);\n\n\tif (var.base != (var.selector << 4))\n\t\treturn false;\n\tif (var.limit != 0xffff)\n\t\treturn false;\n\tif (ar != 0xf3)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 3407
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_rflags",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1405-1421",
          "snippet": "unsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long rflags, save_rflags;\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_RFLAGS)) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (vmx->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = vmx->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tvmx->rflags = rflags;\n\t}\n\treturn vmx->rflags;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))"
          ],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nunsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long rflags, save_rflags;\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_RFLAGS)) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (vmx->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = vmx->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tvmx->rflags = rflags;\n\t}\n\treturn vmx->rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_protmode",
          "args": [
            "vcpu"
          ],
          "line": 3407
        },
        "resolved": true,
        "details": {
          "function_name": "is_protmode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "80-83",
          "snippet": "static inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu)\n{\n\tif (enable_unrestricted_guest)\n\t\treturn true;\n\n\t/* real mode guest state checks */\n\tif (!is_protmode(vcpu) || (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_CS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_SS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t} else {\n\t/* protected mode guest state checks */\n\t\tif (!cs_ss_rpl_check(vcpu))\n\t\t\treturn false;\n\t\tif (!code_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!stack_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t\tif (!tr_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!ldtr_valid(vcpu))\n\t\t\treturn false;\n\t}\n\t/* TODO:\n\t * - Add checks on RIP\n\t * - Add checks on RFLAGS\n\t */\n\n\treturn true;\n}"
  },
  {
    "function_name": "cs_ss_rpl_check",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3385-3394",
    "snippet": "static bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ss;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\n\treturn ((cs.selector & SEGMENT_RPL_MASK) ==\n\t\t (ss.selector & SEGMENT_RPL_MASK));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_get_segment",
          "args": [
            "vcpu",
            "&ss",
            "VCPU_SREG_SS"
          ],
          "line": 3390
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3102-3136",
          "snippet": "void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool cs_ss_rpl_check(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs, ss;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\n\treturn ((cs.selector & SEGMENT_RPL_MASK) ==\n\t\t (ss.selector & SEGMENT_RPL_MASK));\n}"
  },
  {
    "function_name": "ldtr_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3367-3383",
    "snippet": "static bool ldtr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ldtr;\n\n\tvmx_get_segment(vcpu, &ldtr, VCPU_SREG_LDTR);\n\n\tif (ldtr.unusable)\n\t\treturn true;\n\tif (ldtr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (ldtr.type != 2)\n\t\treturn false;\n\tif (!ldtr.present)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_get_segment",
          "args": [
            "vcpu",
            "&ldtr",
            "VCPU_SREG_LDTR"
          ],
          "line": 3371
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3102-3136",
          "snippet": "void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic bool ldtr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ldtr;\n\n\tvmx_get_segment(vcpu, &ldtr, VCPU_SREG_LDTR);\n\n\tif (ldtr.unusable)\n\t\treturn true;\n\tif (ldtr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (ldtr.type != 2)\n\t\treturn false;\n\tif (!ldtr.present)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "tr_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3349-3365",
    "snippet": "static bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) /* TODO: Check if guest is in IA32e mode */\n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_get_segment",
          "args": [
            "vcpu",
            "&tr",
            "VCPU_SREG_TR"
          ],
          "line": 3353
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3102-3136",
          "snippet": "void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic bool tr_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment tr;\n\n\tvmx_get_segment(vcpu, &tr, VCPU_SREG_TR);\n\n\tif (tr.unusable)\n\t\treturn false;\n\tif (tr.selector & SEGMENT_TI_MASK)\t/* TI = 1 */\n\t\treturn false;\n\tif (tr.type != 3 && tr.type != 11) /* TODO: Check if guest is in IA32e mode */\n\t\treturn false;\n\tif (!tr.present)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "data_segment_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3324-3347",
    "snippet": "static bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tunsigned int rpl;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\trpl = var.selector & SEGMENT_RPL_MASK;\n\n\tif (var.unusable)\n\t\treturn true;\n\tif (!var.s)\n\t\treturn false;\n\tif (!var.present)\n\t\treturn false;\n\tif (~var.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_WRITEABLE_MASK)) {\n\t\tif (var.dpl < rpl) /* DPL < RPL */\n\t\t\treturn false;\n\t}\n\n\t/* TODO: Add other members to kvm_segment_field to allow checking for other access\n\t * rights flags\n\t */\n\treturn true;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_get_segment",
          "args": [
            "vcpu",
            "&var",
            "seg"
          ],
          "line": 3329
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3102-3136",
          "snippet": "void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic bool data_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tunsigned int rpl;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\trpl = var.selector & SEGMENT_RPL_MASK;\n\n\tif (var.unusable)\n\t\treturn true;\n\tif (!var.s)\n\t\treturn false;\n\tif (!var.present)\n\t\treturn false;\n\tif (~var.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_WRITEABLE_MASK)) {\n\t\tif (var.dpl < rpl) /* DPL < RPL */\n\t\t\treturn false;\n\t}\n\n\t/* TODO: Add other members to kvm_segment_field to allow checking for other access\n\t * rights flags\n\t */\n\treturn true;\n}"
  },
  {
    "function_name": "stack_segment_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3302-3322",
    "snippet": "static bool stack_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ss;\n\tunsigned int ss_rpl;\n\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\tss_rpl = ss.selector & SEGMENT_RPL_MASK;\n\n\tif (ss.unusable)\n\t\treturn true;\n\tif (ss.type != 3 && ss.type != 7)\n\t\treturn false;\n\tif (!ss.s)\n\t\treturn false;\n\tif (ss.dpl != ss_rpl) /* DPL != RPL */\n\t\treturn false;\n\tif (!ss.present)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_get_segment",
          "args": [
            "vcpu",
            "&ss",
            "VCPU_SREG_SS"
          ],
          "line": 3307
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3102-3136",
          "snippet": "void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic bool stack_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment ss;\n\tunsigned int ss_rpl;\n\n\tvmx_get_segment(vcpu, &ss, VCPU_SREG_SS);\n\tss_rpl = ss.selector & SEGMENT_RPL_MASK;\n\n\tif (ss.unusable)\n\t\treturn true;\n\tif (ss.type != 3 && ss.type != 7)\n\t\treturn false;\n\tif (!ss.s)\n\t\treturn false;\n\tif (ss.dpl != ss_rpl) /* DPL != RPL */\n\t\treturn false;\n\tif (!ss.present)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "code_segment_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3274-3300",
    "snippet": "static bool code_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tunsigned int cs_rpl;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs_rpl = cs.selector & SEGMENT_RPL_MASK;\n\n\tif (cs.unusable)\n\t\treturn false;\n\tif (~cs.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_ACCESSES_MASK))\n\t\treturn false;\n\tif (!cs.s)\n\t\treturn false;\n\tif (cs.type & VMX_AR_TYPE_WRITEABLE_MASK) {\n\t\tif (cs.dpl > cs_rpl)\n\t\t\treturn false;\n\t} else {\n\t\tif (cs.dpl != cs_rpl)\n\t\t\treturn false;\n\t}\n\tif (!cs.present)\n\t\treturn false;\n\n\t/* TODO: Add Reserved field check, this'll require a new member in the kvm_segment_field structure */\n\treturn true;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_get_segment",
          "args": [
            "vcpu",
            "&cs",
            "VCPU_SREG_CS"
          ],
          "line": 3279
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3102-3136",
          "snippet": "void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic bool code_segment_valid(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_segment cs;\n\tunsigned int cs_rpl;\n\n\tvmx_get_segment(vcpu, &cs, VCPU_SREG_CS);\n\tcs_rpl = cs.selector & SEGMENT_RPL_MASK;\n\n\tif (cs.unusable)\n\t\treturn false;\n\tif (~cs.type & (VMX_AR_TYPE_CODE_MASK|VMX_AR_TYPE_ACCESSES_MASK))\n\t\treturn false;\n\tif (!cs.s)\n\t\treturn false;\n\tif (cs.type & VMX_AR_TYPE_WRITEABLE_MASK) {\n\t\tif (cs.dpl > cs_rpl)\n\t\t\treturn false;\n\t} else {\n\t\tif (cs.dpl != cs_rpl)\n\t\t\treturn false;\n\t}\n\tif (!cs.present)\n\t\treturn false;\n\n\t/* TODO: Add Reserved field check, this'll require a new member in the kvm_segment_field structure */\n\treturn true;\n}"
  },
  {
    "function_name": "rmode_segment_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3253-3272",
    "snippet": "static bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tu32 ar;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\tar = vmx_segment_access_rights(&var);\n\n\tif (var.base != (var.selector << 4))\n\t\treturn false;\n\tif (var.limit != 0xffff)\n\t\treturn false;\n\tif (ar != 0xf3)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_segment_access_rights",
          "args": [
            "&var"
          ],
          "line": 3262
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_access_rights",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3161-3179",
          "snippet": "static u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_get_segment",
          "args": [
            "vcpu",
            "&var",
            "seg"
          ],
          "line": 3258
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3102-3136",
          "snippet": "void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic bool rmode_segment_valid(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment var;\n\tu32 ar;\n\n\tvmx_get_segment(vcpu, &var, seg);\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\tar = vmx_segment_access_rights(&var);\n\n\tif (var.base != (var.selector << 4))\n\t\treturn false;\n\tif (var.limit != 0xffff)\n\t\treturn false;\n\tif (ar != 0xf3)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "vmx_set_gdt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3247-3251",
    "snippet": "static void vmx_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_GDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_GDTR_BASE, dt->address);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "GUEST_GDTR_BASE",
            "dt->address"
          ],
          "line": 3250
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "GUEST_GDTR_LIMIT",
            "dt->size"
          ],
          "line": 3249
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_GDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_GDTR_BASE, dt->address);\n}"
  },
  {
    "function_name": "vmx_get_gdt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3241-3245",
    "snippet": "static void vmx_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_GDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_GDTR_BASE);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_GDTR_BASE"
          ],
          "line": 3244
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_GDTR_LIMIT"
          ],
          "line": 3243
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_GDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_GDTR_BASE);\n}"
  },
  {
    "function_name": "vmx_set_idt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3235-3239",
    "snippet": "static void vmx_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_IDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_IDTR_BASE, dt->address);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "GUEST_IDTR_BASE",
            "dt->address"
          ],
          "line": 3238
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "GUEST_IDTR_LIMIT",
            "dt->size"
          ],
          "line": 3237
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tvmcs_write32(GUEST_IDTR_LIMIT, dt->size);\n\tvmcs_writel(GUEST_IDTR_BASE, dt->address);\n}"
  },
  {
    "function_name": "vmx_get_idt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3229-3233",
    "snippet": "static void vmx_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_IDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_IDTR_BASE);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_IDTR_BASE"
          ],
          "line": 3232
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_IDTR_LIMIT"
          ],
          "line": 3231
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tdt->size = vmcs_read32(GUEST_IDTR_LIMIT);\n\tdt->address = vmcs_readl(GUEST_IDTR_BASE);\n}"
  },
  {
    "function_name": "vmx_get_cs_db_l_bits",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3221-3227",
    "snippet": "static void vmx_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tu32 ar = vmx_read_guest_seg_ar(to_vmx(vcpu), VCPU_SREG_CS);\n\n\t*db = (ar >> 14) & 1;\n\t*l = (ar >> 13) & 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_read_guest_seg_ar",
          "args": [
            "to_vmx(vcpu)",
            "VCPU_SREG_CS"
          ],
          "line": 3223
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_guest_seg_ar",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "752-759",
          "snippet": "static u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3223
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_get_cs_db_l_bits(struct kvm_vcpu *vcpu, int *db, int *l)\n{\n\tu32 ar = vmx_read_guest_seg_ar(to_vmx(vcpu), VCPU_SREG_CS);\n\n\t*db = (ar >> 14) & 1;\n\t*l = (ar >> 13) & 1;\n}"
  },
  {
    "function_name": "vmx_set_segment",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3181-3219",
    "snippet": "void vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\tgoto out;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n\nout:\n\tvmx->emulation_required = emulation_required(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);",
      "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulation_required",
          "args": [
            "vcpu"
          ],
          "line": 3218
        },
        "resolved": true,
        "details": {
          "function_name": "emulation_required",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1400-1403",
          "snippet": "static bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "sf->ar_bytes",
            "vmx_segment_access_rights(var)"
          ],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_segment_access_rights",
          "args": [
            "var"
          ],
          "line": 3215
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_access_rights",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3161-3179",
          "snippet": "static u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write16",
          "args": [
            "sf->selector",
            "var->selector"
          ],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "175-182",
          "snippet": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "sf->base",
            "var->base"
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fix_rmode_seg",
          "args": [
            "seg",
            "&vmx->rmode.segs[seg]"
          ],
          "line": 3193
        },
        "resolved": true,
        "details": {
          "function_name": "fix_rmode_seg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2716-2747",
          "snippet": "static void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_writel(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);",
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_writel(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_segment_cache_clear",
          "args": [
            "vmx"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_cache_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "444-447",
          "snippet": "static inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3183
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nvoid vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\tgoto out;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n\nout:\n\tvmx->emulation_required = emulation_required(vcpu);\n}"
  },
  {
    "function_name": "vmx_segment_access_rights",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3161-3179",
    "snippet": "static u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}"
  },
  {
    "function_name": "vmx_get_cpl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3149-3159",
    "snippet": "int vmx_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (unlikely(vmx->rmode.vm86_active))\n\t\treturn 0;\n\telse {\n\t\tint ar = vmx_read_guest_seg_ar(vmx, VCPU_SREG_SS);\n\t\treturn VMX_AR_DPL(ar);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VMX_AR_DPL",
          "args": [
            "ar"
          ],
          "line": 3157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_read_guest_seg_ar",
          "args": [
            "vmx",
            "VCPU_SREG_SS"
          ],
          "line": 3156
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_guest_seg_ar",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "752-759",
          "snippet": "static u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "vmx->rmode.vm86_active"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3151
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nint vmx_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (unlikely(vmx->rmode.vm86_active))\n\t\treturn 0;\n\telse {\n\t\tint ar = vmx_read_guest_seg_ar(vmx, VCPU_SREG_SS);\n\t\treturn VMX_AR_DPL(ar);\n\t}\n}"
  },
  {
    "function_name": "vmx_get_segment_base",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3138-3147",
    "snippet": "static u64 vmx_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment s;\n\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tvmx_get_segment(vcpu, &s, seg);\n\t\treturn s.base;\n\t}\n\treturn vmx_read_guest_seg_base(to_vmx(vcpu), seg);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_read_guest_seg_base",
          "args": [
            "to_vmx(vcpu)",
            "seg"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_guest_seg_base",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "734-741",
          "snippet": "static ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_get_segment",
          "args": [
            "vcpu",
            "&s",
            "seg"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3102-3136",
          "snippet": "void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic u64 vmx_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct kvm_segment s;\n\n\tif (to_vmx(vcpu)->rmode.vm86_active) {\n\t\tvmx_get_segment(vcpu, &s, seg);\n\t\treturn s.base;\n\t}\n\treturn vmx_read_guest_seg_base(to_vmx(vcpu), seg);\n}"
  },
  {
    "function_name": "vmx_get_segment",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3102-3136",
    "snippet": "void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_read_guest_seg_ar",
          "args": [
            "vmx",
            "seg"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_guest_seg_ar",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "752-759",
          "snippet": "static u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_read_guest_seg_selector",
          "args": [
            "vmx",
            "seg"
          ],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_guest_seg_selector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "725-732",
          "snippet": "static u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu16 *p = &vmx->segment_cache.seg[seg].selector;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_SEL))\n\t\t*p = vmcs_read16(kvm_vmx_segment_fields[seg].selector);\n\treturn *p;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu16 *p = &vmx->segment_cache.seg[seg].selector;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_SEL))\n\t\t*p = vmcs_read16(kvm_vmx_segment_fields[seg].selector);\n\treturn *p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_read_guest_seg_limit",
          "args": [
            "vmx",
            "seg"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_guest_seg_limit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "743-750",
          "snippet": "static u32 vmx_read_guest_seg_limit(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].limit;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_LIMIT))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].limit);\n\treturn *p;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u32 vmx_read_guest_seg_limit(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].limit;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_LIMIT))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].limit);\n\treturn *p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_read_guest_seg_base",
          "args": [
            "vmx",
            "seg"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_guest_seg_base",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "734-741",
          "snippet": "static ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3104
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}"
  },
  {
    "function_name": "vmx_set_cr4",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "3027-3100",
    "snippet": "int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\t/*\n\t * Pass through host's Machine Check Enable value to hw_cr4, which\n\t * is in force while we are in guest mode.  Do not let guests control\n\t * this bit, even if host CR4.MCE == 0.\n\t */\n\tunsigned long hw_cr4;\n\n\thw_cr4 = (cr4_read_shadow() & X86_CR4_MCE) | (cr4 & ~X86_CR4_MCE);\n\tif (enable_unrestricted_guest)\n\t\thw_cr4 |= KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse if (vmx->rmode.vm86_active)\n\t\thw_cr4 |= KVM_RMODE_VM_CR4_ALWAYS_ON;\n\telse\n\t\thw_cr4 |= KVM_PMODE_VM_CR4_ALWAYS_ON;\n\n\tif (!boot_cpu_has(X86_FEATURE_UMIP) && vmx_umip_emulated()) {\n\t\tif (cr4 & X86_CR4_UMIP) {\n\t\t\tsecondary_exec_controls_setbit(vmx, SECONDARY_EXEC_DESC);\n\t\t\thw_cr4 &= ~X86_CR4_UMIP;\n\t\t} else if (!is_guest_mode(vcpu) ||\n\t\t\t!nested_cpu_has2(get_vmcs12(vcpu), SECONDARY_EXEC_DESC)) {\n\t\t\tsecondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_DESC);\n\t\t}\n\t}\n\n\tif (cr4 & X86_CR4_VMXE) {\n\t\t/*\n\t\t * To use VMXON (and later other VMX instructions), a guest\n\t\t * must first be able to turn on cr4.VMXE (see handle_vmon()).\n\t\t * So basically the check on whether to allow nested VMX\n\t\t * is here.  We operate under the default treatment of SMM,\n\t\t * so VMX cannot be enabled under SMM.\n\t\t */\n\t\tif (!nested_vmx_allowed(vcpu) || is_smm(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (vmx->nested.vmxon && !nested_cr4_valid(vcpu, cr4))\n\t\treturn 1;\n\n\tvcpu->arch.cr4 = cr4;\n\n\tif (!enable_unrestricted_guest) {\n\t\tif (enable_ept) {\n\t\t\tif (!is_paging(vcpu)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in\n\t\t * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs\n\t\t * to be manually disabled when guest switches to non-paging\n\t\t * mode.\n\t\t *\n\t\t * If !enable_unrestricted_guest, the CPU is always running\n\t\t * with CR0.PG=1 and CR4 needs to be modified.\n\t\t * If enable_unrestricted_guest, the CPU automatically\n\t\t * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.\n\t\t */\n\t\tif (!is_paging(vcpu))\n\t\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\t}\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)",
      "#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)",
      "#define KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR4_VMXE"
    ],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "GUEST_CR4",
            "hw_cr4"
          ],
          "line": 3098
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 3093
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_cr4_valid",
          "args": [
            "vcpu",
            "cr4"
          ],
          "line": 3067
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cr4_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "290-296",
          "snippet": "static inline bool nested_cr4_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr4_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr4_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cr4_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr4_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr4_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_smm",
          "args": [
            "vcpu"
          ],
          "line": 3063
        },
        "resolved": true,
        "details": {
          "function_name": "is_smm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "175-178",
          "snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_allowed",
          "args": [
            "vcpu"
          ],
          "line": 3063
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_allowed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1755-1758",
          "snippet": "bool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nbool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "secondary_exec_controls_clearbit",
          "args": [
            "vmx",
            "SECONDARY_EXEC_DESC"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "get_vmcs12(vcpu)",
            "SECONDARY_EXEC_DESC"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 3050
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "secondary_exec_controls_setbit",
          "args": [
            "vmx",
            "SECONDARY_EXEC_DESC"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_umip_emulated",
          "args": [],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_umip_emulated",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "143-147",
          "snippet": "static inline bool vmx_umip_emulated(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_DESC;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool vmx_umip_emulated(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_DESC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_UMIP"
          ],
          "line": 3045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_read_shadow",
          "args": [],
          "line": 3037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR4_VMXE\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nint vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\t/*\n\t * Pass through host's Machine Check Enable value to hw_cr4, which\n\t * is in force while we are in guest mode.  Do not let guests control\n\t * this bit, even if host CR4.MCE == 0.\n\t */\n\tunsigned long hw_cr4;\n\n\thw_cr4 = (cr4_read_shadow() & X86_CR4_MCE) | (cr4 & ~X86_CR4_MCE);\n\tif (enable_unrestricted_guest)\n\t\thw_cr4 |= KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse if (vmx->rmode.vm86_active)\n\t\thw_cr4 |= KVM_RMODE_VM_CR4_ALWAYS_ON;\n\telse\n\t\thw_cr4 |= KVM_PMODE_VM_CR4_ALWAYS_ON;\n\n\tif (!boot_cpu_has(X86_FEATURE_UMIP) && vmx_umip_emulated()) {\n\t\tif (cr4 & X86_CR4_UMIP) {\n\t\t\tsecondary_exec_controls_setbit(vmx, SECONDARY_EXEC_DESC);\n\t\t\thw_cr4 &= ~X86_CR4_UMIP;\n\t\t} else if (!is_guest_mode(vcpu) ||\n\t\t\t!nested_cpu_has2(get_vmcs12(vcpu), SECONDARY_EXEC_DESC)) {\n\t\t\tsecondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_DESC);\n\t\t}\n\t}\n\n\tif (cr4 & X86_CR4_VMXE) {\n\t\t/*\n\t\t * To use VMXON (and later other VMX instructions), a guest\n\t\t * must first be able to turn on cr4.VMXE (see handle_vmon()).\n\t\t * So basically the check on whether to allow nested VMX\n\t\t * is here.  We operate under the default treatment of SMM,\n\t\t * so VMX cannot be enabled under SMM.\n\t\t */\n\t\tif (!nested_vmx_allowed(vcpu) || is_smm(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (vmx->nested.vmxon && !nested_cr4_valid(vcpu, cr4))\n\t\treturn 1;\n\n\tvcpu->arch.cr4 = cr4;\n\n\tif (!enable_unrestricted_guest) {\n\t\tif (enable_ept) {\n\t\t\tif (!is_paging(vcpu)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in\n\t\t * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs\n\t\t * to be manually disabled when guest switches to non-paging\n\t\t * mode.\n\t\t *\n\t\t * If !enable_unrestricted_guest, the CPU is always running\n\t\t * with CR0.PG=1 and CR4 needs to be modified.\n\t\t * If enable_unrestricted_guest, the CPU automatically\n\t\t * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.\n\t\t */\n\t\tif (!is_paging(vcpu))\n\t\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\t}\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_load_mmu_pgd",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2991-3025",
    "snippet": "void vmx_load_mmu_pgd(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tbool update_guest_cr3 = true;\n\tunsigned long guest_cr3;\n\tu64 eptp;\n\n\tguest_cr3 = cr3;\n\tif (enable_ept) {\n\t\teptp = construct_eptp(vcpu, cr3);\n\t\tvmcs_write64(EPT_POINTER, eptp);\n\n\t\tif (kvm_x86_ops.tlb_remote_flush) {\n\t\t\tspin_lock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\t\t\tto_vmx(vcpu)->ept_pointer = eptp;\n\t\t\tto_kvm_vmx(kvm)->ept_pointers_match\n\t\t\t\t= EPT_POINTERS_CHECK;\n\t\t\tspin_unlock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\t\t}\n\n\t\t/* Loading vmcs02.GUEST_CR3 is handled by nested VM-Enter. */\n\t\tif (is_guest_mode(vcpu))\n\t\t\tupdate_guest_cr3 = false;\n\t\telse if (!enable_unrestricted_guest && !is_paging(vcpu))\n\t\t\tguest_cr3 = to_kvm_vmx(kvm)->ept_identity_map_addr;\n\t\telse if (test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\t\tguest_cr3 = vcpu->arch.cr3;\n\t\telse /* vmcs01.GUEST_CR3 is already up-to-date. */\n\t\t\tupdate_guest_cr3 = false;\n\t\tept_load_pdptrs(vcpu);\n\t}\n\n\tif (update_guest_cr3)\n\t\tvmcs_writel(GUEST_CR3, guest_cr3);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "GUEST_CR3",
            "guest_cr3"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ept_load_pdptrs",
          "args": [
            "vcpu"
          ],
          "line": 3020
        },
        "resolved": true,
        "details": {
          "function_name": "ept_load_pdptrs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2875-2888",
          "snippet": "static void ept_load_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!kvm_register_is_dirty(vcpu, VCPU_EXREG_PDPTR))\n\t\treturn;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tvmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);\n\t\tvmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);\n\t\tvmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);\n\t\tvmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void ept_load_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!kvm_register_is_dirty(vcpu, VCPU_EXREG_PDPTR))\n\t\treturn;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tvmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);\n\t\tvmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);\n\t\tvmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);\n\t\tvmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "VCPU_EXREG_CR3",
            "(ulong *)&vcpu->arch.regs_avail"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_vmx",
          "args": [
            "kvm"
          ],
          "line": 3015
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "474-477",
          "snippet": "static inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&to_kvm_vmx(kvm)->ept_pointer_lock"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&to_kvm_vmx(kvm)->ept_pointer_lock"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_write64",
          "args": [
            "EPT_POINTER",
            "eptp"
          ],
          "line": 3001
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "193-203",
          "snippet": "static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "construct_eptp",
          "args": [
            "vcpu",
            "cr3"
          ],
          "line": 3000
        },
        "resolved": true,
        "details": {
          "function_name": "construct_eptp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2977-2989",
          "snippet": "u64 construct_eptp(struct kvm_vcpu *vcpu, unsigned long root_hpa)\n{\n\tu64 eptp = VMX_EPTP_MT_WB;\n\n\teptp |= (get_ept_level(vcpu) == 5) ? VMX_EPTP_PWL_5 : VMX_EPTP_PWL_4;\n\n\tif (enable_ept_ad_bits &&\n\t    (!is_guest_mode(vcpu) || nested_ept_ad_enabled(vcpu)))\n\t\teptp |= VMX_EPTP_AD_ENABLE_BIT;\n\teptp |= (root_hpa & PAGE_MASK);\n\n\treturn eptp;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nu64 construct_eptp(struct kvm_vcpu *vcpu, unsigned long root_hpa)\n{\n\tu64 eptp = VMX_EPTP_MT_WB;\n\n\teptp |= (get_ept_level(vcpu) == 5) ? VMX_EPTP_PWL_5 : VMX_EPTP_PWL_4;\n\n\tif (enable_ept_ad_bits &&\n\t    (!is_guest_mode(vcpu) || nested_ept_ad_enabled(vcpu)))\n\t\teptp |= VMX_EPTP_AD_ENABLE_BIT;\n\teptp |= (root_hpa & PAGE_MASK);\n\n\treturn eptp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_load_mmu_pgd(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tbool update_guest_cr3 = true;\n\tunsigned long guest_cr3;\n\tu64 eptp;\n\n\tguest_cr3 = cr3;\n\tif (enable_ept) {\n\t\teptp = construct_eptp(vcpu, cr3);\n\t\tvmcs_write64(EPT_POINTER, eptp);\n\n\t\tif (kvm_x86_ops.tlb_remote_flush) {\n\t\t\tspin_lock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\t\t\tto_vmx(vcpu)->ept_pointer = eptp;\n\t\t\tto_kvm_vmx(kvm)->ept_pointers_match\n\t\t\t\t= EPT_POINTERS_CHECK;\n\t\t\tspin_unlock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\t\t}\n\n\t\t/* Loading vmcs02.GUEST_CR3 is handled by nested VM-Enter. */\n\t\tif (is_guest_mode(vcpu))\n\t\t\tupdate_guest_cr3 = false;\n\t\telse if (!enable_unrestricted_guest && !is_paging(vcpu))\n\t\t\tguest_cr3 = to_kvm_vmx(kvm)->ept_identity_map_addr;\n\t\telse if (test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\t\tguest_cr3 = vcpu->arch.cr3;\n\t\telse /* vmcs01.GUEST_CR3 is already up-to-date. */\n\t\t\tupdate_guest_cr3 = false;\n\t\tept_load_pdptrs(vcpu);\n\t}\n\n\tif (update_guest_cr3)\n\t\tvmcs_writel(GUEST_CR3, guest_cr3);\n}"
  },
  {
    "function_name": "construct_eptp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2977-2989",
    "snippet": "u64 construct_eptp(struct kvm_vcpu *vcpu, unsigned long root_hpa)\n{\n\tu64 eptp = VMX_EPTP_MT_WB;\n\n\teptp |= (get_ept_level(vcpu) == 5) ? VMX_EPTP_PWL_5 : VMX_EPTP_PWL_4;\n\n\tif (enable_ept_ad_bits &&\n\t    (!is_guest_mode(vcpu) || nested_ept_ad_enabled(vcpu)))\n\t\teptp |= VMX_EPTP_AD_ENABLE_BIT;\n\teptp |= (root_hpa & PAGE_MASK);\n\n\treturn eptp;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_ept_ad_enabled",
          "args": [
            "vcpu"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "nested_ept_ad_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "71-74",
          "snippet": "static inline bool nested_ept_ad_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn nested_ept_get_eptp(vcpu) & VMX_EPTP_AD_ENABLE_BIT;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_ept_ad_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn nested_ept_get_eptp(vcpu) & VMX_EPTP_AD_ENABLE_BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_ept_level",
          "args": [
            "vcpu"
          ],
          "line": 2981
        },
        "resolved": true,
        "details": {
          "function_name": "get_ept_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2968-2975",
          "snippet": "static int get_ept_level(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && nested_cpu_has_ept(get_vmcs12(vcpu)))\n\t\treturn vmx_eptp_page_walk_level(nested_ept_get_eptp(vcpu));\n\tif (cpu_has_vmx_ept_5levels() && (cpuid_maxphyaddr(vcpu) > 48))\n\t\treturn 5;\n\treturn 4;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int get_ept_level(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && nested_cpu_has_ept(get_vmcs12(vcpu)))\n\t\treturn vmx_eptp_page_walk_level(nested_ept_get_eptp(vcpu));\n\tif (cpu_has_vmx_ept_5levels() && (cpuid_maxphyaddr(vcpu) > 48))\n\t\treturn 5;\n\treturn 4;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nu64 construct_eptp(struct kvm_vcpu *vcpu, unsigned long root_hpa)\n{\n\tu64 eptp = VMX_EPTP_MT_WB;\n\n\teptp |= (get_ept_level(vcpu) == 5) ? VMX_EPTP_PWL_5 : VMX_EPTP_PWL_4;\n\n\tif (enable_ept_ad_bits &&\n\t    (!is_guest_mode(vcpu) || nested_ept_ad_enabled(vcpu)))\n\t\teptp |= VMX_EPTP_AD_ENABLE_BIT;\n\teptp |= (root_hpa & PAGE_MASK);\n\n\treturn eptp;\n}"
  },
  {
    "function_name": "get_ept_level",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2968-2975",
    "snippet": "static int get_ept_level(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && nested_cpu_has_ept(get_vmcs12(vcpu)))\n\t\treturn vmx_eptp_page_walk_level(nested_ept_get_eptp(vcpu));\n\tif (cpu_has_vmx_ept_5levels() && (cpuid_maxphyaddr(vcpu) > 48))\n\t\treturn 5;\n\treturn 4;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuid_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_maxphyaddr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "32-35",
          "snippet": "static inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_ept_5levels",
          "args": [],
          "line": 2972
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_ept_5levels",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "286-289",
          "snippet": "static inline bool cpu_has_vmx_ept_5levels(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_PAGE_WALK_5_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_ept_5levels(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_PAGE_WALK_5_BIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_eptp_page_walk_level",
          "args": [
            "nested_ept_get_eptp(vcpu)"
          ],
          "line": 2971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_ept_get_eptp",
          "args": [
            "vcpu"
          ],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "nested_ept_get_eptp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "65-69",
          "snippet": "static inline unsigned long nested_ept_get_eptp(struct kvm_vcpu *vcpu)\n{\n\t/* return the page table to be shadowed - in our case, EPT12 */\n\treturn get_vmcs12(vcpu)->ept_pointer;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline unsigned long nested_ept_get_eptp(struct kvm_vcpu *vcpu)\n{\n\t/* return the page table to be shadowed - in our case, EPT12 */\n\treturn get_vmcs12(vcpu)->ept_pointer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_cpu_has_ept",
          "args": [
            "get_vmcs12(vcpu)"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has_eptp_switching",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "231-236",
          "snippet": "static inline bool nested_cpu_has_eptp_switching(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has_vmfunc(vmcs12) &&\n\t\t(vmcs12->vm_function_control &\n\t\t VMX_VMFUNC_EPTP_SWITCHING);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_eptp_switching(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has_vmfunc(vmcs12) &&\n\t\t(vmcs12->vm_function_control &\n\t\t VMX_VMFUNC_EPTP_SWITCHING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int get_ept_level(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu) && nested_cpu_has_ept(get_vmcs12(vcpu)))\n\t\treturn vmx_eptp_page_walk_level(nested_ept_get_eptp(vcpu));\n\tif (cpu_has_vmx_ept_5levels() && (cpuid_maxphyaddr(vcpu) > 48))\n\t\treturn 5;\n\treturn 4;\n}"
  },
  {
    "function_name": "vmx_set_cr0",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2930-2966",
    "snippet": "void vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0;\n\n\thw_cr0 = (cr0 & ~KVM_VM_CR0_ALWAYS_OFF);\n\tif (enable_unrestricted_guest)\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept && !enable_unrestricted_guest)\n\t\tept_update_paging_mode_cr0(&hw_cr0, cr0, vcpu);\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = emulation_required(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | \t\\\n\t X86_CR0_WP | X86_CR0_PG | X86_CR0_PE)",
      "#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR0_NE",
      "#define KVM_VM_CR0_ALWAYS_OFF (X86_CR0_NW | X86_CR0_CD)"
    ],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulation_required",
          "args": [
            "vcpu"
          ],
          "line": 2965
        },
        "resolved": true,
        "details": {
          "function_name": "emulation_required",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1400-1403",
          "snippet": "static bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "GUEST_CR0",
            "hw_cr0"
          ],
          "line": 2961
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ept_update_paging_mode_cr0",
          "args": [
            "&hw_cr0",
            "cr0",
            "vcpu"
          ],
          "line": 2958
        },
        "resolved": true,
        "details": {
          "function_name": "ept_update_paging_mode_cr0",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2904-2928",
          "snippet": "static void ept_update_paging_mode_cr0(unsigned long *hw_cr0,\n\t\t\t\t\tunsigned long cr0,\n\t\t\t\t\tstruct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tvmx_cache_reg(vcpu, VCPU_EXREG_CR3);\n\tif (!(cr0 & X86_CR0_PG)) {\n\t\t/* From paging/starting to nonpaging */\n\t\texec_controls_setbit(vmx, CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t  CPU_BASED_CR3_STORE_EXITING);\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t} else if (!is_paging(vcpu)) {\n\t\t/* From nonpaging to paging */\n\t\texec_controls_clearbit(vmx, CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t    CPU_BASED_CR3_STORE_EXITING);\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t}\n\n\tif (!(cr0 & X86_CR0_WP))\n\t\t*hw_cr0 &= ~X86_CR0_WP;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void ept_update_paging_mode_cr0(unsigned long *hw_cr0,\n\t\t\t\t\tunsigned long cr0,\n\t\t\t\t\tstruct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tvmx_cache_reg(vcpu, VCPU_EXREG_CR3);\n\tif (!(cr0 & X86_CR0_PG)) {\n\t\t/* From paging/starting to nonpaging */\n\t\texec_controls_setbit(vmx, CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t  CPU_BASED_CR3_STORE_EXITING);\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t} else if (!is_paging(vcpu)) {\n\t\t/* From nonpaging to paging */\n\t\texec_controls_clearbit(vmx, CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t    CPU_BASED_CR3_STORE_EXITING);\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t}\n\n\tif (!(cr0 & X86_CR0_WP))\n\t\t*hw_cr0 &= ~X86_CR0_WP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit_lmode",
          "args": [
            "vcpu"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "exit_lmode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2837-2841",
          "snippet": "static void exit_lmode(struct kvm_vcpu *vcpu)\n{\n\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\tvmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void exit_lmode(struct kvm_vcpu *vcpu)\n{\n\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\tvmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 2952
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_lmode",
          "args": [
            "vcpu"
          ],
          "line": 2951
        },
        "resolved": true,
        "details": {
          "function_name": "enter_lmode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2820-2835",
          "snippet": "static void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & VMX_AR_TYPE_MASK) != VMX_AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~VMX_AR_TYPE_MASK)\n\t\t\t     | VMX_AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & VMX_AR_TYPE_MASK) != VMX_AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~VMX_AR_TYPE_MASK)\n\t\t\t     | VMX_AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_rmode",
          "args": [
            "vcpu"
          ],
          "line": 2945
        },
        "resolved": true,
        "details": {
          "function_name": "enter_rmode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2749-2796",
          "snippet": "static void enter_rmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(vcpu->kvm);\n\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 1;\n\n\t/*\n\t * Very old userspace does not call KVM_SET_TSS_ADDR before entering\n\t * vcpu. Warn the user that an update is overdue.\n\t */\n\tif (!kvm_vmx->tss_addr)\n\t\tprintk_once(KERN_WARNING \"kvm: KVM_SET_TSS_ADDR need to be \"\n\t\t\t     \"called before entering vcpu\\n\");\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs_writel(GUEST_TR_BASE, kvm_vmx->tss_addr);\n\tvmcs_write32(GUEST_TR_LIMIT, RMODE_TSS_SIZE - 1);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tvmx->rmode.save_rflags = flags;\n\n\tflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\tvmcs_writel(GUEST_CR4, vmcs_readl(GUEST_CR4) | X86_CR4_VME);\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_rmode_seg(VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_rmode_seg(VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_rmode_seg(VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_rmode_seg(VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_rmode_seg(VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n\tfix_rmode_seg(VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\n\tkvm_mmu_reset_context(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void enter_rmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(vcpu->kvm);\n\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 1;\n\n\t/*\n\t * Very old userspace does not call KVM_SET_TSS_ADDR before entering\n\t * vcpu. Warn the user that an update is overdue.\n\t */\n\tif (!kvm_vmx->tss_addr)\n\t\tprintk_once(KERN_WARNING \"kvm: KVM_SET_TSS_ADDR need to be \"\n\t\t\t     \"called before entering vcpu\\n\");\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs_writel(GUEST_TR_BASE, kvm_vmx->tss_addr);\n\tvmcs_write32(GUEST_TR_LIMIT, RMODE_TSS_SIZE - 1);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tvmx->rmode.save_rflags = flags;\n\n\tflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\tvmcs_writel(GUEST_CR4, vmcs_readl(GUEST_CR4) | X86_CR4_VME);\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_rmode_seg(VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_rmode_seg(VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_rmode_seg(VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_rmode_seg(VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_rmode_seg(VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n\tfix_rmode_seg(VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\n\tkvm_mmu_reset_context(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enter_pmode",
          "args": [
            "vcpu"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "enter_pmode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2678-2714",
          "snippet": "static void enter_pmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Update real mode segment cache. It may be not up-to-date if sement\n\t * register was written while vcpu was in a guest mode.\n\t */\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx_set_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tflags |= vmx->rmode.save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\n\tvmcs_writel(GUEST_CR4, (vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |\n\t\t\t(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME));\n\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_pmode_seg(vcpu, VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))"
          ],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void enter_pmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Update real mode segment cache. It may be not up-to-date if sement\n\t * register was written while vcpu was in a guest mode.\n\t */\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx_set_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tflags |= vmx->rmode.save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\n\tvmcs_writel(GUEST_CR4, (vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |\n\t\t\t(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME));\n\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_pmode_seg(vcpu, VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define KVM_VM_CR0_ALWAYS_ON\t\t\t\t\\\n\t(KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST | \t\\\n\t X86_CR0_WP | X86_CR0_PG | X86_CR0_PE)\n#define KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR0_NE\n#define KVM_VM_CR0_ALWAYS_OFF (X86_CR0_NW | X86_CR0_CD)\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long hw_cr0;\n\n\thw_cr0 = (cr0 & ~KVM_VM_CR0_ALWAYS_OFF);\n\tif (enable_unrestricted_guest)\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse {\n\t\thw_cr0 |= KVM_VM_CR0_ALWAYS_ON;\n\n\t\tif (vmx->rmode.vm86_active && (cr0 & X86_CR0_PE))\n\t\t\tenter_pmode(vcpu);\n\n\t\tif (!vmx->rmode.vm86_active && !(cr0 & X86_CR0_PE))\n\t\t\tenter_rmode(vcpu);\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG))\n\t\t\tenter_lmode(vcpu);\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG))\n\t\t\texit_lmode(vcpu);\n\t}\n#endif\n\n\tif (enable_ept && !enable_unrestricted_guest)\n\t\tept_update_paging_mode_cr0(&hw_cr0, cr0, vcpu);\n\n\tvmcs_writel(CR0_READ_SHADOW, cr0);\n\tvmcs_writel(GUEST_CR0, hw_cr0);\n\tvcpu->arch.cr0 = cr0;\n\n\t/* depends on vcpu->arch.cr0 to be set to a new value */\n\tvmx->emulation_required = emulation_required(vcpu);\n}"
  },
  {
    "function_name": "ept_update_paging_mode_cr0",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2904-2928",
    "snippet": "static void ept_update_paging_mode_cr0(unsigned long *hw_cr0,\n\t\t\t\t\tunsigned long cr0,\n\t\t\t\t\tstruct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tvmx_cache_reg(vcpu, VCPU_EXREG_CR3);\n\tif (!(cr0 & X86_CR0_PG)) {\n\t\t/* From paging/starting to nonpaging */\n\t\texec_controls_setbit(vmx, CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t  CPU_BASED_CR3_STORE_EXITING);\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t} else if (!is_paging(vcpu)) {\n\t\t/* From nonpaging to paging */\n\t\texec_controls_clearbit(vmx, CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t    CPU_BASED_CR3_STORE_EXITING);\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t}\n\n\tif (!(cr0 & X86_CR0_WP))\n\t\t*hw_cr0 &= ~X86_CR0_WP;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_set_cr4",
          "args": [
            "vcpu",
            "kvm_read_cr4(vcpu)"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_cr4",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3027-3100",
          "snippet": "int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\t/*\n\t * Pass through host's Machine Check Enable value to hw_cr4, which\n\t * is in force while we are in guest mode.  Do not let guests control\n\t * this bit, even if host CR4.MCE == 0.\n\t */\n\tunsigned long hw_cr4;\n\n\thw_cr4 = (cr4_read_shadow() & X86_CR4_MCE) | (cr4 & ~X86_CR4_MCE);\n\tif (enable_unrestricted_guest)\n\t\thw_cr4 |= KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse if (vmx->rmode.vm86_active)\n\t\thw_cr4 |= KVM_RMODE_VM_CR4_ALWAYS_ON;\n\telse\n\t\thw_cr4 |= KVM_PMODE_VM_CR4_ALWAYS_ON;\n\n\tif (!boot_cpu_has(X86_FEATURE_UMIP) && vmx_umip_emulated()) {\n\t\tif (cr4 & X86_CR4_UMIP) {\n\t\t\tsecondary_exec_controls_setbit(vmx, SECONDARY_EXEC_DESC);\n\t\t\thw_cr4 &= ~X86_CR4_UMIP;\n\t\t} else if (!is_guest_mode(vcpu) ||\n\t\t\t!nested_cpu_has2(get_vmcs12(vcpu), SECONDARY_EXEC_DESC)) {\n\t\t\tsecondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_DESC);\n\t\t}\n\t}\n\n\tif (cr4 & X86_CR4_VMXE) {\n\t\t/*\n\t\t * To use VMXON (and later other VMX instructions), a guest\n\t\t * must first be able to turn on cr4.VMXE (see handle_vmon()).\n\t\t * So basically the check on whether to allow nested VMX\n\t\t * is here.  We operate under the default treatment of SMM,\n\t\t * so VMX cannot be enabled under SMM.\n\t\t */\n\t\tif (!nested_vmx_allowed(vcpu) || is_smm(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (vmx->nested.vmxon && !nested_cr4_valid(vcpu, cr4))\n\t\treturn 1;\n\n\tvcpu->arch.cr4 = cr4;\n\n\tif (!enable_unrestricted_guest) {\n\t\tif (enable_ept) {\n\t\t\tif (!is_paging(vcpu)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in\n\t\t * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs\n\t\t * to be manually disabled when guest switches to non-paging\n\t\t * mode.\n\t\t *\n\t\t * If !enable_unrestricted_guest, the CPU is always running\n\t\t * with CR0.PG=1 and CR4 needs to be modified.\n\t\t * If enable_unrestricted_guest, the CPU automatically\n\t\t * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.\n\t\t */\n\t\tif (!is_paging(vcpu))\n\t\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\t}\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\treturn 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)",
            "#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)",
            "#define KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR4_VMXE"
          ],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define KVM_RMODE_VM_CR4_ALWAYS_ON (X86_CR4_VME | X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_PMODE_VM_CR4_ALWAYS_ON (X86_CR4_PAE | X86_CR4_VMXE)\n#define KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST X86_CR4_VMXE\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nint vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\t/*\n\t * Pass through host's Machine Check Enable value to hw_cr4, which\n\t * is in force while we are in guest mode.  Do not let guests control\n\t * this bit, even if host CR4.MCE == 0.\n\t */\n\tunsigned long hw_cr4;\n\n\thw_cr4 = (cr4_read_shadow() & X86_CR4_MCE) | (cr4 & ~X86_CR4_MCE);\n\tif (enable_unrestricted_guest)\n\t\thw_cr4 |= KVM_VM_CR4_ALWAYS_ON_UNRESTRICTED_GUEST;\n\telse if (vmx->rmode.vm86_active)\n\t\thw_cr4 |= KVM_RMODE_VM_CR4_ALWAYS_ON;\n\telse\n\t\thw_cr4 |= KVM_PMODE_VM_CR4_ALWAYS_ON;\n\n\tif (!boot_cpu_has(X86_FEATURE_UMIP) && vmx_umip_emulated()) {\n\t\tif (cr4 & X86_CR4_UMIP) {\n\t\t\tsecondary_exec_controls_setbit(vmx, SECONDARY_EXEC_DESC);\n\t\t\thw_cr4 &= ~X86_CR4_UMIP;\n\t\t} else if (!is_guest_mode(vcpu) ||\n\t\t\t!nested_cpu_has2(get_vmcs12(vcpu), SECONDARY_EXEC_DESC)) {\n\t\t\tsecondary_exec_controls_clearbit(vmx, SECONDARY_EXEC_DESC);\n\t\t}\n\t}\n\n\tif (cr4 & X86_CR4_VMXE) {\n\t\t/*\n\t\t * To use VMXON (and later other VMX instructions), a guest\n\t\t * must first be able to turn on cr4.VMXE (see handle_vmon()).\n\t\t * So basically the check on whether to allow nested VMX\n\t\t * is here.  We operate under the default treatment of SMM,\n\t\t * so VMX cannot be enabled under SMM.\n\t\t */\n\t\tif (!nested_vmx_allowed(vcpu) || is_smm(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (vmx->nested.vmxon && !nested_cr4_valid(vcpu, cr4))\n\t\treturn 1;\n\n\tvcpu->arch.cr4 = cr4;\n\n\tif (!enable_unrestricted_guest) {\n\t\tif (enable_ept) {\n\t\t\tif (!is_paging(vcpu)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t\thw_cr4 |= X86_CR4_PSE;\n\t\t\t} else if (!(cr4 & X86_CR4_PAE)) {\n\t\t\t\thw_cr4 &= ~X86_CR4_PAE;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * SMEP/SMAP/PKU is disabled if CPU is in non-paging mode in\n\t\t * hardware.  To emulate this behavior, SMEP/SMAP/PKU needs\n\t\t * to be manually disabled when guest switches to non-paging\n\t\t * mode.\n\t\t *\n\t\t * If !enable_unrestricted_guest, the CPU is always running\n\t\t * with CR0.PG=1 and CR4 needs to be modified.\n\t\t * If enable_unrestricted_guest, the CPU automatically\n\t\t * disables SMEP/SMAP/PKU when the guest sets CR0.PG=0.\n\t\t */\n\t\tif (!is_paging(vcpu))\n\t\t\thw_cr4 &= ~(X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE);\n\t}\n\n\tvmcs_writel(CR4_READ_SHADOW, cr4);\n\tvmcs_writel(GUEST_CR4, hw_cr4);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4",
          "args": [
            "vcpu"
          ],
          "line": 2923
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "144-147",
          "snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exec_controls_clearbit",
          "args": [
            "vmx",
            "CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t    CPU_BASED_CR3_STORE_EXITING"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 2918
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "exec_controls_setbit",
          "args": [
            "vmx",
            "CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t  CPU_BASED_CR3_STORE_EXITING"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_cache_reg",
          "args": [
            "vcpu",
            "VCPU_EXREG_CR3"
          ],
          "line": 2911
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_cache_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2189-2212",
          "snippet": "static void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tkvm_register_mark_available(vcpu, reg);\n\n\tswitch (reg) {\n\tcase VCPU_REGS_RSP:\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);\n\t\tbreak;\n\tcase VCPU_REGS_RIP:\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);\n\t\tbreak;\n\tcase VCPU_EXREG_PDPTR:\n\t\tif (enable_ept)\n\t\t\tept_save_pdptrs(vcpu);\n\t\tbreak;\n\tcase VCPU_EXREG_CR3:\n\t\tif (enable_unrestricted_guest || (enable_ept && is_paging(vcpu)))\n\t\t\tvcpu->arch.cr3 = vmcs_readl(GUEST_CR3);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tkvm_register_mark_available(vcpu, reg);\n\n\tswitch (reg) {\n\tcase VCPU_REGS_RSP:\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);\n\t\tbreak;\n\tcase VCPU_REGS_RIP:\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);\n\t\tbreak;\n\tcase VCPU_EXREG_PDPTR:\n\t\tif (enable_ept)\n\t\t\tept_save_pdptrs(vcpu);\n\t\tbreak;\n\tcase VCPU_EXREG_CR3:\n\t\tif (enable_unrestricted_guest || (enable_ept && is_paging(vcpu)))\n\t\t\tvcpu->arch.cr3 = vmcs_readl(GUEST_CR3);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_is_available",
          "args": [
            "vcpu",
            "VCPU_EXREG_CR3"
          ],
          "line": 2910
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_is_available",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "40-44",
          "snippet": "static inline bool kvm_register_is_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     enum kvm_reg reg)\n{\n\treturn test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool kvm_register_is_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     enum kvm_reg reg)\n{\n\treturn test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 2908
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void ept_update_paging_mode_cr0(unsigned long *hw_cr0,\n\t\t\t\t\tunsigned long cr0,\n\t\t\t\t\tstruct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tvmx_cache_reg(vcpu, VCPU_EXREG_CR3);\n\tif (!(cr0 & X86_CR0_PG)) {\n\t\t/* From paging/starting to nonpaging */\n\t\texec_controls_setbit(vmx, CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t  CPU_BASED_CR3_STORE_EXITING);\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t} else if (!is_paging(vcpu)) {\n\t\t/* From nonpaging to paging */\n\t\texec_controls_clearbit(vmx, CPU_BASED_CR3_LOAD_EXITING |\n\t\t\t\t\t    CPU_BASED_CR3_STORE_EXITING);\n\t\tvcpu->arch.cr0 = cr0;\n\t\tvmx_set_cr4(vcpu, kvm_read_cr4(vcpu));\n\t}\n\n\tif (!(cr0 & X86_CR0_WP))\n\t\t*hw_cr0 &= ~X86_CR0_WP;\n}"
  },
  {
    "function_name": "ept_save_pdptrs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2890-2902",
    "snippet": "void ept_save_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tmmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);\n\t\tmmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);\n\t\tmmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);\n\t\tmmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_register_mark_dirty",
          "args": [
            "vcpu",
            "VCPU_EXREG_PDPTR"
          ],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "58-63",
          "snippet": "static inline void kvm_register_mark_dirty(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_mark_dirty(struct kvm_vcpu *vcpu,\n\t\t\t\t\t   enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read64",
          "args": [
            "GUEST_PDPTR3"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "120-130",
          "snippet": "static __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae_paging",
          "args": [
            "vcpu"
          ],
          "line": 2894
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "143-146",
          "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid ept_save_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tmmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);\n\t\tmmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);\n\t\tmmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);\n\t\tmmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);\n}"
  },
  {
    "function_name": "ept_load_pdptrs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2875-2888",
    "snippet": "static void ept_load_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!kvm_register_is_dirty(vcpu, VCPU_EXREG_PDPTR))\n\t\treturn;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tvmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);\n\t\tvmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);\n\t\tvmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);\n\t\tvmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write64",
          "args": [
            "GUEST_PDPTR3",
            "mmu->pdptrs[3]"
          ],
          "line": 2886
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "193-203",
          "snippet": "static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae_paging",
          "args": [
            "vcpu"
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "143-146",
          "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_is_dirty",
          "args": [
            "vcpu",
            "VCPU_EXREG_PDPTR"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_is_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "46-50",
          "snippet": "static inline bool kvm_register_is_dirty(struct kvm_vcpu *vcpu,\n\t\t\t\t\t enum kvm_reg reg)\n{\n\treturn test_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool kvm_register_is_dirty(struct kvm_vcpu *vcpu,\n\t\t\t\t\t enum kvm_reg reg)\n{\n\treturn test_bit(reg, (unsigned long *)&vcpu->arch.regs_dirty);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void ept_load_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (!kvm_register_is_dirty(vcpu, VCPU_EXREG_PDPTR))\n\t\treturn;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tvmcs_write64(GUEST_PDPTR0, mmu->pdptrs[0]);\n\t\tvmcs_write64(GUEST_PDPTR1, mmu->pdptrs[1]);\n\t\tvmcs_write64(GUEST_PDPTR2, mmu->pdptrs[2]);\n\t\tvmcs_write64(GUEST_PDPTR3, mmu->pdptrs[3]);\n\t}\n}"
  },
  {
    "function_name": "vmx_decache_cr4_guest_bits",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2867-2873",
    "snippet": "static void vmx_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr4_guest_owned_bits = vcpu->arch.cr4_guest_owned_bits;\n\n\tvcpu->arch.cr4 &= ~cr4_guest_owned_bits;\n\tvcpu->arch.cr4 |= vmcs_readl(GUEST_CR4) & cr4_guest_owned_bits;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_CR4"
          ],
          "line": 2872
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr4_guest_owned_bits = vcpu->arch.cr4_guest_owned_bits;\n\n\tvcpu->arch.cr4 &= ~cr4_guest_owned_bits;\n\tvcpu->arch.cr4 |= vmcs_readl(GUEST_CR4) & cr4_guest_owned_bits;\n}"
  },
  {
    "function_name": "vmx_decache_cr0_guest_bits",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2859-2865",
    "snippet": "static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr0_guest_owned_bits = vcpu->arch.cr0_guest_owned_bits;\n\n\tvcpu->arch.cr0 &= ~cr0_guest_owned_bits;\n\tvcpu->arch.cr0 |= vmcs_readl(GUEST_CR0) & cr0_guest_owned_bits;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_CR0"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n\tulong cr0_guest_owned_bits = vcpu->arch.cr0_guest_owned_bits;\n\n\tvcpu->arch.cr0 &= ~cr0_guest_owned_bits;\n\tvcpu->arch.cr0 |= vmcs_readl(GUEST_CR0) & cr0_guest_owned_bits;\n}"
  },
  {
    "function_name": "vmx_flush_tlb_gva",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2845-2857",
    "snippet": "static void vmx_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\tint vpid = to_vmx(vcpu)->vpid;\n\n\tif (!vpid_sync_vcpu_addr(vpid, addr))\n\t\tvpid_sync_context(vpid);\n\n\t/*\n\t * If VPIDs are not supported or enabled, then the above is a no-op.\n\t * But we don't really need a TLB flush in that case anyway, because\n\t * each VM entry/exit includes an implicit flush when VPID is 0.\n\t */\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vpid_sync_context",
          "args": [
            "vpid"
          ],
          "line": 2850
        },
        "resolved": true,
        "details": {
          "function_name": "vpid_sync_context",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "299-305",
          "snippet": "static inline void vpid_sync_context(int vpid)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vpid);\n\telse\n\t\tvpid_sync_vcpu_global();\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void vpid_sync_context(int vpid)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vpid);\n\telse\n\t\tvpid_sync_vcpu_global();\n}"
        }
      },
      {
        "call_info": {
          "callee": "vpid_sync_vcpu_addr",
          "args": [
            "vpid",
            "addr"
          ],
          "line": 2849
        },
        "resolved": true,
        "details": {
          "function_name": "vpid_sync_vcpu_addr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "271-282",
          "snippet": "static inline bool vpid_sync_vcpu_addr(int vpid, gva_t addr)\n{\n\tif (vpid == 0)\n\t\treturn true;\n\n\tif (cpu_has_vmx_invvpid_individual_addr()) {\n\t\t__invvpid(VMX_VPID_EXTENT_INDIVIDUAL_ADDR, vpid, addr);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline bool vpid_sync_vcpu_addr(int vpid, gva_t addr)\n{\n\tif (vpid == 0)\n\t\treturn true;\n\n\tif (cpu_has_vmx_invvpid_individual_addr()) {\n\t\t__invvpid(VMX_VPID_EXTENT_INDIVIDUAL_ADDR, vpid, addr);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\tint vpid = to_vmx(vcpu)->vpid;\n\n\tif (!vpid_sync_vcpu_addr(vpid, addr))\n\t\tvpid_sync_context(vpid);\n\n\t/*\n\t * If VPIDs are not supported or enabled, then the above is a no-op.\n\t * But we don't really need a TLB flush in that case anyway, because\n\t * each VM entry/exit includes an implicit flush when VPID is 0.\n\t */\n}"
  },
  {
    "function_name": "exit_lmode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2837-2841",
    "snippet": "static void exit_lmode(struct kvm_vcpu *vcpu)\n{\n\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\tvmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_set_efer",
          "args": [
            "vcpu",
            "vcpu->arch.efer & ~EFER_LMA"
          ],
          "line": 2840
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_efer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2798-2816",
          "snippet": "void vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_entry_controls_clearbit",
          "args": [
            "to_vmx(vcpu)",
            "VM_ENTRY_IA32E_MODE"
          ],
          "line": 2839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 2839
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void exit_lmode(struct kvm_vcpu *vcpu)\n{\n\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\tvmx_set_efer(vcpu, vcpu->arch.efer & ~EFER_LMA);\n}"
  },
  {
    "function_name": "enter_lmode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2820-2835",
    "snippet": "static void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & VMX_AR_TYPE_MASK) != VMX_AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~VMX_AR_TYPE_MASK)\n\t\t\t     | VMX_AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_set_efer",
          "args": [
            "vcpu",
            "vcpu->arch.efer | EFER_LMA"
          ],
          "line": 2834
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_efer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2798-2816",
          "snippet": "void vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "GUEST_TR_AR_BYTES",
            "(guest_tr_ar & ~VMX_AR_TYPE_MASK)\n\t\t\t     | VMX_AR_TYPE_BUSY_64_TSS"
          ],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug_ratelimited",
          "args": [
            "\"%s: tss fixup for long mode. \\n\"",
            "__func__"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_TR_AR_BYTES"
          ],
          "line": 2826
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_segment_cache_clear",
          "args": [
            "to_vmx(vcpu)"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_cache_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "444-447",
          "snippet": "static inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void enter_lmode(struct kvm_vcpu *vcpu)\n{\n\tu32 guest_tr_ar;\n\n\tvmx_segment_cache_clear(to_vmx(vcpu));\n\n\tguest_tr_ar = vmcs_read32(GUEST_TR_AR_BYTES);\n\tif ((guest_tr_ar & VMX_AR_TYPE_MASK) != VMX_AR_TYPE_BUSY_64_TSS) {\n\t\tpr_debug_ratelimited(\"%s: tss fixup for long mode. \\n\",\n\t\t\t\t     __func__);\n\t\tvmcs_write32(GUEST_TR_AR_BYTES,\n\t\t\t     (guest_tr_ar & ~VMX_AR_TYPE_MASK)\n\t\t\t     | VMX_AR_TYPE_BUSY_64_TSS);\n\t}\n\tvmx_set_efer(vcpu, vcpu->arch.efer | EFER_LMA);\n}"
  },
  {
    "function_name": "vmx_set_efer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2798-2816",
    "snippet": "void vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_msrs",
          "args": [
            "vmx"
          ],
          "line": 2815
        },
        "resolved": true,
        "details": {
          "function_name": "setup_msrs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1677-1714",
          "snippet": "static void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\t/*\n\t * The SYSCALL MSRs are only needed on long mode guests, and only\n\t * when EFER.SCE is set.\n\t */\n\tif (is_long_mode(&vmx->vcpu) && (vmx->vcpu.arch.efer & EFER_SCE)) {\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\tif (index >= 0 && guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_IA32_TSX_CTRL);\n\tif (index >= 0)\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\n\tvmx->save_nmsrs = save_nmsrs;\n\tvmx->guest_msrs_ready = false;\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_update_msr_bitmap(&vmx->vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\t/*\n\t * The SYSCALL MSRs are only needed on long mode guests, and only\n\t * when EFER.SCE is set.\n\t */\n\tif (is_long_mode(&vmx->vcpu) && (vmx->vcpu.arch.efer & EFER_SCE)) {\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\tif (index >= 0 && guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_IA32_TSX_CTRL);\n\tif (index >= 0)\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\n\tvmx->save_nmsrs = save_nmsrs;\n\tvmx->guest_msrs_ready = false;\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_update_msr_bitmap(&vmx->vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_entry_controls_clearbit",
          "args": [
            "to_vmx(vcpu)",
            "VM_ENTRY_IA32E_MODE"
          ],
          "line": 2811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 2811
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vm_entry_controls_setbit",
          "args": [
            "to_vmx(vcpu)",
            "VM_ENTRY_IA32E_MODE"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_msr_entry",
          "args": [
            "vmx",
            "MSR_EFER"
          ],
          "line": 2801
        },
        "resolved": true,
        "details": {
          "function_name": "find_msr_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "633-641",
          "snippet": "struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr = find_msr_entry(vmx, MSR_EFER);\n\n\tif (!msr)\n\t\treturn;\n\n\tvcpu->arch.efer = efer;\n\tif (efer & EFER_LMA) {\n\t\tvm_entry_controls_setbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\t\tmsr->data = efer;\n\t} else {\n\t\tvm_entry_controls_clearbit(to_vmx(vcpu), VM_ENTRY_IA32E_MODE);\n\n\t\tmsr->data = efer & ~EFER_LME;\n\t}\n\tsetup_msrs(vmx);\n}"
  },
  {
    "function_name": "enter_rmode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2749-2796",
    "snippet": "static void enter_rmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(vcpu->kvm);\n\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 1;\n\n\t/*\n\t * Very old userspace does not call KVM_SET_TSS_ADDR before entering\n\t * vcpu. Warn the user that an update is overdue.\n\t */\n\tif (!kvm_vmx->tss_addr)\n\t\tprintk_once(KERN_WARNING \"kvm: KVM_SET_TSS_ADDR need to be \"\n\t\t\t     \"called before entering vcpu\\n\");\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs_writel(GUEST_TR_BASE, kvm_vmx->tss_addr);\n\tvmcs_write32(GUEST_TR_LIMIT, RMODE_TSS_SIZE - 1);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tvmx->rmode.save_rflags = flags;\n\n\tflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\tvmcs_writel(GUEST_CR4, vmcs_readl(GUEST_CR4) | X86_CR4_VME);\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_rmode_seg(VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_rmode_seg(VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_rmode_seg(VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_rmode_seg(VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_rmode_seg(VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n\tfix_rmode_seg(VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\n\tkvm_mmu_reset_context(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_reset_context",
          "args": [
            "vcpu"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_context",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5167-5171",
          "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tkvm_init_mmu(vcpu, true);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tkvm_init_mmu(vcpu, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fix_rmode_seg",
          "args": [
            "VCPU_SREG_FS",
            "&vmx->rmode.segs[VCPU_SREG_FS]"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "fix_rmode_seg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2716-2747",
          "snippet": "static void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_writel(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);",
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_writel(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_exception_bitmap",
          "args": [
            "vcpu"
          ],
          "line": 2786
        },
        "resolved": true,
        "details": {
          "function_name": "update_exception_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "761-793",
          "snippet": "void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\teb |= (1u << GP_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\teb |= (1u << GP_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "GUEST_CR4",
            "vmcs_readl(GUEST_CR4) | X86_CR4_VME"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_CR4"
          ],
          "line": 2785
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "GUEST_TR_AR_BYTES",
            "0x008b"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_segment_cache_clear",
          "args": [
            "vmx"
          ],
          "line": 2773
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_cache_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "444-447",
          "snippet": "static inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING \"kvm: KVM_SET_TSS_ADDR need to be \"\n\t\t\t     \"called before entering vcpu\\n\""
          ],
          "line": 2770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_get_segment",
          "args": [
            "vcpu",
            "&vmx->rmode.segs[VCPU_SREG_CS]",
            "VCPU_SREG_CS"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3102-3136",
          "snippet": "void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kvm_vmx",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2753
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "474-477",
          "snippet": "static inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void enter_rmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct kvm_vmx *kvm_vmx = to_kvm_vmx(vcpu->kvm);\n\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 1;\n\n\t/*\n\t * Very old userspace does not call KVM_SET_TSS_ADDR before entering\n\t * vcpu. Warn the user that an update is overdue.\n\t */\n\tif (!kvm_vmx->tss_addr)\n\t\tprintk_once(KERN_WARNING \"kvm: KVM_SET_TSS_ADDR need to be \"\n\t\t\t     \"called before entering vcpu\\n\");\n\n\tvmx_segment_cache_clear(vmx);\n\n\tvmcs_writel(GUEST_TR_BASE, kvm_vmx->tss_addr);\n\tvmcs_write32(GUEST_TR_LIMIT, RMODE_TSS_SIZE - 1);\n\tvmcs_write32(GUEST_TR_AR_BYTES, 0x008b);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tvmx->rmode.save_rflags = flags;\n\n\tflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\tvmcs_writel(GUEST_CR4, vmcs_readl(GUEST_CR4) | X86_CR4_VME);\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_rmode_seg(VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_rmode_seg(VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_rmode_seg(VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_rmode_seg(VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_rmode_seg(VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n\tfix_rmode_seg(VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\n\tkvm_mmu_reset_context(vcpu);\n}"
  },
  {
    "function_name": "fix_rmode_seg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2716-2747",
    "snippet": "static void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_writel(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
      "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);",
      "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "sf->ar_bytes",
            "vmx_segment_access_rights(&var)"
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_segment_access_rights",
          "args": [
            "&var"
          ],
          "line": 2746
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_access_rights",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3161-3179",
          "snippet": "static u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var)\n{\n\tu32 ar;\n\n\tif (var->unusable || !var->present)\n\t\tar = 1 << 16;\n\telse {\n\t\tar = var->type & 15;\n\t\tar |= (var->s & 1) << 4;\n\t\tar |= (var->dpl & 3) << 5;\n\t\tar |= (var->present & 1) << 7;\n\t\tar |= (var->avl & 1) << 12;\n\t\tar |= (var->l & 1) << 13;\n\t\tar |= (var->db & 1) << 14;\n\t\tar |= (var->g & 1) << 15;\n\t}\n\n\treturn ar;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "sf->base",
            "var.base"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write16",
          "args": [
            "sf->selector",
            "var.selector"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "175-182",
          "snippet": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\"",
            "seg"
          ],
          "line": 2738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic void fix_rmode_seg(int seg, struct kvm_segment *save)\n{\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\tstruct kvm_segment var = *save;\n\n\tvar.dpl = 0x3;\n\tif (seg == VCPU_SREG_CS)\n\t\tvar.type = 0x3;\n\n\tif (!emulate_invalid_guest_state) {\n\t\tvar.selector = var.base >> 4;\n\t\tvar.base = var.base & 0xffff0;\n\t\tvar.limit = 0xffff;\n\t\tvar.g = 0;\n\t\tvar.db = 0;\n\t\tvar.present = 1;\n\t\tvar.s = 1;\n\t\tvar.l = 0;\n\t\tvar.unusable = 0;\n\t\tvar.type = 0x3;\n\t\tvar.avl = 0;\n\t\tif (save->base & 0xf)\n\t\t\tprintk_once(KERN_WARNING \"kvm: segment base is not \"\n\t\t\t\t\t\"paragraph aligned when entering \"\n\t\t\t\t\t\"protected mode (seg=%d)\", seg);\n\t}\n\n\tvmcs_write16(sf->selector, var.selector);\n\tvmcs_writel(sf->base, var.base);\n\tvmcs_write32(sf->limit, var.limit);\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(&var));\n}"
  },
  {
    "function_name": "enter_pmode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2678-2714",
    "snippet": "static void enter_pmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Update real mode segment cache. It may be not up-to-date if sement\n\t * register was written while vcpu was in a guest mode.\n\t */\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx_set_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tflags |= vmx->rmode.save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\n\tvmcs_writel(GUEST_CR4, (vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |\n\t\t\t(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME));\n\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_pmode_seg(vcpu, VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))"
    ],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fix_pmode_seg",
          "args": [
            "vcpu",
            "VCPU_SREG_GS",
            "&vmx->rmode.segs[VCPU_SREG_GS]"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "fix_pmode_seg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2659-2676",
          "snippet": "static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SEGMENT_RPL_MASK;\n\t\tsave->dpl = save->selector & SEGMENT_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\tvmx_set_segment(vcpu, save, seg);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SEGMENT_RPL_MASK;\n\t\tsave->dpl = save->selector & SEGMENT_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\tvmx_set_segment(vcpu, save, seg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_exception_bitmap",
          "args": [
            "vcpu"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "update_exception_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "761-793",
          "snippet": "void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\teb |= (1u << GP_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\teb |= (1u << GP_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "GUEST_CR4",
            "(vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |\n\t\t\t(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME)"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "CR4_READ_SHADOW"
          ],
          "line": 2704
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_set_segment",
          "args": [
            "vcpu",
            "&vmx->rmode.segs[VCPU_SREG_TR]",
            "VCPU_SREG_TR"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3181-3219",
          "snippet": "void vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\tgoto out;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n\nout:\n\tvmx->emulation_required = emulation_required(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);",
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nvoid vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\tgoto out;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n\nout:\n\tvmx->emulation_required = emulation_required(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_get_segment",
          "args": [
            "vcpu",
            "&vmx->rmode.segs[VCPU_SREG_CS]",
            "VCPU_SREG_CS"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3102-3136",
          "snippet": "void vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nvoid vmx_get_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tu32 ar;\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\t*var = vmx->rmode.segs[seg];\n\t\tif (seg == VCPU_SREG_TR\n\t\t    || var->selector == vmx_read_guest_seg_selector(vmx, seg))\n\t\t\treturn;\n\t\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\t\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\t\treturn;\n\t}\n\tvar->base = vmx_read_guest_seg_base(vmx, seg);\n\tvar->limit = vmx_read_guest_seg_limit(vmx, seg);\n\tvar->selector = vmx_read_guest_seg_selector(vmx, seg);\n\tar = vmx_read_guest_seg_ar(vmx, seg);\n\tvar->unusable = (ar >> 16) & 1;\n\tvar->type = ar & 15;\n\tvar->s = (ar >> 4) & 1;\n\tvar->dpl = (ar >> 5) & 3;\n\t/*\n\t * Some userspaces do not preserve unusable property. Since usable\n\t * segment has to be present according to VMX spec we can use present\n\t * property to amend userspace bug by making unusable segment always\n\t * nonpresent. vmx_segment_access_rights() already marks nonpresent\n\t * segment as unusable.\n\t */\n\tvar->present = !var->unusable;\n\tvar->avl = (ar >> 12) & 1;\n\tvar->l = (ar >> 13) & 1;\n\tvar->db = (ar >> 14) & 1;\n\tvar->g = (ar >> 15) & 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void enter_pmode(struct kvm_vcpu *vcpu)\n{\n\tunsigned long flags;\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Update real mode segment cache. It may be not up-to-date if sement\n\t * register was written while vcpu was in a guest mode.\n\t */\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_ES], VCPU_SREG_ES);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_DS], VCPU_SREG_DS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_FS], VCPU_SREG_FS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_GS], VCPU_SREG_GS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_SS], VCPU_SREG_SS);\n\tvmx_get_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_CS], VCPU_SREG_CS);\n\n\tvmx->rmode.vm86_active = 0;\n\n\tvmx_set_segment(vcpu, &vmx->rmode.segs[VCPU_SREG_TR], VCPU_SREG_TR);\n\n\tflags = vmcs_readl(GUEST_RFLAGS);\n\tflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tflags |= vmx->rmode.save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\tvmcs_writel(GUEST_RFLAGS, flags);\n\n\tvmcs_writel(GUEST_CR4, (vmcs_readl(GUEST_CR4) & ~X86_CR4_VME) |\n\t\t\t(vmcs_readl(CR4_READ_SHADOW) & X86_CR4_VME));\n\n\tupdate_exception_bitmap(vcpu);\n\n\tfix_pmode_seg(vcpu, VCPU_SREG_CS, &vmx->rmode.segs[VCPU_SREG_CS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_SS, &vmx->rmode.segs[VCPU_SREG_SS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_ES, &vmx->rmode.segs[VCPU_SREG_ES]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_DS, &vmx->rmode.segs[VCPU_SREG_DS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_FS, &vmx->rmode.segs[VCPU_SREG_FS]);\n\tfix_pmode_seg(vcpu, VCPU_SREG_GS, &vmx->rmode.segs[VCPU_SREG_GS]);\n}"
  },
  {
    "function_name": "fix_pmode_seg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2659-2676",
    "snippet": "static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SEGMENT_RPL_MASK;\n\t\tsave->dpl = save->selector & SEGMENT_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\tvmx_set_segment(vcpu, save, seg);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_set_segment",
          "args": [
            "vcpu",
            "save",
            "seg"
          ],
          "line": 2675
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_segment",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3181-3219",
          "snippet": "void vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\tgoto out;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n\nout:\n\tvmx->emulation_required = emulation_required(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static u32 vmx_segment_access_rights(struct kvm_segment *var);",
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);",
            "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic u32 vmx_segment_access_rights(struct kvm_segment *var);\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nvoid vmx_set_segment(struct kvm_vcpu *vcpu, struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tconst struct kvm_vmx_segment_field *sf = &kvm_vmx_segment_fields[seg];\n\n\tvmx_segment_cache_clear(vmx);\n\n\tif (vmx->rmode.vm86_active && seg != VCPU_SREG_LDTR) {\n\t\tvmx->rmode.segs[seg] = *var;\n\t\tif (seg == VCPU_SREG_TR)\n\t\t\tvmcs_write16(sf->selector, var->selector);\n\t\telse if (var->s)\n\t\t\tfix_rmode_seg(seg, &vmx->rmode.segs[seg]);\n\t\tgoto out;\n\t}\n\n\tvmcs_writel(sf->base, var->base);\n\tvmcs_write32(sf->limit, var->limit);\n\tvmcs_write16(sf->selector, var->selector);\n\n\t/*\n\t *   Fix the \"Accessed\" bit in AR field of segment registers for older\n\t * qemu binaries.\n\t *   IA32 arch specifies that at the time of processor reset the\n\t * \"Accessed\" bit in the AR field of segment registers is 1. And qemu\n\t * is setting it to 0 in the userland code. This causes invalid guest\n\t * state vmexit when \"unrestricted guest\" mode is turned on.\n\t *    Fix for this setup issue in cpu_reset is being pushed in the qemu\n\t * tree. Newer qemu binaries with that qemu fix would not need this\n\t * kvm hack.\n\t */\n\tif (enable_unrestricted_guest && (seg != VCPU_SREG_LDTR))\n\t\tvar->type |= 0x1; /* Accessed */\n\n\tvmcs_write32(sf->ar_bytes, vmx_segment_access_rights(var));\n\nout:\n\tvmx->emulation_required = emulation_required(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,\n\t\tstruct kvm_segment *save)\n{\n\tif (!emulate_invalid_guest_state) {\n\t\t/*\n\t\t * CS and SS RPL should be equal during guest entry according\n\t\t * to VMX spec, but in reality it is not always so. Since vcpu\n\t\t * is in the middle of the transition from real mode to\n\t\t * protected mode it is safe to assume that RPL 0 is a good\n\t\t * default value.\n\t\t */\n\t\tif (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)\n\t\t\tsave->selector &= ~SEGMENT_RPL_MASK;\n\t\tsave->dpl = save->selector & SEGMENT_RPL_MASK;\n\t\tsave->s = 1;\n\t}\n\tvmx_set_segment(vcpu, save, seg);\n}"
  },
  {
    "function_name": "alloc_kvm_area",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2628-2657",
    "snippet": "static __init int alloc_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmcs *vmcs;\n\n\t\tvmcs = alloc_vmcs_cpu(false, cpu, GFP_KERNEL);\n\t\tif (!vmcs) {\n\t\t\tfree_kvm_area();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * When eVMCS is enabled, alloc_vmcs_cpu() sets\n\t\t * vmcs->revision_id to KVM_EVMCS_VERSION instead of\n\t\t * revision_id reported by MSR_IA32_VMX_BASIC.\n\t\t *\n\t\t * However, even though not explicitly documented by\n\t\t * TLFS, VMXArea passed as VMXON argument should\n\t\t * still be marked with revision_id reported by\n\t\t * physical CPU.\n\t\t */\n\t\tif (static_branch_unlikely(&enable_evmcs))\n\t\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\t\tper_cpu(vmxarea, cpu) = vmcs;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct vmcs_config vmcs_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vmxarea",
            "cpu"
          ],
          "line": 2654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 2651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_kvm_area",
          "args": [],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "free_kvm_area",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2618-2626",
          "snippet": "static void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_vmcs_cpu",
          "args": [
            "false",
            "cpu",
            "GFP_KERNEL"
          ],
          "line": 2635
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_vmcs_cpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2534-2555",
          "snippet": "struct vmcs *alloc_vmcs_cpu(bool shadow, int cpu, gfp_t flags)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *pages;\n\tstruct vmcs *vmcs;\n\n\tpages = __alloc_pages_node(node, flags, vmcs_config.order);\n\tif (!pages)\n\t\treturn NULL;\n\tvmcs = page_address(pages);\n\tmemset(vmcs, 0, vmcs_config.size);\n\n\t/* KVM supports Enlightened VMCS v1 only */\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tvmcs->hdr.revision_id = KVM_EVMCS_VERSION;\n\telse\n\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\tif (shadow)\n\t\tvmcs->hdr.shadow_vmcs = 1;\n\treturn vmcs;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct vmcs_config vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct vmcs_config vmcs_config;\n\nstruct vmcs *alloc_vmcs_cpu(bool shadow, int cpu, gfp_t flags)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *pages;\n\tstruct vmcs *vmcs;\n\n\tpages = __alloc_pages_node(node, flags, vmcs_config.order);\n\tif (!pages)\n\t\treturn NULL;\n\tvmcs = page_address(pages);\n\tmemset(vmcs, 0, vmcs_config.size);\n\n\t/* KVM supports Enlightened VMCS v1 only */\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tvmcs->hdr.revision_id = KVM_EVMCS_VERSION;\n\telse\n\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\tif (shadow)\n\t\tvmcs->hdr.shadow_vmcs = 1;\n\treturn vmcs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct vmcs_config vmcs_config;\n\nstatic __init int alloc_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct vmcs *vmcs;\n\n\t\tvmcs = alloc_vmcs_cpu(false, cpu, GFP_KERNEL);\n\t\tif (!vmcs) {\n\t\t\tfree_kvm_area();\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/*\n\t\t * When eVMCS is enabled, alloc_vmcs_cpu() sets\n\t\t * vmcs->revision_id to KVM_EVMCS_VERSION instead of\n\t\t * revision_id reported by MSR_IA32_VMX_BASIC.\n\t\t *\n\t\t * However, even though not explicitly documented by\n\t\t * TLFS, VMXArea passed as VMXON argument should\n\t\t * still be marked with revision_id reported by\n\t\t * physical CPU.\n\t\t */\n\t\tif (static_branch_unlikely(&enable_evmcs))\n\t\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\t\tper_cpu(vmxarea, cpu) = vmcs;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "free_kvm_area",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2618-2626",
    "snippet": "static void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vmxarea",
            "cpu"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_vmcs",
          "args": [
            "per_cpu(vmxarea, cpu)"
          ],
          "line": 2623
        },
        "resolved": true,
        "details": {
          "function_name": "free_vmcs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2557-2560",
          "snippet": "void free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct vmcs_config vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct vmcs_config vmcs_config;\n\nvoid free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vmxarea",
            "cpu"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void free_kvm_area(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfree_vmcs(per_cpu(vmxarea, cpu));\n\t\tper_cpu(vmxarea, cpu) = NULL;\n\t}\n}"
  },
  {
    "function_name": "alloc_loaded_vmcs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2577-2616",
    "snippet": "int alloc_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tloaded_vmcs->vmcs = alloc_vmcs(false);\n\tif (!loaded_vmcs->vmcs)\n\t\treturn -ENOMEM;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\n\tloaded_vmcs->shadow_vmcs = NULL;\n\tloaded_vmcs->hv_timer_soft_disabled = false;\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n\n\tif (cpu_has_vmx_msr_bitmap()) {\n\t\tloaded_vmcs->msr_bitmap = (unsigned long *)\n\t\t\t\t__get_free_page(GFP_KERNEL_ACCOUNT);\n\t\tif (!loaded_vmcs->msr_bitmap)\n\t\t\tgoto out_vmcs;\n\t\tmemset(loaded_vmcs->msr_bitmap, 0xff, PAGE_SIZE);\n\n\t\tif (IS_ENABLED(CONFIG_HYPERV) &&\n\t\t    static_branch_unlikely(&enable_evmcs) &&\n\t\t    (ms_hyperv.nested_features & HV_X64_NESTED_MSR_BITMAP)) {\n\t\t\tstruct hv_enlightened_vmcs *evmcs =\n\t\t\t\t(struct hv_enlightened_vmcs *)loaded_vmcs->vmcs;\n\n\t\t\tevmcs->hv_enlightenments_control.msr_bitmap = 1;\n\t\t}\n\t}\n\n\tmemset(&loaded_vmcs->host_state, 0, sizeof(struct vmcs_host_state));\n\tmemset(&loaded_vmcs->controls_shadow, 0,\n\t\tsizeof(struct vmcs_controls_shadow));\n\n\treturn 0;\n\nout_vmcs:\n\tfree_loaded_vmcs(loaded_vmcs);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_loaded_vmcs",
          "args": [
            "loaded_vmcs"
          ],
          "line": 2614
        },
        "resolved": true,
        "details": {
          "function_name": "free_loaded_vmcs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2565-2575",
          "snippet": "void free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tif (loaded_vmcs->msr_bitmap)\n\t\tfree_page((unsigned long)loaded_vmcs->msr_bitmap);\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tif (loaded_vmcs->msr_bitmap)\n\t\tfree_page((unsigned long)loaded_vmcs->msr_bitmap);\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&loaded_vmcs->controls_shadow",
            "0",
            "sizeof(struct vmcs_controls_shadow)"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&loaded_vmcs->host_state",
            "0",
            "sizeof(struct vmcs_host_state)"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 2598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HYPERV"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "loaded_vmcs->msr_bitmap",
            "0xff",
            "PAGE_SIZE"
          ],
          "line": 2595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_msr_bitmap",
          "args": [],
          "line": 2590
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "120-123",
          "snippet": "static inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_clear",
          "args": [
            "loaded_vmcs->vmcs"
          ],
          "line": 2583
        },
        "resolved": true,
        "details": {
          "function_name": "loaded_vmcs_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "701-708",
          "snippet": "void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_vmcs",
          "args": [
            "false"
          ],
          "line": 2579
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_vmcs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "495-499",
          "snippet": "static inline struct vmcs *alloc_vmcs(bool shadow)\n{\n\treturn alloc_vmcs_cpu(shadow, raw_smp_processor_id(),\n\t\t\t      GFP_KERNEL_ACCOUNT);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vmcs *alloc_vmcs(bool shadow)\n{\n\treturn alloc_vmcs_cpu(shadow, raw_smp_processor_id(),\n\t\t\t      GFP_KERNEL_ACCOUNT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nint alloc_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tloaded_vmcs->vmcs = alloc_vmcs(false);\n\tif (!loaded_vmcs->vmcs)\n\t\treturn -ENOMEM;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\n\tloaded_vmcs->shadow_vmcs = NULL;\n\tloaded_vmcs->hv_timer_soft_disabled = false;\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n\n\tif (cpu_has_vmx_msr_bitmap()) {\n\t\tloaded_vmcs->msr_bitmap = (unsigned long *)\n\t\t\t\t__get_free_page(GFP_KERNEL_ACCOUNT);\n\t\tif (!loaded_vmcs->msr_bitmap)\n\t\t\tgoto out_vmcs;\n\t\tmemset(loaded_vmcs->msr_bitmap, 0xff, PAGE_SIZE);\n\n\t\tif (IS_ENABLED(CONFIG_HYPERV) &&\n\t\t    static_branch_unlikely(&enable_evmcs) &&\n\t\t    (ms_hyperv.nested_features & HV_X64_NESTED_MSR_BITMAP)) {\n\t\t\tstruct hv_enlightened_vmcs *evmcs =\n\t\t\t\t(struct hv_enlightened_vmcs *)loaded_vmcs->vmcs;\n\n\t\t\tevmcs->hv_enlightenments_control.msr_bitmap = 1;\n\t\t}\n\t}\n\n\tmemset(&loaded_vmcs->host_state, 0, sizeof(struct vmcs_host_state));\n\tmemset(&loaded_vmcs->controls_shadow, 0,\n\t\tsizeof(struct vmcs_controls_shadow));\n\n\treturn 0;\n\nout_vmcs:\n\tfree_loaded_vmcs(loaded_vmcs);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "free_loaded_vmcs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2565-2575",
    "snippet": "void free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tif (loaded_vmcs->msr_bitmap)\n\t\tfree_page((unsigned long)loaded_vmcs->msr_bitmap);\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "loaded_vmcs->shadow_vmcs != NULL"
          ],
          "line": 2574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)loaded_vmcs->msr_bitmap"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2066-2075",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_vmcs",
          "args": [
            "loaded_vmcs->vmcs"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "free_vmcs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2557-2560",
          "snippet": "void free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct vmcs_config vmcs_config;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct vmcs_config vmcs_config;\n\nvoid free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}"
        }
      },
      {
        "call_info": {
          "callee": "loaded_vmcs_clear",
          "args": [
            "loaded_vmcs"
          ],
          "line": 2569
        },
        "resolved": true,
        "details": {
          "function_name": "loaded_vmcs_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "701-708",
          "snippet": "void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid free_loaded_vmcs(struct loaded_vmcs *loaded_vmcs)\n{\n\tif (!loaded_vmcs->vmcs)\n\t\treturn;\n\tloaded_vmcs_clear(loaded_vmcs);\n\tfree_vmcs(loaded_vmcs->vmcs);\n\tloaded_vmcs->vmcs = NULL;\n\tif (loaded_vmcs->msr_bitmap)\n\t\tfree_page((unsigned long)loaded_vmcs->msr_bitmap);\n\tWARN_ON(loaded_vmcs->shadow_vmcs != NULL);\n}"
  },
  {
    "function_name": "free_vmcs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2557-2560",
    "snippet": "void free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct vmcs_config vmcs_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)vmcs",
            "vmcs_config.order"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct vmcs_config vmcs_config;\n\nvoid free_vmcs(struct vmcs *vmcs)\n{\n\tfree_pages((unsigned long)vmcs, vmcs_config.order);\n}"
  },
  {
    "function_name": "alloc_vmcs_cpu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2534-2555",
    "snippet": "struct vmcs *alloc_vmcs_cpu(bool shadow, int cpu, gfp_t flags)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *pages;\n\tstruct vmcs *vmcs;\n\n\tpages = __alloc_pages_node(node, flags, vmcs_config.order);\n\tif (!pages)\n\t\treturn NULL;\n\tvmcs = page_address(pages);\n\tmemset(vmcs, 0, vmcs_config.size);\n\n\t/* KVM supports Enlightened VMCS v1 only */\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tvmcs->hdr.revision_id = KVM_EVMCS_VERSION;\n\telse\n\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\tif (shadow)\n\t\tvmcs->hdr.shadow_vmcs = 1;\n\treturn vmcs;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct vmcs_config vmcs_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vmcs",
            "0",
            "vmcs_config.size"
          ],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "pages"
          ],
          "line": 2543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__alloc_pages_node",
          "args": [
            "node",
            "flags",
            "vmcs_config.order"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct vmcs_config vmcs_config;\n\nstruct vmcs *alloc_vmcs_cpu(bool shadow, int cpu, gfp_t flags)\n{\n\tint node = cpu_to_node(cpu);\n\tstruct page *pages;\n\tstruct vmcs *vmcs;\n\n\tpages = __alloc_pages_node(node, flags, vmcs_config.order);\n\tif (!pages)\n\t\treturn NULL;\n\tvmcs = page_address(pages);\n\tmemset(vmcs, 0, vmcs_config.size);\n\n\t/* KVM supports Enlightened VMCS v1 only */\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tvmcs->hdr.revision_id = KVM_EVMCS_VERSION;\n\telse\n\t\tvmcs->hdr.revision_id = vmcs_config.revision_id;\n\n\tif (shadow)\n\t\tvmcs->hdr.shadow_vmcs = 1;\n\treturn vmcs;\n}"
  },
  {
    "function_name": "adjust_vmx_controls",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2317-2334",
    "snippet": "static __init int adjust_vmx_controls(u32 ctl_min, u32 ctl_opt,\n\t\t\t\t      u32 msr, u32 *result)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 ctl = ctl_min | ctl_opt;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\n\tctl &= vmx_msr_high; /* bit == 0 in high word ==> must be zero */\n\tctl |= vmx_msr_low;  /* bit == 1 in low word  ==> must be one  */\n\n\t/* Ensure minimum (required) set of control bits are supported. */\n\tif (ctl_min & ~ctl)\n\t\treturn -EIO;\n\n\t*result = ctl;\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdmsr",
          "args": [
            "msr",
            "vmx_msr_low",
            "vmx_msr_high"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __init int adjust_vmx_controls(u32 ctl_min, u32 ctl_opt,\n\t\t\t\t      u32 msr, u32 *result)\n{\n\tu32 vmx_msr_low, vmx_msr_high;\n\tu32 ctl = ctl_min | ctl_opt;\n\n\trdmsr(msr, vmx_msr_low, vmx_msr_high);\n\n\tctl &= vmx_msr_high; /* bit == 0 in high word ==> must be zero */\n\tctl |= vmx_msr_low;  /* bit == 1 in low word  ==> must be one  */\n\n\t/* Ensure minimum (required) set of control bits are supported. */\n\tif (ctl_min & ~ctl)\n\t\treturn -EIO;\n\n\t*result = ctl;\n\treturn 0;\n}"
  },
  {
    "function_name": "cpu_has_sgx",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2312-2315",
    "snippet": "static bool cpu_has_sgx(void)\n{\n\treturn cpuid_eax(0) >= 0x12 && (cpuid_eax(0x12) & BIT(0));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "0"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_eax",
          "args": [
            "0x12"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_eax",
          "args": [
            "0"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool cpu_has_sgx(void)\n{\n\treturn cpuid_eax(0) >= 0x12 && (cpuid_eax(0x12) & BIT(0));\n}"
  },
  {
    "function_name": "hardware_disable",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2300-2304",
    "snippet": "static void hardware_disable(void)\n{\n\tvmclear_local_loaded_vmcss();\n\tkvm_cpu_vmxoff();\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_cpu_vmxoff",
          "args": [],
          "line": 2303
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_vmxoff",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2292-2298",
          "snippet": "static void kvm_cpu_vmxoff(void)\n{\n\tasm volatile (__ex(\"vmxoff\"));\n\n\tintel_pt_handle_vmx(0);\n\tcr4_clear_bits(X86_CR4_VMXE);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void kvm_cpu_vmxoff(void)\n{\n\tasm volatile (__ex(\"vmxoff\"));\n\n\tintel_pt_handle_vmx(0);\n\tcr4_clear_bits(X86_CR4_VMXE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmclear_local_loaded_vmcss",
          "args": [],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "vmclear_local_loaded_vmcss",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2278-2286",
          "snippet": "static void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\n\nstatic void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void hardware_disable(void)\n{\n\tvmclear_local_loaded_vmcss();\n\tkvm_cpu_vmxoff();\n}"
  },
  {
    "function_name": "kvm_cpu_vmxoff",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2292-2298",
    "snippet": "static void kvm_cpu_vmxoff(void)\n{\n\tasm volatile (__ex(\"vmxoff\"));\n\n\tintel_pt_handle_vmx(0);\n\tcr4_clear_bits(X86_CR4_VMXE);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cr4_clear_bits",
          "args": [
            "X86_CR4_VMXE"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_handle_vmx",
          "args": [
            "0"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void kvm_cpu_vmxoff(void)\n{\n\tasm volatile (__ex(\"vmxoff\"));\n\n\tintel_pt_handle_vmx(0);\n\tcr4_clear_bits(X86_CR4_VMXE);\n}"
  },
  {
    "function_name": "vmclear_local_loaded_vmcss",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2278-2286",
    "snippet": "static void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__loaded_vmcs_clear",
          "args": [
            "v"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "__loaded_vmcs_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "672-699",
          "snippet": "static void __loaded_vmcs_clear(void *arg)\n{\n\tstruct loaded_vmcs *loaded_vmcs = arg;\n\tint cpu = raw_smp_processor_id();\n\n\tif (loaded_vmcs->cpu != cpu)\n\t\treturn; /* vcpu migration can race with cpu offline */\n\tif (per_cpu(current_vmcs, cpu) == loaded_vmcs->vmcs)\n\t\tper_cpu(current_vmcs, cpu) = NULL;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\tif (loaded_vmcs->shadow_vmcs && loaded_vmcs->launched)\n\t\tvmcs_clear(loaded_vmcs->shadow_vmcs);\n\n\tlist_del(&loaded_vmcs->loaded_vmcss_on_cpu_link);\n\n\t/*\n\t * Ensure all writes to loaded_vmcs, including deleting it from its\n\t * current percpu list, complete before setting loaded_vmcs->vcpu to\n\t * -1, otherwise a different cpu can see vcpu == -1 first and add\n\t * loaded_vmcs to its percpu list before it's deleted from this cpu's\n\t * list. Pairs with the smp_rmb() in vmx_vcpu_load_vmcs().\n\t */\n\tsmp_wmb();\n\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static DEFINE_PER_CPU(struct vmcs *, vmxarea);\nDEFINE_PER_CPU(struct vmcs *, current_vmcs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct vmcs *, vmxarea);\nDEFINE_PER_CPU(struct vmcs *, current_vmcs);\n\nstatic void __loaded_vmcs_clear(void *arg)\n{\n\tstruct loaded_vmcs *loaded_vmcs = arg;\n\tint cpu = raw_smp_processor_id();\n\n\tif (loaded_vmcs->cpu != cpu)\n\t\treturn; /* vcpu migration can race with cpu offline */\n\tif (per_cpu(current_vmcs, cpu) == loaded_vmcs->vmcs)\n\t\tper_cpu(current_vmcs, cpu) = NULL;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\tif (loaded_vmcs->shadow_vmcs && loaded_vmcs->launched)\n\t\tvmcs_clear(loaded_vmcs->shadow_vmcs);\n\n\tlist_del(&loaded_vmcs->loaded_vmcss_on_cpu_link);\n\n\t/*\n\t * Ensure all writes to loaded_vmcs, including deleting it from its\n\t * current percpu list, complete before setting loaded_vmcs->vcpu to\n\t * -1, otherwise a different cpu can see vcpu == -1 first and add\n\t * loaded_vmcs to its percpu list before it's deleted from this cpu's\n\t * list. Pairs with the smp_rmb() in vmx_vcpu_load_vmcs().\n\t */\n\tsmp_wmb();\n\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "v",
            "n",
            "&per_cpu(loaded_vmcss_on_cpu, cpu)",
            "loaded_vmcss_on_cpu_link"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "loaded_vmcss_on_cpu",
            "cpu"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\n\nstatic void vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v, *n;\n\n\tlist_for_each_entry_safe(v, n, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t\t loaded_vmcss_on_cpu_link)\n\t\t__loaded_vmcs_clear(v);\n}"
  },
  {
    "function_name": "hardware_enable",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2247-2276",
    "snippet": "static int hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tint r;\n\n\tif (cr4_read_shadow() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\n\t/*\n\t * This can happen if we hot-added a CPU but failed to allocate\n\t * VP assist page for it.\n\t */\n\tif (static_branch_unlikely(&enable_evmcs) &&\n\t    !hv_get_vp_assist_page(cpu))\n\t\treturn -EFAULT;\n\n\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\tINIT_LIST_HEAD(&per_cpu(blocked_vcpu_on_cpu, cpu));\n\tspin_lock_init(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n\n\tr = kvm_cpu_vmxon(phys_addr);\n\tif (r)\n\t\treturn r;\n\n\tif (enable_ept)\n\t\tept_sync_global();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);",
      "static DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);",
      "static DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ept_sync_global",
          "args": [],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "ept_sync_global",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "307-310",
          "snippet": "static inline void ept_sync_global(void)\n{\n\t__invept(VMX_EPT_EXTENT_GLOBAL, 0, 0);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void ept_sync_global(void)\n{\n\t__invept(VMX_EPT_EXTENT_GLOBAL, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_vmxon",
          "args": [
            "phys_addr"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_vmxon",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2225-2245",
          "snippet": "static int kvm_cpu_vmxon(u64 vmxon_pointer)\n{\n\tu64 msr;\n\n\tcr4_set_bits(X86_CR4_VMXE);\n\tintel_pt_handle_vmx(1);\n\n\tasm_volatile_goto(\"1: vmxon %[vmxon_pointer]\\n\\t\"\n\t\t\t  _ASM_EXTABLE(1b, %l[fault])\n\t\t\t  : : [vmxon_pointer] \"m\"(vmxon_pointer)\n\t\t\t  : : fault);\n\treturn 0;\n\nfault:\n\tWARN_ONCE(1, \"VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\\n\",\n\t\t  rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr);\n\tintel_pt_handle_vmx(0);\n\tcr4_clear_bits(X86_CR4_VMXE);\n\n\treturn -EFAULT;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int kvm_cpu_vmxon(u64 vmxon_pointer)\n{\n\tu64 msr;\n\n\tcr4_set_bits(X86_CR4_VMXE);\n\tintel_pt_handle_vmx(1);\n\n\tasm_volatile_goto(\"1: vmxon %[vmxon_pointer]\\n\\t\"\n\t\t\t  _ASM_EXTABLE(1b, %l[fault])\n\t\t\t  : : [vmxon_pointer] \"m\"(vmxon_pointer)\n\t\t\t  : : fault);\n\treturn 0;\n\nfault:\n\tWARN_ONCE(1, \"VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\\n\",\n\t\t  rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr);\n\tintel_pt_handle_vmx(0);\n\tcr4_clear_bits(X86_CR4_VMXE);\n\n\treturn -EFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&per_cpu(blocked_vcpu_on_cpu_lock, cpu)"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "blocked_vcpu_on_cpu_lock",
            "cpu"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&per_cpu(blocked_vcpu_on_cpu, cpu)"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "blocked_vcpu_on_cpu",
            "cpu"
          ],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&per_cpu(loaded_vmcss_on_cpu, cpu)"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "loaded_vmcss_on_cpu",
            "cpu"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hv_get_vp_assist_page",
          "args": [
            "cpu"
          ],
          "line": 2261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 2260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_read_shadow",
          "args": [],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "per_cpu(vmxarea, cpu)"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "vmxarea",
            "cpu"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\nstatic DEFINE_PER_CPU(struct list_head, blocked_vcpu_on_cpu);\nstatic DEFINE_PER_CPU(spinlock_t, blocked_vcpu_on_cpu_lock);\n\nstatic int hardware_enable(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tu64 phys_addr = __pa(per_cpu(vmxarea, cpu));\n\tint r;\n\n\tif (cr4_read_shadow() & X86_CR4_VMXE)\n\t\treturn -EBUSY;\n\n\t/*\n\t * This can happen if we hot-added a CPU but failed to allocate\n\t * VP assist page for it.\n\t */\n\tif (static_branch_unlikely(&enable_evmcs) &&\n\t    !hv_get_vp_assist_page(cpu))\n\t\treturn -EFAULT;\n\n\tINIT_LIST_HEAD(&per_cpu(loaded_vmcss_on_cpu, cpu));\n\tINIT_LIST_HEAD(&per_cpu(blocked_vcpu_on_cpu, cpu));\n\tspin_lock_init(&per_cpu(blocked_vcpu_on_cpu_lock, cpu));\n\n\tr = kvm_cpu_vmxon(phys_addr);\n\tif (r)\n\t\treturn r;\n\n\tif (enable_ept)\n\t\tept_sync_global();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_cpu_vmxon",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2225-2245",
    "snippet": "static int kvm_cpu_vmxon(u64 vmxon_pointer)\n{\n\tu64 msr;\n\n\tcr4_set_bits(X86_CR4_VMXE);\n\tintel_pt_handle_vmx(1);\n\n\tasm_volatile_goto(\"1: vmxon %[vmxon_pointer]\\n\\t\"\n\t\t\t  _ASM_EXTABLE(1b, %l[fault])\n\t\t\t  : : [vmxon_pointer] \"m\"(vmxon_pointer)\n\t\t\t  : : fault);\n\treturn 0;\n\nfault:\n\tWARN_ONCE(1, \"VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\\n\",\n\t\t  rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr);\n\tintel_pt_handle_vmx(0);\n\tcr4_clear_bits(X86_CR4_VMXE);\n\n\treturn -EFAULT;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cr4_clear_bits",
          "args": [
            "X86_CR4_VMXE"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_handle_vmx",
          "args": [
            "0"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\\n\"",
            "rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr"
          ],
          "line": 2239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl_safe",
          "args": [
            "MSR_IA32_FEAT_CTL",
            "&msr"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asm_volatile_goto",
          "args": [
            "\"1: vmxon %[vmxon_pointer]\\n\\t\"\n\t\t\t  _ASM_EXTABLE(1b, %l[fault])\n\t\t\t  : : [vmxon_pointer] \"m\"(vmxon_pointer)\n\t\t\t  : :fault"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"m\"",
          "args": [
            "vmxon_pointer"
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"1: vmxon %[vmxon_pointer]\\n\\t\"\n\t\t\t  _ASM_EXTABLE",
          "args": [
            "1b, %l[fault]"
          ],
          "line": 2232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_handle_vmx",
          "args": [
            "1"
          ],
          "line": 2230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cr4_set_bits",
          "args": [
            "X86_CR4_VMXE"
          ],
          "line": 2229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int kvm_cpu_vmxon(u64 vmxon_pointer)\n{\n\tu64 msr;\n\n\tcr4_set_bits(X86_CR4_VMXE);\n\tintel_pt_handle_vmx(1);\n\n\tasm_volatile_goto(\"1: vmxon %[vmxon_pointer]\\n\\t\"\n\t\t\t  _ASM_EXTABLE(1b, %l[fault])\n\t\t\t  : : [vmxon_pointer] \"m\"(vmxon_pointer)\n\t\t\t  : : fault);\n\treturn 0;\n\nfault:\n\tWARN_ONCE(1, \"VMXON faulted, MSR_IA32_FEAT_CTL (0x3a) = 0x%llx\\n\",\n\t\t  rdmsrl_safe(MSR_IA32_FEAT_CTL, &msr) ? 0xdeadbeef : msr);\n\tintel_pt_handle_vmx(0);\n\tcr4_clear_bits(X86_CR4_VMXE);\n\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "vmx_disabled_by_bios",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2219-2223",
    "snippet": "static __init int vmx_disabled_by_bios(void)\n{\n\treturn !boot_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||\n\t       !boot_cpu_has(X86_FEATURE_VMX);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_VMX"
          ],
          "line": 2222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_MSR_IA32_FEAT_CTL"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __init int vmx_disabled_by_bios(void)\n{\n\treturn !boot_cpu_has(X86_FEATURE_MSR_IA32_FEAT_CTL) ||\n\t       !boot_cpu_has(X86_FEATURE_VMX);\n}"
  },
  {
    "function_name": "cpu_has_kvm_support",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2214-2217",
    "snippet": "static __init int cpu_has_kvm_support(void)\n{\n\treturn cpu_has_vmx();\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_has_vmx",
          "args": [],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_intel_pt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "341-350",
          "snippet": "static inline bool cpu_has_vmx_intel_pt(void)\n{\n\tu64 vmx_msr;\n\n\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\treturn (vmx_msr & MSR_IA32_VMX_MISC_INTEL_PT) &&\n\t\t(vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_PT_USE_GPA) &&\n\t\t(vmcs_config.vmexit_ctrl & VM_EXIT_CLEAR_IA32_RTIT_CTL) &&\n\t\t(vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_RTIT_CTL);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_intel_pt(void)\n{\n\tu64 vmx_msr;\n\n\trdmsrl(MSR_IA32_VMX_MISC, vmx_msr);\n\treturn (vmx_msr & MSR_IA32_VMX_MISC_INTEL_PT) &&\n\t\t(vmcs_config.cpu_based_2nd_exec_ctrl & SECONDARY_EXEC_PT_USE_GPA) &&\n\t\t(vmcs_config.vmexit_ctrl & VM_EXIT_CLEAR_IA32_RTIT_CTL) &&\n\t\t(vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_RTIT_CTL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __init int cpu_has_kvm_support(void)\n{\n\treturn cpu_has_vmx();\n}"
  },
  {
    "function_name": "vmx_cache_reg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "2189-2212",
    "snippet": "static void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tkvm_register_mark_available(vcpu, reg);\n\n\tswitch (reg) {\n\tcase VCPU_REGS_RSP:\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);\n\t\tbreak;\n\tcase VCPU_REGS_RIP:\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);\n\t\tbreak;\n\tcase VCPU_EXREG_PDPTR:\n\t\tif (enable_ept)\n\t\t\tept_save_pdptrs(vcpu);\n\t\tbreak;\n\tcase VCPU_EXREG_CR3:\n\t\tif (enable_unrestricted_guest || (enable_ept && is_paging(vcpu)))\n\t\t\tvcpu->arch.cr3 = vmcs_readl(GUEST_CR3);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_CR3"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ept_save_pdptrs",
          "args": [
            "vcpu"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "ept_save_pdptrs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "2890-2902",
          "snippet": "void ept_save_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tmmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);\n\t\tmmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);\n\t\tmmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);\n\t\tmmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid ept_save_pdptrs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.walk_mmu;\n\n\tif (is_pae_paging(vcpu)) {\n\t\tmmu->pdptrs[0] = vmcs_read64(GUEST_PDPTR0);\n\t\tmmu->pdptrs[1] = vmcs_read64(GUEST_PDPTR1);\n\t\tmmu->pdptrs[2] = vmcs_read64(GUEST_PDPTR2);\n\t\tmmu->pdptrs[3] = vmcs_read64(GUEST_PDPTR3);\n\t}\n\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_mark_available",
          "args": [
            "vcpu",
            "reg"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_mark_available",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "52-56",
          "snippet": "static inline void kvm_register_mark_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_mark_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tkvm_register_mark_available(vcpu, reg);\n\n\tswitch (reg) {\n\tcase VCPU_REGS_RSP:\n\t\tvcpu->arch.regs[VCPU_REGS_RSP] = vmcs_readl(GUEST_RSP);\n\t\tbreak;\n\tcase VCPU_REGS_RIP:\n\t\tvcpu->arch.regs[VCPU_REGS_RIP] = vmcs_readl(GUEST_RIP);\n\t\tbreak;\n\tcase VCPU_EXREG_PDPTR:\n\t\tif (enable_ept)\n\t\t\tept_save_pdptrs(vcpu);\n\t\tbreak;\n\tcase VCPU_EXREG_CR3:\n\t\tif (enable_unrestricted_guest || (enable_ept && is_paging(vcpu)))\n\t\t\tvcpu->arch.cr3 = vmcs_readl(GUEST_CR3);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "vmx_set_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1935-2187",
    "snippet": "static int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr;\n\tint ret = 0;\n\tu32 msr_index = msr_info->index;\n\tu64 data = msr_info->data;\n\tu32 index;\n\n\tswitch (msr_index) {\n\tcase MSR_EFER:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_write_guest_kernel_gs_base(vmx, data);\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tif (is_guest_mode(vcpu))\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_cs = data;\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tif (is_guest_mode(vcpu))\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_eip = data;\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tif (is_guest_mode(vcpu))\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_esp = data;\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (is_guest_mode(vcpu) && get_vmcs12(vcpu)->vm_exit_controls &\n\t\t\t\t\t\tVM_EXIT_SAVE_DEBUG_CONTROLS)\n\t\t\tget_vmcs12(vcpu)->guest_ia32_debugctl = data;\n\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported() ||\n\t\t    (!msr_info->host_initiated &&\n\t\t     !guest_cpuid_has(vcpu, X86_FEATURE_MPX)))\n\t\t\treturn 1;\n\t\tif (is_noncanonical_address(data & PAGE_MASK, vcpu) ||\n\t\t    (data & MSR_IA32_BNDCFGS_RSVD))\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_BNDCFGS, data);\n\t\tbreak;\n\tcase MSR_IA32_UMWAIT_CONTROL:\n\t\tif (!msr_info->host_initiated && !vmx_has_waitpkg(vmx))\n\t\t\treturn 1;\n\n\t\t/* The reserved bit 1 and non-32 bit [63:32] should be zero */\n\t\tif (data & (BIT_ULL(1) | GENMASK_ULL(63, 32)))\n\t\t\treturn 1;\n\n\t\tvmx->msr_ia32_umwait_control = data;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL))\n\t\t\treturn 1;\n\n\t\tif (data & ~kvm_spec_ctrl_valid_bits(vcpu))\n\t\t\treturn 1;\n\n\t\tvmx->spec_ctrl = data;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_vmx_prepare_msr_bitmap. We should not touch the\n\t\t * vmcs02.msr_bitmap here since it gets completely overwritten\n\t\t * in the merging. We update the vmcs01 here for L1 as well\n\t\t * since it will end up touching the MSR anyway now.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(vmx->vmcs01.msr_bitmap,\n\t\t\t\t\t      MSR_IA32_SPEC_CTRL,\n\t\t\t\t\t      MSR_TYPE_RW);\n\t\tbreak;\n\tcase MSR_IA32_TSX_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vcpu->arch.arch_capabilities & ARCH_CAP_TSX_CTRL_MSR))\n\t\t\treturn 1;\n\t\tif (data & ~(TSX_CTRL_RTM_DISABLE | TSX_CTRL_CPUID_CLEAR))\n\t\t\treturn 1;\n\t\tgoto find_shared_msr;\n\tcase MSR_IA32_PRED_CMD:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL))\n\t\t\treturn 1;\n\n\t\tif (data & ~PRED_CMD_IBPB)\n\t\t\treturn 1;\n\t\tif (!boot_cpu_has(X86_FEATURE_SPEC_CTRL))\n\t\t\treturn 1;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\twrmsrl(MSR_IA32_PRED_CMD, PRED_CMD_IBPB);\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_vmx_prepare_msr_bitmap. We should not touch the\n\t\t * vmcs02.msr_bitmap here since it gets completely overwritten\n\t\t * in the merging.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(vmx->vmcs01.msr_bitmap, MSR_IA32_PRED_CMD,\n\t\t\t\t\t      MSR_TYPE_W);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (!kvm_pat_valid(data))\n\t\t\treturn 1;\n\n\t\tif (is_guest_mode(vcpu) &&\n\t\t    get_vmcs12(vcpu)->vm_exit_controls & VM_EXIT_SAVE_IA32_PAT)\n\t\t\tget_vmcs12(vcpu)->guest_ia32_pat = data;\n\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif ((!msr_info->host_initiated &&\n\t\t     !(to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t       FEAT_CTL_LMCE_ENABLED)) ||\n\t\t    (data & ~MCG_EXT_CTL_LMCE_EN))\n\t\t\treturn 1;\n\t\tvcpu->arch.mcg_ext_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_FEAT_CTL:\n\t\tif (!vmx_feature_control_msr_valid(vcpu, data) ||\n\t\t    (to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t     FEAT_CTL_LOCKED && !msr_info->host_initiated))\n\t\t\treturn 1;\n\t\tvmx->msr_ia32_feature_control = data;\n\t\tif (msr_info->host_initiated && data == 0)\n\t\t\tvmx_leave_nested(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1; /* they are read-only */\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\treturn vmx_set_vmx_msr(vcpu, msr_index, data);\n\tcase MSR_IA32_RTIT_CTL:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\tvmx_rtit_ctl_check(vcpu, data) ||\n\t\t\tvmx->nested.vmxon)\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_IA32_RTIT_CTL, data);\n\t\tvmx->pt_desc.guest.ctl = data;\n\t\tpt_update_intercept_for_msr(vmx);\n\t\tbreak;\n\tcase MSR_IA32_RTIT_STATUS:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (data & MSR_IA32_RTIT_STATUS_MASK)\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.status = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CR3_MATCH:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_cr3_filtering))\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.cr3_match = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_topa_output) &&\n\t\t    !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_single_range_output))\n\t\t\treturn 1;\n\t\tif (data & MSR_IA32_RTIT_OUTPUT_BASE_MASK)\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.output_base = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_topa_output) &&\n\t\t    !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_single_range_output))\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.output_mask = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tindex = msr_info->index - MSR_IA32_RTIT_ADDR0_A;\n\t\tif (index >= 2 * intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\t       PT_CAP_num_address_ranges))\n\t\t\treturn 1;\n\t\tif (is_noncanonical_address(data, vcpu))\n\t\t\treturn 1;\n\t\tif (index % 2)\n\t\t\tvmx->pt_desc.guest.addr_b[index / 2] = data;\n\t\telse\n\t\t\tvmx->pt_desc.guest.addr_a[index / 2] = data;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\t\t/* Check reserved bit, higher 32 bits should be zero */\n\t\tif ((data >> 32) != 0)\n\t\t\treturn 1;\n\t\tgoto find_shared_msr;\n\n\tdefault:\n\tfind_shared_msr:\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr)\n\t\t\tret = vmx_set_guest_msr(vmx, msr, data);\n\t\telse\n\t\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define MSR_IA32_RTIT_OUTPUT_BASE_MASK \\\n\t(~((1UL << cpuid_query_maxphyaddr(vcpu)) - 1) | 0x7f)",
      "#define MSR_IA32_RTIT_STATUS_MASK (~(RTIT_STATUS_FILTEREN | \\\n\tRTIT_STATUS_CONTEXTEN | RTIT_STATUS_TRIGGEREN | \\\n\tRTIT_STATUS_ERROR | RTIT_STATUS_STOPPED | \\\n\tRTIT_STATUS_BYTECNT))"
    ],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "struct vmcs_config vmcs_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_msr_common",
          "args": [
            "vcpu",
            "msr_info"
          ],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msr_common",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "2730-3000",
          "snippet": "int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t\tbreak;\n\n\tcase MSR_IA32_UCODE_REV:\n\t\tif (msr_info->host_initiated)\n\t\t\tvcpu->arch.microcode_version = data;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.arch_capabilities = data;\n\t\tbreak;\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, msr_info);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\n\t\t/* Handle McStatusWrEn */\n\t\tif (data == BIT_ULL(18)) {\n\t\t\tvcpu->arch.msr_hwcr = data;\n\t\t} else if (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_TSC_ADJUST)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tif (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT) &&\n\t\t    ((vcpu->arch.ia32_misc_enable_msr ^ data) & MSR_IA32_MISC_ENABLE_MWAIT)) {\n\t\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_XMM3))\n\t\t\t\treturn 1;\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t\tkvm_update_cpuid(vcpu);\n\t\t} else {\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tvcpu->arch.msr_ia32_power_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\t/*\n\t\t * KVM supports exposing PT to the guest, but does not support\n\t\t * IA32_XSS[bit 8]. Guests have to use RDMSR/WRMSR rather than\n\t\t * XSAVES/XRSTORS to save/restore PT MSRs.\n\t\t */\n\t\tif (data & ~supported_xss)\n\t\t\treturn 1;\n\t\tvcpu->arch.ia32_xss = data;\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smi_count = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tvcpu->arch.pv_time_enabled = false;\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tif (!kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data, sizeof(u8)))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_KVM_POLL_CONTROL:\n\t\t/* only enable bit supported */\n\t\tif (data & (-1ULL << 1))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.msr_kvm_poll_control = data;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr_info);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tif (report_ignored_msrs)\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\tmsr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated ||\n\t\t    (!(data & MSR_PLATFORM_INFO_CPUID_FAULT) &&\n\t\t     cpuid_fault_enabled(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_platform_info = data;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tif (data & ~MSR_MISC_FEATURES_ENABLES_CPUID_FAULT ||\n\t\t    (data & MSR_MISC_FEATURES_ENABLES_CPUID_FAULT &&\n\t\t     !supports_cpuid_fault(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_misc_features_enables = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_debug_ratelimited(vcpu, \"unhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (report_ignored_msrs)\n\t\t\t\tvcpu_unimpl(vcpu,\n\t\t\t\t\t\"ignored wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\t\tmsr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t\tbreak;\n\n\tcase MSR_IA32_UCODE_REV:\n\t\tif (msr_info->host_initiated)\n\t\t\tvcpu->arch.microcode_version = data;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.arch_capabilities = data;\n\t\tbreak;\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, msr_info);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\n\t\t/* Handle McStatusWrEn */\n\t\tif (data == BIT_ULL(18)) {\n\t\t\tvcpu->arch.msr_hwcr = data;\n\t\t} else if (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_TSC_ADJUST)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tif (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT) &&\n\t\t    ((vcpu->arch.ia32_misc_enable_msr ^ data) & MSR_IA32_MISC_ENABLE_MWAIT)) {\n\t\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_XMM3))\n\t\t\t\treturn 1;\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t\tkvm_update_cpuid(vcpu);\n\t\t} else {\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tvcpu->arch.msr_ia32_power_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\t/*\n\t\t * KVM supports exposing PT to the guest, but does not support\n\t\t * IA32_XSS[bit 8]. Guests have to use RDMSR/WRMSR rather than\n\t\t * XSAVES/XRSTORS to save/restore PT MSRs.\n\t\t */\n\t\tif (data & ~supported_xss)\n\t\t\treturn 1;\n\t\tvcpu->arch.ia32_xss = data;\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smi_count = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tvcpu->arch.pv_time_enabled = false;\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tif (!kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data, sizeof(u8)))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_KVM_POLL_CONTROL:\n\t\t/* only enable bit supported */\n\t\tif (data & (-1ULL << 1))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.msr_kvm_poll_control = data;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr_info);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tif (report_ignored_msrs)\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\tmsr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated ||\n\t\t    (!(data & MSR_PLATFORM_INFO_CPUID_FAULT) &&\n\t\t     cpuid_fault_enabled(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_platform_info = data;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tif (data & ~MSR_MISC_FEATURES_ENABLES_CPUID_FAULT ||\n\t\t    (data & MSR_MISC_FEATURES_ENABLES_CPUID_FAULT &&\n\t\t     !supports_cpuid_fault(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_misc_features_enables = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_debug_ratelimited(vcpu, \"unhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (report_ignored_msrs)\n\t\t\t\tvcpu_unimpl(vcpu,\n\t\t\t\t\t\"ignored wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\t\tmsr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_set_guest_msr",
          "args": [
            "vmx",
            "msr",
            "data"
          ],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_guest_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "643-658",
          "snippet": "static int vmx_set_guest_msr(struct vcpu_vmx *vmx, struct shared_msr_entry *msr, u64 data)\n{\n\tint ret = 0;\n\n\tu64 old_msr_data = msr->data;\n\tmsr->data = data;\n\tif (msr - vmx->guest_msrs < vmx->save_nmsrs) {\n\t\tpreempt_disable();\n\t\tret = kvm_set_shared_msr(msr->index, msr->data,\n\t\t\t\t\t msr->mask);\n\t\tpreempt_enable();\n\t\tif (ret)\n\t\t\tmsr->data = old_msr_data;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int vmx_set_guest_msr(struct vcpu_vmx *vmx, struct shared_msr_entry *msr, u64 data)\n{\n\tint ret = 0;\n\n\tu64 old_msr_data = msr->data;\n\tmsr->data = data;\n\tif (msr - vmx->guest_msrs < vmx->save_nmsrs) {\n\t\tpreempt_disable();\n\t\tret = kvm_set_shared_msr(msr->index, msr->data,\n\t\t\t\t\t msr->mask);\n\t\tpreempt_enable();\n\t\tif (ret)\n\t\t\tmsr->data = old_msr_data;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_msr_entry",
          "args": [
            "vmx",
            "msr_index"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "find_msr_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "633-641",
          "snippet": "struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_RDTSCP"
          ],
          "line": 2170
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_noncanonical_address",
          "args": [
            "data",
            "vcpu"
          ],
          "line": 2161
        },
        "resolved": true,
        "details": {
          "function_name": "emul_is_noncanonical_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/emulate.c",
          "lines": "673-677",
          "snippet": "static inline bool emul_is_noncanonical_address(u64 la,\n\t\t\t\t\t\tstruct x86_emulate_ctxt *ctxt)\n{\n\treturn get_canonical(la, ctxt_virt_addr_bits(ctxt)) != la;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"mmu.h\"",
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/nospec-branch.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/fpu/api.h>",
            "#include <linux/stringify.h>",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"mmu.h\"\n#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/nospec-branch.h>\n#include <asm/debugreg.h>\n#include <asm/fpu/api.h>\n#include <linux/stringify.h>\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool emul_is_noncanonical_address(u64 la,\n\t\t\t\t\t\tstruct x86_emulate_ctxt *ctxt)\n{\n\treturn get_canonical(la, ctxt_virt_addr_bits(ctxt)) != la;\n}"
        }
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_num_address_ranges"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pt_can_write_msr",
          "args": [
            "vmx"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "pt_can_write_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1031-1035",
          "snippet": "static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)\n{\n\treturn vmx_pt_mode_is_host_guest() &&\n\t       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline bool pt_can_write_msr(struct vcpu_vmx *vmx)\n{\n\treturn vmx_pt_mode_is_host_guest() &&\n\t       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_single_range_output"
          ],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_topa_output"
          ],
          "line": 2147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_single_range_output"
          ],
          "line": 2137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_topa_output"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_cr3_filtering"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pt_update_intercept_for_msr",
          "args": [
            "vmx"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "pt_update_intercept_for_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3732-3752",
          "snippet": "void pt_update_intercept_for_msr(struct vcpu_vmx *vmx)\n{\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tbool flag = !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n\tu32 i;\n\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_STATUS,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_OUTPUT_BASE,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_OUTPUT_MASK,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_CR3_MATCH,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tfor (i = 0; i < vmx->pt_desc.addr_range; i++) {\n\t\tvmx_set_intercept_for_msr(msr_bitmap,\n\t\t\tMSR_IA32_RTIT_ADDR0_A + i * 2, MSR_TYPE_RW, flag);\n\t\tvmx_set_intercept_for_msr(msr_bitmap,\n\t\t\tMSR_IA32_RTIT_ADDR0_B + i * 2, MSR_TYPE_RW, flag);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid pt_update_intercept_for_msr(struct vcpu_vmx *vmx)\n{\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tbool flag = !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n\tu32 i;\n\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_STATUS,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_OUTPUT_BASE,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_OUTPUT_MASK,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tvmx_set_intercept_for_msr(msr_bitmap, MSR_IA32_RTIT_CR3_MATCH,\n\t\t\t\t\t\t\tMSR_TYPE_RW, flag);\n\tfor (i = 0; i < vmx->pt_desc.addr_range; i++) {\n\t\tvmx_set_intercept_for_msr(msr_bitmap,\n\t\t\tMSR_IA32_RTIT_ADDR0_A + i * 2, MSR_TYPE_RW, flag);\n\t\tvmx_set_intercept_for_msr(msr_bitmap,\n\t\t\tMSR_IA32_RTIT_ADDR0_B + i * 2, MSR_TYPE_RW, flag);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write64",
          "args": [
            "GUEST_IA32_RTIT_CTL",
            "data"
          ],
          "line": 2113
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "193-203",
          "snippet": "static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_rtit_ctl_check",
          "args": [
            "vcpu",
            "data"
          ],
          "line": 2110
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_rtit_ctl_check",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1476-1546",
          "snippet": "static int vmx_rtit_ctl_check(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long value;\n\n\t/*\n\t * Any MSR write that attempts to change bits marked reserved will\n\t * case a #GP fault.\n\t */\n\tif (data & vmx->pt_desc.ctl_bitmask)\n\t\treturn 1;\n\n\t/*\n\t * Any attempt to modify IA32_RTIT_CTL while TraceEn is set will\n\t * result in a #GP unless the same write also clears TraceEn.\n\t */\n\tif ((vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) &&\n\t\t((vmx->pt_desc.guest.ctl ^ data) & ~RTIT_CTL_TRACEEN))\n\t\treturn 1;\n\n\t/*\n\t * WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit\n\t * and FabricEn would cause #GP, if\n\t * CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 0\n\t */\n\tif ((data & RTIT_CTL_TRACEEN) && !(data & RTIT_CTL_TOPA) &&\n\t\t!(data & RTIT_CTL_FABRIC_EN) &&\n\t\t!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output))\n\t\treturn 1;\n\n\t/*\n\t * MTCFreq, CycThresh and PSBFreq encodings check, any MSR write that\n\t * utilize encodings marked reserved will casue a #GP fault.\n\t */\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc) &&\n\t\t\t!test_bit((data & RTIT_CTL_MTC_RANGE) >>\n\t\t\tRTIT_CTL_MTC_RANGE_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_cycle_thresholds);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_CYC_THRESH) >>\n\t\t\tRTIT_CTL_CYC_THRESH_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_PSB_FREQ) >>\n\t\t\tRTIT_CTL_PSB_FREQ_OFFSET, &value))\n\t\treturn 1;\n\n\t/*\n\t * If ADDRx_CFG is reserved or the encodings is >2 will\n\t * cause a #GP fault.\n\t */\n\tvalue = (data & RTIT_CTL_ADDR0) >> RTIT_CTL_ADDR0_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 1)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR1) >> RTIT_CTL_ADDR1_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 2)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR2) >> RTIT_CTL_ADDR2_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 3)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR3) >> RTIT_CTL_ADDR3_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 4)) || (value > 2))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_rtit_ctl_check(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long value;\n\n\t/*\n\t * Any MSR write that attempts to change bits marked reserved will\n\t * case a #GP fault.\n\t */\n\tif (data & vmx->pt_desc.ctl_bitmask)\n\t\treturn 1;\n\n\t/*\n\t * Any attempt to modify IA32_RTIT_CTL while TraceEn is set will\n\t * result in a #GP unless the same write also clears TraceEn.\n\t */\n\tif ((vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) &&\n\t\t((vmx->pt_desc.guest.ctl ^ data) & ~RTIT_CTL_TRACEEN))\n\t\treturn 1;\n\n\t/*\n\t * WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit\n\t * and FabricEn would cause #GP, if\n\t * CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 0\n\t */\n\tif ((data & RTIT_CTL_TRACEEN) && !(data & RTIT_CTL_TOPA) &&\n\t\t!(data & RTIT_CTL_FABRIC_EN) &&\n\t\t!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output))\n\t\treturn 1;\n\n\t/*\n\t * MTCFreq, CycThresh and PSBFreq encodings check, any MSR write that\n\t * utilize encodings marked reserved will casue a #GP fault.\n\t */\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc) &&\n\t\t\t!test_bit((data & RTIT_CTL_MTC_RANGE) >>\n\t\t\tRTIT_CTL_MTC_RANGE_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_cycle_thresholds);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_CYC_THRESH) >>\n\t\t\tRTIT_CTL_CYC_THRESH_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_PSB_FREQ) >>\n\t\t\tRTIT_CTL_PSB_FREQ_OFFSET, &value))\n\t\treturn 1;\n\n\t/*\n\t * If ADDRx_CFG is reserved or the encodings is >2 will\n\t * cause a #GP fault.\n\t */\n\tvalue = (data & RTIT_CTL_ADDR0) >> RTIT_CTL_ADDR0_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 1)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR1) >> RTIT_CTL_ADDR1_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 2)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR2) >> RTIT_CTL_ADDR2_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 3)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR3) >> RTIT_CTL_ADDR3_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 4)) || (value > 2))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_pt_mode_is_host_guest",
          "args": [],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_pt_mode_is_host_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "365-368",
          "snippet": "static inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [
            "#define PT_MODE_HOST_GUEST\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\n#define PT_MODE_HOST_GUEST\t1\n\nstatic inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_set_vmx_msr",
          "args": [
            "vcpu",
            "msr_index",
            "data"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_vmx_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "1310-1372",
          "snippet": "int vmx_set_vmx_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Don't allow changes to the VMX capability MSRs while the vCPU\n\t * is in VMX operation.\n\t */\n\tif (vmx->nested.vmxon)\n\t\treturn -EBUSY;\n\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\treturn vmx_restore_vmx_basic(vmx, data);\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t/*\n\t\t * The \"non-true\" VMX capability MSRs are generated from the\n\t\t * \"true\" MSRs, so we do not support restoring them directly.\n\t\t *\n\t\t * If userspace wants to emulate VMX_BASIC[55]=0, userspace\n\t\t * should restore the \"true\" MSRs with the must-be-1 bits\n\t\t * set according to the SDM Vol 3. A.2 \"RESERVED CONTROLS AND\n\t\t * DEFAULT SETTINGS\".\n\t\t */\n\t\treturn -EINVAL;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\treturn vmx_restore_control_msr(vmx, msr_index, data);\n\tcase MSR_IA32_VMX_MISC:\n\t\treturn vmx_restore_vmx_misc(vmx, data);\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\treturn vmx_restore_fixed0_msr(vmx, msr_index, data);\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t/*\n\t\t * These MSRs are generated based on the vCPU's CPUID, so we\n\t\t * do not support restoring them directly.\n\t\t */\n\t\treturn -EINVAL;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\treturn vmx_restore_vmx_ept_vpid_cap(vmx, data);\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\tvmx->nested.msrs.vmcs_enum = data;\n\t\treturn 0;\n\tcase MSR_IA32_VMX_VMFUNC:\n\t\tif (data & ~vmx->nested.msrs.vmfunc_controls)\n\t\t\treturn -EINVAL;\n\t\tvmx->nested.msrs.vmfunc_controls = data;\n\t\treturn 0;\n\tdefault:\n\t\t/*\n\t\t * The rest of the VMX capability MSRs do not support restore.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nint vmx_set_vmx_msr(struct kvm_vcpu *vcpu, u32 msr_index, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * Don't allow changes to the VMX capability MSRs while the vCPU\n\t * is in VMX operation.\n\t */\n\tif (vmx->nested.vmxon)\n\t\treturn -EBUSY;\n\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\treturn vmx_restore_vmx_basic(vmx, data);\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t/*\n\t\t * The \"non-true\" VMX capability MSRs are generated from the\n\t\t * \"true\" MSRs, so we do not support restoring them directly.\n\t\t *\n\t\t * If userspace wants to emulate VMX_BASIC[55]=0, userspace\n\t\t * should restore the \"true\" MSRs with the must-be-1 bits\n\t\t * set according to the SDM Vol 3. A.2 \"RESERVED CONTROLS AND\n\t\t * DEFAULT SETTINGS\".\n\t\t */\n\t\treturn -EINVAL;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\treturn vmx_restore_control_msr(vmx, msr_index, data);\n\tcase MSR_IA32_VMX_MISC:\n\t\treturn vmx_restore_vmx_misc(vmx, data);\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\treturn vmx_restore_fixed0_msr(vmx, msr_index, data);\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t/*\n\t\t * These MSRs are generated based on the vCPU's CPUID, so we\n\t\t * do not support restoring them directly.\n\t\t */\n\t\treturn -EINVAL;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\treturn vmx_restore_vmx_ept_vpid_cap(vmx, data);\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\tvmx->nested.msrs.vmcs_enum = data;\n\t\treturn 0;\n\tcase MSR_IA32_VMX_VMFUNC:\n\t\tif (data & ~vmx->nested.msrs.vmfunc_controls)\n\t\t\treturn -EINVAL;\n\t\tvmx->nested.msrs.vmfunc_controls = data;\n\t\treturn 0;\n\tdefault:\n\t\t/*\n\t\t * The rest of the VMX capability MSRs do not support restore.\n\t\t */\n\t\treturn -EINVAL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_allowed",
          "args": [
            "vcpu"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_allowed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1755-1758",
          "snippet": "bool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nbool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_leave_nested",
          "args": [
            "vcpu"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_leave_nested",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "5814-5821",
          "snippet": "void vmx_leave_nested(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tto_vmx(vcpu)->nested.nested_run_pending = 0;\n\t\tnested_vmx_vmexit(vcpu, -1, 0, 0);\n\t}\n\tfree_nested(vcpu);\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nvoid vmx_leave_nested(struct kvm_vcpu *vcpu)\n{\n\tif (is_guest_mode(vcpu)) {\n\t\tto_vmx(vcpu)->nested.nested_run_pending = 0;\n\t\tnested_vmx_vmexit(vcpu, -1, 0, 0);\n\t}\n\tfree_nested(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_feature_control_msr_valid",
          "args": [
            "vcpu",
            "data"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_feature_control_msr_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1760-1766",
          "snippet": "static inline bool vmx_feature_control_msr_valid(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t uint64_t val)\n{\n\tuint64_t valid_bits = to_vmx(vcpu)->msr_ia32_feature_control_valid_bits;\n\n\treturn !(val & ~valid_bits);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic inline bool vmx_feature_control_msr_valid(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t uint64_t val)\n{\n\tuint64_t valid_bits = to_vmx(vcpu)->msr_ia32_feature_control_valid_bits;\n\n\treturn !(val & ~valid_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_pat_valid",
          "args": [
            "data"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pat_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "344-350",
          "snippet": "static inline bool kvm_pat_valid(u64 data)\n{\n\tif (data & 0xF8F8F8F8F8F8F8F8ull)\n\t\treturn false;\n\t/* 0, 1, 4, 5, 6, 7 are valid values.  */\n\treturn (data | ((data & 0x0202020202020202ull) << 1)) == data;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_pat_valid(u64 data)\n{\n\tif (data & 0xF8F8F8F8F8F8F8F8ull)\n\t\treturn false;\n\t/* 0, 1, 4, 5, 6, 7 are valid values.  */\n\treturn (data | ((data & 0x0202020202020202ull) << 1)) == data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_disable_intercept_for_msr",
          "args": [
            "vmx->vmcs01.msr_bitmap",
            "MSR_IA32_PRED_CMD",
            "MSR_TYPE_W"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_disable_intercept_for_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3591-3627",
          "snippet": "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type);\n\nstatic __always_inline void vmx_disable_intercept_for_msr(unsigned long *msr_bitmap,\n\t\t\t\t\t\t\t  u32 msr, int type)\n{\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn;\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\tevmcs_touch_msr_bitmap();\n\n\t/*\n\t * See Intel PRM Vol. 3, 20.6.9 (MSR-Bitmap Address). Early manuals\n\t * have the write-low and read-high bitmap offsets the wrong way round.\n\t * We can control MSRs 0x00000000-0x00001fff and 0xc0000000-0xc0001fff.\n\t */\n\tif (msr <= 0x1fff) {\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x000 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-low */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x800 / f);\n\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\tif (type & MSR_TYPE_R)\n\t\t\t/* read-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0x400 / f);\n\n\t\tif (type & MSR_TYPE_W)\n\t\t\t/* write-high */\n\t\t\t__clear_bit(msr, msr_bitmap + 0xc00 / f);\n\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_PRED_CMD",
            "PRED_CMD_IBPB"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_SPEC_CTRL"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_spec_ctrl_valid_bits",
          "args": [
            "vcpu"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_spec_ctrl_valid_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10540-10560",
          "snippet": "u64 kvm_spec_ctrl_valid_bits(struct kvm_vcpu *vcpu)\n{\n\tuint64_t bits = SPEC_CTRL_IBRS | SPEC_CTRL_STIBP | SPEC_CTRL_SSBD;\n\n\t/* The STIBP bit doesn't fault even if it's not advertised */\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) &&\n\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBRS))\n\t\tbits &= ~(SPEC_CTRL_IBRS | SPEC_CTRL_STIBP);\n\tif (!boot_cpu_has(X86_FEATURE_SPEC_CTRL) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_IBRS))\n\t\tbits &= ~(SPEC_CTRL_IBRS | SPEC_CTRL_STIBP);\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL_SSBD) &&\n\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_SSBD))\n\t\tbits &= ~SPEC_CTRL_SSBD;\n\tif (!boot_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tbits &= ~SPEC_CTRL_SSBD;\n\n\treturn bits;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nu64 kvm_spec_ctrl_valid_bits(struct kvm_vcpu *vcpu)\n{\n\tuint64_t bits = SPEC_CTRL_IBRS | SPEC_CTRL_STIBP | SPEC_CTRL_SSBD;\n\n\t/* The STIBP bit doesn't fault even if it's not advertised */\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) &&\n\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBRS))\n\t\tbits &= ~(SPEC_CTRL_IBRS | SPEC_CTRL_STIBP);\n\tif (!boot_cpu_has(X86_FEATURE_SPEC_CTRL) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_IBRS))\n\t\tbits &= ~(SPEC_CTRL_IBRS | SPEC_CTRL_STIBP);\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL_SSBD) &&\n\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_SSBD))\n\t\tbits &= ~SPEC_CTRL_SSBD;\n\tif (!boot_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tbits &= ~SPEC_CTRL_SSBD;\n\n\treturn bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GENMASK_ULL",
          "args": [
            "63",
            "32"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT_ULL",
          "args": [
            "1"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_has_waitpkg",
          "args": [
            "vmx"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_has_waitpkg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "527-531",
          "snippet": "static inline bool vmx_has_waitpkg(struct vcpu_vmx *vmx)\n{\n\treturn vmx->secondary_exec_control &\n\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool vmx_has_waitpkg(struct vcpu_vmx *vmx)\n{\n\treturn vmx->secondary_exec_control &\n\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mpx_supported",
          "args": [],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mpx_supported",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "277-281",
          "snippet": "static inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "GUEST_SYSENTER_ESP",
            "data"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "GUEST_SYSENTER_CS",
            "data"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_write_guest_kernel_gs_base",
          "args": [
            "vmx",
            "data"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_write_guest_kernel_gs_base",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1243-1250",
          "snippet": "static void vmx_write_guest_kernel_gs_base(struct vcpu_vmx *vmx, u64 data)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, data);\n\tpreempt_enable();\n\tvmx->msr_guest_kernel_gs_base = data;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_write_guest_kernel_gs_base(struct vcpu_vmx *vmx, u64 data)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, data);\n\tpreempt_enable();\n\tvmx->msr_guest_kernel_gs_base = data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_segment_cache_clear",
          "args": [
            "vmx"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_cache_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "444-447",
          "snippet": "static inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void vmx_segment_cache_clear(struct vcpu_vmx *vmx)\n{\n\tvmx->segment_cache.bitmask = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define MSR_IA32_RTIT_OUTPUT_BASE_MASK \\\n\t(~((1UL << cpuid_query_maxphyaddr(vcpu)) - 1) | 0x7f)\n#define MSR_IA32_RTIT_STATUS_MASK (~(RTIT_STATUS_FILTEREN | \\\n\tRTIT_STATUS_CONTEXTEN | RTIT_STATUS_TRIGGEREN | \\\n\tRTIT_STATUS_ERROR | RTIT_STATUS_STOPPED | \\\n\tRTIT_STATUS_BYTECNT))\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstruct vmcs_config vmcs_config;\n\nstatic int vmx_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr;\n\tint ret = 0;\n\tu32 msr_index = msr_info->index;\n\tu64 data = msr_info->data;\n\tu32 index;\n\n\tswitch (msr_index) {\n\tcase MSR_EFER:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_FS_BASE, data);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tvmx_segment_cache_clear(vmx);\n\t\tvmcs_writel(GUEST_GS_BASE, data);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tvmx_write_guest_kernel_gs_base(vmx, data);\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tif (is_guest_mode(vcpu))\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_cs = data;\n\t\tvmcs_write32(GUEST_SYSENTER_CS, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tif (is_guest_mode(vcpu))\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_eip = data;\n\t\tvmcs_writel(GUEST_SYSENTER_EIP, data);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tif (is_guest_mode(vcpu))\n\t\t\tget_vmcs12(vcpu)->guest_sysenter_esp = data;\n\t\tvmcs_writel(GUEST_SYSENTER_ESP, data);\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (is_guest_mode(vcpu) && get_vmcs12(vcpu)->vm_exit_controls &\n\t\t\t\t\t\tVM_EXIT_SAVE_DEBUG_CONTROLS)\n\t\t\tget_vmcs12(vcpu)->guest_ia32_debugctl = data;\n\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported() ||\n\t\t    (!msr_info->host_initiated &&\n\t\t     !guest_cpuid_has(vcpu, X86_FEATURE_MPX)))\n\t\t\treturn 1;\n\t\tif (is_noncanonical_address(data & PAGE_MASK, vcpu) ||\n\t\t    (data & MSR_IA32_BNDCFGS_RSVD))\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_BNDCFGS, data);\n\t\tbreak;\n\tcase MSR_IA32_UMWAIT_CONTROL:\n\t\tif (!msr_info->host_initiated && !vmx_has_waitpkg(vmx))\n\t\t\treturn 1;\n\n\t\t/* The reserved bit 1 and non-32 bit [63:32] should be zero */\n\t\tif (data & (BIT_ULL(1) | GENMASK_ULL(63, 32)))\n\t\t\treturn 1;\n\n\t\tvmx->msr_ia32_umwait_control = data;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL))\n\t\t\treturn 1;\n\n\t\tif (data & ~kvm_spec_ctrl_valid_bits(vcpu))\n\t\t\treturn 1;\n\n\t\tvmx->spec_ctrl = data;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_vmx_prepare_msr_bitmap. We should not touch the\n\t\t * vmcs02.msr_bitmap here since it gets completely overwritten\n\t\t * in the merging. We update the vmcs01 here for L1 as well\n\t\t * since it will end up touching the MSR anyway now.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(vmx->vmcs01.msr_bitmap,\n\t\t\t\t\t      MSR_IA32_SPEC_CTRL,\n\t\t\t\t\t      MSR_TYPE_RW);\n\t\tbreak;\n\tcase MSR_IA32_TSX_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vcpu->arch.arch_capabilities & ARCH_CAP_TSX_CTRL_MSR))\n\t\t\treturn 1;\n\t\tif (data & ~(TSX_CTRL_RTM_DISABLE | TSX_CTRL_CPUID_CLEAR))\n\t\t\treturn 1;\n\t\tgoto find_shared_msr;\n\tcase MSR_IA32_PRED_CMD:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL))\n\t\t\treturn 1;\n\n\t\tif (data & ~PRED_CMD_IBPB)\n\t\t\treturn 1;\n\t\tif (!boot_cpu_has(X86_FEATURE_SPEC_CTRL))\n\t\t\treturn 1;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\twrmsrl(MSR_IA32_PRED_CMD, PRED_CMD_IBPB);\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_vmx_prepare_msr_bitmap. We should not touch the\n\t\t * vmcs02.msr_bitmap here since it gets completely overwritten\n\t\t * in the merging.\n\t\t */\n\t\tvmx_disable_intercept_for_msr(vmx->vmcs01.msr_bitmap, MSR_IA32_PRED_CMD,\n\t\t\t\t\t      MSR_TYPE_W);\n\t\tbreak;\n\tcase MSR_IA32_CR_PAT:\n\t\tif (!kvm_pat_valid(data))\n\t\t\treturn 1;\n\n\t\tif (is_guest_mode(vcpu) &&\n\t\t    get_vmcs12(vcpu)->vm_exit_controls & VM_EXIT_SAVE_IA32_PAT)\n\t\t\tget_vmcs12(vcpu)->guest_ia32_pat = data;\n\n\t\tif (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PAT) {\n\t\t\tvmcs_write64(GUEST_IA32_PAT, data);\n\t\t\tvcpu->arch.pat = data;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif ((!msr_info->host_initiated &&\n\t\t     !(to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t       FEAT_CTL_LMCE_ENABLED)) ||\n\t\t    (data & ~MCG_EXT_CTL_LMCE_EN))\n\t\t\treturn 1;\n\t\tvcpu->arch.mcg_ext_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_FEAT_CTL:\n\t\tif (!vmx_feature_control_msr_valid(vcpu, data) ||\n\t\t    (to_vmx(vcpu)->msr_ia32_feature_control &\n\t\t     FEAT_CTL_LOCKED && !msr_info->host_initiated))\n\t\t\treturn 1;\n\t\tvmx->msr_ia32_feature_control = data;\n\t\tif (msr_info->host_initiated && data == 0)\n\t\t\tvmx_leave_nested(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1; /* they are read-only */\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\treturn vmx_set_vmx_msr(vcpu, msr_index, data);\n\tcase MSR_IA32_RTIT_CTL:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\tvmx_rtit_ctl_check(vcpu, data) ||\n\t\t\tvmx->nested.vmxon)\n\t\t\treturn 1;\n\t\tvmcs_write64(GUEST_IA32_RTIT_CTL, data);\n\t\tvmx->pt_desc.guest.ctl = data;\n\t\tpt_update_intercept_for_msr(vmx);\n\t\tbreak;\n\tcase MSR_IA32_RTIT_STATUS:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (data & MSR_IA32_RTIT_STATUS_MASK)\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.status = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CR3_MATCH:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_cr3_filtering))\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.cr3_match = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_topa_output) &&\n\t\t    !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_single_range_output))\n\t\t\treturn 1;\n\t\tif (data & MSR_IA32_RTIT_OUTPUT_BASE_MASK)\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.output_base = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tif (!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_topa_output) &&\n\t\t    !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t   PT_CAP_single_range_output))\n\t\t\treturn 1;\n\t\tvmx->pt_desc.guest.output_mask = data;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\tif (!pt_can_write_msr(vmx))\n\t\t\treturn 1;\n\t\tindex = msr_info->index - MSR_IA32_RTIT_ADDR0_A;\n\t\tif (index >= 2 * intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\t       PT_CAP_num_address_ranges))\n\t\t\treturn 1;\n\t\tif (is_noncanonical_address(data, vcpu))\n\t\t\treturn 1;\n\t\tif (index % 2)\n\t\t\tvmx->pt_desc.guest.addr_b[index / 2] = data;\n\t\telse\n\t\t\tvmx->pt_desc.guest.addr_a[index / 2] = data;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\t\t/* Check reserved bit, higher 32 bits should be zero */\n\t\tif ((data >> 32) != 0)\n\t\t\treturn 1;\n\t\tgoto find_shared_msr;\n\n\tdefault:\n\tfind_shared_msr:\n\t\tmsr = find_msr_entry(vmx, msr_index);\n\t\tif (msr)\n\t\t\tret = vmx_set_guest_msr(vmx, msr, data);\n\t\telse\n\t\t\tret = kvm_set_msr_common(vcpu, msr_info);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vmx_get_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1785-1928",
    "snippet": "static int vmx_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr;\n\tu32 index;\n\n\tswitch (msr_info->index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_FS_BASE);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_GS_BASE);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = vmx_read_guest_kernel_gs_base(vmx);\n\t\tbreak;\n#endif\n\tcase MSR_EFER:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\tcase MSR_IA32_TSX_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vcpu->arch.arch_capabilities & ARCH_CAP_TSX_CTRL_MSR))\n\t\t\treturn 1;\n\t\tgoto find_shared_msr;\n\tcase MSR_IA32_UMWAIT_CONTROL:\n\t\tif (!msr_info->host_initiated && !vmx_has_waitpkg(vmx))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vmx->msr_ia32_umwait_control;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = to_vmx(vcpu)->spec_ctrl;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = vmcs_read32(GUEST_SYSENTER_CS);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_EIP);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_ESP);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported() ||\n\t\t    (!msr_info->host_initiated &&\n\t\t     !guest_cpuid_has(vcpu, X86_FEATURE_MPX)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmcs_read64(GUEST_BNDCFGS);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vmx->msr_ia32_feature_control &\n\t\t      FEAT_CTL_LMCE_ENABLED))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.mcg_ext_ctl;\n\t\tbreak;\n\tcase MSR_IA32_FEAT_CTL:\n\t\tmsr_info->data = vmx->msr_ia32_feature_control;\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\tif (vmx_get_vmx_msr(&vmx->nested.msrs, msr_info->index,\n\t\t\t\t    &msr_info->data))\n\t\t\treturn 1;\n\t\t/*\n\t\t * Enlightened VMCS v1 doesn't have certain fields, but buggy\n\t\t * Hyper-V versions are still trying to use corresponding\n\t\t * features when they are exposed. Filter out the essential\n\t\t * minimum.\n\t\t */\n\t\tif (!msr_info->host_initiated &&\n\t\t    vmx->nested.enlightened_vmcs_enabled)\n\t\t\tnested_evmcs_filter_control_msr(msr_info->index,\n\t\t\t\t\t\t\t&msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CTL:\n\t\tif (!vmx_pt_mode_is_host_guest())\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.ctl;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_STATUS:\n\t\tif (!vmx_pt_mode_is_host_guest())\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.status;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CR3_MATCH:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_cr3_filtering))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.cr3_match;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t(!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_topa_output) &&\n\t\t\t !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.output_base;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t(!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_topa_output) &&\n\t\t\t !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.output_mask;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\tindex = msr_info->index - MSR_IA32_RTIT_ADDR0_A;\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t(index >= 2 * intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_num_address_ranges)))\n\t\t\treturn 1;\n\t\tif (index % 2)\n\t\t\tmsr_info->data = vmx->pt_desc.guest.addr_b[index / 2];\n\t\telse\n\t\t\tmsr_info->data = vmx->pt_desc.guest.addr_a[index / 2];\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\t\tgoto find_shared_msr;\n\tdefault:\n\tfind_shared_msr:\n\t\tmsr = find_msr_entry(vmx, msr_info->index);\n\t\tif (msr) {\n\t\t\tmsr_info->data = msr->data;\n\t\t\tbreak;\n\t\t}\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_msr_common",
          "args": [
            "vcpu",
            "msr_info"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_msr_common",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "3041-3246",
          "snippet": "int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_IA32_PERF_CTL:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = vcpu->arch.microcode_version;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.arch_capabilities;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tmsr_info->data = vcpu->arch.msr_ia32_power_ctl;\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tmsr_info->data = kvm_scale_tsc(vcpu, rdtsc()) + vcpu->arch.tsc_offset;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tmsr_info->data = vcpu->arch.smi_count;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_POLL_CONTROL:\n\t\tmsr_info->data = vcpu->arch.msr_kvm_poll_control;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data,\n\t\t\t\t   msr_info->host_initiated);\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.ia32_xss;\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !vcpu->kvm->arch.guest_can_read_msr_platform_info)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.msr_platform_info;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tmsr_info->data = vcpu->arch.msr_misc_features_enables;\n\t\tbreak;\n\tcase MSR_K7_HWCR:\n\t\tmsr_info->data = vcpu->arch.msr_hwcr;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_debug_ratelimited(vcpu, \"unhandled rdmsr: 0x%x\\n\",\n\t\t\t\t\t       msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (report_ignored_msrs)\n\t\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\",\n\t\t\t\t\tmsr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_IA32_PERF_CTL:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = vcpu->arch.microcode_version;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.arch_capabilities;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tmsr_info->data = vcpu->arch.msr_ia32_power_ctl;\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tmsr_info->data = kvm_scale_tsc(vcpu, rdtsc()) + vcpu->arch.tsc_offset;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tmsr_info->data = vcpu->arch.smi_count;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_POLL_CONTROL:\n\t\tmsr_info->data = vcpu->arch.msr_kvm_poll_control;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data,\n\t\t\t\t   msr_info->host_initiated);\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.ia32_xss;\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !vcpu->kvm->arch.guest_can_read_msr_platform_info)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.msr_platform_info;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tmsr_info->data = vcpu->arch.msr_misc_features_enables;\n\t\tbreak;\n\tcase MSR_K7_HWCR:\n\t\tmsr_info->data = vcpu->arch.msr_hwcr;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_debug_ratelimited(vcpu, \"unhandled rdmsr: 0x%x\\n\",\n\t\t\t\t\t       msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (report_ignored_msrs)\n\t\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\",\n\t\t\t\t\tmsr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_msr_entry",
          "args": [
            "vmx",
            "msr_info->index"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "find_msr_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "633-641",
          "snippet": "struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_RDTSCP"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_num_address_ranges"
          ],
          "line": 1904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_pt_mode_is_host_guest",
          "args": [],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_pt_mode_is_host_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "365-368",
          "snippet": "static inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [
            "#define PT_MODE_HOST_GUEST\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\n#define PT_MODE_HOST_GUEST\t1\n\nstatic inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_single_range_output"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_topa_output"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_single_range_output"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_topa_output"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_cr3_filtering"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_evmcs_filter_control_msr",
          "args": [
            "msr_info->index",
            "&msr_info->data"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "nested_evmcs_filter_control_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.c",
          "lines": "350-374",
          "snippet": "void nested_evmcs_filter_control_msr(u32 msr_index, u64 *pdata)\n{\n\tu32 ctl_low = (u32)*pdata;\n\tu32 ctl_high = (u32)(*pdata >> 32);\n\n\t/*\n\t * Hyper-V 2016 and 2019 try using these features even when eVMCS\n\t * is enabled but there are no corresponding fields.\n\t */\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\t\tctl_high &= ~VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\tbreak;\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\t\tctl_high &= ~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\tctl_high &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\tbreak;\n\t}\n\n\t*pdata = ctl_low | ((u64)ctl_high << 32);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include \"../hyperv.h\"",
            "#include <linux/smp.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vmx.h\"\n#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include \"../hyperv.h\"\n#include <linux/smp.h>\n#include <linux/errno.h>\n\nvoid nested_evmcs_filter_control_msr(u32 msr_index, u64 *pdata)\n{\n\tu32 ctl_low = (u32)*pdata;\n\tu32 ctl_high = (u32)(*pdata >> 32);\n\n\t/*\n\t * Hyper-V 2016 and 2019 try using these features even when eVMCS\n\t * is enabled but there are no corresponding fields.\n\t */\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\t\tctl_high &= ~VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\tbreak;\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\t\tctl_high &= ~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\tctl_high &= ~SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;\n\t\tbreak;\n\t}\n\n\t*pdata = ctl_low | ((u64)ctl_high << 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_get_vmx_msr",
          "args": [
            "&vmx->nested.msrs",
            "msr_info->index",
            "&msr_info->data"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_vmx_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "1375-1450",
          "snippet": "int vmx_get_vmx_msr(struct nested_vmx_msrs *msrs, u32 msr_index, u64 *pdata)\n{\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\t*pdata = msrs->basic;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->pinbased_ctls_low,\n\t\t\tmsrs->pinbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PINBASED_CTLS)\n\t\t\t*pdata |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->procbased_ctls_low,\n\t\t\tmsrs->procbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PROCBASED_CTLS)\n\t\t\t*pdata |= CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->exit_ctls_low,\n\t\t\tmsrs->exit_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_EXIT_CTLS)\n\t\t\t*pdata |= VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->entry_ctls_low,\n\t\t\tmsrs->entry_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_ENTRY_CTLS)\n\t\t\t*pdata |= VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_MISC:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->misc_low,\n\t\t\tmsrs->misc_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\t\t*pdata = msrs->cr0_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\t\t*pdata = msrs->cr0_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\t*pdata = msrs->cr4_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t*pdata = msrs->cr4_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\t*pdata = msrs->vmcs_enum;\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->secondary_ctls_low,\n\t\t\tmsrs->secondary_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\t*pdata = msrs->ept_caps |\n\t\t\t((u64)msrs->vpid_caps << 32);\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMFUNC:\n\t\t*pdata = msrs->vmfunc_controls;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nint vmx_get_vmx_msr(struct nested_vmx_msrs *msrs, u32 msr_index, u64 *pdata)\n{\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\t*pdata = msrs->basic;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->pinbased_ctls_low,\n\t\t\tmsrs->pinbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PINBASED_CTLS)\n\t\t\t*pdata |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->procbased_ctls_low,\n\t\t\tmsrs->procbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PROCBASED_CTLS)\n\t\t\t*pdata |= CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->exit_ctls_low,\n\t\t\tmsrs->exit_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_EXIT_CTLS)\n\t\t\t*pdata |= VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->entry_ctls_low,\n\t\t\tmsrs->entry_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_ENTRY_CTLS)\n\t\t\t*pdata |= VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_MISC:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->misc_low,\n\t\t\tmsrs->misc_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\t\t*pdata = msrs->cr0_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\t\t*pdata = msrs->cr0_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\t*pdata = msrs->cr4_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t*pdata = msrs->cr4_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\t*pdata = msrs->vmcs_enum;\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->secondary_ctls_low,\n\t\t\tmsrs->secondary_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\t*pdata = msrs->ept_caps |\n\t\t\t((u64)msrs->vpid_caps << 32);\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMFUNC:\n\t\t*pdata = msrs->vmfunc_controls;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_vmx_allowed",
          "args": [
            "vcpu"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_allowed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1755-1758",
          "snippet": "bool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nbool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read64",
          "args": [
            "GUEST_BNDCFGS"
          ],
          "line": 1837
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "120-130",
          "snippet": "static __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mpx_supported",
          "args": [],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mpx_supported",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "277-281",
          "snippet": "static inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_mpx_supported(void)\n{\n\treturn (supported_xcr0 & (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR))\n\t\t== (XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_SYSENTER_ESP"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_SYSENTER_CS"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_has_waitpkg",
          "args": [
            "vmx"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_has_waitpkg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "527-531",
          "snippet": "static inline bool vmx_has_waitpkg(struct vcpu_vmx *vmx)\n{\n\treturn vmx->secondary_exec_control &\n\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool vmx_has_waitpkg(struct vcpu_vmx *vmx)\n{\n\treturn vmx->secondary_exec_control &\n\t\tSECONDARY_EXEC_ENABLE_USR_WAIT_PAUSE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_read_guest_kernel_gs_base",
          "args": [
            "vmx"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_guest_kernel_gs_base",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1234-1241",
          "snippet": "static u64 vmx_read_guest_kernel_gs_base(struct vcpu_vmx *vmx)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\tpreempt_enable();\n\treturn vmx->msr_guest_kernel_gs_base;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic u64 vmx_read_guest_kernel_gs_base(struct vcpu_vmx *vmx)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\tpreempt_enable();\n\treturn vmx->msr_guest_kernel_gs_base;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct shared_msr_entry *msr;\n\tu32 index;\n\n\tswitch (msr_info->index) {\n#ifdef CONFIG_X86_64\n\tcase MSR_FS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_FS_BASE);\n\t\tbreak;\n\tcase MSR_GS_BASE:\n\t\tmsr_info->data = vmcs_readl(GUEST_GS_BASE);\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = vmx_read_guest_kernel_gs_base(vmx);\n\t\tbreak;\n#endif\n\tcase MSR_EFER:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\tcase MSR_IA32_TSX_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vcpu->arch.arch_capabilities & ARCH_CAP_TSX_CTRL_MSR))\n\t\t\treturn 1;\n\t\tgoto find_shared_msr;\n\tcase MSR_IA32_UMWAIT_CONTROL:\n\t\tif (!msr_info->host_initiated && !vmx_has_waitpkg(vmx))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = vmx->msr_ia32_umwait_control;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = to_vmx(vcpu)->spec_ctrl;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = vmcs_read32(GUEST_SYSENTER_CS);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_EIP);\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = vmcs_readl(GUEST_SYSENTER_ESP);\n\t\tbreak;\n\tcase MSR_IA32_BNDCFGS:\n\t\tif (!kvm_mpx_supported() ||\n\t\t    (!msr_info->host_initiated &&\n\t\t     !guest_cpuid_has(vcpu, X86_FEATURE_MPX)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmcs_read64(GUEST_BNDCFGS);\n\t\tbreak;\n\tcase MSR_IA32_MCG_EXT_CTL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !(vmx->msr_ia32_feature_control &\n\t\t      FEAT_CTL_LMCE_ENABLED))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.mcg_ext_ctl;\n\t\tbreak;\n\tcase MSR_IA32_FEAT_CTL:\n\t\tmsr_info->data = vmx->msr_ia32_feature_control;\n\t\tbreak;\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested_vmx_allowed(vcpu))\n\t\t\treturn 1;\n\t\tif (vmx_get_vmx_msr(&vmx->nested.msrs, msr_info->index,\n\t\t\t\t    &msr_info->data))\n\t\t\treturn 1;\n\t\t/*\n\t\t * Enlightened VMCS v1 doesn't have certain fields, but buggy\n\t\t * Hyper-V versions are still trying to use corresponding\n\t\t * features when they are exposed. Filter out the essential\n\t\t * minimum.\n\t\t */\n\t\tif (!msr_info->host_initiated &&\n\t\t    vmx->nested.enlightened_vmcs_enabled)\n\t\t\tnested_evmcs_filter_control_msr(msr_info->index,\n\t\t\t\t\t\t\t&msr_info->data);\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CTL:\n\t\tif (!vmx_pt_mode_is_host_guest())\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.ctl;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_STATUS:\n\t\tif (!vmx_pt_mode_is_host_guest())\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.status;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_CR3_MATCH:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_cr3_filtering))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.cr3_match;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_BASE:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t(!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_topa_output) &&\n\t\t\t !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.output_base;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_OUTPUT_MASK:\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t(!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_topa_output) &&\n\t\t\t !intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output)))\n\t\t\treturn 1;\n\t\tmsr_info->data = vmx->pt_desc.guest.output_mask;\n\t\tbreak;\n\tcase MSR_IA32_RTIT_ADDR0_A ... MSR_IA32_RTIT_ADDR3_B:\n\t\tindex = msr_info->index - MSR_IA32_RTIT_ADDR0_A;\n\t\tif (!vmx_pt_mode_is_host_guest() ||\n\t\t\t(index >= 2 * intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_num_address_ranges)))\n\t\t\treturn 1;\n\t\tif (index % 2)\n\t\t\tmsr_info->data = vmx->pt_desc.guest.addr_b[index / 2];\n\t\telse\n\t\t\tmsr_info->data = vmx->pt_desc.guest.addr_a[index / 2];\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\t\tgoto find_shared_msr;\n\tdefault:\n\tfind_shared_msr:\n\t\tmsr = find_msr_entry(vmx, msr_info->index);\n\t\tif (msr) {\n\t\t\tmsr_info->data = msr->data;\n\t\t\tbreak;\n\t\t}\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_get_msr_feature",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1768-1778",
    "snippet": "static int vmx_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested)\n\t\t\treturn 1;\n\t\treturn vmx_get_vmx_msr(&vmcs_config.nested, msr->index, &msr->data);\n\tdefault:\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "struct vmcs_config vmcs_config;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_get_vmx_msr",
          "args": [
            "&vmcs_config.nested",
            "msr->index",
            "&msr->data"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_vmx_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "1375-1450",
          "snippet": "int vmx_get_vmx_msr(struct nested_vmx_msrs *msrs, u32 msr_index, u64 *pdata)\n{\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\t*pdata = msrs->basic;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->pinbased_ctls_low,\n\t\t\tmsrs->pinbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PINBASED_CTLS)\n\t\t\t*pdata |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->procbased_ctls_low,\n\t\t\tmsrs->procbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PROCBASED_CTLS)\n\t\t\t*pdata |= CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->exit_ctls_low,\n\t\t\tmsrs->exit_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_EXIT_CTLS)\n\t\t\t*pdata |= VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->entry_ctls_low,\n\t\t\tmsrs->entry_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_ENTRY_CTLS)\n\t\t\t*pdata |= VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_MISC:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->misc_low,\n\t\t\tmsrs->misc_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\t\t*pdata = msrs->cr0_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\t\t*pdata = msrs->cr0_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\t*pdata = msrs->cr4_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t*pdata = msrs->cr4_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\t*pdata = msrs->vmcs_enum;\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->secondary_ctls_low,\n\t\t\tmsrs->secondary_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\t*pdata = msrs->ept_caps |\n\t\t\t((u64)msrs->vpid_caps << 32);\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMFUNC:\n\t\t*pdata = msrs->vmfunc_controls;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nint vmx_get_vmx_msr(struct nested_vmx_msrs *msrs, u32 msr_index, u64 *pdata)\n{\n\tswitch (msr_index) {\n\tcase MSR_IA32_VMX_BASIC:\n\t\t*pdata = msrs->basic;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PINBASED_CTLS:\n\tcase MSR_IA32_VMX_PINBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->pinbased_ctls_low,\n\t\t\tmsrs->pinbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PINBASED_CTLS)\n\t\t\t*pdata |= PIN_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_PROCBASED_CTLS:\n\tcase MSR_IA32_VMX_PROCBASED_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->procbased_ctls_low,\n\t\t\tmsrs->procbased_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_PROCBASED_CTLS)\n\t\t\t*pdata |= CPU_BASED_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_EXIT_CTLS:\n\tcase MSR_IA32_VMX_EXIT_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->exit_ctls_low,\n\t\t\tmsrs->exit_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_EXIT_CTLS)\n\t\t\t*pdata |= VM_EXIT_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_TRUE_ENTRY_CTLS:\n\tcase MSR_IA32_VMX_ENTRY_CTLS:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->entry_ctls_low,\n\t\t\tmsrs->entry_ctls_high);\n\t\tif (msr_index == MSR_IA32_VMX_ENTRY_CTLS)\n\t\t\t*pdata |= VM_ENTRY_ALWAYSON_WITHOUT_TRUE_MSR;\n\t\tbreak;\n\tcase MSR_IA32_VMX_MISC:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->misc_low,\n\t\t\tmsrs->misc_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED0:\n\t\t*pdata = msrs->cr0_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR0_FIXED1:\n\t\t*pdata = msrs->cr0_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED0:\n\t\t*pdata = msrs->cr4_fixed0;\n\t\tbreak;\n\tcase MSR_IA32_VMX_CR4_FIXED1:\n\t\t*pdata = msrs->cr4_fixed1;\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMCS_ENUM:\n\t\t*pdata = msrs->vmcs_enum;\n\t\tbreak;\n\tcase MSR_IA32_VMX_PROCBASED_CTLS2:\n\t\t*pdata = vmx_control_msr(\n\t\t\tmsrs->secondary_ctls_low,\n\t\t\tmsrs->secondary_ctls_high);\n\t\tbreak;\n\tcase MSR_IA32_VMX_EPT_VPID_CAP:\n\t\t*pdata = msrs->ept_caps |\n\t\t\t((u64)msrs->vpid_caps << 32);\n\t\tbreak;\n\tcase MSR_IA32_VMX_VMFUNC:\n\t\t*pdata = msrs->vmfunc_controls;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstruct vmcs_config vmcs_config;\n\nstatic int vmx_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tswitch (msr->index) {\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\tif (!nested)\n\t\t\treturn 1;\n\t\treturn vmx_get_vmx_msr(&vmcs_config.nested, msr->index, &msr->data);\n\tdefault:\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "vmx_feature_control_msr_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1760-1766",
    "snippet": "static inline bool vmx_feature_control_msr_valid(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t uint64_t val)\n{\n\tuint64_t valid_bits = to_vmx(vcpu)->msr_ia32_feature_control_valid_bits;\n\n\treturn !(val & ~valid_bits);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1763
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic inline bool vmx_feature_control_msr_valid(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t uint64_t val)\n{\n\tuint64_t valid_bits = to_vmx(vcpu)->msr_ia32_feature_control_valid_bits;\n\n\treturn !(val & ~valid_bits);\n}"
  },
  {
    "function_name": "nested_vmx_allowed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1755-1758",
    "snippet": "bool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_VMX"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nbool nested_vmx_allowed(struct kvm_vcpu *vcpu)\n{\n\treturn nested && guest_cpuid_has(vcpu, X86_FEATURE_VMX);\n}"
  },
  {
    "function_name": "vmx_write_l1_tsc_offset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1727-1747",
    "snippet": "static u64 vmx_write_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu64 g_tsc_offset = 0;\n\n\t/*\n\t * We're here if L1 chose not to trap WRMSR to TSC. According\n\t * to the spec, this should set L1's TSC; The offset that L1\n\t * set for L2 remains unchanged, and still needs to be added\n\t * to the newly set TSC to get L2's TSC.\n\t */\n\tif (is_guest_mode(vcpu) &&\n\t    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING))\n\t\tg_tsc_offset = vmcs12->tsc_offset;\n\n\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t   vcpu->arch.tsc_offset - g_tsc_offset,\n\t\t\t\t   offset);\n\tvmcs_write64(TSC_OFFSET, offset + g_tsc_offset);\n\treturn offset + g_tsc_offset;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write64",
          "args": [
            "TSC_OFFSET",
            "offset + g_tsc_offset"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "193-203",
          "snippet": "static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_write_tsc_offset",
          "args": [
            "vcpu->vcpu_id",
            "vcpu->arch.tsc_offset - g_tsc_offset",
            "offset"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic u64 vmx_write_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tu64 g_tsc_offset = 0;\n\n\t/*\n\t * We're here if L1 chose not to trap WRMSR to TSC. According\n\t * to the spec, this should set L1's TSC; The offset that L1\n\t * set for L2 remains unchanged, and still needs to be added\n\t * to the newly set TSC to get L2's TSC.\n\t */\n\tif (is_guest_mode(vcpu) &&\n\t    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING))\n\t\tg_tsc_offset = vmcs12->tsc_offset;\n\n\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t   vcpu->arch.tsc_offset - g_tsc_offset,\n\t\t\t\t   offset);\n\tvmcs_write64(TSC_OFFSET, offset + g_tsc_offset);\n\treturn offset + g_tsc_offset;\n}"
  },
  {
    "function_name": "vmx_read_l1_tsc_offset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1716-1725",
    "snippet": "static u64 vmx_read_l1_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING))\n\t\treturn vcpu->arch.tsc_offset - vmcs12->tsc_offset;\n\n\treturn vcpu->arch.tsc_offset;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 1720
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic u64 vmx_read_l1_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING))\n\t\treturn vcpu->arch.tsc_offset - vmcs12->tsc_offset;\n\n\treturn vcpu->arch.tsc_offset;\n}"
  },
  {
    "function_name": "setup_msrs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1677-1714",
    "snippet": "static void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\t/*\n\t * The SYSCALL MSRs are only needed on long mode guests, and only\n\t * when EFER.SCE is set.\n\t */\n\tif (is_long_mode(&vmx->vcpu) && (vmx->vcpu.arch.efer & EFER_SCE)) {\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\tif (index >= 0 && guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_IA32_TSX_CTRL);\n\tif (index >= 0)\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\n\tvmx->save_nmsrs = save_nmsrs;\n\tvmx->guest_msrs_ready = false;\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_update_msr_bitmap(&vmx->vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_update_msr_bitmap",
          "args": [
            "&vmx->vcpu"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_update_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3716-3730",
          "snippet": "void vmx_update_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tu8 mode = vmx_msr_bitmap_mode(vcpu);\n\tu8 changed = mode ^ vmx->msr_bitmap_mode;\n\n\tif (!changed)\n\t\treturn;\n\n\tif (changed & (MSR_BITMAP_MODE_X2APIC | MSR_BITMAP_MODE_X2APIC_APICV))\n\t\tvmx_update_msr_bitmap_x2apic(msr_bitmap, mode);\n\n\tvmx->msr_bitmap_mode = mode;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define MSR_BITMAP_MODE_X2APIC_APICV\t2",
            "#define MSR_BITMAP_MODE_X2APIC\t\t1"
          ],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define MSR_BITMAP_MODE_X2APIC_APICV\t2\n#define MSR_BITMAP_MODE_X2APIC\t\t1\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_update_msr_bitmap(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long *msr_bitmap = vmx->vmcs01.msr_bitmap;\n\tu8 mode = vmx_msr_bitmap_mode(vcpu);\n\tu8 changed = mode ^ vmx->msr_bitmap_mode;\n\n\tif (!changed)\n\t\treturn;\n\n\tif (changed & (MSR_BITMAP_MODE_X2APIC | MSR_BITMAP_MODE_X2APIC_APICV))\n\t\tvmx_update_msr_bitmap_x2apic(msr_bitmap, mode);\n\n\tvmx->msr_bitmap_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_msr_bitmap",
          "args": [],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "120-123",
          "snippet": "static inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "move_msr_up",
          "args": [
            "vmx",
            "index",
            "save_nmsrs++"
          ],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "move_msr_up",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1663-1670",
          "snippet": "static void move_msr_up(struct vcpu_vmx *vmx, int from, int to)\n{\n\tstruct shared_msr_entry tmp;\n\n\ttmp = vmx->guest_msrs[to];\n\tvmx->guest_msrs[to] = vmx->guest_msrs[from];\n\tvmx->guest_msrs[from] = tmp;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void move_msr_up(struct vcpu_vmx *vmx, int from, int to)\n{\n\tstruct shared_msr_entry tmp;\n\n\ttmp = vmx->guest_msrs[to];\n\tvmx->guest_msrs[to] = vmx->guest_msrs[from];\n\tvmx->guest_msrs[from] = tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__find_msr_index",
          "args": [
            "vmx",
            "MSR_IA32_TSX_CTRL"
          ],
          "line": 1705
        },
        "resolved": true,
        "details": {
          "function_name": "__find_msr_index",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "623-631",
          "snippet": "static inline int __find_msr_index(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < vmx->nmsrs; ++i)\n\t\tif (vmx_msr_index[vmx->guest_msrs[i].index] == msr)\n\t\t\treturn i;\n\treturn -1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline int __find_msr_index(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < vmx->nmsrs; ++i)\n\t\tif (vmx_msr_index[vmx->guest_msrs[i].index] == msr)\n\t\t\treturn i;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "&vmx->vcpu",
            "X86_FEATURE_RDTSCP"
          ],
          "line": 1703
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_transition_efer",
          "args": [
            "vmx",
            "index"
          ],
          "line": 1700
        },
        "resolved": true,
        "details": {
          "function_name": "update_transition_efer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "954-1000",
          "snippet": "static bool update_transition_efer(struct vcpu_vmx *vmx, int efer_offset)\n{\n\tu64 guest_efer = vmx->vcpu.arch.efer;\n\tu64 ignore_bits = 0;\n\n\t/* Shadow paging assumes NX to be available.  */\n\tif (!enable_ept)\n\t\tguest_efer |= EFER_NX;\n\n\t/*\n\t * LMA and LME handled by hardware; SCE meaningless outside long mode.\n\t */\n\tignore_bits |= EFER_SCE;\n#ifdef CONFIG_X86_64\n\tignore_bits |= EFER_LMA | EFER_LME;\n\t/* SCE is meaningful only in long mode on Intel */\n\tif (guest_efer & EFER_LMA)\n\t\tignore_bits &= ~(u64)EFER_SCE;\n#endif\n\n\t/*\n\t * On EPT, we can't emulate NX, so we must switch EFER atomically.\n\t * On CPUs that support \"load IA32_EFER\", always switch EFER\n\t * atomically, since it's faster than switching it manually.\n\t */\n\tif (cpu_has_load_ia32_efer() ||\n\t    (enable_ept && ((vmx->vcpu.arch.efer ^ host_efer) & EFER_NX))) {\n\t\tif (!(guest_efer & EFER_LMA))\n\t\t\tguest_efer &= ~EFER_LME;\n\t\tif (guest_efer != host_efer)\n\t\t\tadd_atomic_switch_msr(vmx, MSR_EFER,\n\t\t\t\t\t      guest_efer, host_efer, false);\n\t\telse\n\t\t\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\t\treturn false;\n\t} else {\n\t\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\n\t\tguest_efer &= ~ignore_bits;\n\t\tguest_efer |= host_efer & ignore_bits;\n\n\t\tvmx->guest_msrs[efer_offset].data = guest_efer;\n\t\tvmx->guest_msrs[efer_offset].mask = ~ignore_bits;\n\n\t\treturn true;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool update_transition_efer(struct vcpu_vmx *vmx, int efer_offset)\n{\n\tu64 guest_efer = vmx->vcpu.arch.efer;\n\tu64 ignore_bits = 0;\n\n\t/* Shadow paging assumes NX to be available.  */\n\tif (!enable_ept)\n\t\tguest_efer |= EFER_NX;\n\n\t/*\n\t * LMA and LME handled by hardware; SCE meaningless outside long mode.\n\t */\n\tignore_bits |= EFER_SCE;\n#ifdef CONFIG_X86_64\n\tignore_bits |= EFER_LMA | EFER_LME;\n\t/* SCE is meaningful only in long mode on Intel */\n\tif (guest_efer & EFER_LMA)\n\t\tignore_bits &= ~(u64)EFER_SCE;\n#endif\n\n\t/*\n\t * On EPT, we can't emulate NX, so we must switch EFER atomically.\n\t * On CPUs that support \"load IA32_EFER\", always switch EFER\n\t * atomically, since it's faster than switching it manually.\n\t */\n\tif (cpu_has_load_ia32_efer() ||\n\t    (enable_ept && ((vmx->vcpu.arch.efer ^ host_efer) & EFER_NX))) {\n\t\tif (!(guest_efer & EFER_LMA))\n\t\t\tguest_efer &= ~EFER_LME;\n\t\tif (guest_efer != host_efer)\n\t\t\tadd_atomic_switch_msr(vmx, MSR_EFER,\n\t\t\t\t\t      guest_efer, host_efer, false);\n\t\telse\n\t\t\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\t\treturn false;\n\t} else {\n\t\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\n\t\tguest_efer &= ~ignore_bits;\n\t\tguest_efer |= host_efer & ignore_bits;\n\n\t\tvmx->guest_msrs[efer_offset].data = guest_efer;\n\t\tvmx->guest_msrs[efer_offset].mask = ~ignore_bits;\n\n\t\treturn true;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "&vmx->vcpu"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "85-92",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void setup_msrs(struct vcpu_vmx *vmx)\n{\n\tint save_nmsrs, index;\n\n\tsave_nmsrs = 0;\n#ifdef CONFIG_X86_64\n\t/*\n\t * The SYSCALL MSRs are only needed on long mode guests, and only\n\t * when EFER.SCE is set.\n\t */\n\tif (is_long_mode(&vmx->vcpu) && (vmx->vcpu.arch.efer & EFER_SCE)) {\n\t\tindex = __find_msr_index(vmx, MSR_STAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_LSTAR);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t\tindex = __find_msr_index(vmx, MSR_SYSCALL_MASK);\n\t\tif (index >= 0)\n\t\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\t}\n#endif\n\tindex = __find_msr_index(vmx, MSR_EFER);\n\tif (index >= 0 && update_transition_efer(vmx, index))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_TSC_AUX);\n\tif (index >= 0 && guest_cpuid_has(&vmx->vcpu, X86_FEATURE_RDTSCP))\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\tindex = __find_msr_index(vmx, MSR_IA32_TSX_CTRL);\n\tif (index >= 0)\n\t\tmove_msr_up(vmx, index, save_nmsrs++);\n\n\tvmx->save_nmsrs = save_nmsrs;\n\tvmx->guest_msrs_ready = false;\n\n\tif (cpu_has_vmx_msr_bitmap())\n\t\tvmx_update_msr_bitmap(&vmx->vcpu);\n}"
  },
  {
    "function_name": "move_msr_up",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1663-1670",
    "snippet": "static void move_msr_up(struct vcpu_vmx *vmx, int from, int to)\n{\n\tstruct shared_msr_entry tmp;\n\n\ttmp = vmx->guest_msrs[to];\n\tvmx->guest_msrs[to] = vmx->guest_msrs[from];\n\tvmx->guest_msrs[from] = tmp;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void move_msr_up(struct vcpu_vmx *vmx, int from, int to)\n{\n\tstruct shared_msr_entry tmp;\n\n\ttmp = vmx->guest_msrs[to];\n\tvmx->guest_msrs[to] = vmx->guest_msrs[from];\n\tvmx->guest_msrs[from] = tmp;\n}"
  },
  {
    "function_name": "vmx_queue_exception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1623-1658",
    "snippet": "static void vmx_queue_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_error_code = vcpu->arch.exception.has_error_code;\n\tu32 error_code = vcpu->arch.exception.error_code;\n\tu32 intr_info = nr | INTR_INFO_VALID_MASK;\n\n\tkvm_deliver_exception_payload(vcpu);\n\n\tif (has_error_code) {\n\t\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE, error_code);\n\t\tintr_info |= INTR_INFO_DELIVER_CODE_MASK;\n\t}\n\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (kvm_exception_is_soft(nr))\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tkvm_inject_realmode_interrupt(vcpu, nr, inc_eip);\n\t\treturn;\n\t}\n\n\tWARN_ON_ONCE(vmx->emulation_required);\n\n\tif (kvm_exception_is_soft(nr)) {\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t\tintr_info |= INTR_TYPE_SOFT_EXCEPTION;\n\t} else\n\t\tintr_info |= INTR_TYPE_HARD_EXCEPTION;\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr_info);\n\n\tvmx_clear_hlt(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_clear_hlt",
          "args": [
            "vcpu"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_clear_hlt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1610-1621",
          "snippet": "static void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "VM_ENTRY_INTR_INFO_FIELD",
            "intr_info"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_exception_is_soft",
          "args": [
            "nr"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_exception_is_soft",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "75-78",
          "snippet": "static inline bool kvm_exception_is_soft(unsigned int nr)\n{\n\treturn (nr == BP_VECTOR) || (nr == OF_VECTOR);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_exception_is_soft(unsigned int nr)\n{\n\treturn (nr == BP_VECTOR) || (nr == OF_VECTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "vmx->emulation_required"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_inject_realmode_interrupt",
          "args": [
            "vcpu",
            "nr",
            "inc_eip"
          ],
          "line": 1642
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_inject_realmode_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6435-6454",
          "snippet": "void kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t} else {\n\t\tctxt->eip = ctxt->_eip;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tkvm_set_rflags(vcpu, ctxt->eflags);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_inject_realmode_interrupt(struct kvm_vcpu *vcpu, int irq, int inc_eip)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tctxt->op_bytes = 2;\n\tctxt->ad_bytes = 2;\n\tctxt->_eip = ctxt->eip + inc_eip;\n\tret = emulate_int_real(ctxt, irq);\n\n\tif (ret != X86EMUL_CONTINUE) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t} else {\n\t\tctxt->eip = ctxt->_eip;\n\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\tkvm_set_rflags(vcpu, ctxt->eflags);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_deliver_exception_payload",
          "args": [
            "vcpu"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_deliver_exception_payload",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "437-484",
          "snippet": "void kvm_deliver_exception_payload(struct kvm_vcpu *vcpu)\n{\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_payload = vcpu->arch.exception.has_payload;\n\tunsigned long payload = vcpu->arch.exception.payload;\n\n\tif (!has_payload)\n\t\treturn;\n\n\tswitch (nr) {\n\tcase DB_VECTOR:\n\t\t/*\n\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t * remaining contents of the DR6 register are never\n\t\t * cleared by the processor\".\n\t\t */\n\t\tvcpu->arch.dr6 &= ~DR_TRAP_BITS;\n\t\t/*\n\t\t * DR6.RTM is set by all #DB exceptions that don't clear it.\n\t\t */\n\t\tvcpu->arch.dr6 |= DR6_RTM;\n\t\tvcpu->arch.dr6 |= payload;\n\t\t/*\n\t\t * Bit 16 should be set in the payload whenever the #DB\n\t\t * exception should clear DR6.RTM. This makes the payload\n\t\t * compatible with the pending debug exceptions under VMX.\n\t\t * Though not currently documented in the SDM, this also\n\t\t * makes the payload compatible with the exit qualification\n\t\t * for #DB exceptions under VMX.\n\t\t */\n\t\tvcpu->arch.dr6 ^= payload & DR6_RTM;\n\n\t\t/*\n\t\t * The #DB payload is defined as compatible with the 'pending\n\t\t * debug exceptions' field under VMX, not DR6. While bit 12 is\n\t\t * defined in the 'pending debug exceptions' field (enabled\n\t\t * breakpoint), it is reserved and must be zero in DR6.\n\t\t */\n\t\tvcpu->arch.dr6 &= ~BIT(12);\n\t\tbreak;\n\tcase PF_VECTOR:\n\t\tvcpu->arch.cr2 = payload;\n\t\tbreak;\n\t}\n\n\tvcpu->arch.exception.has_payload = false;\n\tvcpu->arch.exception.payload = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_deliver_exception_payload(struct kvm_vcpu *vcpu)\n{\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_payload = vcpu->arch.exception.has_payload;\n\tunsigned long payload = vcpu->arch.exception.payload;\n\n\tif (!has_payload)\n\t\treturn;\n\n\tswitch (nr) {\n\tcase DB_VECTOR:\n\t\t/*\n\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t * remaining contents of the DR6 register are never\n\t\t * cleared by the processor\".\n\t\t */\n\t\tvcpu->arch.dr6 &= ~DR_TRAP_BITS;\n\t\t/*\n\t\t * DR6.RTM is set by all #DB exceptions that don't clear it.\n\t\t */\n\t\tvcpu->arch.dr6 |= DR6_RTM;\n\t\tvcpu->arch.dr6 |= payload;\n\t\t/*\n\t\t * Bit 16 should be set in the payload whenever the #DB\n\t\t * exception should clear DR6.RTM. This makes the payload\n\t\t * compatible with the pending debug exceptions under VMX.\n\t\t * Though not currently documented in the SDM, this also\n\t\t * makes the payload compatible with the exit qualification\n\t\t * for #DB exceptions under VMX.\n\t\t */\n\t\tvcpu->arch.dr6 ^= payload & DR6_RTM;\n\n\t\t/*\n\t\t * The #DB payload is defined as compatible with the 'pending\n\t\t * debug exceptions' field under VMX, not DR6. While bit 12 is\n\t\t * defined in the 'pending debug exceptions' field (enabled\n\t\t * breakpoint), it is reserved and must be zero in DR6.\n\t\t */\n\t\tvcpu->arch.dr6 &= ~BIT(12);\n\t\tbreak;\n\tcase PF_VECTOR:\n\t\tvcpu->arch.cr2 = payload;\n\t\tbreak;\n\t}\n\n\tvcpu->arch.exception.has_payload = false;\n\tvcpu->arch.exception.payload = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_queue_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_error_code = vcpu->arch.exception.has_error_code;\n\tu32 error_code = vcpu->arch.exception.error_code;\n\tu32 intr_info = nr | INTR_INFO_VALID_MASK;\n\n\tkvm_deliver_exception_payload(vcpu);\n\n\tif (has_error_code) {\n\t\tvmcs_write32(VM_ENTRY_EXCEPTION_ERROR_CODE, error_code);\n\t\tintr_info |= INTR_INFO_DELIVER_CODE_MASK;\n\t}\n\n\tif (vmx->rmode.vm86_active) {\n\t\tint inc_eip = 0;\n\t\tif (kvm_exception_is_soft(nr))\n\t\t\tinc_eip = vcpu->arch.event_exit_inst_len;\n\t\tkvm_inject_realmode_interrupt(vcpu, nr, inc_eip);\n\t\treturn;\n\t}\n\n\tWARN_ON_ONCE(vmx->emulation_required);\n\n\tif (kvm_exception_is_soft(nr)) {\n\t\tvmcs_write32(VM_ENTRY_INSTRUCTION_LEN,\n\t\t\t     vmx->vcpu.arch.event_exit_inst_len);\n\t\tintr_info |= INTR_TYPE_SOFT_EXCEPTION;\n\t} else\n\t\tintr_info |= INTR_TYPE_HARD_EXCEPTION;\n\n\tvmcs_write32(VM_ENTRY_INTR_INFO_FIELD, intr_info);\n\n\tvmx_clear_hlt(vcpu);\n}"
  },
  {
    "function_name": "vmx_clear_hlt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1610-1621",
    "snippet": "static void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "GUEST_ACTIVITY_STATE",
            "GUEST_ACTIVITY_ACTIVE"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_ACTIVITY_STATE"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hlt_in_guest",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hlt_in_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "316-319",
          "snippet": "static inline bool kvm_hlt_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.hlt_in_guest;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_hlt_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.hlt_in_guest;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_clear_hlt(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Ensure that we clear the HLT state in the VMCS.  We don't need to\n\t * explicitly skip the instruction because if the HLT state is set,\n\t * then the instruction is already executing and RIP has already been\n\t * advanced.\n\t */\n\tif (kvm_hlt_in_guest(vcpu->kvm) &&\n\t\t\tvmcs_read32(GUEST_ACTIVITY_STATE) == GUEST_ACTIVITY_HLT)\n\t\tvmcs_write32(GUEST_ACTIVITY_STATE, GUEST_ACTIVITY_ACTIVE);\n}"
  },
  {
    "function_name": "vmx_skip_emulated_instruction",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1604-1608",
    "snippet": "static int vmx_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tvmx_update_emulated_instruction(vcpu);\n\treturn skip_emulated_instruction(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1604-1608",
          "snippet": "static int vmx_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tvmx_update_emulated_instruction(vcpu);\n\treturn skip_emulated_instruction(vcpu);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "vmx_update_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_update_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1581-1602",
          "snippet": "static void vmx_update_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!is_guest_mode(vcpu))\n\t\treturn;\n\n\t/*\n\t * Per the SDM, MTF takes priority over debug-trap exceptions besides\n\t * T-bit traps. As instruction emulation is completed (i.e. at the\n\t * instruction boundary), any #DB exception pending delivery must be a\n\t * debug-trap. Record the pending MTF state to be delivered in\n\t * vmx_check_nested_events().\n\t */\n\tif (nested_cpu_has_mtf(vmcs12) &&\n\t    (!vcpu->arch.exception.pending ||\n\t     vcpu->arch.exception.nr == DB_VECTOR))\n\t\tvmx->nested.mtf_pending = true;\n\telse\n\t\tvmx->nested.mtf_pending = false;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_update_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!is_guest_mode(vcpu))\n\t\treturn;\n\n\t/*\n\t * Per the SDM, MTF takes priority over debug-trap exceptions besides\n\t * T-bit traps. As instruction emulation is completed (i.e. at the\n\t * instruction boundary), any #DB exception pending delivery must be a\n\t * debug-trap. Record the pending MTF state to be delivered in\n\t * vmx_check_nested_events().\n\t */\n\tif (nested_cpu_has_mtf(vmcs12) &&\n\t    (!vcpu->arch.exception.pending ||\n\t     vcpu->arch.exception.nr == DB_VECTOR))\n\t\tvmx->nested.mtf_pending = true;\n\telse\n\t\tvmx->nested.mtf_pending = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tvmx_update_emulated_instruction(vcpu);\n\treturn skip_emulated_instruction(vcpu);\n}"
  },
  {
    "function_name": "vmx_update_emulated_instruction",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1581-1602",
    "snippet": "static void vmx_update_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!is_guest_mode(vcpu))\n\t\treturn;\n\n\t/*\n\t * Per the SDM, MTF takes priority over debug-trap exceptions besides\n\t * T-bit traps. As instruction emulation is completed (i.e. at the\n\t * instruction boundary), any #DB exception pending delivery must be a\n\t * debug-trap. Record the pending MTF state to be delivered in\n\t * vmx_check_nested_events().\n\t */\n\tif (nested_cpu_has_mtf(vmcs12) &&\n\t    (!vcpu->arch.exception.pending ||\n\t     vcpu->arch.exception.nr == DB_VECTOR))\n\t\tvmx->nested.mtf_pending = true;\n\telse\n\t\tvmx->nested.mtf_pending = false;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has_mtf",
          "args": [
            "vmcs12"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has_mtf",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "181-184",
          "snippet": "static inline int nested_cpu_has_mtf(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_TRAP_FLAG);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline int nested_cpu_has_mtf(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_TRAP_FLAG);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_update_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (!is_guest_mode(vcpu))\n\t\treturn;\n\n\t/*\n\t * Per the SDM, MTF takes priority over debug-trap exceptions besides\n\t * T-bit traps. As instruction emulation is completed (i.e. at the\n\t * instruction boundary), any #DB exception pending delivery must be a\n\t * debug-trap. Record the pending MTF state to be delivered in\n\t * vmx_check_nested_events().\n\t */\n\tif (nested_cpu_has_mtf(vmcs12) &&\n\t    (!vcpu->arch.exception.pending ||\n\t     vcpu->arch.exception.nr == DB_VECTOR))\n\t\tvmx->nested.mtf_pending = true;\n\telse\n\t\tvmx->nested.mtf_pending = false;\n}"
  },
  {
    "function_name": "skip_emulated_instruction",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1548-1574",
    "snippet": "static int skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\t/*\n\t * Using VMCS.VM_EXIT_INSTRUCTION_LEN on EPT misconfig depends on\n\t * undefined behavior: Intel's SDM doesn't mandate the VMCS field be\n\t * set when EPT misconfig occurs.  In practice, real hardware updates\n\t * VM_EXIT_INSTRUCTION_LEN on EPT misconfig, but other hypervisors\n\t * (namely Hyper-V) don't set it due to it being undefined behavior,\n\t * i.e. we end up advancing IP with some random value.\n\t */\n\tif (!static_cpu_has(X86_FEATURE_HYPERVISOR) ||\n\t    to_vmx(vcpu)->exit_reason != EXIT_REASON_EPT_MISCONFIG) {\n\t\trip = kvm_rip_read(vcpu);\n\t\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_rip_write(vcpu, rip);\n\t} else {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t}\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_set_interrupt_shadow",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_interrupt_shadow",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1460-1474",
          "snippet": "void vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "vcpu",
            "EMULTYPE_SKIP"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "vcpu",
            "rip"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "91-94",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "VM_EXIT_INSTRUCTION_LEN"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "86-89",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_HYPERVISOR"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rip;\n\n\t/*\n\t * Using VMCS.VM_EXIT_INSTRUCTION_LEN on EPT misconfig depends on\n\t * undefined behavior: Intel's SDM doesn't mandate the VMCS field be\n\t * set when EPT misconfig occurs.  In practice, real hardware updates\n\t * VM_EXIT_INSTRUCTION_LEN on EPT misconfig, but other hypervisors\n\t * (namely Hyper-V) don't set it due to it being undefined behavior,\n\t * i.e. we end up advancing IP with some random value.\n\t */\n\tif (!static_cpu_has(X86_FEATURE_HYPERVISOR) ||\n\t    to_vmx(vcpu)->exit_reason != EXIT_REASON_EPT_MISCONFIG) {\n\t\trip = kvm_rip_read(vcpu);\n\t\trip += vmcs_read32(VM_EXIT_INSTRUCTION_LEN);\n\t\tkvm_rip_write(vcpu, rip);\n\t} else {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t}\n\n\t/* skipping an emulated instruction also counts */\n\tvmx_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "vmx_rtit_ctl_check",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1476-1546",
    "snippet": "static int vmx_rtit_ctl_check(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long value;\n\n\t/*\n\t * Any MSR write that attempts to change bits marked reserved will\n\t * case a #GP fault.\n\t */\n\tif (data & vmx->pt_desc.ctl_bitmask)\n\t\treturn 1;\n\n\t/*\n\t * Any attempt to modify IA32_RTIT_CTL while TraceEn is set will\n\t * result in a #GP unless the same write also clears TraceEn.\n\t */\n\tif ((vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) &&\n\t\t((vmx->pt_desc.guest.ctl ^ data) & ~RTIT_CTL_TRACEEN))\n\t\treturn 1;\n\n\t/*\n\t * WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit\n\t * and FabricEn would cause #GP, if\n\t * CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 0\n\t */\n\tif ((data & RTIT_CTL_TRACEEN) && !(data & RTIT_CTL_TOPA) &&\n\t\t!(data & RTIT_CTL_FABRIC_EN) &&\n\t\t!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output))\n\t\treturn 1;\n\n\t/*\n\t * MTCFreq, CycThresh and PSBFreq encodings check, any MSR write that\n\t * utilize encodings marked reserved will casue a #GP fault.\n\t */\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc) &&\n\t\t\t!test_bit((data & RTIT_CTL_MTC_RANGE) >>\n\t\t\tRTIT_CTL_MTC_RANGE_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_cycle_thresholds);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_CYC_THRESH) >>\n\t\t\tRTIT_CTL_CYC_THRESH_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_PSB_FREQ) >>\n\t\t\tRTIT_CTL_PSB_FREQ_OFFSET, &value))\n\t\treturn 1;\n\n\t/*\n\t * If ADDRx_CFG is reserved or the encodings is >2 will\n\t * cause a #GP fault.\n\t */\n\tvalue = (data & RTIT_CTL_ADDR0) >> RTIT_CTL_ADDR0_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 1)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR1) >> RTIT_CTL_ADDR1_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 2)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR2) >> RTIT_CTL_ADDR2_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 3)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR3) >> RTIT_CTL_ADDR3_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 4)) || (value > 2))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "(data & RTIT_CTL_PSB_FREQ) >>\n\t\t\tRTIT_CTL_PSB_FREQ_OFFSET",
            "&value"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_psb_cyc"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_psb_periods"
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "(data & RTIT_CTL_CYC_THRESH) >>\n\t\t\tRTIT_CTL_CYC_THRESH_OFFSET",
            "&value"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_psb_cyc"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_cycle_thresholds"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "(data & RTIT_CTL_MTC_RANGE) >>\n\t\t\tRTIT_CTL_MTC_RANGE_OFFSET",
            "&value"
          ],
          "line": 1513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_mtc"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_mtc_periods"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "intel_pt_validate_cap",
          "args": [
            "vmx->pt_desc.caps",
            "PT_CAP_single_range_output"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int vmx_rtit_ctl_check(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long value;\n\n\t/*\n\t * Any MSR write that attempts to change bits marked reserved will\n\t * case a #GP fault.\n\t */\n\tif (data & vmx->pt_desc.ctl_bitmask)\n\t\treturn 1;\n\n\t/*\n\t * Any attempt to modify IA32_RTIT_CTL while TraceEn is set will\n\t * result in a #GP unless the same write also clears TraceEn.\n\t */\n\tif ((vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) &&\n\t\t((vmx->pt_desc.guest.ctl ^ data) & ~RTIT_CTL_TRACEEN))\n\t\treturn 1;\n\n\t/*\n\t * WRMSR to IA32_RTIT_CTL that sets TraceEn but clears this bit\n\t * and FabricEn would cause #GP, if\n\t * CPUID.(EAX=14H, ECX=0):ECX.SNGLRGNOUT[bit 2] = 0\n\t */\n\tif ((data & RTIT_CTL_TRACEEN) && !(data & RTIT_CTL_TOPA) &&\n\t\t!(data & RTIT_CTL_FABRIC_EN) &&\n\t\t!intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\tPT_CAP_single_range_output))\n\t\treturn 1;\n\n\t/*\n\t * MTCFreq, CycThresh and PSBFreq encodings check, any MSR write that\n\t * utilize encodings marked reserved will casue a #GP fault.\n\t */\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_mtc) &&\n\t\t\t!test_bit((data & RTIT_CTL_MTC_RANGE) >>\n\t\t\tRTIT_CTL_MTC_RANGE_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps,\n\t\t\t\t\t\tPT_CAP_cycle_thresholds);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_CYC_THRESH) >>\n\t\t\tRTIT_CTL_CYC_THRESH_OFFSET, &value))\n\t\treturn 1;\n\tvalue = intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_periods);\n\tif (intel_pt_validate_cap(vmx->pt_desc.caps, PT_CAP_psb_cyc) &&\n\t\t\t!test_bit((data & RTIT_CTL_PSB_FREQ) >>\n\t\t\tRTIT_CTL_PSB_FREQ_OFFSET, &value))\n\t\treturn 1;\n\n\t/*\n\t * If ADDRx_CFG is reserved or the encodings is >2 will\n\t * cause a #GP fault.\n\t */\n\tvalue = (data & RTIT_CTL_ADDR0) >> RTIT_CTL_ADDR0_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 1)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR1) >> RTIT_CTL_ADDR1_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 2)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR2) >> RTIT_CTL_ADDR2_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 3)) || (value > 2))\n\t\treturn 1;\n\tvalue = (data & RTIT_CTL_ADDR3) >> RTIT_CTL_ADDR3_OFFSET;\n\tif ((value && (vmx->pt_desc.addr_range < 4)) || (value > 2))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "vmx_set_interrupt_shadow",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1460-1474",
    "snippet": "void vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO",
            "interruptibility"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tu32 interruptibility_old = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tu32 interruptibility = interruptibility_old;\n\n\tinterruptibility &= ~(GUEST_INTR_STATE_STI | GUEST_INTR_STATE_MOV_SS);\n\n\tif (mask & KVM_X86_SHADOW_INT_MOV_SS)\n\t\tinterruptibility |= GUEST_INTR_STATE_MOV_SS;\n\telse if (mask & KVM_X86_SHADOW_INT_STI)\n\t\tinterruptibility |= GUEST_INTR_STATE_STI;\n\n\tif ((interruptibility != interruptibility_old))\n\t\tvmcs_write32(GUEST_INTERRUPTIBILITY_INFO, interruptibility);\n}"
  },
  {
    "function_name": "vmx_get_interrupt_shadow",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1447-1458",
    "snippet": "u32 vmx_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tu32 interruptibility = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tint ret = 0;\n\n\tif (interruptibility & GUEST_INTR_STATE_STI)\n\t\tret |= KVM_X86_SHADOW_INT_STI;\n\tif (interruptibility & GUEST_INTR_STATE_MOV_SS)\n\t\tret |= KVM_X86_SHADOW_INT_MOV_SS;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "GUEST_INTERRUPTIBILITY_INFO"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nu32 vmx_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tu32 interruptibility = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO);\n\tint ret = 0;\n\n\tif (interruptibility & GUEST_INTR_STATE_STI)\n\t\tret |= KVM_X86_SHADOW_INT_STI;\n\tif (interruptibility & GUEST_INTR_STATE_MOV_SS)\n\t\tret |= KVM_X86_SHADOW_INT_MOV_SS;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vmx_set_rflags",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1423-1445",
    "snippet": "void vmx_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long old_rflags;\n\n\tif (enable_unrestricted_guest) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\tvmx->rflags = rflags;\n\t\tvmcs_writel(GUEST_RFLAGS, rflags);\n\t\treturn;\n\t}\n\n\told_rflags = vmx_get_rflags(vcpu);\n\tvmx->rflags = rflags;\n\tif (vmx->rmode.vm86_active) {\n\t\tvmx->rmode.save_rflags = rflags;\n\t\trflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\t}\n\tvmcs_writel(GUEST_RFLAGS, rflags);\n\n\tif ((old_rflags ^ vmx->rflags) & X86_EFLAGS_VM)\n\t\tvmx->emulation_required = emulation_required(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "emulation_required",
          "args": [
            "vcpu"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "emulation_required",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1400-1403",
          "snippet": "static bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "GUEST_RFLAGS",
            "rflags"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 1435
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_get_rflags",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1405-1421",
          "snippet": "unsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long rflags, save_rflags;\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_RFLAGS)) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (vmx->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = vmx->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tvmx->rflags = rflags;\n\t}\n\treturn vmx->rflags;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))"
          ],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nunsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long rflags, save_rflags;\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_RFLAGS)) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (vmx->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = vmx->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tvmx->rflags = rflags;\n\t}\n\treturn vmx->rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_mark_available",
          "args": [
            "vcpu",
            "VCPU_EXREG_RFLAGS"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_mark_available",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "52-56",
          "snippet": "static inline void kvm_register_mark_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_mark_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long old_rflags;\n\n\tif (enable_unrestricted_guest) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\tvmx->rflags = rflags;\n\t\tvmcs_writel(GUEST_RFLAGS, rflags);\n\t\treturn;\n\t}\n\n\told_rflags = vmx_get_rflags(vcpu);\n\tvmx->rflags = rflags;\n\tif (vmx->rmode.vm86_active) {\n\t\tvmx->rmode.save_rflags = rflags;\n\t\trflags |= X86_EFLAGS_IOPL | X86_EFLAGS_VM;\n\t}\n\tvmcs_writel(GUEST_RFLAGS, rflags);\n\n\tif ((old_rflags ^ vmx->rflags) & X86_EFLAGS_VM)\n\t\tvmx->emulation_required = emulation_required(vcpu);\n}"
  },
  {
    "function_name": "vmx_get_rflags",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1405-1421",
    "snippet": "unsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long rflags, save_rflags;\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_RFLAGS)) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (vmx->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = vmx->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tvmx->rflags = rflags;\n\t}\n\treturn vmx->rflags;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))"
    ],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "GUEST_RFLAGS"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_mark_available",
          "args": [
            "vcpu",
            "VCPU_EXREG_RFLAGS"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_mark_available",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "52-56",
          "snippet": "static inline void kvm_register_mark_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_mark_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_is_available",
          "args": [
            "vcpu",
            "VCPU_EXREG_RFLAGS"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_is_available",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "40-44",
          "snippet": "static inline bool kvm_register_is_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     enum kvm_reg reg)\n{\n\treturn test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool kvm_register_is_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     enum kvm_reg reg)\n{\n\treturn test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define RMODE_GUEST_OWNED_EFLAGS_BITS (~(X86_EFLAGS_IOPL | X86_EFLAGS_VM))\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nunsigned long vmx_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunsigned long rflags, save_rflags;\n\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_RFLAGS)) {\n\t\tkvm_register_mark_available(vcpu, VCPU_EXREG_RFLAGS);\n\t\trflags = vmcs_readl(GUEST_RFLAGS);\n\t\tif (vmx->rmode.vm86_active) {\n\t\t\trflags &= RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t\tsave_rflags = vmx->rmode.save_rflags;\n\t\t\trflags |= save_rflags & ~RMODE_GUEST_OWNED_EFLAGS_BITS;\n\t\t}\n\t\tvmx->rflags = rflags;\n\t}\n\treturn vmx->rflags;\n}"
  },
  {
    "function_name": "emulation_required",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1400-1403",
    "snippet": "static bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "guest_state_valid",
          "args": [
            "vcpu"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "guest_state_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "3401-3447",
          "snippet": "static bool guest_state_valid(struct kvm_vcpu *vcpu)\n{\n\tif (enable_unrestricted_guest)\n\t\treturn true;\n\n\t/* real mode guest state checks */\n\tif (!is_protmode(vcpu) || (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_CS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_SS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t} else {\n\t/* protected mode guest state checks */\n\t\tif (!cs_ss_rpl_check(vcpu))\n\t\t\treturn false;\n\t\tif (!code_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!stack_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t\tif (!tr_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!ldtr_valid(vcpu))\n\t\t\treturn false;\n\t}\n\t/* TODO:\n\t * - Add checks on RIP\n\t * - Add checks on RFLAGS\n\t */\n\n\treturn true;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu)\n{\n\tif (enable_unrestricted_guest)\n\t\treturn true;\n\n\t/* real mode guest state checks */\n\tif (!is_protmode(vcpu) || (vmx_get_rflags(vcpu) & X86_EFLAGS_VM)) {\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_CS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_SS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!rmode_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t} else {\n\t/* protected mode guest state checks */\n\t\tif (!cs_ss_rpl_check(vcpu))\n\t\t\treturn false;\n\t\tif (!code_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!stack_segment_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_DS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_ES))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_FS))\n\t\t\treturn false;\n\t\tif (!data_segment_valid(vcpu, VCPU_SREG_GS))\n\t\t\treturn false;\n\t\tif (!tr_valid(vcpu))\n\t\t\treturn false;\n\t\tif (!ldtr_valid(vcpu))\n\t\t\treturn false;\n\t}\n\t/* TODO:\n\t * - Add checks on RIP\n\t * - Add checks on RFLAGS\n\t */\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool emulation_required(struct kvm_vcpu *vcpu)\n{\n\treturn emulate_invalid_guest_state && !guest_state_valid(vcpu);\n}"
  },
  {
    "function_name": "vmx_vcpu_put",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1393-1398",
    "snippet": "static void vmx_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tvmx_vcpu_pi_put(vcpu);\n\n\tvmx_prepare_switch_to_host(to_vmx(vcpu));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_prepare_switch_to_host",
          "args": [
            "to_vmx(vcpu)"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_prepare_switch_to_host",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1194-1231",
          "snippet": "static void vmx_prepare_switch_to_host(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs_host_state *host_state;\n\n\tif (!vmx->guest_state_loaded)\n\t\treturn;\n\n\thost_state = &vmx->loaded_vmcs->host_state;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (host_state->ldt_sel || (host_state->gs_sel & 7)) {\n\t\tkvm_load_ldt(host_state->ldt_sel);\n#ifdef CONFIG_X86_64\n\t\tload_gs_index(host_state->gs_sel);\n#else\n\t\tloadsegment(gs, host_state->gs_sel);\n#endif\n\t}\n\tif (host_state->fs_sel & 7)\n\t\tloadsegment(fs, host_state->fs_sel);\n#ifdef CONFIG_X86_64\n\tif (unlikely(host_state->ds_sel | host_state->es_sel)) {\n\t\tloadsegment(ds, host_state->ds_sel);\n\t\tloadsegment(es, host_state->es_sel);\n\t}\n#endif\n\tinvalidate_tss_limit();\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n#endif\n\tload_fixmap_gdt(raw_smp_processor_id());\n\tvmx->guest_state_loaded = false;\n\tvmx->guest_msrs_ready = false;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_prepare_switch_to_host(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs_host_state *host_state;\n\n\tif (!vmx->guest_state_loaded)\n\t\treturn;\n\n\thost_state = &vmx->loaded_vmcs->host_state;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (host_state->ldt_sel || (host_state->gs_sel & 7)) {\n\t\tkvm_load_ldt(host_state->ldt_sel);\n#ifdef CONFIG_X86_64\n\t\tload_gs_index(host_state->gs_sel);\n#else\n\t\tloadsegment(gs, host_state->gs_sel);\n#endif\n\t}\n\tif (host_state->fs_sel & 7)\n\t\tloadsegment(fs, host_state->fs_sel);\n#ifdef CONFIG_X86_64\n\tif (unlikely(host_state->ds_sel | host_state->es_sel)) {\n\t\tloadsegment(ds, host_state->ds_sel);\n\t\tloadsegment(es, host_state->es_sel);\n\t}\n#endif\n\tinvalidate_tss_limit();\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n#endif\n\tload_fixmap_gdt(raw_smp_processor_id());\n\tvmx->guest_state_loaded = false;\n\tvmx->guest_msrs_ready = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_vcpu_pi_put",
          "args": [
            "vcpu"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_vcpu_pi_put",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1379-1391",
          "snippet": "static void vmx_vcpu_pi_put(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/* Set SN when the vCPU is preempted */\n\tif (vcpu->preempted)\n\t\tpi_set_sn(pi_desc);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_vcpu_pi_put(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/* Set SN when the vCPU is preempted */\n\tif (vcpu->preempted)\n\t\tpi_set_sn(pi_desc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tvmx_vcpu_pi_put(vcpu);\n\n\tvmx_prepare_switch_to_host(to_vmx(vcpu));\n}"
  },
  {
    "function_name": "vmx_vcpu_pi_put",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1379-1391",
    "snippet": "static void vmx_vcpu_pi_put(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/* Set SN when the vCPU is preempted */\n\tif (vcpu->preempted)\n\t\tpi_set_sn(pi_desc);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pi_set_sn",
          "args": [
            "pi_desc"
          ],
          "line": 1390
        },
        "resolved": true,
        "details": {
          "function_name": "pi_set_sn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "377-381",
          "snippet": "static inline void pi_set_sn(struct pi_desc *pi_desc)\n{\n\tset_bit(POSTED_INTR_SN,\n\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_SN  1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_SN  1\n\nstatic inline void pi_set_sn(struct pi_desc *pi_desc)\n{\n\tset_bit(POSTED_INTR_SN,\n\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_remapping_cap",
          "args": [
            "IRQ_POSTING_CAP"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_has_assigned_device",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_has_assigned_device",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10460-10463",
          "snippet": "bool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pi_desc",
          "args": [
            "vcpu"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_pi_desc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "484-487",
          "snippet": "static inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_vcpu_pi_put(struct kvm_vcpu *vcpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm) ||\n\t\t!irq_remapping_cap(IRQ_POSTING_CAP)  ||\n\t\t!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/* Set SN when the vCPU is preempted */\n\tif (vcpu->preempted)\n\t\tpi_set_sn(pi_desc);\n}"
  },
  {
    "function_name": "vmx_vcpu_load",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1367-1377",
    "snippet": "void vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx_vcpu_load_vmcs(vcpu, cpu);\n\n\tvmx_vcpu_pi_load(vcpu, cpu);\n\n\tvmx->host_pkru = read_pkru();\n\tvmx->host_debugctlmsr = get_debugctlmsr();\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_debugctlmsr",
          "args": [],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_pkru",
          "args": [],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_vcpu_pi_load",
          "args": [
            "vcpu",
            "cpu"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_vcpu_pi_load",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1253-1307",
          "snippet": "static void vmx_vcpu_pi_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\t/*\n\t * In case of hot-plug or hot-unplug, we may have to undo\n\t * vmx_vcpu_pi_put even if there is no assigned device.  And we\n\t * always keep PI.NDST up to date for simplicity: it makes the\n\t * code easier, and CPU migration is not a fast path.\n\t */\n\tif (!pi_test_sn(pi_desc) && vcpu->cpu == cpu)\n\t\treturn;\n\n\t/*\n\t * If the 'nv' field is POSTED_INTR_WAKEUP_VECTOR, do not change\n\t * PI.NDST: pi_post_block is the one expected to change PID.NDST and the\n\t * wakeup handler expects the vCPU to be on the blocked_vcpu_list that\n\t * matches PI.NDST. Otherwise, a vcpu may not be able to be woken up\n\t * correctly.\n\t */\n\tif (pi_desc->nv == POSTED_INTR_WAKEUP_VECTOR || vcpu->cpu == cpu) {\n\t\tpi_clear_sn(pi_desc);\n\t\tgoto after_clear_sn;\n\t}\n\n\t/* The full case.  */\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\tdest = cpu_physical_id(cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\tnew.sn = 0;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\nafter_clear_sn:\n\n\t/*\n\t * Clear SN before reading the bitmap.  The VT-d firmware\n\t * writes the bitmap and reads SN atomically (5.2.3 in the\n\t * spec), so it doesn't really have a memory barrier that\n\t * pairs with this, but we cannot do that and we need one.\n\t */\n\tsmp_mb__after_atomic();\n\n\tif (!pi_is_pir_empty(pi_desc))\n\t\tpi_set_on(pi_desc);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_vcpu_pi_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\t/*\n\t * In case of hot-plug or hot-unplug, we may have to undo\n\t * vmx_vcpu_pi_put even if there is no assigned device.  And we\n\t * always keep PI.NDST up to date for simplicity: it makes the\n\t * code easier, and CPU migration is not a fast path.\n\t */\n\tif (!pi_test_sn(pi_desc) && vcpu->cpu == cpu)\n\t\treturn;\n\n\t/*\n\t * If the 'nv' field is POSTED_INTR_WAKEUP_VECTOR, do not change\n\t * PI.NDST: pi_post_block is the one expected to change PID.NDST and the\n\t * wakeup handler expects the vCPU to be on the blocked_vcpu_list that\n\t * matches PI.NDST. Otherwise, a vcpu may not be able to be woken up\n\t * correctly.\n\t */\n\tif (pi_desc->nv == POSTED_INTR_WAKEUP_VECTOR || vcpu->cpu == cpu) {\n\t\tpi_clear_sn(pi_desc);\n\t\tgoto after_clear_sn;\n\t}\n\n\t/* The full case.  */\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\tdest = cpu_physical_id(cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\tnew.sn = 0;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\nafter_clear_sn:\n\n\t/*\n\t * Clear SN before reading the bitmap.  The VT-d firmware\n\t * writes the bitmap and reads SN atomically (5.2.3 in the\n\t * spec), so it doesn't really have a memory barrier that\n\t * pairs with this, but we cannot do that and we need one.\n\t */\n\tsmp_mb__after_atomic();\n\n\tif (!pi_is_pir_empty(pi_desc))\n\t\tpi_set_on(pi_desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_vcpu_load_vmcs",
          "args": [
            "vcpu",
            "cpu"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_vcpu_load_vmcs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1309-1361",
          "snippet": "void vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool already_loaded = vmx->loaded_vmcs->cpu == cpu;\n\n\tif (!already_loaded) {\n\t\tloaded_vmcs_clear(vmx->loaded_vmcs);\n\t\tlocal_irq_disable();\n\n\t\t/*\n\t\t * Ensure loaded_vmcs->cpu is read before adding loaded_vmcs to\n\t\t * this cpu's percpu list, otherwise it may not yet be deleted\n\t\t * from its previous cpu's percpu list.  Pairs with the\n\t\t * smb_wmb() in __loaded_vmcs_clear().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tlist_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,\n\t\t\t &per_cpu(loaded_vmcss_on_cpu, cpu));\n\t\tlocal_irq_enable();\n\t}\n\n\tif (per_cpu(current_vmcs, cpu) != vmx->loaded_vmcs->vmcs) {\n\t\tper_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;\n\t\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\t\tindirect_branch_prediction_barrier();\n\t}\n\n\tif (!already_loaded) {\n\t\tvoid *gdt = get_current_gdt_ro();\n\t\tunsigned long sysenter_esp;\n\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\n\t\t/*\n\t\t * Linux uses per-cpu TSS and GDT, so set these when switching\n\t\t * processors.  See 22.2.4.\n\t\t */\n\t\tvmcs_writel(HOST_TR_BASE,\n\t\t\t    (unsigned long)&get_cpu_entry_area(cpu)->tss.x86_tss);\n\t\tvmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);   /* 22.2.4 */\n\n\t\trdmsrl(MSR_IA32_SYSENTER_ESP, sysenter_esp);\n\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP, sysenter_esp); /* 22.2.3 */\n\n\t\tvmx->loaded_vmcs->cpu = cpu;\n\t}\n\n\t/* Setup TSC multiplier */\n\tif (kvm_has_tsc_control &&\n\t    vmx->current_tsc_ratio != vcpu->arch.tsc_scaling_ratio)\n\t\tdecache_tsc_multiplier(vmx);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
            "static DEFINE_PER_CPU(struct vmcs *, vmxarea);\nDEFINE_PER_CPU(struct vmcs *, current_vmcs);",
            "static DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct vmcs *, vmxarea);\nDEFINE_PER_CPU(struct vmcs *, current_vmcs);\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\n\nvoid vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool already_loaded = vmx->loaded_vmcs->cpu == cpu;\n\n\tif (!already_loaded) {\n\t\tloaded_vmcs_clear(vmx->loaded_vmcs);\n\t\tlocal_irq_disable();\n\n\t\t/*\n\t\t * Ensure loaded_vmcs->cpu is read before adding loaded_vmcs to\n\t\t * this cpu's percpu list, otherwise it may not yet be deleted\n\t\t * from its previous cpu's percpu list.  Pairs with the\n\t\t * smb_wmb() in __loaded_vmcs_clear().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tlist_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,\n\t\t\t &per_cpu(loaded_vmcss_on_cpu, cpu));\n\t\tlocal_irq_enable();\n\t}\n\n\tif (per_cpu(current_vmcs, cpu) != vmx->loaded_vmcs->vmcs) {\n\t\tper_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;\n\t\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\t\tindirect_branch_prediction_barrier();\n\t}\n\n\tif (!already_loaded) {\n\t\tvoid *gdt = get_current_gdt_ro();\n\t\tunsigned long sysenter_esp;\n\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\n\t\t/*\n\t\t * Linux uses per-cpu TSS and GDT, so set these when switching\n\t\t * processors.  See 22.2.4.\n\t\t */\n\t\tvmcs_writel(HOST_TR_BASE,\n\t\t\t    (unsigned long)&get_cpu_entry_area(cpu)->tss.x86_tss);\n\t\tvmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);   /* 22.2.4 */\n\n\t\trdmsrl(MSR_IA32_SYSENTER_ESP, sysenter_esp);\n\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP, sysenter_esp); /* 22.2.3 */\n\n\t\tvmx->loaded_vmcs->cpu = cpu;\n\t}\n\n\t/* Setup TSC multiplier */\n\tif (kvm_has_tsc_control &&\n\t    vmx->current_tsc_ratio != vcpu->arch.tsc_scaling_ratio)\n\t\tdecache_tsc_multiplier(vmx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tvmx_vcpu_load_vmcs(vcpu, cpu);\n\n\tvmx_vcpu_pi_load(vcpu, cpu);\n\n\tvmx->host_pkru = read_pkru();\n\tvmx->host_debugctlmsr = get_debugctlmsr();\n}"
  },
  {
    "function_name": "vmx_vcpu_load_vmcs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1309-1361",
    "snippet": "void vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool already_loaded = vmx->loaded_vmcs->cpu == cpu;\n\n\tif (!already_loaded) {\n\t\tloaded_vmcs_clear(vmx->loaded_vmcs);\n\t\tlocal_irq_disable();\n\n\t\t/*\n\t\t * Ensure loaded_vmcs->cpu is read before adding loaded_vmcs to\n\t\t * this cpu's percpu list, otherwise it may not yet be deleted\n\t\t * from its previous cpu's percpu list.  Pairs with the\n\t\t * smb_wmb() in __loaded_vmcs_clear().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tlist_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,\n\t\t\t &per_cpu(loaded_vmcss_on_cpu, cpu));\n\t\tlocal_irq_enable();\n\t}\n\n\tif (per_cpu(current_vmcs, cpu) != vmx->loaded_vmcs->vmcs) {\n\t\tper_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;\n\t\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\t\tindirect_branch_prediction_barrier();\n\t}\n\n\tif (!already_loaded) {\n\t\tvoid *gdt = get_current_gdt_ro();\n\t\tunsigned long sysenter_esp;\n\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\n\t\t/*\n\t\t * Linux uses per-cpu TSS and GDT, so set these when switching\n\t\t * processors.  See 22.2.4.\n\t\t */\n\t\tvmcs_writel(HOST_TR_BASE,\n\t\t\t    (unsigned long)&get_cpu_entry_area(cpu)->tss.x86_tss);\n\t\tvmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);   /* 22.2.4 */\n\n\t\trdmsrl(MSR_IA32_SYSENTER_ESP, sysenter_esp);\n\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP, sysenter_esp); /* 22.2.3 */\n\n\t\tvmx->loaded_vmcs->cpu = cpu;\n\t}\n\n\t/* Setup TSC multiplier */\n\tif (kvm_has_tsc_control &&\n\t    vmx->current_tsc_ratio != vcpu->arch.tsc_scaling_ratio)\n\t\tdecache_tsc_multiplier(vmx);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(struct vmcs *, vmxarea);\nDEFINE_PER_CPU(struct vmcs *, current_vmcs);",
      "static DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "decache_tsc_multiplier",
          "args": [
            "vmx"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "decache_tsc_multiplier",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "521-525",
          "snippet": "static inline void decache_tsc_multiplier(struct vcpu_vmx *vmx)\n{\n\tvmx->current_tsc_ratio = vmx->vcpu.arch.tsc_scaling_ratio;\n\tvmcs_write64(TSC_MULTIPLIER, vmx->current_tsc_ratio);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline void decache_tsc_multiplier(struct vcpu_vmx *vmx)\n{\n\tvmx->current_tsc_ratio = vmx->vcpu.arch.tsc_scaling_ratio;\n\tvmcs_write64(TSC_MULTIPLIER, vmx->current_tsc_ratio);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "HOST_IA32_SYSENTER_ESP",
            "sysenter_esp"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_SYSENTER_ESP",
            "sysenter_esp"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu_entry_area",
          "args": [
            "cpu"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_gdt_ro",
          "args": [],
          "line": 1338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "indirect_branch_prediction_barrier",
          "args": [],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_load",
          "args": [
            "vmx->loaded_vmcs->vmcs"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_load",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "241-249",
          "snippet": "static inline void vmcs_load(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_load(phys_addr);\n\n\tvmx_asm1(vmptrld, \"m\"(phys_addr), vmcs, phys_addr);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void vmcs_load(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_load(phys_addr);\n\n\tvmx_asm1(vmptrld, \"m\"(phys_addr), vmcs, phys_addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "current_vmcs",
            "cpu"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "current_vmcs",
            "cpu"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link",
            "&per_cpu(loaded_vmcss_on_cpu, cpu)"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "svm_ir_list_add",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4206-4248",
          "snippet": "static int svm_ir_list_add(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\n\t/**\n\t * In some cases, the existing irte is updaed and re-set,\n\t * so we need to check here if it's already been * added\n\t * to the ir_list.\n\t */\n\tif (pi->ir_data && (pi->prev_ga_tag != 0)) {\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tu32 vcpu_id = AVIC_GATAG_TO_VCPUID(pi->prev_ga_tag);\n\t\tstruct kvm_vcpu *prev_vcpu = kvm_get_vcpu_by_id(kvm, vcpu_id);\n\t\tstruct vcpu_svm *prev_svm;\n\n\t\tif (!prev_vcpu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprev_svm = to_svm(prev_vcpu);\n\t\tsvm_ir_list_del(prev_svm, pi);\n\t}\n\n\t/**\n\t * Allocating new amd_iommu_pi_data, which will get\n\t * add to the per-vcpu ir_list.\n\t */\n\tir = kzalloc(sizeof(struct amd_svm_iommu_ir), GFP_KERNEL_ACCOUNT);\n\tif (!ir) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tir->data = pi->ir_data;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_add(&ir->node, &svm->ir_list);\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_ir_list_add(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\n\t/**\n\t * In some cases, the existing irte is updaed and re-set,\n\t * so we need to check here if it's already been * added\n\t * to the ir_list.\n\t */\n\tif (pi->ir_data && (pi->prev_ga_tag != 0)) {\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tu32 vcpu_id = AVIC_GATAG_TO_VCPUID(pi->prev_ga_tag);\n\t\tstruct kvm_vcpu *prev_vcpu = kvm_get_vcpu_by_id(kvm, vcpu_id);\n\t\tstruct vcpu_svm *prev_svm;\n\n\t\tif (!prev_vcpu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprev_svm = to_svm(prev_vcpu);\n\t\tsvm_ir_list_del(prev_svm, pi);\n\t}\n\n\t/**\n\t * Allocating new amd_iommu_pi_data, which will get\n\t * add to the per-vcpu ir_list.\n\t */\n\tir = kzalloc(sizeof(struct amd_svm_iommu_ir), GFP_KERNEL_ACCOUNT);\n\tif (!ir) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tir->data = pi->ir_data;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_add(&ir->node, &svm->ir_list);\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "loaded_vmcss_on_cpu",
            "cpu"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loaded_vmcs_clear",
          "args": [
            "vmx->loaded_vmcs"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "loaded_vmcs_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "701-708",
          "snippet": "void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct vmcs *, vmxarea);\nDEFINE_PER_CPU(struct vmcs *, current_vmcs);\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\n\nvoid vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tbool already_loaded = vmx->loaded_vmcs->cpu == cpu;\n\n\tif (!already_loaded) {\n\t\tloaded_vmcs_clear(vmx->loaded_vmcs);\n\t\tlocal_irq_disable();\n\n\t\t/*\n\t\t * Ensure loaded_vmcs->cpu is read before adding loaded_vmcs to\n\t\t * this cpu's percpu list, otherwise it may not yet be deleted\n\t\t * from its previous cpu's percpu list.  Pairs with the\n\t\t * smb_wmb() in __loaded_vmcs_clear().\n\t\t */\n\t\tsmp_rmb();\n\n\t\tlist_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link,\n\t\t\t &per_cpu(loaded_vmcss_on_cpu, cpu));\n\t\tlocal_irq_enable();\n\t}\n\n\tif (per_cpu(current_vmcs, cpu) != vmx->loaded_vmcs->vmcs) {\n\t\tper_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs;\n\t\tvmcs_load(vmx->loaded_vmcs->vmcs);\n\t\tindirect_branch_prediction_barrier();\n\t}\n\n\tif (!already_loaded) {\n\t\tvoid *gdt = get_current_gdt_ro();\n\t\tunsigned long sysenter_esp;\n\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\n\t\t/*\n\t\t * Linux uses per-cpu TSS and GDT, so set these when switching\n\t\t * processors.  See 22.2.4.\n\t\t */\n\t\tvmcs_writel(HOST_TR_BASE,\n\t\t\t    (unsigned long)&get_cpu_entry_area(cpu)->tss.x86_tss);\n\t\tvmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);   /* 22.2.4 */\n\n\t\trdmsrl(MSR_IA32_SYSENTER_ESP, sysenter_esp);\n\t\tvmcs_writel(HOST_IA32_SYSENTER_ESP, sysenter_esp); /* 22.2.3 */\n\n\t\tvmx->loaded_vmcs->cpu = cpu;\n\t}\n\n\t/* Setup TSC multiplier */\n\tif (kvm_has_tsc_control &&\n\t    vmx->current_tsc_ratio != vcpu->arch.tsc_scaling_ratio)\n\t\tdecache_tsc_multiplier(vmx);\n}"
  },
  {
    "function_name": "vmx_vcpu_pi_load",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1253-1307",
    "snippet": "static void vmx_vcpu_pi_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\t/*\n\t * In case of hot-plug or hot-unplug, we may have to undo\n\t * vmx_vcpu_pi_put even if there is no assigned device.  And we\n\t * always keep PI.NDST up to date for simplicity: it makes the\n\t * code easier, and CPU migration is not a fast path.\n\t */\n\tif (!pi_test_sn(pi_desc) && vcpu->cpu == cpu)\n\t\treturn;\n\n\t/*\n\t * If the 'nv' field is POSTED_INTR_WAKEUP_VECTOR, do not change\n\t * PI.NDST: pi_post_block is the one expected to change PID.NDST and the\n\t * wakeup handler expects the vCPU to be on the blocked_vcpu_list that\n\t * matches PI.NDST. Otherwise, a vcpu may not be able to be woken up\n\t * correctly.\n\t */\n\tif (pi_desc->nv == POSTED_INTR_WAKEUP_VECTOR || vcpu->cpu == cpu) {\n\t\tpi_clear_sn(pi_desc);\n\t\tgoto after_clear_sn;\n\t}\n\n\t/* The full case.  */\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\tdest = cpu_physical_id(cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\tnew.sn = 0;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\nafter_clear_sn:\n\n\t/*\n\t * Clear SN before reading the bitmap.  The VT-d firmware\n\t * writes the bitmap and reads SN atomically (5.2.3 in the\n\t * spec), so it doesn't really have a memory barrier that\n\t * pairs with this, but we cannot do that and we need one.\n\t */\n\tsmp_mb__after_atomic();\n\n\tif (!pi_is_pir_empty(pi_desc))\n\t\tpi_set_on(pi_desc);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pi_set_on",
          "args": [
            "pi_desc"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "pi_set_on",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "383-387",
          "snippet": "static inline void pi_set_on(struct pi_desc *pi_desc)\n{\n\tset_bit(POSTED_INTR_ON,\n\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_ON  0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_ON  0\n\nstatic inline void pi_set_on(struct pi_desc *pi_desc)\n{\n\tset_bit(POSTED_INTR_ON,\n\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pi_is_pir_empty",
          "args": [
            "pi_desc"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "pi_is_pir_empty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "372-375",
          "snippet": "static inline bool pi_is_pir_empty(struct pi_desc *pi_desc)\n{\n\treturn bitmap_empty((unsigned long *)pi_desc->pir, NR_VECTORS);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool pi_is_pir_empty(struct pi_desc *pi_desc)\n{\n\treturn bitmap_empty((unsigned long *)pi_desc->pir, NR_VECTORS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmpxchg64",
          "args": [
            "&pi_desc->control",
            "old.control",
            "new.control"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x2apic_enabled",
          "args": [],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_physical_id",
          "args": [
            "cpu"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pi_clear_sn",
          "args": [
            "pi_desc"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "pi_clear_sn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "395-399",
          "snippet": "static inline void pi_clear_sn(struct pi_desc *pi_desc)\n{\n\tclear_bit(POSTED_INTR_SN,\n\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_SN  1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_SN  1\n\nstatic inline void pi_clear_sn(struct pi_desc *pi_desc)\n{\n\tclear_bit(POSTED_INTR_SN,\n\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pi_test_sn",
          "args": [
            "pi_desc"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "pi_test_sn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "407-411",
          "snippet": "static inline int pi_test_sn(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define POSTED_INTR_SN  1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\n#define POSTED_INTR_SN  1\n\nstatic inline int pi_test_sn(struct pi_desc *pi_desc)\n{\n\treturn test_bit(POSTED_INTR_SN,\n\t\t\t(unsigned long *)&pi_desc->control);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pi_desc",
          "args": [
            "vcpu"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_pi_desc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "484-487",
          "snippet": "static inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct pi_desc *vcpu_to_pi_desc(struct kvm_vcpu *vcpu)\n{\n\treturn &(to_vmx(vcpu)->pi_desc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_vcpu_pi_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct pi_desc *pi_desc = vcpu_to_pi_desc(vcpu);\n\tstruct pi_desc old, new;\n\tunsigned int dest;\n\n\t/*\n\t * In case of hot-plug or hot-unplug, we may have to undo\n\t * vmx_vcpu_pi_put even if there is no assigned device.  And we\n\t * always keep PI.NDST up to date for simplicity: it makes the\n\t * code easier, and CPU migration is not a fast path.\n\t */\n\tif (!pi_test_sn(pi_desc) && vcpu->cpu == cpu)\n\t\treturn;\n\n\t/*\n\t * If the 'nv' field is POSTED_INTR_WAKEUP_VECTOR, do not change\n\t * PI.NDST: pi_post_block is the one expected to change PID.NDST and the\n\t * wakeup handler expects the vCPU to be on the blocked_vcpu_list that\n\t * matches PI.NDST. Otherwise, a vcpu may not be able to be woken up\n\t * correctly.\n\t */\n\tif (pi_desc->nv == POSTED_INTR_WAKEUP_VECTOR || vcpu->cpu == cpu) {\n\t\tpi_clear_sn(pi_desc);\n\t\tgoto after_clear_sn;\n\t}\n\n\t/* The full case.  */\n\tdo {\n\t\told.control = new.control = pi_desc->control;\n\n\t\tdest = cpu_physical_id(cpu);\n\n\t\tif (x2apic_enabled())\n\t\t\tnew.ndst = dest;\n\t\telse\n\t\t\tnew.ndst = (dest << 8) & 0xFF00;\n\n\t\tnew.sn = 0;\n\t} while (cmpxchg64(&pi_desc->control, old.control,\n\t\t\t   new.control) != old.control);\n\nafter_clear_sn:\n\n\t/*\n\t * Clear SN before reading the bitmap.  The VT-d firmware\n\t * writes the bitmap and reads SN atomically (5.2.3 in the\n\t * spec), so it doesn't really have a memory barrier that\n\t * pairs with this, but we cannot do that and we need one.\n\t */\n\tsmp_mb__after_atomic();\n\n\tif (!pi_is_pir_empty(pi_desc))\n\t\tpi_set_on(pi_desc);\n}"
  },
  {
    "function_name": "vmx_write_guest_kernel_gs_base",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1243-1250",
    "snippet": "static void vmx_write_guest_kernel_gs_base(struct vcpu_vmx *vmx, u64 data)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, data);\n\tpreempt_enable();\n\tvmx->msr_guest_kernel_gs_base = data;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_KERNEL_GS_BASE",
            "data"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void vmx_write_guest_kernel_gs_base(struct vcpu_vmx *vmx, u64 data)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\twrmsrl(MSR_KERNEL_GS_BASE, data);\n\tpreempt_enable();\n\tvmx->msr_guest_kernel_gs_base = data;\n}"
  },
  {
    "function_name": "vmx_read_guest_kernel_gs_base",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1234-1241",
    "snippet": "static u64 vmx_read_guest_kernel_gs_base(struct vcpu_vmx *vmx)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\tpreempt_enable();\n\treturn vmx->msr_guest_kernel_gs_base;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_KERNEL_GS_BASE",
            "vmx->msr_guest_kernel_gs_base"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic u64 vmx_read_guest_kernel_gs_base(struct vcpu_vmx *vmx)\n{\n\tpreempt_disable();\n\tif (vmx->guest_state_loaded)\n\t\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n\tpreempt_enable();\n\treturn vmx->msr_guest_kernel_gs_base;\n}"
  },
  {
    "function_name": "vmx_prepare_switch_to_host",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1194-1231",
    "snippet": "static void vmx_prepare_switch_to_host(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs_host_state *host_state;\n\n\tif (!vmx->guest_state_loaded)\n\t\treturn;\n\n\thost_state = &vmx->loaded_vmcs->host_state;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (host_state->ldt_sel || (host_state->gs_sel & 7)) {\n\t\tkvm_load_ldt(host_state->ldt_sel);\n#ifdef CONFIG_X86_64\n\t\tload_gs_index(host_state->gs_sel);\n#else\n\t\tloadsegment(gs, host_state->gs_sel);\n#endif\n\t}\n\tif (host_state->fs_sel & 7)\n\t\tloadsegment(fs, host_state->fs_sel);\n#ifdef CONFIG_X86_64\n\tif (unlikely(host_state->ds_sel | host_state->es_sel)) {\n\t\tloadsegment(ds, host_state->ds_sel);\n\t\tloadsegment(es, host_state->es_sel);\n\t}\n#endif\n\tinvalidate_tss_limit();\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n#endif\n\tload_fixmap_gdt(raw_smp_processor_id());\n\tvmx->guest_state_loaded = false;\n\tvmx->guest_msrs_ready = false;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_fixmap_gdt",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_KERNEL_GS_BASE",
            "vmx->msr_host_kernel_gs_base"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "invalidate_tss_limit",
          "args": [],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "es",
            "host_state->es_sel"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "ds",
            "host_state->ds_sel"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "host_state->ds_sel | host_state->es_sel"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "fs",
            "host_state->fs_sel"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "gs",
            "host_state->gs_sel"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_gs_index",
          "args": [
            "host_state->gs_sel"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_load_ldt",
          "args": [
            "host_state->ldt_sel"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_KERNEL_GS_BASE",
            "vmx->msr_guest_kernel_gs_base"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void vmx_prepare_switch_to_host(struct vcpu_vmx *vmx)\n{\n\tstruct vmcs_host_state *host_state;\n\n\tif (!vmx->guest_state_loaded)\n\t\treturn;\n\n\thost_state = &vmx->loaded_vmcs->host_state;\n\n\t++vmx->vcpu.stat.host_state_reload;\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#endif\n\tif (host_state->ldt_sel || (host_state->gs_sel & 7)) {\n\t\tkvm_load_ldt(host_state->ldt_sel);\n#ifdef CONFIG_X86_64\n\t\tload_gs_index(host_state->gs_sel);\n#else\n\t\tloadsegment(gs, host_state->gs_sel);\n#endif\n\t}\n\tif (host_state->fs_sel & 7)\n\t\tloadsegment(fs, host_state->fs_sel);\n#ifdef CONFIG_X86_64\n\tif (unlikely(host_state->ds_sel | host_state->es_sel)) {\n\t\tloadsegment(ds, host_state->ds_sel);\n\t\tloadsegment(es, host_state->es_sel);\n\t}\n#endif\n\tinvalidate_tss_limit();\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_host_kernel_gs_base);\n#endif\n\tload_fixmap_gdt(raw_smp_processor_id());\n\tvmx->guest_state_loaded = false;\n\tvmx->guest_msrs_ready = false;\n}"
  },
  {
    "function_name": "vmx_prepare_switch_to_guest",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1123-1192",
    "snippet": "void vmx_prepare_switch_to_guest(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs_host_state *host_state;\n#ifdef CONFIG_X86_64\n\tint cpu = raw_smp_processor_id();\n#endif\n\tunsigned long fs_base, gs_base;\n\tu16 fs_sel, gs_sel;\n\tint i;\n\n\tvmx->req_immediate_exit = false;\n\n\t/*\n\t * Note that guest MSRs to be saved/restored can also be changed\n\t * when guest state is loaded. This happens when guest transitions\n\t * to/from long-mode by setting MSR_EFER.LMA.\n\t */\n\tif (!vmx->guest_msrs_ready) {\n\t\tvmx->guest_msrs_ready = true;\n\t\tfor (i = 0; i < vmx->save_nmsrs; ++i)\n\t\t\tkvm_set_shared_msr(vmx->guest_msrs[i].index,\n\t\t\t\t\t   vmx->guest_msrs[i].data,\n\t\t\t\t\t   vmx->guest_msrs[i].mask);\n\n\t}\n\n    \tif (vmx->nested.need_vmcs12_to_shadow_sync)\n\t\tnested_sync_vmcs12_to_shadow(vcpu);\n\n\tif (vmx->guest_state_loaded)\n\t\treturn;\n\n\thost_state = &vmx->loaded_vmcs->host_state;\n\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\thost_state->ldt_sel = kvm_read_ldt();\n\n#ifdef CONFIG_X86_64\n\tsavesegment(ds, host_state->ds_sel);\n\tsavesegment(es, host_state->es_sel);\n\n\tgs_base = cpu_kernelmode_gs_base(cpu);\n\tif (likely(is_64bit_mm(current->mm))) {\n\t\tsave_fsgs_for_kvm();\n\t\tfs_sel = current->thread.fsindex;\n\t\tgs_sel = current->thread.gsindex;\n\t\tfs_base = current->thread.fsbase;\n\t\tvmx->msr_host_kernel_gs_base = current->thread.gsbase;\n\t} else {\n\t\tsavesegment(fs, fs_sel);\n\t\tsavesegment(gs, gs_sel);\n\t\tfs_base = read_msr(MSR_FS_BASE);\n\t\tvmx->msr_host_kernel_gs_base = read_msr(MSR_KERNEL_GS_BASE);\n\t}\n\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#else\n\tsavesegment(fs, fs_sel);\n\tsavesegment(gs, gs_sel);\n\tfs_base = segment_base(fs_sel);\n\tgs_base = segment_base(gs_sel);\n#endif\n\n\tvmx_set_host_fs_gs(host_state, fs_sel, gs_sel, fs_base, gs_base);\n\tvmx->guest_state_loaded = true;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_set_host_fs_gs",
          "args": [
            "host_state",
            "fs_sel",
            "gs_sel",
            "fs_base",
            "gs_base"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_set_host_fs_gs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1096-1121",
          "snippet": "void vmx_set_host_fs_gs(struct vmcs_host_state *host, u16 fs_sel, u16 gs_sel,\n\t\t\tunsigned long fs_base, unsigned long gs_base)\n{\n\tif (unlikely(fs_sel != host->fs_sel)) {\n\t\tif (!(fs_sel & 7))\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, fs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\thost->fs_sel = fs_sel;\n\t}\n\tif (unlikely(gs_sel != host->gs_sel)) {\n\t\tif (!(gs_sel & 7))\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, gs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\thost->gs_sel = gs_sel;\n\t}\n\tif (unlikely(fs_base != host->fs_base)) {\n\t\tvmcs_writel(HOST_FS_BASE, fs_base);\n\t\thost->fs_base = fs_base;\n\t}\n\tif (unlikely(gs_base != host->gs_base)) {\n\t\tvmcs_writel(HOST_GS_BASE, gs_base);\n\t\thost->gs_base = gs_base;\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid vmx_set_host_fs_gs(struct vmcs_host_state *host, u16 fs_sel, u16 gs_sel,\n\t\t\tunsigned long fs_base, unsigned long gs_base)\n{\n\tif (unlikely(fs_sel != host->fs_sel)) {\n\t\tif (!(fs_sel & 7))\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, fs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\thost->fs_sel = fs_sel;\n\t}\n\tif (unlikely(gs_sel != host->gs_sel)) {\n\t\tif (!(gs_sel & 7))\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, gs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\thost->gs_sel = gs_sel;\n\t}\n\tif (unlikely(fs_base != host->fs_base)) {\n\t\tvmcs_writel(HOST_FS_BASE, fs_base);\n\t\thost->fs_base = fs_base;\n\t}\n\tif (unlikely(gs_base != host->gs_base)) {\n\t\tvmcs_writel(HOST_GS_BASE, gs_base);\n\t\thost->gs_base = gs_base;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "segment_base",
          "args": [
            "gs_sel"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "segment_base",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1008-1028",
          "snippet": "static unsigned long segment_base(u16 selector)\n{\n\tstruct desc_struct *table;\n\tunsigned long v;\n\n\tif (!(selector & ~SEGMENT_RPL_MASK))\n\t\treturn 0;\n\n\ttable = get_current_gdt_ro();\n\n\tif ((selector & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tu16 ldt_selector = kvm_read_ldt();\n\n\t\tif (!(ldt_selector & ~SEGMENT_RPL_MASK))\n\t\t\treturn 0;\n\n\t\ttable = (struct desc_struct *)segment_base(ldt_selector);\n\t}\n\tv = get_desc_base(&table[selector >> 3]);\n\treturn v;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic unsigned long segment_base(u16 selector)\n{\n\tstruct desc_struct *table;\n\tunsigned long v;\n\n\tif (!(selector & ~SEGMENT_RPL_MASK))\n\t\treturn 0;\n\n\ttable = get_current_gdt_ro();\n\n\tif ((selector & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tu16 ldt_selector = kvm_read_ldt();\n\n\t\tif (!(ldt_selector & ~SEGMENT_RPL_MASK))\n\t\t\treturn 0;\n\n\t\ttable = (struct desc_struct *)segment_base(ldt_selector);\n\t}\n\tv = get_desc_base(&table[selector >> 3]);\n\treturn v;\n}"
        }
      },
      {
        "call_info": {
          "callee": "savesegment",
          "args": [
            "gs",
            "gs_sel"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "savesegment",
          "args": [
            "fs",
            "fs_sel"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_KERNEL_GS_BASE",
            "vmx->msr_guest_kernel_gs_base"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_msr",
          "args": [
            "MSR_KERNEL_GS_BASE"
          ],
          "line": 1179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_msr",
          "args": [
            "MSR_FS_BASE"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "savesegment",
          "args": [
            "gs",
            "gs_sel"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "savesegment",
          "args": [
            "fs",
            "fs_sel"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_fsgs_for_kvm",
          "args": [],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "is_64bit_mm(current->mm)"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_64bit_mm",
          "args": [
            "current->mm"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_kernelmode_gs_base",
          "args": [
            "cpu"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "savesegment",
          "args": [
            "es",
            "host_state->es_sel"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "savesegment",
          "args": [
            "ds",
            "host_state->ds_sel"
          ],
          "line": 1165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_ldt",
          "args": [],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_sync_vmcs12_to_shadow",
          "args": [
            "vcpu"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "nested_sync_vmcs12_to_shadow",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "1995-2009",
          "snippet": "void nested_sync_vmcs12_to_shadow(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (vmx->nested.hv_evmcs) {\n\t\tcopy_vmcs12_to_enlightened(vmx);\n\t\t/* All fields are clean */\n\t\tvmx->nested.hv_evmcs->hv_clean_fields |=\n\t\t\tHV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL;\n\t} else {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t}\n\n\tvmx->nested.need_vmcs12_to_shadow_sync = false;\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nvoid nested_sync_vmcs12_to_shadow(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\tif (vmx->nested.hv_evmcs) {\n\t\tcopy_vmcs12_to_enlightened(vmx);\n\t\t/* All fields are clean */\n\t\tvmx->nested.hv_evmcs->hv_clean_fields |=\n\t\t\tHV_VMX_ENLIGHTENED_CLEAN_FIELD_ALL;\n\t} else {\n\t\tcopy_vmcs12_to_shadow(vmx);\n\t}\n\n\tvmx->nested.need_vmcs12_to_shadow_sync = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_shared_msr",
          "args": [
            "vmx->guest_msrs[i].index",
            "vmx->guest_msrs[i].data",
            "vmx->guest_msrs[i].mask"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_shared_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "318-338",
          "snippet": "int kvm_set_shared_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\tint err;\n\n\tvalue = (value & mask) | (smsr->values[slot].host & ~mask);\n\tif (value == smsr->values[slot].curr)\n\t\treturn 0;\n\terr = wrmsrl_safe(shared_msrs_global.msrs[slot], value);\n\tif (err)\n\t\treturn 1;\n\n\tsmsr->values[slot].curr = value;\n\tif (!smsr->registered) {\n\t\tsmsr->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&smsr->urn);\n\t\tsmsr->registered = true;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kvm_shared_msrs __percpu *shared_msrs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nint kvm_set_shared_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\tint err;\n\n\tvalue = (value & mask) | (smsr->values[slot].host & ~mask);\n\tif (value == smsr->values[slot].curr)\n\t\treturn 0;\n\terr = wrmsrl_safe(shared_msrs_global.msrs[slot], value);\n\tif (err)\n\t\treturn 1;\n\n\tsmsr->values[slot].curr = value;\n\tif (!smsr->registered) {\n\t\tsmsr->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&smsr->urn);\n\t\tsmsr->registered = true;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid vmx_prepare_switch_to_guest(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs_host_state *host_state;\n#ifdef CONFIG_X86_64\n\tint cpu = raw_smp_processor_id();\n#endif\n\tunsigned long fs_base, gs_base;\n\tu16 fs_sel, gs_sel;\n\tint i;\n\n\tvmx->req_immediate_exit = false;\n\n\t/*\n\t * Note that guest MSRs to be saved/restored can also be changed\n\t * when guest state is loaded. This happens when guest transitions\n\t * to/from long-mode by setting MSR_EFER.LMA.\n\t */\n\tif (!vmx->guest_msrs_ready) {\n\t\tvmx->guest_msrs_ready = true;\n\t\tfor (i = 0; i < vmx->save_nmsrs; ++i)\n\t\t\tkvm_set_shared_msr(vmx->guest_msrs[i].index,\n\t\t\t\t\t   vmx->guest_msrs[i].data,\n\t\t\t\t\t   vmx->guest_msrs[i].mask);\n\n\t}\n\n    \tif (vmx->nested.need_vmcs12_to_shadow_sync)\n\t\tnested_sync_vmcs12_to_shadow(vcpu);\n\n\tif (vmx->guest_state_loaded)\n\t\treturn;\n\n\thost_state = &vmx->loaded_vmcs->host_state;\n\n\t/*\n\t * Set host fs and gs selectors.  Unfortunately, 22.2.3 does not\n\t * allow segment selectors with cpl > 0 or ti == 1.\n\t */\n\thost_state->ldt_sel = kvm_read_ldt();\n\n#ifdef CONFIG_X86_64\n\tsavesegment(ds, host_state->ds_sel);\n\tsavesegment(es, host_state->es_sel);\n\n\tgs_base = cpu_kernelmode_gs_base(cpu);\n\tif (likely(is_64bit_mm(current->mm))) {\n\t\tsave_fsgs_for_kvm();\n\t\tfs_sel = current->thread.fsindex;\n\t\tgs_sel = current->thread.gsindex;\n\t\tfs_base = current->thread.fsbase;\n\t\tvmx->msr_host_kernel_gs_base = current->thread.gsbase;\n\t} else {\n\t\tsavesegment(fs, fs_sel);\n\t\tsavesegment(gs, gs_sel);\n\t\tfs_base = read_msr(MSR_FS_BASE);\n\t\tvmx->msr_host_kernel_gs_base = read_msr(MSR_KERNEL_GS_BASE);\n\t}\n\n\twrmsrl(MSR_KERNEL_GS_BASE, vmx->msr_guest_kernel_gs_base);\n#else\n\tsavesegment(fs, fs_sel);\n\tsavesegment(gs, gs_sel);\n\tfs_base = segment_base(fs_sel);\n\tgs_base = segment_base(gs_sel);\n#endif\n\n\tvmx_set_host_fs_gs(host_state, fs_sel, gs_sel, fs_base, gs_base);\n\tvmx->guest_state_loaded = true;\n}"
  },
  {
    "function_name": "vmx_set_host_fs_gs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1096-1121",
    "snippet": "void vmx_set_host_fs_gs(struct vmcs_host_state *host, u16 fs_sel, u16 gs_sel,\n\t\t\tunsigned long fs_base, unsigned long gs_base)\n{\n\tif (unlikely(fs_sel != host->fs_sel)) {\n\t\tif (!(fs_sel & 7))\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, fs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\thost->fs_sel = fs_sel;\n\t}\n\tif (unlikely(gs_sel != host->gs_sel)) {\n\t\tif (!(gs_sel & 7))\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, gs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\thost->gs_sel = gs_sel;\n\t}\n\tif (unlikely(fs_base != host->fs_base)) {\n\t\tvmcs_writel(HOST_FS_BASE, fs_base);\n\t\thost->fs_base = fs_base;\n\t}\n\tif (unlikely(gs_base != host->gs_base)) {\n\t\tvmcs_writel(HOST_GS_BASE, gs_base);\n\t\thost->gs_base = gs_base;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_writel",
          "args": [
            "HOST_GS_BASE",
            "gs_base"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_writel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "205-212",
          "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gs_base != host->gs_base"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fs_base != host->fs_base"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_write16",
          "args": [
            "HOST_GS_SELECTOR",
            "0"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "175-182",
          "snippet": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gs_sel != host->gs_sel"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fs_sel != host->fs_sel"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid vmx_set_host_fs_gs(struct vmcs_host_state *host, u16 fs_sel, u16 gs_sel,\n\t\t\tunsigned long fs_base, unsigned long gs_base)\n{\n\tif (unlikely(fs_sel != host->fs_sel)) {\n\t\tif (!(fs_sel & 7))\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, fs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_FS_SELECTOR, 0);\n\t\thost->fs_sel = fs_sel;\n\t}\n\tif (unlikely(gs_sel != host->gs_sel)) {\n\t\tif (!(gs_sel & 7))\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, gs_sel);\n\t\telse\n\t\t\tvmcs_write16(HOST_GS_SELECTOR, 0);\n\t\thost->gs_sel = gs_sel;\n\t}\n\tif (unlikely(fs_base != host->fs_base)) {\n\t\tvmcs_writel(HOST_FS_BASE, fs_base);\n\t\thost->fs_base = fs_base;\n\t}\n\tif (unlikely(gs_base != host->gs_base)) {\n\t\tvmcs_writel(HOST_GS_BASE, gs_base);\n\t\thost->gs_base = gs_base;\n\t}\n}"
  },
  {
    "function_name": "pt_guest_exit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1082-1094",
    "snippet": "static void pt_guest_exit(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\tpt_save_msr(&vmx->pt_desc.guest, vmx->pt_desc.addr_range);\n\t\tpt_load_msr(&vmx->pt_desc.host, vmx->pt_desc.addr_range);\n\t}\n\n\t/* Reload host state (IA32_RTIT_CTL will be cleared on VM exit). */\n\twrmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_RTIT_CTL",
            "vmx->pt_desc.host.ctl"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pt_load_msr",
          "args": [
            "&vmx->pt_desc.host",
            "vmx->pt_desc.addr_range"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "pt_load_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1037-1049",
          "snippet": "static inline void pt_load_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\twrmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\twrmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline void pt_load_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\twrmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\twrmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pt_save_msr",
          "args": [
            "&vmx->pt_desc.guest",
            "vmx->pt_desc.addr_range"
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "pt_save_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1051-1063",
          "snippet": "static inline void pt_save_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\trdmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\trdmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline void pt_save_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\trdmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\trdmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_pt_mode_is_system",
          "args": [],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_pt_mode_is_system",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "361-364",
          "snippet": "static inline bool vmx_pt_mode_is_system(void)\n{\n\treturn pt_mode == PT_MODE_SYSTEM;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [
            "#define PT_MODE_SYSTEM\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\n#define PT_MODE_SYSTEM\t\t0\n\nstatic inline bool vmx_pt_mode_is_system(void)\n{\n\treturn pt_mode == PT_MODE_SYSTEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void pt_guest_exit(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\tpt_save_msr(&vmx->pt_desc.guest, vmx->pt_desc.addr_range);\n\t\tpt_load_msr(&vmx->pt_desc.host, vmx->pt_desc.addr_range);\n\t}\n\n\t/* Reload host state (IA32_RTIT_CTL will be cleared on VM exit). */\n\twrmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n}"
  },
  {
    "function_name": "pt_guest_enter",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1065-1080",
    "snippet": "static void pt_guest_enter(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\t/*\n\t * GUEST_IA32_RTIT_CTL is already set in the VMCS.\n\t * Save host state before VM entry.\n\t */\n\trdmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\twrmsrl(MSR_IA32_RTIT_CTL, 0);\n\t\tpt_save_msr(&vmx->pt_desc.host, vmx->pt_desc.addr_range);\n\t\tpt_load_msr(&vmx->pt_desc.guest, vmx->pt_desc.addr_range);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pt_load_msr",
          "args": [
            "&vmx->pt_desc.guest",
            "vmx->pt_desc.addr_range"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "pt_load_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1037-1049",
          "snippet": "static inline void pt_load_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\twrmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\twrmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline void pt_load_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\twrmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\twrmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pt_save_msr",
          "args": [
            "&vmx->pt_desc.host",
            "vmx->pt_desc.addr_range"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "pt_save_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1051-1063",
          "snippet": "static inline void pt_save_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\trdmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\trdmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline void pt_save_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\trdmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\trdmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_RTIT_CTL",
            "0"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_RTIT_CTL",
            "vmx->pt_desc.host.ctl"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_pt_mode_is_system",
          "args": [],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_pt_mode_is_system",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "361-364",
          "snippet": "static inline bool vmx_pt_mode_is_system(void)\n{\n\treturn pt_mode == PT_MODE_SYSTEM;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [
            "#define PT_MODE_SYSTEM\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\n#define PT_MODE_SYSTEM\t\t0\n\nstatic inline bool vmx_pt_mode_is_system(void)\n{\n\treturn pt_mode == PT_MODE_SYSTEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void pt_guest_enter(struct vcpu_vmx *vmx)\n{\n\tif (vmx_pt_mode_is_system())\n\t\treturn;\n\n\t/*\n\t * GUEST_IA32_RTIT_CTL is already set in the VMCS.\n\t * Save host state before VM entry.\n\t */\n\trdmsrl(MSR_IA32_RTIT_CTL, vmx->pt_desc.host.ctl);\n\tif (vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN) {\n\t\twrmsrl(MSR_IA32_RTIT_CTL, 0);\n\t\tpt_save_msr(&vmx->pt_desc.host, vmx->pt_desc.addr_range);\n\t\tpt_load_msr(&vmx->pt_desc.guest, vmx->pt_desc.addr_range);\n\t}\n}"
  },
  {
    "function_name": "pt_save_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1051-1063",
    "snippet": "static inline void pt_save_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\trdmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\trdmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_RTIT_ADDR0_B + i * 2",
            "ctx->addr_b[i]"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_RTIT_ADDR0_A + i * 2",
            "ctx->addr_a[i]"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_RTIT_CR3_MATCH",
            "ctx->cr3_match"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_RTIT_OUTPUT_MASK",
            "ctx->output_mask"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_RTIT_OUTPUT_BASE",
            "ctx->output_base"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_RTIT_STATUS",
            "ctx->status"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline void pt_save_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\trdmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\trdmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\trdmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\trdmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}"
  },
  {
    "function_name": "pt_load_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1037-1049",
    "snippet": "static inline void pt_load_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\twrmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\twrmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_RTIT_ADDR0_B + i * 2",
            "ctx->addr_b[i]"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_RTIT_ADDR0_A + i * 2",
            "ctx->addr_a[i]"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_RTIT_CR3_MATCH",
            "ctx->cr3_match"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_RTIT_OUTPUT_MASK",
            "ctx->output_mask"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_RTIT_OUTPUT_BASE",
            "ctx->output_base"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_RTIT_STATUS",
            "ctx->status"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline void pt_load_msr(struct pt_ctx *ctx, u32 addr_range)\n{\n\tu32 i;\n\n\twrmsrl(MSR_IA32_RTIT_STATUS, ctx->status);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_BASE, ctx->output_base);\n\twrmsrl(MSR_IA32_RTIT_OUTPUT_MASK, ctx->output_mask);\n\twrmsrl(MSR_IA32_RTIT_CR3_MATCH, ctx->cr3_match);\n\tfor (i = 0; i < addr_range; i++) {\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_A + i * 2, ctx->addr_a[i]);\n\t\twrmsrl(MSR_IA32_RTIT_ADDR0_B + i * 2, ctx->addr_b[i]);\n\t}\n}"
  },
  {
    "function_name": "pt_can_write_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1031-1035",
    "snippet": "static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)\n{\n\treturn vmx_pt_mode_is_host_guest() &&\n\t       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_pt_mode_is_host_guest",
          "args": [],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_pt_mode_is_host_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "365-368",
          "snippet": "static inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [
            "#define PT_MODE_HOST_GUEST\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\n#define PT_MODE_HOST_GUEST\t1\n\nstatic inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline bool pt_can_write_msr(struct vcpu_vmx *vmx)\n{\n\treturn vmx_pt_mode_is_host_guest() &&\n\t       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);\n}"
  },
  {
    "function_name": "segment_base",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "1008-1028",
    "snippet": "static unsigned long segment_base(u16 selector)\n{\n\tstruct desc_struct *table;\n\tunsigned long v;\n\n\tif (!(selector & ~SEGMENT_RPL_MASK))\n\t\treturn 0;\n\n\ttable = get_current_gdt_ro();\n\n\tif ((selector & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tu16 ldt_selector = kvm_read_ldt();\n\n\t\tif (!(ldt_selector & ~SEGMENT_RPL_MASK))\n\t\t\treturn 0;\n\n\t\ttable = (struct desc_struct *)segment_base(ldt_selector);\n\t}\n\tv = get_desc_base(&table[selector >> 3]);\n\treturn v;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_desc_base",
          "args": [
            "&table[selector >> 3]"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "segment_base",
          "args": [
            "ldt_selector"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "segment_base",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1008-1028",
          "snippet": "static unsigned long segment_base(u16 selector)\n{\n\tstruct desc_struct *table;\n\tunsigned long v;\n\n\tif (!(selector & ~SEGMENT_RPL_MASK))\n\t\treturn 0;\n\n\ttable = get_current_gdt_ro();\n\n\tif ((selector & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tu16 ldt_selector = kvm_read_ldt();\n\n\t\tif (!(ldt_selector & ~SEGMENT_RPL_MASK))\n\t\t\treturn 0;\n\n\t\ttable = (struct desc_struct *)segment_base(ldt_selector);\n\t}\n\tv = get_desc_base(&table[selector >> 3]);\n\treturn v;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_ldt",
          "args": [],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_gdt_ro",
          "args": [],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic unsigned long segment_base(u16 selector)\n{\n\tstruct desc_struct *table;\n\tunsigned long v;\n\n\tif (!(selector & ~SEGMENT_RPL_MASK))\n\t\treturn 0;\n\n\ttable = get_current_gdt_ro();\n\n\tif ((selector & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tu16 ldt_selector = kvm_read_ldt();\n\n\t\tif (!(ldt_selector & ~SEGMENT_RPL_MASK))\n\t\t\treturn 0;\n\n\t\ttable = (struct desc_struct *)segment_base(ldt_selector);\n\t}\n\tv = get_desc_base(&table[selector >> 3]);\n\treturn v;\n}"
  },
  {
    "function_name": "update_transition_efer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "954-1000",
    "snippet": "static bool update_transition_efer(struct vcpu_vmx *vmx, int efer_offset)\n{\n\tu64 guest_efer = vmx->vcpu.arch.efer;\n\tu64 ignore_bits = 0;\n\n\t/* Shadow paging assumes NX to be available.  */\n\tif (!enable_ept)\n\t\tguest_efer |= EFER_NX;\n\n\t/*\n\t * LMA and LME handled by hardware; SCE meaningless outside long mode.\n\t */\n\tignore_bits |= EFER_SCE;\n#ifdef CONFIG_X86_64\n\tignore_bits |= EFER_LMA | EFER_LME;\n\t/* SCE is meaningful only in long mode on Intel */\n\tif (guest_efer & EFER_LMA)\n\t\tignore_bits &= ~(u64)EFER_SCE;\n#endif\n\n\t/*\n\t * On EPT, we can't emulate NX, so we must switch EFER atomically.\n\t * On CPUs that support \"load IA32_EFER\", always switch EFER\n\t * atomically, since it's faster than switching it manually.\n\t */\n\tif (cpu_has_load_ia32_efer() ||\n\t    (enable_ept && ((vmx->vcpu.arch.efer ^ host_efer) & EFER_NX))) {\n\t\tif (!(guest_efer & EFER_LMA))\n\t\t\tguest_efer &= ~EFER_LME;\n\t\tif (guest_efer != host_efer)\n\t\t\tadd_atomic_switch_msr(vmx, MSR_EFER,\n\t\t\t\t\t      guest_efer, host_efer, false);\n\t\telse\n\t\t\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\t\treturn false;\n\t} else {\n\t\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\n\t\tguest_efer &= ~ignore_bits;\n\t\tguest_efer |= host_efer & ignore_bits;\n\n\t\tvmx->guest_msrs[efer_offset].data = guest_efer;\n\t\tvmx->guest_msrs[efer_offset].mask = ~ignore_bits;\n\n\t\treturn true;\n\t}\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_atomic_switch_msr",
          "args": [
            "vmx",
            "MSR_EFER"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "clear_atomic_switch_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "836-874",
          "snippet": "static void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tint i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (i < 0)\n\t\tgoto skip_guest;\n\t--m->guest.nr;\n\tm->guest.val[i] = m->guest.val[m->guest.nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\nskip_guest:\n\ti = vmx_find_msr_index(&m->host, msr);\n\tif (i < 0)\n\t\treturn;\n\n\t--m->host.nr;\n\tm->host.val[i] = m->host.val[m->host.nr];\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tint i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (i < 0)\n\t\tgoto skip_guest;\n\t--m->guest.nr;\n\tm->guest.val[i] = m->guest.val[m->guest.nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\nskip_guest:\n\ti = vmx_find_msr_index(&m->host, msr);\n\tif (i < 0)\n\t\treturn;\n\n\t--m->host.nr;\n\tm->host.val[i] = m->host.val[m->host.nr];\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_atomic_switch_msr",
          "args": [
            "vmx",
            "MSR_EFER",
            "guest_efer",
            "host_efer",
            "false"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "add_atomic_switch_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "888-952",
          "snippet": "static void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val, bool entry_only)\n{\n\tint i, j = 0;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (!entry_only)\n\t\tj = vmx_find_msr_index(&m->host, msr);\n\n\tif ((i < 0 && m->guest.nr == NR_LOADSTORE_MSRS) ||\n\t\t(j < 0 &&  m->host.nr == NR_LOADSTORE_MSRS)) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t}\n\tif (i < 0) {\n\t\ti = m->guest.nr++;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\t}\n\tm->guest.val[i].index = msr;\n\tm->guest.val[i].value = guest_val;\n\n\tif (entry_only)\n\t\treturn;\n\n\tif (j < 0) {\n\t\tj = m->host.nr++;\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n\t}\n\tm->host.val[j].index = msr;\n\tm->host.val[j].value = host_val;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val, bool entry_only)\n{\n\tint i, j = 0;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (!entry_only)\n\t\tj = vmx_find_msr_index(&m->host, msr);\n\n\tif ((i < 0 && m->guest.nr == NR_LOADSTORE_MSRS) ||\n\t\t(j < 0 &&  m->host.nr == NR_LOADSTORE_MSRS)) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t}\n\tif (i < 0) {\n\t\ti = m->guest.nr++;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\t}\n\tm->guest.val[i].index = msr;\n\tm->guest.val[i].value = guest_val;\n\n\tif (entry_only)\n\t\treturn;\n\n\tif (j < 0) {\n\t\tj = m->host.nr++;\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n\t}\n\tm->host.val[j].index = msr;\n\tm->host.val[j].value = host_val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_load_ia32_efer",
          "args": [],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_load_ia32_efer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "92-96",
          "snippet": "static inline bool cpu_has_load_ia32_efer(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_EFER) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_EFER);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_load_ia32_efer(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_EFER) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_EFER);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool update_transition_efer(struct vcpu_vmx *vmx, int efer_offset)\n{\n\tu64 guest_efer = vmx->vcpu.arch.efer;\n\tu64 ignore_bits = 0;\n\n\t/* Shadow paging assumes NX to be available.  */\n\tif (!enable_ept)\n\t\tguest_efer |= EFER_NX;\n\n\t/*\n\t * LMA and LME handled by hardware; SCE meaningless outside long mode.\n\t */\n\tignore_bits |= EFER_SCE;\n#ifdef CONFIG_X86_64\n\tignore_bits |= EFER_LMA | EFER_LME;\n\t/* SCE is meaningful only in long mode on Intel */\n\tif (guest_efer & EFER_LMA)\n\t\tignore_bits &= ~(u64)EFER_SCE;\n#endif\n\n\t/*\n\t * On EPT, we can't emulate NX, so we must switch EFER atomically.\n\t * On CPUs that support \"load IA32_EFER\", always switch EFER\n\t * atomically, since it's faster than switching it manually.\n\t */\n\tif (cpu_has_load_ia32_efer() ||\n\t    (enable_ept && ((vmx->vcpu.arch.efer ^ host_efer) & EFER_NX))) {\n\t\tif (!(guest_efer & EFER_LMA))\n\t\t\tguest_efer &= ~EFER_LME;\n\t\tif (guest_efer != host_efer)\n\t\t\tadd_atomic_switch_msr(vmx, MSR_EFER,\n\t\t\t\t\t      guest_efer, host_efer, false);\n\t\telse\n\t\t\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\t\treturn false;\n\t} else {\n\t\tclear_atomic_switch_msr(vmx, MSR_EFER);\n\n\t\tguest_efer &= ~ignore_bits;\n\t\tguest_efer |= host_efer & ignore_bits;\n\n\t\tvmx->guest_msrs[efer_offset].data = guest_efer;\n\t\tvmx->guest_msrs[efer_offset].mask = ~ignore_bits;\n\n\t\treturn true;\n\t}\n}"
  },
  {
    "function_name": "add_atomic_switch_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "888-952",
    "snippet": "static void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val, bool entry_only)\n{\n\tint i, j = 0;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (!entry_only)\n\t\tj = vmx_find_msr_index(&m->host, msr);\n\n\tif ((i < 0 && m->guest.nr == NR_LOADSTORE_MSRS) ||\n\t\t(j < 0 &&  m->host.nr == NR_LOADSTORE_MSRS)) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t}\n\tif (i < 0) {\n\t\ti = m->guest.nr++;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\t}\n\tm->guest.val[i].index = msr;\n\tm->guest.val[i].value = guest_val;\n\n\tif (entry_only)\n\t\treturn;\n\n\tif (j < 0) {\n\t\tj = m->host.nr++;\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n\t}\n\tm->host.val[j].index = msr;\n\tm->host.val[j].value = host_val;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "VM_EXIT_MSR_LOAD_COUNT",
            "m->host.nr"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\"",
            "msr"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_find_msr_index",
          "args": [
            "&m->host",
            "msr"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_find_msr_index",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "825-834",
          "snippet": "int vmx_find_msr_index(struct vmx_msrs *m, u32 msr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < m->nr; ++i) {\n\t\tif (m->val[i].index == msr)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nint vmx_find_msr_index(struct vmx_msrs *m, u32 msr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < m->nr; ++i) {\n\t\tif (m->val[i].index == msr)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_PEBS_ENABLE",
            "0"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_atomic_switch_msr_special",
          "args": [
            "vmx",
            "VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL",
            "VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL",
            "GUEST_IA32_PERF_GLOBAL_CTRL",
            "HOST_IA32_PERF_GLOBAL_CTRL",
            "guest_val",
            "host_val"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "add_atomic_switch_msr_special",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "876-886",
          "snippet": "static void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit,\n\t\tunsigned long guest_val_vmcs, unsigned long host_val_vmcs,\n\t\tu64 guest_val, u64 host_val)\n{\n\tvmcs_write64(guest_val_vmcs, guest_val);\n\tif (host_val_vmcs != HOST_IA32_EFER)\n\t\tvmcs_write64(host_val_vmcs, host_val);\n\tvm_entry_controls_setbit(vmx, entry);\n\tvm_exit_controls_setbit(vmx, exit);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit,\n\t\tunsigned long guest_val_vmcs, unsigned long host_val_vmcs,\n\t\tu64 guest_val, u64 host_val)\n{\n\tvmcs_write64(guest_val_vmcs, guest_val);\n\tif (host_val_vmcs != HOST_IA32_EFER)\n\t\tvmcs_write64(host_val_vmcs, host_val);\n\tvm_entry_controls_setbit(vmx, entry);\n\tvm_exit_controls_setbit(vmx, exit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_load_perf_global_ctrl",
          "args": [],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_load_perf_global_ctrl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "98-102",
          "snippet": "static inline bool cpu_has_load_perf_global_ctrl(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_load_perf_global_ctrl(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_load_ia32_efer",
          "args": [],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_load_ia32_efer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "92-96",
          "snippet": "static inline bool cpu_has_load_ia32_efer(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_EFER) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_EFER);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_load_ia32_efer(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_EFER) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_EFER);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void add_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr,\n\t\t\t\t  u64 guest_val, u64 host_val, bool entry_only)\n{\n\tint i, j = 0;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER,\n\t\t\t\t\tGUEST_IA32_EFER,\n\t\t\t\t\tHOST_IA32_EFER,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tadd_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tGUEST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tHOST_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tguest_val, host_val);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_PEBS_ENABLE:\n\t\t/* PEBS needs a quiescent period after being disabled (to write\n\t\t * a record).  Disabling PEBS through VMX MSR swapping doesn't\n\t\t * provide that period, so a CPU could write host's record into\n\t\t * guest's memory.\n\t\t */\n\t\twrmsrl(MSR_IA32_PEBS_ENABLE, 0);\n\t}\n\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (!entry_only)\n\t\tj = vmx_find_msr_index(&m->host, msr);\n\n\tif ((i < 0 && m->guest.nr == NR_LOADSTORE_MSRS) ||\n\t\t(j < 0 &&  m->host.nr == NR_LOADSTORE_MSRS)) {\n\t\tprintk_once(KERN_WARNING \"Not enough msr switch entries. \"\n\t\t\t\t\"Can't add msr %x\\n\", msr);\n\t\treturn;\n\t}\n\tif (i < 0) {\n\t\ti = m->guest.nr++;\n\t\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\t}\n\tm->guest.val[i].index = msr;\n\tm->guest.val[i].value = guest_val;\n\n\tif (entry_only)\n\t\treturn;\n\n\tif (j < 0) {\n\t\tj = m->host.nr++;\n\t\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n\t}\n\tm->host.val[j].index = msr;\n\tm->host.val[j].value = host_val;\n}"
  },
  {
    "function_name": "add_atomic_switch_msr_special",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "876-886",
    "snippet": "static void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit,\n\t\tunsigned long guest_val_vmcs, unsigned long host_val_vmcs,\n\t\tu64 guest_val, u64 host_val)\n{\n\tvmcs_write64(guest_val_vmcs, guest_val);\n\tif (host_val_vmcs != HOST_IA32_EFER)\n\t\tvmcs_write64(host_val_vmcs, host_val);\n\tvm_entry_controls_setbit(vmx, entry);\n\tvm_exit_controls_setbit(vmx, exit);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_exit_controls_setbit",
          "args": [
            "vmx",
            "exit"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_entry_controls_setbit",
          "args": [
            "vmx",
            "entry"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_write64",
          "args": [
            "host_val_vmcs",
            "host_val"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "193-203",
          "snippet": "static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void add_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit,\n\t\tunsigned long guest_val_vmcs, unsigned long host_val_vmcs,\n\t\tu64 guest_val, u64 host_val)\n{\n\tvmcs_write64(guest_val_vmcs, guest_val);\n\tif (host_val_vmcs != HOST_IA32_EFER)\n\t\tvmcs_write64(host_val_vmcs, host_val);\n\tvm_entry_controls_setbit(vmx, entry);\n\tvm_exit_controls_setbit(vmx, exit);\n}"
  },
  {
    "function_name": "clear_atomic_switch_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "836-874",
    "snippet": "static void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tint i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (i < 0)\n\t\tgoto skip_guest;\n\t--m->guest.nr;\n\tm->guest.val[i] = m->guest.val[m->guest.nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\nskip_guest:\n\ti = vmx_find_msr_index(&m->host, msr);\n\tif (i < 0)\n\t\treturn;\n\n\t--m->host.nr;\n\tm->host.val[i] = m->host.val[m->host.nr];\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "VM_EXIT_MSR_LOAD_COUNT",
            "m->host.nr"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_find_msr_index",
          "args": [
            "&m->host",
            "msr"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_find_msr_index",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "825-834",
          "snippet": "int vmx_find_msr_index(struct vmx_msrs *m, u32 msr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < m->nr; ++i) {\n\t\tif (m->val[i].index == msr)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nint vmx_find_msr_index(struct vmx_msrs *m, u32 msr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < m->nr; ++i) {\n\t\tif (m->val[i].index == msr)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_atomic_switch_msr_special",
          "args": [
            "vmx",
            "VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL",
            "VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "clear_atomic_switch_msr_special",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "818-823",
          "snippet": "static void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit)\n{\n\tvm_entry_controls_clearbit(vmx, entry);\n\tvm_exit_controls_clearbit(vmx, exit);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit)\n{\n\tvm_entry_controls_clearbit(vmx, entry);\n\tvm_exit_controls_clearbit(vmx, exit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_load_perf_global_ctrl",
          "args": [],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_load_perf_global_ctrl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "98-102",
          "snippet": "static inline bool cpu_has_load_perf_global_ctrl(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_load_perf_global_ctrl(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_load_ia32_efer",
          "args": [],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_load_ia32_efer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "92-96",
          "snippet": "static inline bool cpu_has_load_ia32_efer(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_EFER) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_EFER);\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_load_ia32_efer(void)\n{\n\treturn (vmcs_config.vmentry_ctrl & VM_ENTRY_LOAD_IA32_EFER) &&\n\t       (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_EFER);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void clear_atomic_switch_msr(struct vcpu_vmx *vmx, unsigned msr)\n{\n\tint i;\n\tstruct msr_autoload *m = &vmx->msr_autoload;\n\n\tswitch (msr) {\n\tcase MSR_EFER:\n\t\tif (cpu_has_load_ia32_efer()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_EFER,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_EFER);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (cpu_has_load_perf_global_ctrl()) {\n\t\t\tclear_atomic_switch_msr_special(vmx,\n\t\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL,\n\t\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL);\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n\ti = vmx_find_msr_index(&m->guest, msr);\n\tif (i < 0)\n\t\tgoto skip_guest;\n\t--m->guest.nr;\n\tm->guest.val[i] = m->guest.val[m->guest.nr];\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, m->guest.nr);\n\nskip_guest:\n\ti = vmx_find_msr_index(&m->host, msr);\n\tif (i < 0)\n\t\treturn;\n\n\t--m->host.nr;\n\tm->host.val[i] = m->host.val[m->host.nr];\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, m->host.nr);\n}"
  },
  {
    "function_name": "vmx_find_msr_index",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "825-834",
    "snippet": "int vmx_find_msr_index(struct vmx_msrs *m, u32 msr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < m->nr; ++i) {\n\t\tif (m->val[i].index == msr)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nint vmx_find_msr_index(struct vmx_msrs *m, u32 msr)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < m->nr; ++i) {\n\t\tif (m->val[i].index == msr)\n\t\t\treturn i;\n\t}\n\treturn -ENOENT;\n}"
  },
  {
    "function_name": "clear_atomic_switch_msr_special",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "818-823",
    "snippet": "static void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit)\n{\n\tvm_entry_controls_clearbit(vmx, entry);\n\tvm_exit_controls_clearbit(vmx, exit);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vm_exit_controls_clearbit",
          "args": [
            "vmx",
            "exit"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vm_entry_controls_clearbit",
          "args": [
            "vmx",
            "entry"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic void clear_atomic_switch_msr_special(struct vcpu_vmx *vmx,\n\t\tunsigned long entry, unsigned long exit)\n{\n\tvm_entry_controls_clearbit(vmx, entry);\n\tvm_exit_controls_clearbit(vmx, exit);\n}"
  },
  {
    "function_name": "msr_write_intercepted",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "798-816",
    "snippet": "static bool msr_write_intercepted(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tunsigned long *msr_bitmap;\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn true;\n\n\tmsr_bitmap = to_vmx(vcpu)->loaded_vmcs->msr_bitmap;\n\n\tif (msr <= 0x1fff) {\n\t\treturn !!test_bit(msr, msr_bitmap + 0x800 / f);\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\treturn !!test_bit(msr, msr_bitmap + 0xc00 / f);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "msr",
            "msr_bitmap + 0xc00 / f"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "msr",
            "msr_bitmap + 0x800 / f"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_msr_bitmap",
          "args": [],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_msr_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "120-123",
          "snippet": "static inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_msr_bitmap(void)\n{\n\treturn vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool msr_write_intercepted(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tunsigned long *msr_bitmap;\n\tint f = sizeof(unsigned long);\n\n\tif (!cpu_has_vmx_msr_bitmap())\n\t\treturn true;\n\n\tmsr_bitmap = to_vmx(vcpu)->loaded_vmcs->msr_bitmap;\n\n\tif (msr <= 0x1fff) {\n\t\treturn !!test_bit(msr, msr_bitmap + 0x800 / f);\n\t} else if ((msr >= 0xc0000000) && (msr <= 0xc0001fff)) {\n\t\tmsr &= 0x1fff;\n\t\treturn !!test_bit(msr, msr_bitmap + 0xc00 / f);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "update_exception_bitmap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "761-793",
    "snippet": "void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\teb |= (1u << GP_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_write32",
          "args": [
            "EXCEPTION_BITMAP",
            "eb"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "184-191",
          "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 790
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool __read_mostly nested = 1;\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nvoid update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n\tu32 eb;\n\n\teb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n\t     (1u << DB_VECTOR) | (1u << AC_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\teb |= (1u << GP_VECTOR);\n\tif ((vcpu->guest_debug &\n\t     (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n\t    (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n\t\teb |= 1u << BP_VECTOR;\n\tif (to_vmx(vcpu)->rmode.vm86_active)\n\t\teb = ~0;\n\tif (enable_ept)\n\t\teb &= ~(1u << PF_VECTOR);\n\n\t/* When we are running a nested L2 guest and L1 specified for it a\n\t * certain exception bitmap, we must trap the same exceptions and pass\n\t * them to L1. When running L2, we will only handle the exceptions\n\t * specified above if L1 did not want them.\n\t */\n\tif (is_guest_mode(vcpu))\n\t\teb |= get_vmcs12(vcpu)->exception_bitmap;\n\n\tvmcs_write32(EXCEPTION_BITMAP, eb);\n}"
  },
  {
    "function_name": "vmx_read_guest_seg_ar",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "752-759",
    "snippet": "static u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "kvm_vmx_segment_fields[seg].ar_bytes"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_segment_cache_test_set",
          "args": [
            "vmx",
            "seg",
            "SEG_FIELD_AR"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_cache_test_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "710-723",
          "snippet": "static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u32 vmx_read_guest_seg_ar(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].ar;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_AR))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].ar_bytes);\n\treturn *p;\n}"
  },
  {
    "function_name": "vmx_read_guest_seg_limit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "743-750",
    "snippet": "static u32 vmx_read_guest_seg_limit(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].limit;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_LIMIT))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].limit);\n\treturn *p;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "kvm_vmx_segment_fields[seg].limit"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_segment_cache_test_set",
          "args": [
            "vmx",
            "seg",
            "SEG_FIELD_LIMIT"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_cache_test_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "710-723",
          "snippet": "static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u32 vmx_read_guest_seg_limit(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu32 *p = &vmx->segment_cache.seg[seg].limit;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_LIMIT))\n\t\t*p = vmcs_read32(kvm_vmx_segment_fields[seg].limit);\n\treturn *p;\n}"
  },
  {
    "function_name": "vmx_read_guest_seg_base",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "734-741",
    "snippet": "static ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "kvm_vmx_segment_fields[seg].base"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_segment_cache_test_set",
          "args": [
            "vmx",
            "seg",
            "SEG_FIELD_BASE"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_cache_test_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "710-723",
          "snippet": "static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic ulong vmx_read_guest_seg_base(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tulong *p = &vmx->segment_cache.seg[seg].base;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_BASE))\n\t\t*p = vmcs_readl(kvm_vmx_segment_fields[seg].base);\n\treturn *p;\n}"
  },
  {
    "function_name": "vmx_read_guest_seg_selector",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "725-732",
    "snippet": "static u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu16 *p = &vmx->segment_cache.seg[seg].selector;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_SEL))\n\t\t*p = vmcs_read16(kvm_vmx_segment_fields[seg].selector);\n\treturn *p;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_read16",
          "args": [
            "kvm_vmx_segment_fields[seg].selector"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "104-110",
          "snippet": "static __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_segment_cache_test_set",
          "args": [
            "vmx",
            "seg",
            "SEG_FIELD_SEL"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_segment_cache_test_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "710-723",
          "snippet": "static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct kvm_vmx_segment_field {\n\tunsigned selector;\n\tunsigned base;\n\tunsigned limit;\n\tunsigned ar_bytes;\n} kvm_vmx_segment_fields[] = {\n\tVMX_SEGMENT_FIELD(CS),\n\tVMX_SEGMENT_FIELD(DS),\n\tVMX_SEGMENT_FIELD(ES),\n\tVMX_SEGMENT_FIELD(FS),\n\tVMX_SEGMENT_FIELD(GS),\n\tVMX_SEGMENT_FIELD(SS),\n\tVMX_SEGMENT_FIELD(TR),\n\tVMX_SEGMENT_FIELD(LDTR),\n};\n\nstatic u16 vmx_read_guest_seg_selector(struct vcpu_vmx *vmx, unsigned seg)\n{\n\tu16 *p = &vmx->segment_cache.seg[seg].selector;\n\n\tif (!vmx_segment_cache_test_set(vmx, seg, SEG_FIELD_SEL))\n\t\t*p = vmcs_read16(kvm_vmx_segment_fields[seg].selector);\n\treturn *p;\n}"
  },
  {
    "function_name": "vmx_segment_cache_test_set",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "710-723",
    "snippet": "static bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_register_mark_available",
          "args": [
            "&vmx->vcpu",
            "VCPU_EXREG_SEGMENTS"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_mark_available",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "52-56",
          "snippet": "static inline void kvm_register_mark_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_mark_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t       enum kvm_reg reg)\n{\n\t__set_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_is_available",
          "args": [
            "&vmx->vcpu",
            "VCPU_EXREG_SEGMENTS"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_is_available",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "40-44",
          "snippet": "static inline bool kvm_register_is_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     enum kvm_reg reg)\n{\n\treturn test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool kvm_register_is_available(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     enum kvm_reg reg)\n{\n\treturn test_bit(reg, (unsigned long *)&vcpu->arch.regs_avail);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic bool vmx_segment_cache_test_set(struct vcpu_vmx *vmx, unsigned seg,\n\t\t\t\t       unsigned field)\n{\n\tbool ret;\n\tu32 mask = 1 << (seg * SEG_FIELD_NR + field);\n\n\tif (!kvm_register_is_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS)) {\n\t\tkvm_register_mark_available(&vmx->vcpu, VCPU_EXREG_SEGMENTS);\n\t\tvmx->segment_cache.bitmask = 0;\n\t}\n\tret = vmx->segment_cache.bitmask & mask;\n\tvmx->segment_cache.bitmask |= mask;\n\treturn ret;\n}"
  },
  {
    "function_name": "loaded_vmcs_clear",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "701-708",
    "snippet": "void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_call_function_single",
          "args": [
            "cpu",
            "__loaded_vmcs_clear",
            "loaded_vmcs",
            "1"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}"
  },
  {
    "function_name": "__loaded_vmcs_clear",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "672-699",
    "snippet": "static void __loaded_vmcs_clear(void *arg)\n{\n\tstruct loaded_vmcs *loaded_vmcs = arg;\n\tint cpu = raw_smp_processor_id();\n\n\tif (loaded_vmcs->cpu != cpu)\n\t\treturn; /* vcpu migration can race with cpu offline */\n\tif (per_cpu(current_vmcs, cpu) == loaded_vmcs->vmcs)\n\t\tper_cpu(current_vmcs, cpu) = NULL;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\tif (loaded_vmcs->shadow_vmcs && loaded_vmcs->launched)\n\t\tvmcs_clear(loaded_vmcs->shadow_vmcs);\n\n\tlist_del(&loaded_vmcs->loaded_vmcss_on_cpu_link);\n\n\t/*\n\t * Ensure all writes to loaded_vmcs, including deleting it from its\n\t * current percpu list, complete before setting loaded_vmcs->vcpu to\n\t * -1, otherwise a different cpu can see vcpu == -1 first and add\n\t * loaded_vmcs to its percpu list before it's deleted from this cpu's\n\t * list. Pairs with the smp_rmb() in vmx_vcpu_load_vmcs().\n\t */\n\tsmp_wmb();\n\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(struct vmcs *, vmxarea);\nDEFINE_PER_CPU(struct vmcs *, current_vmcs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&loaded_vmcs->loaded_vmcss_on_cpu_link"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_clear",
          "args": [
            "loaded_vmcs->shadow_vmcs"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "loaded_vmcs_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "701-708",
          "snippet": "void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "current_vmcs",
            "cpu"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "current_vmcs",
            "cpu"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct vmcs *, vmxarea);\nDEFINE_PER_CPU(struct vmcs *, current_vmcs);\n\nstatic void __loaded_vmcs_clear(void *arg)\n{\n\tstruct loaded_vmcs *loaded_vmcs = arg;\n\tint cpu = raw_smp_processor_id();\n\n\tif (loaded_vmcs->cpu != cpu)\n\t\treturn; /* vcpu migration can race with cpu offline */\n\tif (per_cpu(current_vmcs, cpu) == loaded_vmcs->vmcs)\n\t\tper_cpu(current_vmcs, cpu) = NULL;\n\n\tvmcs_clear(loaded_vmcs->vmcs);\n\tif (loaded_vmcs->shadow_vmcs && loaded_vmcs->launched)\n\t\tvmcs_clear(loaded_vmcs->shadow_vmcs);\n\n\tlist_del(&loaded_vmcs->loaded_vmcss_on_cpu_link);\n\n\t/*\n\t * Ensure all writes to loaded_vmcs, including deleting it from its\n\t * current percpu list, complete before setting loaded_vmcs->vcpu to\n\t * -1, otherwise a different cpu can see vcpu == -1 first and add\n\t * loaded_vmcs to its percpu list before it's deleted from this cpu's\n\t * list. Pairs with the smp_rmb() in vmx_vcpu_load_vmcs().\n\t */\n\tsmp_wmb();\n\n\tloaded_vmcs->cpu = -1;\n\tloaded_vmcs->launched = 0;\n}"
  },
  {
    "function_name": "crash_vmclear_local_loaded_vmcss",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "661-669",
    "snippet": "static void crash_vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v;\n\n\tlist_for_each_entry(v, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t    loaded_vmcss_on_cpu_link)\n\t\tvmcs_clear(v->vmcs);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmcs_clear",
          "args": [
            "v->vmcs"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "loaded_vmcs_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "701-708",
          "snippet": "void loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nvoid loaded_vmcs_clear(struct loaded_vmcs *loaded_vmcs)\n{\n\tint cpu = loaded_vmcs->cpu;\n\n\tif (cpu != -1)\n\t\tsmp_call_function_single(cpu,\n\t\t\t __loaded_vmcs_clear, loaded_vmcs, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "v",
            "&per_cpu(loaded_vmcss_on_cpu, cpu)",
            "loaded_vmcss_on_cpu_link"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "loaded_vmcss_on_cpu",
            "cpu"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic DEFINE_PER_CPU(struct list_head, loaded_vmcss_on_cpu);\n\nstatic void crash_vmclear_local_loaded_vmcss(void)\n{\n\tint cpu = raw_smp_processor_id();\n\tstruct loaded_vmcs *v;\n\n\tlist_for_each_entry(v, &per_cpu(loaded_vmcss_on_cpu, cpu),\n\t\t\t    loaded_vmcss_on_cpu_link)\n\t\tvmcs_clear(v->vmcs);\n}"
  },
  {
    "function_name": "vmx_set_guest_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "643-658",
    "snippet": "static int vmx_set_guest_msr(struct vcpu_vmx *vmx, struct shared_msr_entry *msr, u64 data)\n{\n\tint ret = 0;\n\n\tu64 old_msr_data = msr->data;\n\tmsr->data = data;\n\tif (msr - vmx->guest_msrs < vmx->save_nmsrs) {\n\t\tpreempt_disable();\n\t\tret = kvm_set_shared_msr(msr->index, msr->data,\n\t\t\t\t\t msr->mask);\n\t\tpreempt_enable();\n\t\tif (ret)\n\t\t\tmsr->data = old_msr_data;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_shared_msr",
          "args": [
            "msr->index",
            "msr->data",
            "msr->mask"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_shared_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "318-338",
          "snippet": "int kvm_set_shared_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\tint err;\n\n\tvalue = (value & mask) | (smsr->values[slot].host & ~mask);\n\tif (value == smsr->values[slot].curr)\n\t\treturn 0;\n\terr = wrmsrl_safe(shared_msrs_global.msrs[slot], value);\n\tif (err)\n\t\treturn 1;\n\n\tsmsr->values[slot].curr = value;\n\tif (!smsr->registered) {\n\t\tsmsr->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&smsr->urn);\n\t\tsmsr->registered = true;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kvm_shared_msrs __percpu *shared_msrs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic struct kvm_shared_msrs __percpu *shared_msrs;\n\nint kvm_set_shared_msr(unsigned slot, u64 value, u64 mask)\n{\n\tunsigned int cpu = smp_processor_id();\n\tstruct kvm_shared_msrs *smsr = per_cpu_ptr(shared_msrs, cpu);\n\tint err;\n\n\tvalue = (value & mask) | (smsr->values[slot].host & ~mask);\n\tif (value == smsr->values[slot].curr)\n\t\treturn 0;\n\terr = wrmsrl_safe(shared_msrs_global.msrs[slot], value);\n\tif (err)\n\t\treturn 1;\n\n\tsmsr->values[slot].curr = value;\n\tif (!smsr->registered) {\n\t\tsmsr->urn.on_user_return = kvm_on_user_return;\n\t\tuser_return_notifier_register(&smsr->urn);\n\t\tsmsr->registered = true;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int vmx_set_guest_msr(struct vcpu_vmx *vmx, struct shared_msr_entry *msr, u64 data)\n{\n\tint ret = 0;\n\n\tu64 old_msr_data = msr->data;\n\tmsr->data = data;\n\tif (msr - vmx->guest_msrs < vmx->save_nmsrs) {\n\t\tpreempt_disable();\n\t\tret = kvm_set_shared_msr(msr->index, msr->data,\n\t\t\t\t\t msr->mask);\n\t\tpreempt_enable();\n\t\tif (ret)\n\t\t\tmsr->data = old_msr_data;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "find_msr_entry",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "633-641",
    "snippet": "struct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__find_msr_index",
          "args": [
            "vmx",
            "msr"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "__find_msr_index",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "623-631",
          "snippet": "static inline int __find_msr_index(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < vmx->nmsrs; ++i)\n\t\tif (vmx_msr_index[vmx->guest_msrs[i].index] == msr)\n\t\t\treturn i;\n\treturn -1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline int __find_msr_index(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < vmx->nmsrs; ++i)\n\t\tif (vmx_msr_index[vmx->guest_msrs[i].index] == msr)\n\t\t\treturn i;\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstruct shared_msr_entry *find_msr_entry(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\ti = __find_msr_index(vmx, msr);\n\tif (i >= 0)\n\t\treturn &vmx->guest_msrs[i];\n\treturn NULL;\n}"
  },
  {
    "function_name": "__find_msr_index",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "623-631",
    "snippet": "static inline int __find_msr_index(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < vmx->nmsrs; ++i)\n\t\tif (vmx_msr_index[vmx->guest_msrs[i].index] == msr)\n\t\t\treturn i;\n\treturn -1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline int __find_msr_index(struct vcpu_vmx *vmx, u32 msr)\n{\n\tint i;\n\n\tfor (i = 0; i < vmx->nmsrs; ++i)\n\t\tif (vmx_msr_index[vmx->guest_msrs[i].index] == msr)\n\t\t\treturn i;\n\treturn -1;\n}"
  },
  {
    "function_name": "report_flexpriority",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "618-621",
    "snippet": "static inline bool report_flexpriority(void)\n{\n\treturn flexpriority_enabled;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline bool report_flexpriority(void)\n{\n\treturn flexpriority_enabled;\n}"
  },
  {
    "function_name": "cpu_need_virtualize_apic_accesses",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "613-616",
    "snippet": "static inline bool cpu_need_virtualize_apic_accesses(struct kvm_vcpu *vcpu)\n{\n\treturn flexpriority_enabled && lapic_in_kernel(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic inline bool cpu_need_virtualize_apic_accesses(struct kvm_vcpu *vcpu)\n{\n\treturn flexpriority_enabled && lapic_in_kernel(vcpu);\n}"
  },
  {
    "function_name": "cpu_has_broken_vmx_preemption_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "600-611",
    "snippet": "static inline bool cpu_has_broken_vmx_preemption_timer(void)\n{\n\tu32 eax = cpuid_eax(0x00000001), i;\n\n\t/* Clear the reserved bits */\n\teax &= ~(0x3U << 14 | 0xfU << 28);\n\tfor (i = 0; i < ARRAY_SIZE(vmx_preemption_cpu_tfms); i++)\n\t\tif (eax == vmx_preemption_cpu_tfms[i])\n\t\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vmx_preemption_cpu_tfms"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_eax",
          "args": [
            "0x00000001"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic inline bool cpu_has_broken_vmx_preemption_timer(void)\n{\n\tu32 eax = cpuid_eax(0x00000001), i;\n\n\t/* Clear the reserved bits */\n\teax &= ~(0x3U << 14 | 0xfU << 28);\n\tfor (i = 0; i < ARRAY_SIZE(vmx_preemption_cpu_tfms); i++)\n\t\tif (eax == vmx_preemption_cpu_tfms[i])\n\t\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "hv_enable_direct_tlbflush",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "538-561",
    "snippet": "static int hv_enable_direct_tlbflush(struct kvm_vcpu *vcpu)\n{\n\tstruct hv_enlightened_vmcs *evmcs;\n\tstruct hv_partition_assist_pg **p_hv_pa_pg =\n\t\t\t&vcpu->kvm->arch.hyperv.hv_pa_pg;\n\t/*\n\t * Synthetic VM-Exit is not enabled in current code and so All\n\t * evmcs in singe VM shares same assist page.\n\t */\n\tif (!*p_hv_pa_pg)\n\t\t*p_hv_pa_pg = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\n\tif (!*p_hv_pa_pg)\n\t\treturn -ENOMEM;\n\n\tevmcs = (struct hv_enlightened_vmcs *)to_vmx(vcpu)->loaded_vmcs->vmcs;\n\n\tevmcs->partition_assist_page =\n\t\t__pa(*p_hv_pa_pg);\n\tevmcs->hv_vm_id = (unsigned long)vcpu->kvm;\n\tevmcs->hv_enlightenments_control.nested_flush_hypercall = 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "*p_hv_pa_pg"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int hv_enable_direct_tlbflush(struct kvm_vcpu *vcpu)\n{\n\tstruct hv_enlightened_vmcs *evmcs;\n\tstruct hv_partition_assist_pg **p_hv_pa_pg =\n\t\t\t&vcpu->kvm->arch.hyperv.hv_pa_pg;\n\t/*\n\t * Synthetic VM-Exit is not enabled in current code and so All\n\t * evmcs in singe VM shares same assist page.\n\t */\n\tif (!*p_hv_pa_pg)\n\t\t*p_hv_pa_pg = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\n\tif (!*p_hv_pa_pg)\n\t\treturn -ENOMEM;\n\n\tevmcs = (struct hv_enlightened_vmcs *)to_vmx(vcpu)->loaded_vmcs->vmcs;\n\n\tevmcs->partition_assist_page =\n\t\t__pa(*p_hv_pa_pg);\n\tevmcs->hv_vm_id = (unsigned long)vcpu->kvm;\n\tevmcs->hv_enlightenments_control.nested_flush_hypercall = 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hv_remote_flush_tlb",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "533-536",
    "snippet": "static int hv_remote_flush_tlb(struct kvm *kvm)\n{\n\treturn hv_remote_flush_tlb_with_range(kvm, NULL);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hv_remote_flush_tlb_with_range",
          "args": [
            "kvm",
            "NULL"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "hv_remote_flush_tlb_with_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "507-532",
          "snippet": "static int hv_remote_flush_tlb_with_range(struct kvm *kvm,\n\t\tstruct kvm_tlb_range *range)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint ret = 0, i;\n\n\tspin_lock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\n\tif (to_kvm_vmx(kvm)->ept_pointers_match == EPT_POINTERS_CHECK)\n\t\tcheck_ept_pointer_match(kvm);\n\n\tif (to_kvm_vmx(kvm)->ept_pointers_match != EPT_POINTERS_MATCH) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t/* If ept_pointer is invalid pointer, bypass flush request. */\n\t\t\tif (VALID_PAGE(to_vmx(vcpu)->ept_pointer))\n\t\t\t\tret |= __hv_remote_flush_tlb_with_range(\n\t\t\t\t\tkvm, vcpu, range);\n\t\t}\n\t} else {\n\t\tret = __hv_remote_flush_tlb_with_range(kvm,\n\t\t\t\tkvm_get_vcpu(kvm, 0), range);\n\t}\n\n\tspin_unlock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int hv_remote_flush_tlb_with_range(struct kvm *kvm,\n\t\tstruct kvm_tlb_range *range)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint ret = 0, i;\n\n\tspin_lock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\n\tif (to_kvm_vmx(kvm)->ept_pointers_match == EPT_POINTERS_CHECK)\n\t\tcheck_ept_pointer_match(kvm);\n\n\tif (to_kvm_vmx(kvm)->ept_pointers_match != EPT_POINTERS_MATCH) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t/* If ept_pointer is invalid pointer, bypass flush request. */\n\t\t\tif (VALID_PAGE(to_vmx(vcpu)->ept_pointer))\n\t\t\t\tret |= __hv_remote_flush_tlb_with_range(\n\t\t\t\t\tkvm, vcpu, range);\n\t\t}\n\t} else {\n\t\tret = __hv_remote_flush_tlb_with_range(kvm,\n\t\t\t\tkvm_get_vcpu(kvm, 0), range);\n\t}\n\n\tspin_unlock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int hv_remote_flush_tlb(struct kvm *kvm)\n{\n\treturn hv_remote_flush_tlb_with_range(kvm, NULL);\n}"
  },
  {
    "function_name": "hv_remote_flush_tlb_with_range",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "507-532",
    "snippet": "static int hv_remote_flush_tlb_with_range(struct kvm *kvm,\n\t\tstruct kvm_tlb_range *range)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint ret = 0, i;\n\n\tspin_lock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\n\tif (to_kvm_vmx(kvm)->ept_pointers_match == EPT_POINTERS_CHECK)\n\t\tcheck_ept_pointer_match(kvm);\n\n\tif (to_kvm_vmx(kvm)->ept_pointers_match != EPT_POINTERS_MATCH) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t/* If ept_pointer is invalid pointer, bypass flush request. */\n\t\t\tif (VALID_PAGE(to_vmx(vcpu)->ept_pointer))\n\t\t\t\tret |= __hv_remote_flush_tlb_with_range(\n\t\t\t\t\tkvm, vcpu, range);\n\t\t}\n\t} else {\n\t\tret = __hv_remote_flush_tlb_with_range(kvm,\n\t\t\t\tkvm_get_vcpu(kvm, 0), range);\n\t}\n\n\tspin_unlock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&to_kvm_vmx(kvm)->ept_pointer_lock"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_vmx",
          "args": [
            "kvm"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "474-477",
          "snippet": "static inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__hv_remote_flush_tlb_with_range",
          "args": [
            "kvm",
            "kvm_get_vcpu(kvm, 0)",
            "range"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "__hv_remote_flush_tlb_with_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "490-505",
          "snippet": "static inline int __hv_remote_flush_tlb_with_range(struct kvm *kvm,\n\t\tstruct kvm_vcpu *vcpu, struct kvm_tlb_range *range)\n{\n\tu64 ept_pointer = to_vmx(vcpu)->ept_pointer;\n\n\t/*\n\t * FLUSH_GUEST_PHYSICAL_ADDRESS_SPACE hypercall needs address\n\t * of the base of EPT PML4 table, strip off EPT configuration\n\t * information.\n\t */\n\tif (range)\n\t\treturn hyperv_flush_guest_mapping_range(ept_pointer & PAGE_MASK,\n\t\t\t\tkvm_fill_hv_flush_list_func, (void *)range);\n\telse\n\t\treturn hyperv_flush_guest_mapping(ept_pointer & PAGE_MASK);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic inline int __hv_remote_flush_tlb_with_range(struct kvm *kvm,\n\t\tstruct kvm_vcpu *vcpu, struct kvm_tlb_range *range)\n{\n\tu64 ept_pointer = to_vmx(vcpu)->ept_pointer;\n\n\t/*\n\t * FLUSH_GUEST_PHYSICAL_ADDRESS_SPACE hypercall needs address\n\t * of the base of EPT PML4 table, strip off EPT configuration\n\t * information.\n\t */\n\tif (range)\n\t\treturn hyperv_flush_guest_mapping_range(ept_pointer & PAGE_MASK,\n\t\t\t\tkvm_fill_hv_flush_list_func, (void *)range);\n\telse\n\t\treturn hyperv_flush_guest_mapping(ept_pointer & PAGE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_vcpu",
          "args": [
            "kvm",
            "0"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "to_vmx(vcpu)->ept_pointer"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_ept_pointer_match",
          "args": [
            "kvm"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "check_ept_pointer_match",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "462-479",
          "snippet": "static void check_ept_pointer_match(struct kvm *kvm)\n{\n\tstruct kvm_vcpu *vcpu;\n\tu64 tmp_eptp = INVALID_PAGE;\n\tint i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!VALID_PAGE(tmp_eptp)) {\n\t\t\ttmp_eptp = to_vmx(vcpu)->ept_pointer;\n\t\t} else if (tmp_eptp != to_vmx(vcpu)->ept_pointer) {\n\t\t\tto_kvm_vmx(kvm)->ept_pointers_match\n\t\t\t\t= EPT_POINTERS_MISMATCH;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tto_kvm_vmx(kvm)->ept_pointers_match = EPT_POINTERS_MATCH;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void check_ept_pointer_match(struct kvm *kvm)\n{\n\tstruct kvm_vcpu *vcpu;\n\tu64 tmp_eptp = INVALID_PAGE;\n\tint i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!VALID_PAGE(tmp_eptp)) {\n\t\t\ttmp_eptp = to_vmx(vcpu)->ept_pointer;\n\t\t} else if (tmp_eptp != to_vmx(vcpu)->ept_pointer) {\n\t\t\tto_kvm_vmx(kvm)->ept_pointers_match\n\t\t\t\t= EPT_POINTERS_MISMATCH;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tto_kvm_vmx(kvm)->ept_pointers_match = EPT_POINTERS_MATCH;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&to_kvm_vmx(kvm)->ept_pointer_lock"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic int hv_remote_flush_tlb_with_range(struct kvm *kvm,\n\t\tstruct kvm_tlb_range *range)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint ret = 0, i;\n\n\tspin_lock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\n\tif (to_kvm_vmx(kvm)->ept_pointers_match == EPT_POINTERS_CHECK)\n\t\tcheck_ept_pointer_match(kvm);\n\n\tif (to_kvm_vmx(kvm)->ept_pointers_match != EPT_POINTERS_MATCH) {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\t/* If ept_pointer is invalid pointer, bypass flush request. */\n\t\t\tif (VALID_PAGE(to_vmx(vcpu)->ept_pointer))\n\t\t\t\tret |= __hv_remote_flush_tlb_with_range(\n\t\t\t\t\tkvm, vcpu, range);\n\t\t}\n\t} else {\n\t\tret = __hv_remote_flush_tlb_with_range(kvm,\n\t\t\t\tkvm_get_vcpu(kvm, 0), range);\n\t}\n\n\tspin_unlock(&to_kvm_vmx(kvm)->ept_pointer_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "__hv_remote_flush_tlb_with_range",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "490-505",
    "snippet": "static inline int __hv_remote_flush_tlb_with_range(struct kvm *kvm,\n\t\tstruct kvm_vcpu *vcpu, struct kvm_tlb_range *range)\n{\n\tu64 ept_pointer = to_vmx(vcpu)->ept_pointer;\n\n\t/*\n\t * FLUSH_GUEST_PHYSICAL_ADDRESS_SPACE hypercall needs address\n\t * of the base of EPT PML4 table, strip off EPT configuration\n\t * information.\n\t */\n\tif (range)\n\t\treturn hyperv_flush_guest_mapping_range(ept_pointer & PAGE_MASK,\n\t\t\t\tkvm_fill_hv_flush_list_func, (void *)range);\n\telse\n\t\treturn hyperv_flush_guest_mapping(ept_pointer & PAGE_MASK);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hyperv_flush_guest_mapping",
          "args": [
            "ept_pointer & PAGE_MASK"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hyperv_flush_guest_mapping_range",
          "args": [
            "ept_pointer & PAGE_MASK",
            "kvm_fill_hv_flush_list_func",
            "(void *)range"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic inline int __hv_remote_flush_tlb_with_range(struct kvm *kvm,\n\t\tstruct kvm_vcpu *vcpu, struct kvm_tlb_range *range)\n{\n\tu64 ept_pointer = to_vmx(vcpu)->ept_pointer;\n\n\t/*\n\t * FLUSH_GUEST_PHYSICAL_ADDRESS_SPACE hypercall needs address\n\t * of the base of EPT PML4 table, strip off EPT configuration\n\t * information.\n\t */\n\tif (range)\n\t\treturn hyperv_flush_guest_mapping_range(ept_pointer & PAGE_MASK,\n\t\t\t\tkvm_fill_hv_flush_list_func, (void *)range);\n\telse\n\t\treturn hyperv_flush_guest_mapping(ept_pointer & PAGE_MASK);\n}"
  },
  {
    "function_name": "kvm_fill_hv_flush_list_func",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "481-488",
    "snippet": "static int kvm_fill_hv_flush_list_func(struct hv_guest_mapping_flush_list *flush,\n\t\tvoid *data)\n{\n\tstruct kvm_tlb_range *range = data;\n\n\treturn hyperv_fill_flush_guest_mapping_list(flush, range->start_gfn,\n\t\t\trange->pages);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hyperv_fill_flush_guest_mapping_list",
          "args": [
            "flush",
            "range->start_gfn",
            "range->pages"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic int kvm_fill_hv_flush_list_func(struct hv_guest_mapping_flush_list *flush,\n\t\tvoid *data)\n{\n\tstruct kvm_tlb_range *range = data;\n\n\treturn hyperv_fill_flush_guest_mapping_list(flush, range->start_gfn,\n\t\t\trange->pages);\n}"
  },
  {
    "function_name": "check_ept_pointer_match",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "462-479",
    "snippet": "static void check_ept_pointer_match(struct kvm *kvm)\n{\n\tstruct kvm_vcpu *vcpu;\n\tu64 tmp_eptp = INVALID_PAGE;\n\tint i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!VALID_PAGE(tmp_eptp)) {\n\t\t\ttmp_eptp = to_vmx(vcpu)->ept_pointer;\n\t\t} else if (tmp_eptp != to_vmx(vcpu)->ept_pointer) {\n\t\t\tto_kvm_vmx(kvm)->ept_pointers_match\n\t\t\t\t= EPT_POINTERS_MISMATCH;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tto_kvm_vmx(kvm)->ept_pointers_match = EPT_POINTERS_MATCH;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_kvm_vmx",
          "args": [
            "kvm"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "474-477",
          "snippet": "static inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vmx *to_kvm_vmx(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_vmx, kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "tmp_eptp"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic void check_ept_pointer_match(struct kvm *kvm)\n{\n\tstruct kvm_vcpu *vcpu;\n\tu64 tmp_eptp = INVALID_PAGE;\n\tint i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!VALID_PAGE(tmp_eptp)) {\n\t\t\ttmp_eptp = to_vmx(vcpu)->ept_pointer;\n\t\t} else if (tmp_eptp != to_vmx(vcpu)->ept_pointer) {\n\t\t\tto_kvm_vmx(kvm)->ept_pointers_match\n\t\t\t\t= EPT_POINTERS_MISMATCH;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tto_kvm_vmx(kvm)->ept_pointers_match = EPT_POINTERS_MATCH;\n}"
  },
  {
    "function_name": "invept_error",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "389-393",
    "snippet": "noinline void invept_error(unsigned long ext, u64 eptp, gpa_t gpa)\n{\n\tvmx_insn_failed(\"kvm: invept failed: ext=0x%lx eptp=%llx gpa=0x%llx\\n\",\n\t\t\text, eptp, gpa);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_insn_failed",
          "args": [
            "\"kvm: invept failed: ext=0x%lx eptp=%llx gpa=0x%llx\\n\"",
            "ext",
            "eptp",
            "gpa"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nnoinline void invept_error(unsigned long ext, u64 eptp, gpa_t gpa)\n{\n\tvmx_insn_failed(\"kvm: invept failed: ext=0x%lx eptp=%llx gpa=0x%llx\\n\",\n\t\t\text, eptp, gpa);\n}"
  },
  {
    "function_name": "invvpid_error",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "383-387",
    "snippet": "noinline void invvpid_error(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tvmx_insn_failed(\"kvm: invvpid failed: ext=0x%lx vpid=%u gva=0x%lx\\n\",\n\t\t\text, vpid, gva);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_insn_failed",
          "args": [
            "\"kvm: invvpid failed: ext=0x%lx vpid=%u gva=0x%lx\\n\"",
            "ext",
            "vpid",
            "gva"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nnoinline void invvpid_error(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tvmx_insn_failed(\"kvm: invvpid failed: ext=0x%lx vpid=%u gva=0x%lx\\n\",\n\t\t\text, vpid, gva);\n}"
  },
  {
    "function_name": "vmptrld_error",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "378-381",
    "snippet": "noinline void vmptrld_error(struct vmcs *vmcs, u64 phys_addr)\n{\n\tvmx_insn_failed(\"kvm: vmptrld failed: %p/%llx\\n\", vmcs, phys_addr);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_insn_failed",
          "args": [
            "\"kvm: vmptrld failed: %p/%llx\\n\"",
            "vmcs",
            "phys_addr"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nnoinline void vmptrld_error(struct vmcs *vmcs, u64 phys_addr)\n{\n\tvmx_insn_failed(\"kvm: vmptrld failed: %p/%llx\\n\", vmcs, phys_addr);\n}"
  },
  {
    "function_name": "vmclear_error",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "373-376",
    "snippet": "noinline void vmclear_error(struct vmcs *vmcs, u64 phys_addr)\n{\n\tvmx_insn_failed(\"kvm: vmclear failed: %p/%llx\\n\", vmcs, phys_addr);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_insn_failed",
          "args": [
            "\"kvm: vmclear failed: %p/%llx\\n\"",
            "vmcs",
            "phys_addr"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nnoinline void vmclear_error(struct vmcs *vmcs, u64 phys_addr)\n{\n\tvmx_insn_failed(\"kvm: vmclear failed: %p/%llx\\n\", vmcs, phys_addr);\n}"
  },
  {
    "function_name": "vmwrite_error",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "367-371",
    "snippet": "noinline void vmwrite_error(unsigned long field, unsigned long value)\n{\n\tvmx_insn_failed(\"kvm: vmwrite failed: field=%lx val=%lx err=%d\\n\",\n\t\t\tfield, value, vmcs_read32(VM_INSTRUCTION_ERROR));\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_insn_failed",
          "args": [
            "\"kvm: vmwrite failed: field=%lx val=%lx err=%d\\n\"",
            "field",
            "value",
            "vmcs_read32(VM_INSTRUCTION_ERROR)"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "VM_INSTRUCTION_ERROR"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nnoinline void vmwrite_error(unsigned long field, unsigned long value)\n{\n\tvmx_insn_failed(\"kvm: vmwrite failed: field=%lx val=%lx err=%d\\n\",\n\t\t\tfield, value, vmcs_read32(VM_INSTRUCTION_ERROR));\n}"
  },
  {
    "function_name": "vmread_error",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "359-365",
    "snippet": "asmlinkage void vmread_error(unsigned long field, bool fault)\n{\n\tif (fault)\n\t\tkvm_spurious_fault();\n\telse\n\t\tvmx_insn_failed(\"kvm: vmread failed: field=%lx\\n\", field);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_insn_failed",
          "args": [
            "\"kvm: vmread failed: field=%lx\\n\"",
            "field"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_spurious_fault",
          "args": [],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_spurious_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "384-388",
          "snippet": "void kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG_ON(!kvm_rebooting);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_spurious_fault(void)\n{\n\t/* Fault while not rebooting.  We want the trace. */\n\tBUG_ON(!kvm_rebooting);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nasmlinkage void vmread_error(unsigned long field, bool fault)\n{\n\tif (fault)\n\t\tkvm_spurious_fault();\n\telse\n\t\tvmx_insn_failed(\"kvm: vmread failed: field=%lx\\n\", field);\n}"
  },
  {
    "function_name": "vmentry_l1d_flush_get",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "332-338",
    "snippet": "static int vmentry_l1d_flush_get(char *s, const struct kernel_param *kp)\n{\n\tif (WARN_ON_ONCE(l1tf_vmx_mitigation >= ARRAY_SIZE(vmentry_l1d_param)))\n\t\treturn sprintf(s, \"???\\n\");\n\n\treturn sprintf(s, \"%s\\n\", vmentry_l1d_param[l1tf_vmx_mitigation].option);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct {\n\tconst char *option;\n\tbool for_parse;\n} vmentry_l1d_param[] = {\n\t[VMENTER_L1D_FLUSH_AUTO]\t = {\"auto\", true},\n\t[VMENTER_L1D_FLUSH_NEVER]\t = {\"never\", true},\n\t[VMENTER_L1D_FLUSH_COND]\t = {\"cond\", true},\n\t[VMENTER_L1D_FLUSH_ALWAYS]\t = {\"always\", true},\n\t[VMENTER_L1D_FLUSH_EPT_DISABLED] = {\"EPT disabled\", false},\n\t[VMENTER_L1D_FLUSH_NOT_REQUIRED] = {\"not required\", false},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%s\\n\"",
            "vmentry_l1d_param[l1tf_vmx_mitigation].option"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"???\\n\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "l1tf_vmx_mitigation >= ARRAY_SIZE(vmentry_l1d_param)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vmentry_l1d_param"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct {\n\tconst char *option;\n\tbool for_parse;\n} vmentry_l1d_param[] = {\n\t[VMENTER_L1D_FLUSH_AUTO]\t = {\"auto\", true},\n\t[VMENTER_L1D_FLUSH_NEVER]\t = {\"never\", true},\n\t[VMENTER_L1D_FLUSH_COND]\t = {\"cond\", true},\n\t[VMENTER_L1D_FLUSH_ALWAYS]\t = {\"always\", true},\n\t[VMENTER_L1D_FLUSH_EPT_DISABLED] = {\"EPT disabled\", false},\n\t[VMENTER_L1D_FLUSH_NOT_REQUIRED] = {\"not required\", false},\n};\n\nstatic int vmentry_l1d_flush_get(char *s, const struct kernel_param *kp)\n{\n\tif (WARN_ON_ONCE(l1tf_vmx_mitigation >= ARRAY_SIZE(vmentry_l1d_param)))\n\t\treturn sprintf(s, \"???\\n\");\n\n\treturn sprintf(s, \"%s\\n\", vmentry_l1d_param[l1tf_vmx_mitigation].option);\n}"
  },
  {
    "function_name": "vmentry_l1d_flush_set",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "304-330",
    "snippet": "static int vmentry_l1d_flush_set(const char *s, const struct kernel_param *kp)\n{\n\tint l1tf, ret;\n\n\tl1tf = vmentry_l1d_flush_parse(s);\n\tif (l1tf < 0)\n\t\treturn l1tf;\n\n\tif (!boot_cpu_has(X86_BUG_L1TF))\n\t\treturn 0;\n\n\t/*\n\t * Has vmx_init() run already? If not then this is the pre init\n\t * parameter parsing. In that case just store the value and let\n\t * vmx_init() do the proper setup after enable_ept has been\n\t * established.\n\t */\n\tif (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_AUTO) {\n\t\tvmentry_l1d_flush_param = l1tf;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&vmx_l1d_flush_mutex);\n\tret = vmx_setup_l1d_flush(l1tf);\n\tmutex_unlock(&vmx_l1d_flush_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(vmx_l1d_flush_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vmx_l1d_flush_mutex"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmx_setup_l1d_flush",
          "args": [
            "l1tf"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_setup_l1d_flush",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "209-288",
          "snippet": "static int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)\n{\n\tstruct page *page;\n\tunsigned int i;\n\n\tif (!boot_cpu_has_bug(X86_BUG_L1TF)) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\treturn 0;\n\t}\n\n\tif (!enable_ept) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;\n\t\treturn 0;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {\n\t\tu64 msr;\n\n\t\trdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);\n\t\tif (msr & ARCH_CAP_SKIP_VMENTRY_L1DFLUSH) {\n\t\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If set to auto use the default l1tf mitigation method */\n\tif (l1tf == VMENTER_L1D_FLUSH_AUTO) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_NEVER;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_COND;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL:\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t\t\tbreak;\n\t\t}\n\t} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {\n\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t}\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&\n\t    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\t/*\n\t\t * This allocation for vmx_l1d_flush_pages is not tied to a VM\n\t\t * lifetime and so should not be charged to a memcg.\n\t\t */\n\t\tpage = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tvmx_l1d_flush_pages = page_address(page);\n\n\t\t/*\n\t\t * Initialize each page with a different pattern in\n\t\t * order to protect against KSM in the nested\n\t\t * virtualization case.\n\t\t */\n\t\tfor (i = 0; i < 1u << L1D_CACHE_ORDER; ++i) {\n\t\t\tmemset(vmx_l1d_flush_pages + i * PAGE_SIZE, i + 1,\n\t\t\t       PAGE_SIZE);\n\t\t}\n\t}\n\n\tl1tf_vmx_mitigation = l1tf;\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER)\n\t\tstatic_branch_enable(&vmx_l1d_should_flush);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_should_flush);\n\n\tif (l1tf == VMENTER_L1D_FLUSH_COND)\n\t\tstatic_branch_enable(&vmx_l1d_flush_cond);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_flush_cond);\n\treturn 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [
            "#define L1D_CACHE_ORDER 4"
          ],
          "globals_used": [
            "static bool __read_mostly nested = 1;",
            "static DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);",
            "static DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);",
            "static void *vmx_l1d_flush_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define L1D_CACHE_ORDER 4\n\nstatic bool __read_mostly nested = 1;\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);\nstatic void *vmx_l1d_flush_pages;\n\nstatic int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)\n{\n\tstruct page *page;\n\tunsigned int i;\n\n\tif (!boot_cpu_has_bug(X86_BUG_L1TF)) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\treturn 0;\n\t}\n\n\tif (!enable_ept) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;\n\t\treturn 0;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {\n\t\tu64 msr;\n\n\t\trdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);\n\t\tif (msr & ARCH_CAP_SKIP_VMENTRY_L1DFLUSH) {\n\t\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If set to auto use the default l1tf mitigation method */\n\tif (l1tf == VMENTER_L1D_FLUSH_AUTO) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_NEVER;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_COND;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL:\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t\t\tbreak;\n\t\t}\n\t} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {\n\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t}\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&\n\t    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\t/*\n\t\t * This allocation for vmx_l1d_flush_pages is not tied to a VM\n\t\t * lifetime and so should not be charged to a memcg.\n\t\t */\n\t\tpage = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tvmx_l1d_flush_pages = page_address(page);\n\n\t\t/*\n\t\t * Initialize each page with a different pattern in\n\t\t * order to protect against KSM in the nested\n\t\t * virtualization case.\n\t\t */\n\t\tfor (i = 0; i < 1u << L1D_CACHE_ORDER; ++i) {\n\t\t\tmemset(vmx_l1d_flush_pages + i * PAGE_SIZE, i + 1,\n\t\t\t       PAGE_SIZE);\n\t\t}\n\t}\n\n\tl1tf_vmx_mitigation = l1tf;\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER)\n\t\tstatic_branch_enable(&vmx_l1d_should_flush);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_should_flush);\n\n\tif (l1tf == VMENTER_L1D_FLUSH_COND)\n\t\tstatic_branch_enable(&vmx_l1d_flush_cond);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_flush_cond);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vmx_l1d_flush_mutex"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_BUG_L1TF"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmentry_l1d_flush_parse",
          "args": [
            "s"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "vmentry_l1d_flush_parse",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "290-302",
          "snippet": "static int vmentry_l1d_flush_parse(const char *s)\n{\n\tunsigned int i;\n\n\tif (s) {\n\t\tfor (i = 0; i < ARRAY_SIZE(vmentry_l1d_param); i++) {\n\t\t\tif (vmentry_l1d_param[i].for_parse &&\n\t\t\t    sysfs_streq(s, vmentry_l1d_param[i].option))\n\t\t\t\treturn i;\n\t\t}\n\t}\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tconst char *option;\n\tbool for_parse;\n} vmentry_l1d_param[] = {\n\t[VMENTER_L1D_FLUSH_AUTO]\t = {\"auto\", true},\n\t[VMENTER_L1D_FLUSH_NEVER]\t = {\"never\", true},\n\t[VMENTER_L1D_FLUSH_COND]\t = {\"cond\", true},\n\t[VMENTER_L1D_FLUSH_ALWAYS]\t = {\"always\", true},\n\t[VMENTER_L1D_FLUSH_EPT_DISABLED] = {\"EPT disabled\", false},\n\t[VMENTER_L1D_FLUSH_NOT_REQUIRED] = {\"not required\", false},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct {\n\tconst char *option;\n\tbool for_parse;\n} vmentry_l1d_param[] = {\n\t[VMENTER_L1D_FLUSH_AUTO]\t = {\"auto\", true},\n\t[VMENTER_L1D_FLUSH_NEVER]\t = {\"never\", true},\n\t[VMENTER_L1D_FLUSH_COND]\t = {\"cond\", true},\n\t[VMENTER_L1D_FLUSH_ALWAYS]\t = {\"always\", true},\n\t[VMENTER_L1D_FLUSH_EPT_DISABLED] = {\"EPT disabled\", false},\n\t[VMENTER_L1D_FLUSH_NOT_REQUIRED] = {\"not required\", false},\n};\n\nstatic int vmentry_l1d_flush_parse(const char *s)\n{\n\tunsigned int i;\n\n\tif (s) {\n\t\tfor (i = 0; i < ARRAY_SIZE(vmentry_l1d_param); i++) {\n\t\t\tif (vmentry_l1d_param[i].for_parse &&\n\t\t\t    sysfs_streq(s, vmentry_l1d_param[i].option))\n\t\t\t\treturn i;\n\t\t}\n\t}\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic DEFINE_MUTEX(vmx_l1d_flush_mutex);\n\nstatic int vmentry_l1d_flush_set(const char *s, const struct kernel_param *kp)\n{\n\tint l1tf, ret;\n\n\tl1tf = vmentry_l1d_flush_parse(s);\n\tif (l1tf < 0)\n\t\treturn l1tf;\n\n\tif (!boot_cpu_has(X86_BUG_L1TF))\n\t\treturn 0;\n\n\t/*\n\t * Has vmx_init() run already? If not then this is the pre init\n\t * parameter parsing. In that case just store the value and let\n\t * vmx_init() do the proper setup after enable_ept has been\n\t * established.\n\t */\n\tif (l1tf_vmx_mitigation == VMENTER_L1D_FLUSH_AUTO) {\n\t\tvmentry_l1d_flush_param = l1tf;\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&vmx_l1d_flush_mutex);\n\tret = vmx_setup_l1d_flush(l1tf);\n\tmutex_unlock(&vmx_l1d_flush_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "vmentry_l1d_flush_parse",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "290-302",
    "snippet": "static int vmentry_l1d_flush_parse(const char *s)\n{\n\tunsigned int i;\n\n\tif (s) {\n\t\tfor (i = 0; i < ARRAY_SIZE(vmentry_l1d_param); i++) {\n\t\t\tif (vmentry_l1d_param[i].for_parse &&\n\t\t\t    sysfs_streq(s, vmentry_l1d_param[i].option))\n\t\t\t\treturn i;\n\t\t}\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct {\n\tconst char *option;\n\tbool for_parse;\n} vmentry_l1d_param[] = {\n\t[VMENTER_L1D_FLUSH_AUTO]\t = {\"auto\", true},\n\t[VMENTER_L1D_FLUSH_NEVER]\t = {\"never\", true},\n\t[VMENTER_L1D_FLUSH_COND]\t = {\"cond\", true},\n\t[VMENTER_L1D_FLUSH_ALWAYS]\t = {\"always\", true},\n\t[VMENTER_L1D_FLUSH_EPT_DISABLED] = {\"EPT disabled\", false},\n\t[VMENTER_L1D_FLUSH_NOT_REQUIRED] = {\"not required\", false},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_streq",
          "args": [
            "s",
            "vmentry_l1d_param[i].option"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "vmentry_l1d_param"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic const struct {\n\tconst char *option;\n\tbool for_parse;\n} vmentry_l1d_param[] = {\n\t[VMENTER_L1D_FLUSH_AUTO]\t = {\"auto\", true},\n\t[VMENTER_L1D_FLUSH_NEVER]\t = {\"never\", true},\n\t[VMENTER_L1D_FLUSH_COND]\t = {\"cond\", true},\n\t[VMENTER_L1D_FLUSH_ALWAYS]\t = {\"always\", true},\n\t[VMENTER_L1D_FLUSH_EPT_DISABLED] = {\"EPT disabled\", false},\n\t[VMENTER_L1D_FLUSH_NOT_REQUIRED] = {\"not required\", false},\n};\n\nstatic int vmentry_l1d_flush_parse(const char *s)\n{\n\tunsigned int i;\n\n\tif (s) {\n\t\tfor (i = 0; i < ARRAY_SIZE(vmentry_l1d_param); i++) {\n\t\t\tif (vmentry_l1d_param[i].for_parse &&\n\t\t\t    sysfs_streq(s, vmentry_l1d_param[i].option))\n\t\t\t\treturn i;\n\t\t}\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "vmx_setup_l1d_flush",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
    "lines": "209-288",
    "snippet": "static int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)\n{\n\tstruct page *page;\n\tunsigned int i;\n\n\tif (!boot_cpu_has_bug(X86_BUG_L1TF)) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\treturn 0;\n\t}\n\n\tif (!enable_ept) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;\n\t\treturn 0;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {\n\t\tu64 msr;\n\n\t\trdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);\n\t\tif (msr & ARCH_CAP_SKIP_VMENTRY_L1DFLUSH) {\n\t\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If set to auto use the default l1tf mitigation method */\n\tif (l1tf == VMENTER_L1D_FLUSH_AUTO) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_NEVER;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_COND;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL:\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t\t\tbreak;\n\t\t}\n\t} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {\n\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t}\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&\n\t    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\t/*\n\t\t * This allocation for vmx_l1d_flush_pages is not tied to a VM\n\t\t * lifetime and so should not be charged to a memcg.\n\t\t */\n\t\tpage = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tvmx_l1d_flush_pages = page_address(page);\n\n\t\t/*\n\t\t * Initialize each page with a different pattern in\n\t\t * order to protect against KSM in the nested\n\t\t * virtualization case.\n\t\t */\n\t\tfor (i = 0; i < 1u << L1D_CACHE_ORDER; ++i) {\n\t\t\tmemset(vmx_l1d_flush_pages + i * PAGE_SIZE, i + 1,\n\t\t\t       PAGE_SIZE);\n\t\t}\n\t}\n\n\tl1tf_vmx_mitigation = l1tf;\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER)\n\t\tstatic_branch_enable(&vmx_l1d_should_flush);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_should_flush);\n\n\tif (l1tf == VMENTER_L1D_FLUSH_COND)\n\t\tstatic_branch_enable(&vmx_l1d_flush_cond);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_flush_cond);\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"vmcs.h\"",
      "#include \"trace.h\"",
      "#include \"pmu.h\"",
      "#include \"ops.h\"",
      "#include \"nested.h\"",
      "#include \"mmu.h\"",
      "#include \"lapic.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"irq.h\"",
      "#include \"evmcs.h\"",
      "#include \"cpuid.h\"",
      "#include \"capabilities.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/virtext.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/mwait.h>",
      "#include <asm/mshyperv.h>",
      "#include <asm/mmu_context.h>",
      "#include <asm/mce.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/kexec.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/io.h>",
      "#include <asm/fpu/internal.h>",
      "#include <asm/desc.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/cpu.h>",
      "#include <asm/asm.h>",
      "#include <asm/apic.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/tboot.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/smt.h>",
      "#include <linux/sched.h>",
      "#include <linux/mm.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/kernel.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/highmem.h>",
      "#include <linux/frame.h>"
    ],
    "macros_used": [
      "#define L1D_CACHE_ORDER 4"
    ],
    "globals_used": [
      "static bool __read_mostly nested = 1;",
      "static DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);",
      "static DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);",
      "static void *vmx_l1d_flush_pages;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&vmx_l1d_flush_cond"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&vmx_l1d_flush_cond"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&vmx_l1d_should_flush"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&vmx_l1d_should_flush"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vmx_l1d_flush_pages + i * PAGE_SIZE",
            "i + 1",
            "PAGE_SIZE"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "GFP_KERNEL",
            "L1D_CACHE_ORDER"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_FLUSH_L1D"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_IA32_ARCH_CAPABILITIES",
            "msr"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_ARCH_CAPABILITIES"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has_bug",
          "args": [
            "X86_BUG_L1TF"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\n#define L1D_CACHE_ORDER 4\n\nstatic bool __read_mostly nested = 1;\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_should_flush);\nstatic DEFINE_STATIC_KEY_FALSE(vmx_l1d_flush_cond);\nstatic void *vmx_l1d_flush_pages;\n\nstatic int vmx_setup_l1d_flush(enum vmx_l1d_flush_state l1tf)\n{\n\tstruct page *page;\n\tunsigned int i;\n\n\tif (!boot_cpu_has_bug(X86_BUG_L1TF)) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\treturn 0;\n\t}\n\n\tif (!enable_ept) {\n\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_EPT_DISABLED;\n\t\treturn 0;\n\t}\n\n\tif (boot_cpu_has(X86_FEATURE_ARCH_CAPABILITIES)) {\n\t\tu64 msr;\n\n\t\trdmsrl(MSR_IA32_ARCH_CAPABILITIES, msr);\n\t\tif (msr & ARCH_CAP_SKIP_VMENTRY_L1DFLUSH) {\n\t\t\tl1tf_vmx_mitigation = VMENTER_L1D_FLUSH_NOT_REQUIRED;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* If set to auto use the default l1tf mitigation method */\n\tif (l1tf == VMENTER_L1D_FLUSH_AUTO) {\n\t\tswitch (l1tf_mitigation) {\n\t\tcase L1TF_MITIGATION_OFF:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_NEVER;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FLUSH_NOWARN:\n\t\tcase L1TF_MITIGATION_FLUSH:\n\t\tcase L1TF_MITIGATION_FLUSH_NOSMT:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_COND;\n\t\t\tbreak;\n\t\tcase L1TF_MITIGATION_FULL:\n\t\tcase L1TF_MITIGATION_FULL_FORCE:\n\t\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t\t\tbreak;\n\t\t}\n\t} else if (l1tf_mitigation == L1TF_MITIGATION_FULL_FORCE) {\n\t\tl1tf = VMENTER_L1D_FLUSH_ALWAYS;\n\t}\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER && !vmx_l1d_flush_pages &&\n\t    !boot_cpu_has(X86_FEATURE_FLUSH_L1D)) {\n\t\t/*\n\t\t * This allocation for vmx_l1d_flush_pages is not tied to a VM\n\t\t * lifetime and so should not be charged to a memcg.\n\t\t */\n\t\tpage = alloc_pages(GFP_KERNEL, L1D_CACHE_ORDER);\n\t\tif (!page)\n\t\t\treturn -ENOMEM;\n\t\tvmx_l1d_flush_pages = page_address(page);\n\n\t\t/*\n\t\t * Initialize each page with a different pattern in\n\t\t * order to protect against KSM in the nested\n\t\t * virtualization case.\n\t\t */\n\t\tfor (i = 0; i < 1u << L1D_CACHE_ORDER; ++i) {\n\t\t\tmemset(vmx_l1d_flush_pages + i * PAGE_SIZE, i + 1,\n\t\t\t       PAGE_SIZE);\n\t\t}\n\t}\n\n\tl1tf_vmx_mitigation = l1tf;\n\n\tif (l1tf != VMENTER_L1D_FLUSH_NEVER)\n\t\tstatic_branch_enable(&vmx_l1d_should_flush);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_should_flush);\n\n\tif (l1tf == VMENTER_L1D_FLUSH_COND)\n\t\tstatic_branch_enable(&vmx_l1d_flush_cond);\n\telse\n\t\tstatic_branch_disable(&vmx_l1d_flush_cond);\n\treturn 0;\n}"
  }
]