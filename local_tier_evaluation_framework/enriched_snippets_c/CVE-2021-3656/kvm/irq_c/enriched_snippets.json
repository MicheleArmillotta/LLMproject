[
  {
    "function_name": "kvm_arch_irqfd_allowed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
    "lines": "164-169",
    "snippet": "bool kvm_arch_irqfd_allowed(struct kvm *kvm, struct kvm_irqfd *args)\n{\n\tbool resample = args->flags & KVM_IRQFD_FLAG_RESAMPLE;\n\n\treturn resample ? irqchip_kernel(kvm) : irqchip_in_kernel(kvm);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.h",
          "lines": "96-103",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode != KVM_IRQCHIP_NONE;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode != KVM_IRQCHIP_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_kernel",
          "args": [
            "kvm"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.h",
          "lines": "87-94",
          "snippet": "static inline int irqchip_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nbool kvm_arch_irqfd_allowed(struct kvm *kvm, struct kvm_irqfd *args)\n{\n\tbool resample = args->flags & KVM_IRQFD_FLAG_RESAMPLE;\n\n\treturn resample ? irqchip_kernel(kvm) : irqchip_in_kernel(kvm);\n}"
  },
  {
    "function_name": "__kvm_migrate_timers",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
    "lines": "158-162",
    "snippet": "void __kvm_migrate_timers(struct kvm_vcpu *vcpu)\n{\n\t__kvm_migrate_apic_timer(vcpu);\n\t__kvm_migrate_pit_timer(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kvm_migrate_pit_timer",
          "args": [
            "vcpu"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_migrate_pit_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8254.c",
          "lines": "218-231",
          "snippet": "void __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\n\ttimer = &pit->pit_state.timer;\n\tmutex_lock(&pit->pit_state.lock);\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n\tmutex_unlock(&pit->pit_state.lock);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include \"ioapic.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include \"ioapic.h\"\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid __kvm_migrate_pit_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pit *pit = vcpu->kvm->arch.vpit;\n\tstruct hrtimer *timer;\n\n\tif (!kvm_vcpu_is_bsp(vcpu) || !pit)\n\t\treturn;\n\n\ttimer = &pit->pit_state.timer;\n\tmutex_lock(&pit->pit_state.lock);\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS);\n\tmutex_unlock(&pit->pit_state.lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kvm_migrate_apic_timer",
          "args": [
            "vcpu"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_migrate_apic_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2545-2556",
          "snippet": "void __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct hrtimer *timer;\n\n\tif (!lapic_in_kernel(vcpu) ||\n\t\tkvm_can_post_timer_interrupt(vcpu))\n\t\treturn;\n\n\ttimer = &vcpu->arch.apic->lapic_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_HARD);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid __kvm_migrate_apic_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct hrtimer *timer;\n\n\tif (!lapic_in_kernel(vcpu) ||\n\t\tkvm_can_post_timer_interrupt(vcpu))\n\t\treturn;\n\n\ttimer = &vcpu->arch.apic->lapic_timer.timer;\n\tif (hrtimer_cancel(timer))\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_HARD);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nvoid __kvm_migrate_timers(struct kvm_vcpu *vcpu)\n{\n\t__kvm_migrate_apic_timer(vcpu);\n\t__kvm_migrate_pit_timer(vcpu);\n}"
  },
  {
    "function_name": "kvm_inject_pending_timer_irqs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
    "lines": "151-155",
    "snippet": "void kvm_inject_pending_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_inject_apic_timer_irqs(vcpu);\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_inject_apic_timer_irqs",
          "args": [
            "vcpu"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_inject_apic_timer_irqs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2423-2431",
          "snippet": "void kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (atomic_read(&apic->lapic_timer.pending) > 0) {\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nvoid kvm_inject_apic_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (atomic_read(&apic->lapic_timer.pending) > 0) {\n\t\tkvm_apic_inject_pending_timer_irqs(apic);\n\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nvoid kvm_inject_pending_timer_irqs(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_inject_apic_timer_irqs(vcpu);\n}"
  },
  {
    "function_name": "kvm_cpu_get_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
    "lines": "135-148",
    "snippet": "int kvm_cpu_get_interrupt(struct kvm_vcpu *v)\n{\n\tint vector;\n\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.nr;\n\n\tvector = kvm_cpu_get_extint(v);\n\n\tif (vector != -1)\n\t\treturn vector;\t\t\t/* PIC */\n\n\treturn kvm_get_apic_interrupt(v);\t/* APIC */\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_apic_interrupt",
          "args": [
            "v"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_apic_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2433-2469",
          "snippet": "int kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)\n{\n\tint vector = kvm_apic_has_interrupt(vcpu);\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (vector == -1)\n\t\treturn -1;\n\n\t/*\n\t * We get here even with APIC virtualization enabled, if doing\n\t * nested virtualization and L1 runs with the \"acknowledge interrupt\n\t * on exit\" mode.  Then we cannot inject the interrupt via RVI,\n\t * because the process would deliver it through the IDT.\n\t */\n\n\tapic_clear_irr(vector, apic);\n\tif (test_bit(vector, vcpu_to_synic(vcpu)->auto_eoi_bitmap)) {\n\t\t/*\n\t\t * For auto-EOI interrupts, there might be another pending\n\t\t * interrupt above PPR, so check whether to raise another\n\t\t * KVM_REQ_EVENT.\n\t\t */\n\t\tapic_update_ppr(apic);\n\t} else {\n\t\t/*\n\t\t * For normal interrupts, PPR has been raised and there cannot\n\t\t * be a higher-priority pending interrupt---except if there was\n\t\t * a concurrent interrupt injection, but that would have\n\t\t * triggered KVM_REQ_EVENT already.\n\t\t */\n\t\tapic_set_isr(vector, apic);\n\t\t__apic_update_ppr(apic, &ppr);\n\t}\n\n\treturn vector;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_get_apic_interrupt(struct kvm_vcpu *vcpu)\n{\n\tint vector = kvm_apic_has_interrupt(vcpu);\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (vector == -1)\n\t\treturn -1;\n\n\t/*\n\t * We get here even with APIC virtualization enabled, if doing\n\t * nested virtualization and L1 runs with the \"acknowledge interrupt\n\t * on exit\" mode.  Then we cannot inject the interrupt via RVI,\n\t * because the process would deliver it through the IDT.\n\t */\n\n\tapic_clear_irr(vector, apic);\n\tif (test_bit(vector, vcpu_to_synic(vcpu)->auto_eoi_bitmap)) {\n\t\t/*\n\t\t * For auto-EOI interrupts, there might be another pending\n\t\t * interrupt above PPR, so check whether to raise another\n\t\t * KVM_REQ_EVENT.\n\t\t */\n\t\tapic_update_ppr(apic);\n\t} else {\n\t\t/*\n\t\t * For normal interrupts, PPR has been raised and there cannot\n\t\t * be a higher-priority pending interrupt---except if there was\n\t\t * a concurrent interrupt injection, but that would have\n\t\t * triggered KVM_REQ_EVENT already.\n\t\t */\n\t\tapic_set_isr(vector, apic);\n\t\t__apic_update_ppr(apic, &ppr);\n\t}\n\n\treturn vector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_get_extint",
          "args": [
            "v"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_get_extint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
          "lines": "118-130",
          "snippet": "static int kvm_cpu_get_extint(struct kvm_vcpu *v)\n{\n\tif (kvm_cpu_has_extint(v)) {\n\t\tif (irqchip_split(v->kvm)) {\n\t\t\tint vector = v->arch.pending_external_vector;\n\n\t\t\tv->arch.pending_external_vector = -1;\n\t\t\treturn vector;\n\t\t} else\n\t\t\treturn kvm_pic_read_irq(v->kvm); /* PIC */\n\t} else\n\t\treturn -1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nstatic int kvm_cpu_get_extint(struct kvm_vcpu *v)\n{\n\tif (kvm_cpu_has_extint(v)) {\n\t\tif (irqchip_split(v->kvm)) {\n\t\t\tint vector = v->arch.pending_external_vector;\n\n\t\t\tv->arch.pending_external_vector = -1;\n\t\t\treturn vector;\n\t\t} else\n\t\t\treturn kvm_pic_read_irq(v->kvm); /* PIC */\n\t} else\n\t\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "v"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nint kvm_cpu_get_interrupt(struct kvm_vcpu *v)\n{\n\tint vector;\n\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.nr;\n\n\tvector = kvm_cpu_get_extint(v);\n\n\tif (vector != -1)\n\t\treturn vector;\t\t\t/* PIC */\n\n\treturn kvm_get_apic_interrupt(v);\t/* APIC */\n}"
  },
  {
    "function_name": "kvm_cpu_get_extint",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
    "lines": "118-130",
    "snippet": "static int kvm_cpu_get_extint(struct kvm_vcpu *v)\n{\n\tif (kvm_cpu_has_extint(v)) {\n\t\tif (irqchip_split(v->kvm)) {\n\t\t\tint vector = v->arch.pending_external_vector;\n\n\t\t\tv->arch.pending_external_vector = -1;\n\t\t\treturn vector;\n\t\t} else\n\t\t\treturn kvm_pic_read_irq(v->kvm); /* PIC */\n\t} else\n\t\treturn -1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_pic_read_irq",
          "args": [
            "v->kvm"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_pic_read_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/i8259.c",
          "lines": "234-269",
          "snippet": "int kvm_pic_read_irq(struct kvm *kvm)\n{\n\tint irq, irq2, intno;\n\tstruct kvm_pic *s = kvm->arch.vpic;\n\n\ts->output = 0;\n\n\tpic_lock(s);\n\tirq = pic_get_irq(&s->pics[0]);\n\tif (irq >= 0) {\n\t\tpic_intack(&s->pics[0], irq);\n\t\tif (irq == 2) {\n\t\t\tirq2 = pic_get_irq(&s->pics[1]);\n\t\t\tif (irq2 >= 0)\n\t\t\t\tpic_intack(&s->pics[1], irq2);\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * spurious IRQ on slave controller\n\t\t\t\t */\n\t\t\t\tirq2 = 7;\n\t\t\tintno = s->pics[1].irq_base + irq2;\n\t\t\tirq = irq2 + 8;\n\t\t} else\n\t\t\tintno = s->pics[0].irq_base + irq;\n\t} else {\n\t\t/*\n\t\t * spurious IRQ on host controller\n\t\t */\n\t\tirq = 7;\n\t\tintno = s->pics[0].irq_base + irq;\n\t}\n\tpic_update_irq(s);\n\tpic_unlock(s);\n\n\treturn intno;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/kvm_host.h>",
            "#include \"irq.h\"",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/kvm_host.h>\n#include \"irq.h\"\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint kvm_pic_read_irq(struct kvm *kvm)\n{\n\tint irq, irq2, intno;\n\tstruct kvm_pic *s = kvm->arch.vpic;\n\n\ts->output = 0;\n\n\tpic_lock(s);\n\tirq = pic_get_irq(&s->pics[0]);\n\tif (irq >= 0) {\n\t\tpic_intack(&s->pics[0], irq);\n\t\tif (irq == 2) {\n\t\t\tirq2 = pic_get_irq(&s->pics[1]);\n\t\t\tif (irq2 >= 0)\n\t\t\t\tpic_intack(&s->pics[1], irq2);\n\t\t\telse\n\t\t\t\t/*\n\t\t\t\t * spurious IRQ on slave controller\n\t\t\t\t */\n\t\t\t\tirq2 = 7;\n\t\t\tintno = s->pics[1].irq_base + irq2;\n\t\t\tirq = irq2 + 8;\n\t\t} else\n\t\t\tintno = s->pics[0].irq_base + irq;\n\t} else {\n\t\t/*\n\t\t * spurious IRQ on host controller\n\t\t */\n\t\tirq = 7;\n\t\tintno = s->pics[0].irq_base + irq;\n\t}\n\tpic_update_irq(s);\n\tpic_unlock(s);\n\n\treturn intno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_split",
          "args": [
            "v->kvm"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_split",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.h",
          "lines": "78-85",
          "snippet": "static inline int irqchip_split(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_SPLIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_split(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_SPLIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_has_extint",
          "args": [
            "v"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_has_extint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
          "lines": "43-54",
          "snippet": "static int kvm_cpu_has_extint(struct kvm_vcpu *v)\n{\n\tu8 accept = kvm_apic_accept_pic_intr(v);\n\n\tif (accept) {\n\t\tif (irqchip_split(v->kvm))\n\t\t\treturn pending_userspace_extint(v);\n\t\telse\n\t\t\treturn v->kvm->arch.vpic->output;\n\t} else\n\t\treturn 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nstatic int kvm_cpu_has_extint(struct kvm_vcpu *v)\n{\n\tu8 accept = kvm_apic_accept_pic_intr(v);\n\n\tif (accept) {\n\t\tif (irqchip_split(v->kvm))\n\t\t\treturn pending_userspace_extint(v);\n\t\telse\n\t\t\treturn v->kvm->arch.vpic->output;\n\t} else\n\t\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nstatic int kvm_cpu_get_extint(struct kvm_vcpu *v)\n{\n\tif (kvm_cpu_has_extint(v)) {\n\t\tif (irqchip_split(v->kvm)) {\n\t\t\tint vector = v->arch.pending_external_vector;\n\n\t\t\tv->arch.pending_external_vector = -1;\n\t\t\treturn vector;\n\t\t} else\n\t\t\treturn kvm_pic_read_irq(v->kvm); /* PIC */\n\t} else\n\t\treturn -1;\n}"
  },
  {
    "function_name": "kvm_cpu_has_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
    "lines": "91-111",
    "snippet": "int kvm_cpu_has_interrupt(struct kvm_vcpu *v)\n{\n\t/*\n\t * FIXME: interrupt.injected represents an interrupt that it's\n\t * side-effects have already been applied (e.g. bit from IRR\n\t * already moved to ISR). Therefore, it is incorrect to rely\n\t * on interrupt.injected to know if there is a pending\n\t * interrupt in the user-mode LAPIC.\n\t * This leads to nVMX/nSVM not be able to distinguish\n\t * if it should exit from L2 to L1 on EXTERNAL_INTERRUPT on\n\t * pending interrupt or should re-inject an injected\n\t * interrupt.\n\t */\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.injected;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\treturn kvm_apic_has_interrupt(v) != -1;\t/* LAPIC */\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_has_interrupt",
          "args": [
            "v"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_has_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2399-2409",
          "snippet": "int kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (!kvm_apic_hw_enabled(apic))\n\t\treturn -1;\n\n\t__apic_update_ppr(apic, &ppr);\n\treturn apic_has_interrupt_for_ppr(apic, ppr);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (!kvm_apic_hw_enabled(apic))\n\t\treturn -1;\n\n\t__apic_update_ppr(apic, &ppr);\n\treturn apic_has_interrupt_for_ppr(apic, ppr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_has_extint",
          "args": [
            "v"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_has_extint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
          "lines": "43-54",
          "snippet": "static int kvm_cpu_has_extint(struct kvm_vcpu *v)\n{\n\tu8 accept = kvm_apic_accept_pic_intr(v);\n\n\tif (accept) {\n\t\tif (irqchip_split(v->kvm))\n\t\t\treturn pending_userspace_extint(v);\n\t\telse\n\t\t\treturn v->kvm->arch.vpic->output;\n\t} else\n\t\treturn 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nstatic int kvm_cpu_has_extint(struct kvm_vcpu *v)\n{\n\tu8 accept = kvm_apic_accept_pic_intr(v);\n\n\tif (accept) {\n\t\tif (irqchip_split(v->kvm))\n\t\t\treturn pending_userspace_extint(v);\n\t\telse\n\t\t\treturn v->kvm->arch.vpic->output;\n\t} else\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "v"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nint kvm_cpu_has_interrupt(struct kvm_vcpu *v)\n{\n\t/*\n\t * FIXME: interrupt.injected represents an interrupt that it's\n\t * side-effects have already been applied (e.g. bit from IRR\n\t * already moved to ISR). Therefore, it is incorrect to rely\n\t * on interrupt.injected to know if there is a pending\n\t * interrupt in the user-mode LAPIC.\n\t * This leads to nVMX/nSVM not be able to distinguish\n\t * if it should exit from L2 to L1 on EXTERNAL_INTERRUPT on\n\t * pending interrupt or should re-inject an injected\n\t * interrupt.\n\t */\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.injected;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\treturn kvm_apic_has_interrupt(v) != -1;\t/* LAPIC */\n}"
  },
  {
    "function_name": "kvm_cpu_has_injectable_intr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
    "lines": "62-85",
    "snippet": "int kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)\n{\n\t/*\n\t * FIXME: interrupt.injected represents an interrupt that it's\n\t * side-effects have already been applied (e.g. bit from IRR\n\t * already moved to ISR). Therefore, it is incorrect to rely\n\t * on interrupt.injected to know if there is a pending\n\t * interrupt in the user-mode LAPIC.\n\t * This leads to nVMX/nSVM not be able to distinguish\n\t * if it should exit from L2 to L1 on EXTERNAL_INTERRUPT on\n\t * pending interrupt or should re-inject an injected\n\t * interrupt.\n\t */\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.injected;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\tif (!is_guest_mode(v) && kvm_vcpu_apicv_active(v))\n\t\treturn 0;\n\n\treturn kvm_apic_has_interrupt(v) != -1; /* LAPIC */\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_has_interrupt",
          "args": [
            "v"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_has_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2399-2409",
          "snippet": "int kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (!kvm_apic_hw_enabled(apic))\n\t\treturn -1;\n\n\t__apic_update_ppr(apic, &ppr);\n\treturn apic_has_interrupt_for_ppr(apic, ppr);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_has_interrupt(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 ppr;\n\n\tif (!kvm_apic_hw_enabled(apic))\n\t\treturn -1;\n\n\t__apic_update_ppr(apic, &ppr);\n\treturn apic_has_interrupt_for_ppr(apic, ppr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "v"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "v"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_has_extint",
          "args": [
            "v"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_has_extint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
          "lines": "43-54",
          "snippet": "static int kvm_cpu_has_extint(struct kvm_vcpu *v)\n{\n\tu8 accept = kvm_apic_accept_pic_intr(v);\n\n\tif (accept) {\n\t\tif (irqchip_split(v->kvm))\n\t\t\treturn pending_userspace_extint(v);\n\t\telse\n\t\t\treturn v->kvm->arch.vpic->output;\n\t} else\n\t\treturn 0;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nstatic int kvm_cpu_has_extint(struct kvm_vcpu *v)\n{\n\tu8 accept = kvm_apic_accept_pic_intr(v);\n\n\tif (accept) {\n\t\tif (irqchip_split(v->kvm))\n\t\t\treturn pending_userspace_extint(v);\n\t\telse\n\t\t\treturn v->kvm->arch.vpic->output;\n\t} else\n\t\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "v"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nint kvm_cpu_has_injectable_intr(struct kvm_vcpu *v)\n{\n\t/*\n\t * FIXME: interrupt.injected represents an interrupt that it's\n\t * side-effects have already been applied (e.g. bit from IRR\n\t * already moved to ISR). Therefore, it is incorrect to rely\n\t * on interrupt.injected to know if there is a pending\n\t * interrupt in the user-mode LAPIC.\n\t * This leads to nVMX/nSVM not be able to distinguish\n\t * if it should exit from L2 to L1 on EXTERNAL_INTERRUPT on\n\t * pending interrupt or should re-inject an injected\n\t * interrupt.\n\t */\n\tif (!lapic_in_kernel(v))\n\t\treturn v->arch.interrupt.injected;\n\n\tif (kvm_cpu_has_extint(v))\n\t\treturn 1;\n\n\tif (!is_guest_mode(v) && kvm_vcpu_apicv_active(v))\n\t\treturn 0;\n\n\treturn kvm_apic_has_interrupt(v) != -1; /* LAPIC */\n}"
  },
  {
    "function_name": "kvm_cpu_has_extint",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
    "lines": "43-54",
    "snippet": "static int kvm_cpu_has_extint(struct kvm_vcpu *v)\n{\n\tu8 accept = kvm_apic_accept_pic_intr(v);\n\n\tif (accept) {\n\t\tif (irqchip_split(v->kvm))\n\t\t\treturn pending_userspace_extint(v);\n\t\telse\n\t\t\treturn v->kvm->arch.vpic->output;\n\t} else\n\t\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pending_userspace_extint",
          "args": [
            "v"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "pending_userspace_extint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
          "lines": "34-37",
          "snippet": "static int pending_userspace_extint(struct kvm_vcpu *v)\n{\n\treturn v->arch.pending_external_vector != -1;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"i8254.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nstatic int pending_userspace_extint(struct kvm_vcpu *v)\n{\n\treturn v->arch.pending_external_vector != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_split",
          "args": [
            "v->kvm"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_split",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.h",
          "lines": "78-85",
          "snippet": "static inline int irqchip_split(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_SPLIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_split(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_SPLIT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_accept_pic_intr",
          "args": [
            "v"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_accept_pic_intr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2411-2421",
          "snippet": "int kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_accept_pic_intr(struct kvm_vcpu *vcpu)\n{\n\tu32 lvt0 = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LVT0);\n\n\tif (!kvm_apic_hw_enabled(vcpu->arch.apic))\n\t\treturn 1;\n\tif ((lvt0 & APIC_LVT_MASKED) == 0 &&\n\t    GET_APIC_DELIVERY_MODE(lvt0) == APIC_MODE_EXTINT)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nstatic int kvm_cpu_has_extint(struct kvm_vcpu *v)\n{\n\tu8 accept = kvm_apic_accept_pic_intr(v);\n\n\tif (accept) {\n\t\tif (irqchip_split(v->kvm))\n\t\t\treturn pending_userspace_extint(v);\n\t\telse\n\t\t\treturn v->kvm->arch.vpic->output;\n\t} else\n\t\treturn 0;\n}"
  },
  {
    "function_name": "pending_userspace_extint",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
    "lines": "34-37",
    "snippet": "static int pending_userspace_extint(struct kvm_vcpu *v)\n{\n\treturn v->arch.pending_external_vector != -1;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nstatic int pending_userspace_extint(struct kvm_vcpu *v)\n{\n\treturn v->arch.pending_external_vector != -1;\n}"
  },
  {
    "function_name": "kvm_cpu_has_pending_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.c",
    "lines": "22-28",
    "snippet": "int kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn apic_has_pending_timer(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"x86.h\"",
      "#include \"i8254.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "apic_has_pending_timer",
          "args": [
            "vcpu"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "apic_has_pending_timer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2299-2307",
          "snippet": "int apic_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic_enabled(apic) && apic_lvt_enabled(apic, APIC_LVTT))\n\t\treturn atomic_read(&apic->lapic_timer.pending);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint apic_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (apic_enabled(apic) && apic_lvt_enabled(apic, APIC_LVTT))\n\t\treturn atomic_read(&apic->lapic_timer.pending);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"x86.h\"\n#include \"i8254.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n#include <linux/export.h>\n\nint kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn apic_has_pending_timer(vcpu);\n\n\treturn 0;\n}"
  }
]