[
  {
    "function_name": "intel_pmu_reset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "376-398",
    "snippet": "static void intel_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc = NULL;\n\tint i;\n\n\tfor (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {\n\t\tpmc = &pmu->gp_counters[i];\n\n\t\tpmc_stop_counter(pmc);\n\t\tpmc->counter = pmc->eventsel = 0;\n\t}\n\n\tfor (i = 0; i < INTEL_PMC_MAX_FIXED; i++) {\n\t\tpmc = &pmu->fixed_counters[i];\n\n\t\tpmc_stop_counter(pmc);\n\t\tpmc->counter = 0;\n\t}\n\n\tpmu->fixed_ctr_ctrl = pmu->global_ctrl = pmu->global_status =\n\t\tpmu->global_ovf_ctrl = 0;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pmc_stop_counter",
          "args": [
            "pmc"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_stop_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "71-77",
          "snippet": "static inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tpmc_release_perf_event(pmc);\n\t}\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline void pmc_stop_counter(struct kvm_pmc *pmc)\n{\n\tif (pmc->perf_event) {\n\t\tpmc->counter = pmc_read_counter(pmc);\n\t\tpmc_release_perf_event(pmc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void intel_pmu_reset(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc = NULL;\n\tint i;\n\n\tfor (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {\n\t\tpmc = &pmu->gp_counters[i];\n\n\t\tpmc_stop_counter(pmc);\n\t\tpmc->counter = pmc->eventsel = 0;\n\t}\n\n\tfor (i = 0; i < INTEL_PMC_MAX_FIXED; i++) {\n\t\tpmc = &pmu->fixed_counters[i];\n\n\t\tpmc_stop_counter(pmc);\n\t\tpmc->counter = 0;\n\t}\n\n\tpmu->fixed_ctr_ctrl = pmu->global_ctrl = pmu->global_status =\n\t\tpmu->global_ovf_ctrl = 0;\n}"
  },
  {
    "function_name": "intel_pmu_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "356-374",
    "snippet": "static void intel_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tfor (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {\n\t\tpmu->gp_counters[i].type = KVM_PMC_GP;\n\t\tpmu->gp_counters[i].vcpu = vcpu;\n\t\tpmu->gp_counters[i].idx = i;\n\t\tpmu->gp_counters[i].current_config = 0;\n\t}\n\n\tfor (i = 0; i < INTEL_PMC_MAX_FIXED; i++) {\n\t\tpmu->fixed_counters[i].type = KVM_PMC_FIXED;\n\t\tpmu->fixed_counters[i].vcpu = vcpu;\n\t\tpmu->fixed_counters[i].idx = i + INTEL_PMC_IDX_FIXED;\n\t\tpmu->fixed_counters[i].current_config = 0;\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void intel_pmu_init(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\n\tfor (i = 0; i < INTEL_PMC_MAX_GENERIC; i++) {\n\t\tpmu->gp_counters[i].type = KVM_PMC_GP;\n\t\tpmu->gp_counters[i].vcpu = vcpu;\n\t\tpmu->gp_counters[i].idx = i;\n\t\tpmu->gp_counters[i].current_config = 0;\n\t}\n\n\tfor (i = 0; i < INTEL_PMC_MAX_FIXED; i++) {\n\t\tpmu->fixed_counters[i].type = KVM_PMC_FIXED;\n\t\tpmu->fixed_counters[i].vcpu = vcpu;\n\t\tpmu->fixed_counters[i].idx = i + INTEL_PMC_IDX_FIXED;\n\t\tpmu->fixed_counters[i].current_config = 0;\n\t}\n}"
  },
  {
    "function_name": "intel_pmu_refresh",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "289-354",
    "snippet": "static void intel_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct x86_pmu_capability x86_pmu;\n\tstruct kvm_cpuid_entry2 *entry;\n\tunion cpuid10_eax eax;\n\tunion cpuid10_edx edx;\n\n\tpmu->nr_arch_gp_counters = 0;\n\tpmu->nr_arch_fixed_counters = 0;\n\tpmu->counter_bitmask[KVM_PMC_GP] = 0;\n\tpmu->counter_bitmask[KVM_PMC_FIXED] = 0;\n\tpmu->version = 0;\n\tpmu->reserved_bits = 0xffffffff00200000ull;\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0xa, 0);\n\tif (!entry)\n\t\treturn;\n\teax.full = entry->eax;\n\tedx.full = entry->edx;\n\n\tpmu->version = eax.split.version_id;\n\tif (!pmu->version)\n\t\treturn;\n\n\tperf_get_x86_pmu_capability(&x86_pmu);\n\n\tpmu->nr_arch_gp_counters = min_t(int, eax.split.num_counters,\n\t\t\t\t\t x86_pmu.num_counters_gp);\n\tpmu->counter_bitmask[KVM_PMC_GP] = ((u64)1 << eax.split.bit_width) - 1;\n\tpmu->available_event_types = ~entry->ebx &\n\t\t\t\t\t((1ull << eax.split.mask_length) - 1);\n\n\tif (pmu->version == 1) {\n\t\tpmu->nr_arch_fixed_counters = 0;\n\t} else {\n\t\tpmu->nr_arch_fixed_counters =\n\t\t\tmin_t(int, edx.split.num_counters_fixed,\n\t\t\t      x86_pmu.num_counters_fixed);\n\t\tpmu->counter_bitmask[KVM_PMC_FIXED] =\n\t\t\t((u64)1 << edx.split.bit_width_fixed) - 1;\n\t}\n\n\tpmu->global_ctrl = ((1ull << pmu->nr_arch_gp_counters) - 1) |\n\t\t(((1ull << pmu->nr_arch_fixed_counters) - 1) << INTEL_PMC_IDX_FIXED);\n\tpmu->global_ctrl_mask = ~pmu->global_ctrl;\n\tpmu->global_ovf_ctrl_mask = pmu->global_ctrl_mask\n\t\t\t& ~(MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF |\n\t\t\t    MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD);\n\tif (vmx_pt_mode_is_host_guest())\n\t\tpmu->global_ovf_ctrl_mask &=\n\t\t\t\t~MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI;\n\n\tentry = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (entry &&\n\t    (boot_cpu_has(X86_FEATURE_HLE) || boot_cpu_has(X86_FEATURE_RTM)) &&\n\t    (entry->ebx & (X86_FEATURE_HLE|X86_FEATURE_RTM)))\n\t\tpmu->reserved_bits ^= HSW_IN_TX|HSW_IN_TX_CHECKPOINTED;\n\n\tbitmap_set(pmu->all_valid_pmc_idx,\n\t\t0, pmu->nr_arch_gp_counters);\n\tbitmap_set(pmu->all_valid_pmc_idx,\n\t\tINTEL_PMC_MAX_GENERIC, pmu->nr_arch_fixed_counters);\n\n\tnested_vmx_pmu_entry_exit_ctls_update(vcpu);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_vmx_pmu_entry_exit_ctls_update",
          "args": [
            "vcpu"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_pmu_entry_exit_ctls_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "4530-4549",
          "snippet": "void nested_vmx_pmu_entry_exit_ctls_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx;\n\n\tif (!nested_vmx_allowed(vcpu))\n\t\treturn;\n\n\tvmx = to_vmx(vcpu);\n\tif (kvm_x86_ops.pmu_ops->is_valid_msr(vcpu, MSR_CORE_PERF_GLOBAL_CTRL)) {\n\t\tvmx->nested.msrs.entry_ctls_high |=\n\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\tvmx->nested.msrs.exit_ctls_high |=\n\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t} else {\n\t\tvmx->nested.msrs.entry_ctls_high &=\n\t\t\t\t~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\tvmx->nested.msrs.exit_ctls_high &=\n\t\t\t\t~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t}\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nvoid nested_vmx_pmu_entry_exit_ctls_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx;\n\n\tif (!nested_vmx_allowed(vcpu))\n\t\treturn;\n\n\tvmx = to_vmx(vcpu);\n\tif (kvm_x86_ops.pmu_ops->is_valid_msr(vcpu, MSR_CORE_PERF_GLOBAL_CTRL)) {\n\t\tvmx->nested.msrs.entry_ctls_high |=\n\t\t\t\tVM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\tvmx->nested.msrs.exit_ctls_high |=\n\t\t\t\tVM_EXIT_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t} else {\n\t\tvmx->nested.msrs.entry_ctls_high &=\n\t\t\t\t~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t\tvmx->nested.msrs.exit_ctls_high &=\n\t\t\t\t~VM_ENTRY_LOAD_IA32_PERF_GLOBAL_CTRL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "pmu->all_valid_pmc_idx",
            "INTEL_PMC_MAX_GENERIC",
            "pmu->nr_arch_fixed_counters"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "pmu->all_valid_pmc_idx",
            "0",
            "pmu->nr_arch_gp_counters"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_RTM"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_HLE"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_cpuid_entry",
          "args": [
            "vcpu",
            "7",
            "0"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_cpuid_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.c",
          "lines": "903-917",
          "snippet": "struct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *e;\n\tint i;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\n\t\tif (e->function == function && (e->index == index ||\n\t\t    !(e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX)))\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/processor.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/processor.h>\n#include <linux/sched/stat.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/kvm_host.h>\n\nstruct kvm_cpuid_entry2 *kvm_find_cpuid_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t\t      u32 function, u32 index)\n{\n\tstruct kvm_cpuid_entry2 *e;\n\tint i;\n\n\tfor (i = 0; i < vcpu->arch.cpuid_nent; ++i) {\n\t\te = &vcpu->arch.cpuid_entries[i];\n\n\t\tif (e->function == function && (e->index == index ||\n\t\t    !(e->flags & KVM_CPUID_FLAG_SIGNIFCANT_INDEX)))\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_pt_mode_is_host_guest",
          "args": [],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_pt_mode_is_host_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "365-368",
          "snippet": "static inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [
            "#define PT_MODE_HOST_GUEST\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\n#define PT_MODE_HOST_GUEST\t1\n\nstatic inline bool vmx_pt_mode_is_host_guest(void)\n{\n\treturn pt_mode == PT_MODE_HOST_GUEST;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "edx.split.num_counters_fixed",
            "x86_pmu.num_counters_fixed"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "int",
            "eax.split.num_counters",
            "x86_pmu.num_counters_gp"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_get_x86_pmu_capability",
          "args": [
            "&x86_pmu"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void intel_pmu_refresh(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct x86_pmu_capability x86_pmu;\n\tstruct kvm_cpuid_entry2 *entry;\n\tunion cpuid10_eax eax;\n\tunion cpuid10_edx edx;\n\n\tpmu->nr_arch_gp_counters = 0;\n\tpmu->nr_arch_fixed_counters = 0;\n\tpmu->counter_bitmask[KVM_PMC_GP] = 0;\n\tpmu->counter_bitmask[KVM_PMC_FIXED] = 0;\n\tpmu->version = 0;\n\tpmu->reserved_bits = 0xffffffff00200000ull;\n\n\tentry = kvm_find_cpuid_entry(vcpu, 0xa, 0);\n\tif (!entry)\n\t\treturn;\n\teax.full = entry->eax;\n\tedx.full = entry->edx;\n\n\tpmu->version = eax.split.version_id;\n\tif (!pmu->version)\n\t\treturn;\n\n\tperf_get_x86_pmu_capability(&x86_pmu);\n\n\tpmu->nr_arch_gp_counters = min_t(int, eax.split.num_counters,\n\t\t\t\t\t x86_pmu.num_counters_gp);\n\tpmu->counter_bitmask[KVM_PMC_GP] = ((u64)1 << eax.split.bit_width) - 1;\n\tpmu->available_event_types = ~entry->ebx &\n\t\t\t\t\t((1ull << eax.split.mask_length) - 1);\n\n\tif (pmu->version == 1) {\n\t\tpmu->nr_arch_fixed_counters = 0;\n\t} else {\n\t\tpmu->nr_arch_fixed_counters =\n\t\t\tmin_t(int, edx.split.num_counters_fixed,\n\t\t\t      x86_pmu.num_counters_fixed);\n\t\tpmu->counter_bitmask[KVM_PMC_FIXED] =\n\t\t\t((u64)1 << edx.split.bit_width_fixed) - 1;\n\t}\n\n\tpmu->global_ctrl = ((1ull << pmu->nr_arch_gp_counters) - 1) |\n\t\t(((1ull << pmu->nr_arch_fixed_counters) - 1) << INTEL_PMC_IDX_FIXED);\n\tpmu->global_ctrl_mask = ~pmu->global_ctrl;\n\tpmu->global_ovf_ctrl_mask = pmu->global_ctrl_mask\n\t\t\t& ~(MSR_CORE_PERF_GLOBAL_OVF_CTRL_OVF_BUF |\n\t\t\t    MSR_CORE_PERF_GLOBAL_OVF_CTRL_COND_CHGD);\n\tif (vmx_pt_mode_is_host_guest())\n\t\tpmu->global_ovf_ctrl_mask &=\n\t\t\t\t~MSR_CORE_PERF_GLOBAL_OVF_CTRL_TRACE_TOPA_PMI;\n\n\tentry = kvm_find_cpuid_entry(vcpu, 7, 0);\n\tif (entry &&\n\t    (boot_cpu_has(X86_FEATURE_HLE) || boot_cpu_has(X86_FEATURE_RTM)) &&\n\t    (entry->ebx & (X86_FEATURE_HLE|X86_FEATURE_RTM)))\n\t\tpmu->reserved_bits ^= HSW_IN_TX|HSW_IN_TX_CHECKPOINTED;\n\n\tbitmap_set(pmu->all_valid_pmc_idx,\n\t\t0, pmu->nr_arch_gp_counters);\n\tbitmap_set(pmu->all_valid_pmc_idx,\n\t\tINTEL_PMC_MAX_GENERIC, pmu->nr_arch_fixed_counters);\n\n\tnested_vmx_pmu_entry_exit_ctls_update(vcpu);\n}"
  },
  {
    "function_name": "intel_pmu_set_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "223-287",
    "snippet": "static int intel_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\t\tif (pmu->fixed_ctr_ctrl == data)\n\t\t\treturn 0;\n\t\tif (!(data & 0xfffffffffffff444ull)) {\n\t\t\treprogram_fixed_counters(pmu, data);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\t\tif (msr_info->host_initiated) {\n\t\t\tpmu->global_status = data;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak; /* RO MSR */\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (pmu->global_ctrl == data)\n\t\t\treturn 0;\n\t\tif (kvm_valid_perf_global_ctrl(pmu, data)) {\n\t\t\tglobal_ctrl_changed(pmu, data);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\tif (!(data & pmu->global_ovf_ctrl_mask)) {\n\t\t\tif (!msr_info->host_initiated)\n\t\t\t\tpmu->global_status &= ~data;\n\t\t\tpmu->global_ovf_ctrl = data;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif ((pmc = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0))) {\n\t\t\tif (!msr_info->host_initiated)\n\t\t\t\tdata = (s64)(s32)data;\n\t\t\tpmc->counter += data - pmc_read_counter(pmc);\n\t\t\tif (pmc->perf_event)\n\t\t\t\tperf_event_period(pmc->perf_event,\n\t\t\t\t\t\t  get_sample_period(pmc, data));\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_fixed_pmc(pmu, msr))) {\n\t\t\tpmc->counter += data - pmc_read_counter(pmc);\n\t\t\tif (pmc->perf_event)\n\t\t\t\tperf_event_period(pmc->perf_event,\n\t\t\t\t\t\t  get_sample_period(pmc, data));\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0))) {\n\t\t\tif (data == pmc->eventsel)\n\t\t\t\treturn 0;\n\t\t\tif (!(data & pmu->reserved_bits)) {\n\t\t\t\treprogram_gp_counter(pmc, data);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reprogram_gp_counter",
          "args": [
            "pmc",
            "data"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_gp_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.c",
          "lines": "171-236",
          "snippet": "void reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\tstruct kvm *kvm = pmc->vcpu->kvm;\n\tstruct kvm_pmu_event_filter *filter;\n\tint i;\n\tbool allow_event = true;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_pause_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tfilter = srcu_dereference(kvm->arch.pmu_event_filter, &kvm->srcu);\n\tif (filter) {\n\t\tfor (i = 0; i < filter->nevents; i++)\n\t\t\tif (filter->events[i] ==\n\t\t\t    (eventsel & AMD64_RAW_EVENT_MASK_NB))\n\t\t\t\tbreak;\n\t\tif (filter->action == KVM_PMU_EVENT_ALLOW &&\n\t\t    i == filter->nevents)\n\t\t\tallow_event = false;\n\t\tif (filter->action == KVM_PMU_EVENT_DENY &&\n\t\t    i < filter->nevents)\n\t\t\tallow_event = false;\n\t}\n\tif (!allow_event)\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops.pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tif (pmc->current_config == eventsel && pmc_resume_counter(pmc))\n\t\treturn;\n\n\tpmc_release_perf_event(pmc);\n\n\tpmc->current_config = eventsel;\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_gp_counter(struct kvm_pmc *pmc, u64 eventsel)\n{\n\tunsigned config, type = PERF_TYPE_RAW;\n\tu8 event_select, unit_mask;\n\tstruct kvm *kvm = pmc->vcpu->kvm;\n\tstruct kvm_pmu_event_filter *filter;\n\tint i;\n\tbool allow_event = true;\n\n\tif (eventsel & ARCH_PERFMON_EVENTSEL_PIN_CONTROL)\n\t\tprintk_once(\"kvm pmu: pin control bit is ignored\\n\");\n\n\tpmc->eventsel = eventsel;\n\n\tpmc_pause_counter(pmc);\n\n\tif (!(eventsel & ARCH_PERFMON_EVENTSEL_ENABLE) || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tfilter = srcu_dereference(kvm->arch.pmu_event_filter, &kvm->srcu);\n\tif (filter) {\n\t\tfor (i = 0; i < filter->nevents; i++)\n\t\t\tif (filter->events[i] ==\n\t\t\t    (eventsel & AMD64_RAW_EVENT_MASK_NB))\n\t\t\t\tbreak;\n\t\tif (filter->action == KVM_PMU_EVENT_ALLOW &&\n\t\t    i == filter->nevents)\n\t\t\tallow_event = false;\n\t\tif (filter->action == KVM_PMU_EVENT_DENY &&\n\t\t    i < filter->nevents)\n\t\t\tallow_event = false;\n\t}\n\tif (!allow_event)\n\t\treturn;\n\n\tevent_select = eventsel & ARCH_PERFMON_EVENTSEL_EVENT;\n\tunit_mask = (eventsel & ARCH_PERFMON_EVENTSEL_UMASK) >> 8;\n\n\tif (!(eventsel & (ARCH_PERFMON_EVENTSEL_EDGE |\n\t\t\t  ARCH_PERFMON_EVENTSEL_INV |\n\t\t\t  ARCH_PERFMON_EVENTSEL_CMASK |\n\t\t\t  HSW_IN_TX |\n\t\t\t  HSW_IN_TX_CHECKPOINTED))) {\n\t\tconfig = kvm_x86_ops.pmu_ops->find_arch_event(pmc_to_pmu(pmc),\n\t\t\t\t\t\t      event_select,\n\t\t\t\t\t\t      unit_mask);\n\t\tif (config != PERF_COUNT_HW_MAX)\n\t\t\ttype = PERF_TYPE_HARDWARE;\n\t}\n\n\tif (type == PERF_TYPE_RAW)\n\t\tconfig = eventsel & X86_RAW_EVENT_MASK;\n\n\tif (pmc->current_config == eventsel && pmc_resume_counter(pmc))\n\t\treturn;\n\n\tpmc_release_perf_event(pmc);\n\n\tpmc->current_config = eventsel;\n\tpmc_reprogram_counter(pmc, type, config,\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_USR),\n\t\t\t      !(eventsel & ARCH_PERFMON_EVENTSEL_OS),\n\t\t\t      eventsel & ARCH_PERFMON_EVENTSEL_INT,\n\t\t\t      (eventsel & HSW_IN_TX),\n\t\t\t      (eventsel & HSW_IN_TX_CHECKPOINTED));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "msr",
            "MSR_P6_EVNTSEL0"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "104-115",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_gp_counters);\n\n\t\treturn &pmu->gp_counters[index];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_gp_counters);\n\n\t\treturn &pmu->gp_counters[index];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_period",
          "args": [
            "pmc->perf_event",
            "get_sample_period(pmc, data)"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_sample_period",
          "args": [
            "pmc",
            "data"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "get_sample_period",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "132-139",
          "snippet": "static inline u64 get_sample_period(struct kvm_pmc *pmc, u64 counter_value)\n{\n\tu64 sample_period = (-counter_value) & pmc_bitmask(pmc);\n\n\tif (!sample_period)\n\t\tsample_period = pmc_bitmask(pmc) + 1;\n\treturn sample_period;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline u64 get_sample_period(struct kvm_pmc *pmc, u64 counter_value)\n{\n\tu64 sample_period = (-counter_value) & pmc_bitmask(pmc);\n\n\tif (!sample_period)\n\t\tsample_period = pmc_bitmask(pmc) + 1;\n\treturn sample_period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_read_counter",
          "args": [
            "pmc"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_read_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "49-59",
          "snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fixed_pmc",
          "args": [
            "pmu",
            "msr"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "get_fixed_pmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "118-130",
          "snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_event_period",
          "args": [
            "pmc->perf_event",
            "get_sample_period(pmc, data)"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "global_ctrl_changed",
          "args": [
            "pmu",
            "data"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "global_ctrl_changed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
          "lines": "58-67",
          "snippet": "static void global_ctrl_changed(struct kvm_pmu *pmu, u64 data)\n{\n\tint bit;\n\tu64 diff = pmu->global_ctrl ^ data;\n\n\tpmu->global_ctrl = data;\n\n\tfor_each_set_bit(bit, (unsigned long *)&diff, X86_PMC_IDX_MAX)\n\t\treprogram_counter(pmu, bit);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void global_ctrl_changed(struct kvm_pmu *pmu, u64 data)\n{\n\tint bit;\n\tu64 diff = pmu->global_ctrl ^ data;\n\n\tpmu->global_ctrl = data;\n\n\tfor_each_set_bit(bit, (unsigned long *)&diff, X86_PMC_IDX_MAX)\n\t\treprogram_counter(pmu, bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_valid_perf_global_ctrl",
          "args": [
            "pmu",
            "data"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_valid_perf_global_ctrl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "94-98",
          "snippet": "static inline bool kvm_valid_perf_global_ctrl(struct kvm_pmu *pmu,\n\t\t\t\t\t\t u64 data)\n{\n\treturn !(pmu->global_ctrl_mask & data);\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline bool kvm_valid_perf_global_ctrl(struct kvm_pmu *pmu,\n\t\t\t\t\t\t u64 data)\n{\n\treturn !(pmu->global_ctrl_mask & data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reprogram_fixed_counters",
          "args": [
            "pmu",
            "data"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_fixed_counters",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
          "lines": "36-55",
          "snippet": "static void reprogram_fixed_counters(struct kvm_pmu *pmu, u64 data)\n{\n\tint i;\n\n\tfor (i = 0; i < pmu->nr_arch_fixed_counters; i++) {\n\t\tu8 new_ctrl = fixed_ctrl_field(data, i);\n\t\tu8 old_ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, i);\n\t\tstruct kvm_pmc *pmc;\n\n\t\tpmc = get_fixed_pmc(pmu, MSR_CORE_PERF_FIXED_CTR0 + i);\n\n\t\tif (old_ctrl == new_ctrl)\n\t\t\tcontinue;\n\n\t\t__set_bit(INTEL_PMC_IDX_FIXED + i, pmu->pmc_in_use);\n\t\treprogram_fixed_counter(pmc, new_ctrl, i);\n\t}\n\n\tpmu->fixed_ctr_ctrl = data;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void reprogram_fixed_counters(struct kvm_pmu *pmu, u64 data)\n{\n\tint i;\n\n\tfor (i = 0; i < pmu->nr_arch_fixed_counters; i++) {\n\t\tu8 new_ctrl = fixed_ctrl_field(data, i);\n\t\tu8 old_ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, i);\n\t\tstruct kvm_pmc *pmc;\n\n\t\tpmc = get_fixed_pmc(pmu, MSR_CORE_PERF_FIXED_CTR0 + i);\n\n\t\tif (old_ctrl == new_ctrl)\n\t\t\tcontinue;\n\n\t\t__set_bit(INTEL_PMC_IDX_FIXED + i, pmu->pmc_in_use);\n\t\treprogram_fixed_counter(pmc, new_ctrl, i);\n\t}\n\n\tpmu->fixed_ctr_ctrl = data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int intel_pmu_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\t\tif (pmu->fixed_ctr_ctrl == data)\n\t\t\treturn 0;\n\t\tif (!(data & 0xfffffffffffff444ull)) {\n\t\t\treprogram_fixed_counters(pmu, data);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\t\tif (msr_info->host_initiated) {\n\t\t\tpmu->global_status = data;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak; /* RO MSR */\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\tif (pmu->global_ctrl == data)\n\t\t\treturn 0;\n\t\tif (kvm_valid_perf_global_ctrl(pmu, data)) {\n\t\t\tglobal_ctrl_changed(pmu, data);\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\tif (!(data & pmu->global_ovf_ctrl_mask)) {\n\t\t\tif (!msr_info->host_initiated)\n\t\t\t\tpmu->global_status &= ~data;\n\t\t\tpmu->global_ovf_ctrl = data;\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif ((pmc = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0))) {\n\t\t\tif (!msr_info->host_initiated)\n\t\t\t\tdata = (s64)(s32)data;\n\t\t\tpmc->counter += data - pmc_read_counter(pmc);\n\t\t\tif (pmc->perf_event)\n\t\t\t\tperf_event_period(pmc->perf_event,\n\t\t\t\t\t\t  get_sample_period(pmc, data));\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_fixed_pmc(pmu, msr))) {\n\t\t\tpmc->counter += data - pmc_read_counter(pmc);\n\t\t\tif (pmc->perf_event)\n\t\t\t\tperf_event_period(pmc->perf_event,\n\t\t\t\t\t\t  get_sample_period(pmc, data));\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0))) {\n\t\t\tif (data == pmc->eventsel)\n\t\t\t\treturn 0;\n\t\t\tif (!(data & pmu->reserved_bits)) {\n\t\t\t\treprogram_gp_counter(pmc, data);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "intel_pmu_get_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "187-221",
    "snippet": "static int intel_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\t\t*data = pmu->fixed_ctr_ctrl;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\t\t*data = pmu->global_status;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\t*data = pmu->global_ctrl;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\t*data = pmu->global_ovf_ctrl;\n\t\treturn 0;\n\tdefault:\n\t\tif ((pmc = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0))) {\n\t\t\tu64 val = pmc_read_counter(pmc);\n\t\t\t*data = val & pmu->counter_bitmask[KVM_PMC_GP];\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_fixed_pmc(pmu, msr))) {\n\t\t\tu64 val = pmc_read_counter(pmc);\n\t\t\t*data = val & pmu->counter_bitmask[KVM_PMC_FIXED];\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0))) {\n\t\t\t*data = pmc->eventsel;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "msr",
            "MSR_P6_EVNTSEL0"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "104-115",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_gp_counters);\n\n\t\treturn &pmu->gp_counters[index];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_gp_counters);\n\n\t\treturn &pmu->gp_counters[index];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pmc_read_counter",
          "args": [
            "pmc"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "pmc_read_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "49-59",
          "snippet": "static inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline u64 pmc_read_counter(struct kvm_pmc *pmc)\n{\n\tu64 counter, enabled, running;\n\n\tcounter = pmc->counter;\n\tif (pmc->perf_event)\n\t\tcounter += perf_event_read_value(pmc->perf_event,\n\t\t\t\t\t\t &enabled, &running);\n\t/* FIXME: Scaling needed? */\n\treturn counter & pmc_bitmask(pmc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fixed_pmc",
          "args": [
            "pmu",
            "msr"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "get_fixed_pmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "118-130",
          "snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int intel_pmu_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *data)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\t\t*data = pmu->fixed_ctr_ctrl;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\t\t*data = pmu->global_status;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\t\t*data = pmu->global_ctrl;\n\t\treturn 0;\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\t*data = pmu->global_ovf_ctrl;\n\t\treturn 0;\n\tdefault:\n\t\tif ((pmc = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0))) {\n\t\t\tu64 val = pmc_read_counter(pmc);\n\t\t\t*data = val & pmu->counter_bitmask[KVM_PMC_GP];\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_fixed_pmc(pmu, msr))) {\n\t\t\tu64 val = pmc_read_counter(pmc);\n\t\t\t*data = val & pmu->counter_bitmask[KVM_PMC_FIXED];\n\t\t\treturn 0;\n\t\t} else if ((pmc = get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0))) {\n\t\t\t*data = pmc->eventsel;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "intel_msr_idx_to_pmc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "175-185",
    "snippet": "static struct kvm_pmc *intel_msr_idx_to_pmc(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\tpmc = get_fixed_pmc(pmu, msr);\n\tpmc = pmc ? pmc : get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0);\n\tpmc = pmc ? pmc : get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0);\n\n\treturn pmc;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "msr",
            "MSR_IA32_PERFCTR0"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "104-115",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_gp_counters);\n\n\t\treturn &pmu->gp_counters[index];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_gp_counters);\n\n\t\treturn &pmu->gp_counters[index];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_fixed_pmc",
          "args": [
            "pmu",
            "msr"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "get_fixed_pmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "118-130",
          "snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_pmc *intel_msr_idx_to_pmc(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tstruct kvm_pmc *pmc;\n\n\tpmc = get_fixed_pmc(pmu, msr);\n\tpmc = pmc ? pmc : get_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0);\n\tpmc = pmc ? pmc : get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0);\n\n\treturn pmc;\n}"
  },
  {
    "function_name": "intel_is_valid_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "153-173",
    "snippet": "static bool intel_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint ret;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\tret = pmu->version > 1;\n\t\tbreak;\n\tdefault:\n\t\tret = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0) ||\n\t\t\tget_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0) ||\n\t\t\tget_fixed_pmc(pmu, msr);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_fixed_pmc",
          "args": [
            "pmu",
            "msr"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "get_fixed_pmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "118-130",
          "snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "msr",
            "MSR_P6_EVNTSEL0"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "104-115",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_gp_counters);\n\n\t\treturn &pmu->gp_counters[index];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_gp_counters);\n\n\t\treturn &pmu->gp_counters[index];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic bool intel_is_valid_msr(struct kvm_vcpu *vcpu, u32 msr)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tint ret;\n\n\tswitch (msr) {\n\tcase MSR_CORE_PERF_FIXED_CTR_CTRL:\n\tcase MSR_CORE_PERF_GLOBAL_STATUS:\n\tcase MSR_CORE_PERF_GLOBAL_CTRL:\n\tcase MSR_CORE_PERF_GLOBAL_OVF_CTRL:\n\t\tret = pmu->version > 1;\n\t\tbreak;\n\tdefault:\n\t\tret = get_gp_pmc(pmu, msr, MSR_IA32_PERFCTR0) ||\n\t\t\tget_gp_pmc(pmu, msr, MSR_P6_EVNTSEL0) ||\n\t\t\tget_fixed_pmc(pmu, msr);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "intel_rdpmc_ecx_to_pmc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "131-151",
    "snippet": "static struct kvm_pmc *intel_rdpmc_ecx_to_pmc(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int idx, u64 *mask)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tbool fixed = idx & (1u << 30);\n\tstruct kvm_pmc *counters;\n\tunsigned int num_counters;\n\n\tidx &= ~(3u << 30);\n\tif (fixed) {\n\t\tcounters = pmu->fixed_counters;\n\t\tnum_counters = pmu->nr_arch_fixed_counters;\n\t} else {\n\t\tcounters = pmu->gp_counters;\n\t\tnum_counters = pmu->nr_arch_gp_counters;\n\t}\n\tif (idx >= num_counters)\n\t\treturn NULL;\n\t*mask &= pmu->counter_bitmask[fixed ? KVM_PMC_FIXED : KVM_PMC_GP];\n\treturn &counters[array_index_nospec(idx, num_counters)];\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "idx",
            "num_counters"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_pmc *intel_rdpmc_ecx_to_pmc(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int idx, u64 *mask)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tbool fixed = idx & (1u << 30);\n\tstruct kvm_pmc *counters;\n\tunsigned int num_counters;\n\n\tidx &= ~(3u << 30);\n\tif (fixed) {\n\t\tcounters = pmu->fixed_counters;\n\t\tnum_counters = pmu->nr_arch_fixed_counters;\n\t} else {\n\t\tcounters = pmu->gp_counters;\n\t\tnum_counters = pmu->nr_arch_gp_counters;\n\t}\n\tif (idx >= num_counters)\n\t\treturn NULL;\n\t*mask &= pmu->counter_bitmask[fixed ? KVM_PMC_FIXED : KVM_PMC_GP];\n\treturn &counters[array_index_nospec(idx, num_counters)];\n}"
  },
  {
    "function_name": "intel_is_valid_rdpmc_ecx",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "120-129",
    "snippet": "static int intel_is_valid_rdpmc_ecx(struct kvm_vcpu *vcpu, unsigned int idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tbool fixed = idx & (1u << 30);\n\n\tidx &= ~(3u << 30);\n\n\treturn (!fixed && idx >= pmu->nr_arch_gp_counters) ||\n\t\t(fixed && idx >= pmu->nr_arch_fixed_counters);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_pmu",
          "args": [
            "vcpu"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic int intel_is_valid_rdpmc_ecx(struct kvm_vcpu *vcpu, unsigned int idx)\n{\n\tstruct kvm_pmu *pmu = vcpu_to_pmu(vcpu);\n\tbool fixed = idx & (1u << 30);\n\n\tidx &= ~(3u << 30);\n\n\treturn (!fixed && idx >= pmu->nr_arch_gp_counters) ||\n\t\t(fixed && idx >= pmu->nr_arch_fixed_counters);\n}"
  },
  {
    "function_name": "intel_pmc_idx_to_pmc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "107-117",
    "snippet": "static struct kvm_pmc *intel_pmc_idx_to_pmc(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tif (pmc_idx < INTEL_PMC_IDX_FIXED)\n\t\treturn get_gp_pmc(pmu, MSR_P6_EVNTSEL0 + pmc_idx,\n\t\t\t\t  MSR_P6_EVNTSEL0);\n\telse {\n\t\tu32 idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\n\t\treturn get_fixed_pmc(pmu, idx + MSR_CORE_PERF_FIXED_CTR0);\n\t}\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_fixed_pmc",
          "args": [
            "pmu",
            "idx + MSR_CORE_PERF_FIXED_CTR0"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "get_fixed_pmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "118-130",
          "snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_gp_pmc",
          "args": [
            "pmu",
            "MSR_P6_EVNTSEL0 + pmc_idx",
            "MSR_P6_EVNTSEL0"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "get_gp_pmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "104-115",
          "snippet": "static inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_gp_counters);\n\n\t\treturn &pmu->gp_counters[index];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline struct kvm_pmc *get_gp_pmc(struct kvm_pmu *pmu, u32 msr,\n\t\t\t\t\t u32 base)\n{\n\tif (msr >= base && msr < base + pmu->nr_arch_gp_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_gp_counters);\n\n\t\treturn &pmu->gp_counters[index];\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_pmc *intel_pmc_idx_to_pmc(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tif (pmc_idx < INTEL_PMC_IDX_FIXED)\n\t\treturn get_gp_pmc(pmu, MSR_P6_EVNTSEL0 + pmc_idx,\n\t\t\t\t  MSR_P6_EVNTSEL0);\n\telse {\n\t\tu32 idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\n\t\treturn get_fixed_pmc(pmu, idx + MSR_CORE_PERF_FIXED_CTR0);\n\t}\n}"
  },
  {
    "function_name": "intel_pmc_is_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "100-105",
    "snippet": "static bool intel_pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\treturn test_bit(pmc->idx, (unsigned long *)&pmu->global_ctrl);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "pmc->idx",
            "(unsigned long *)&pmu->global_ctrl"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pmc_to_pmu",
          "args": [
            "pmc"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic bool intel_pmc_is_enabled(struct kvm_pmc *pmc)\n{\n\tstruct kvm_pmu *pmu = pmc_to_pmu(pmc);\n\n\treturn test_bit(pmc->idx, (unsigned long *)&pmu->global_ctrl);\n}"
  },
  {
    "function_name": "intel_find_fixed_event",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "87-97",
    "snippet": "static unsigned intel_find_fixed_event(int idx)\n{\n\tu32 event;\n\tsize_t size = ARRAY_SIZE(fixed_pmc_events);\n\n\tif (idx >= size)\n\t\treturn PERF_COUNT_HW_MAX;\n\n\tevent = fixed_pmc_events[array_index_nospec(idx, size)];\n\treturn intel_arch_events[event].event_type;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kvm_event_hw_type_mapping intel_arch_events[] = {\n\t/* Index must match CPUID 0x0A.EBX bit vector */\n\t[0] = { 0x3c, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x3c, 0x01, PERF_COUNT_HW_BUS_CYCLES  },\n\t[3] = { 0x2e, 0x4f, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[4] = { 0x2e, 0x41, PERF_COUNT_HW_CACHE_MISSES },\n\t[5] = { 0xc4, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[6] = { 0xc5, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[7] = { 0x00, 0x30, PERF_COUNT_HW_REF_CPU_CYCLES },\n};",
      "static int fixed_pmc_events[] = {1, 0, 7};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "idx",
            "size"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "fixed_pmc_events"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_event_hw_type_mapping intel_arch_events[] = {\n\t/* Index must match CPUID 0x0A.EBX bit vector */\n\t[0] = { 0x3c, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x3c, 0x01, PERF_COUNT_HW_BUS_CYCLES  },\n\t[3] = { 0x2e, 0x4f, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[4] = { 0x2e, 0x41, PERF_COUNT_HW_CACHE_MISSES },\n\t[5] = { 0xc4, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[6] = { 0xc5, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[7] = { 0x00, 0x30, PERF_COUNT_HW_REF_CPU_CYCLES },\n};\nstatic int fixed_pmc_events[] = {1, 0, 7};\n\nstatic unsigned intel_find_fixed_event(int idx)\n{\n\tu32 event;\n\tsize_t size = ARRAY_SIZE(fixed_pmc_events);\n\n\tif (idx >= size)\n\t\treturn PERF_COUNT_HW_MAX;\n\n\tevent = fixed_pmc_events[array_index_nospec(idx, size)];\n\treturn intel_arch_events[event].event_type;\n}"
  },
  {
    "function_name": "intel_find_arch_event",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "69-85",
    "snippet": "static unsigned intel_find_arch_event(struct kvm_pmu *pmu,\n\t\t\t\t      u8 event_select,\n\t\t\t\t      u8 unit_mask)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(intel_arch_events); i++)\n\t\tif (intel_arch_events[i].eventsel == event_select\n\t\t    && intel_arch_events[i].unit_mask == unit_mask\n\t\t    && (pmu->available_event_types & (1 << i)))\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(intel_arch_events))\n\t\treturn PERF_COUNT_HW_MAX;\n\n\treturn intel_arch_events[i].event_type;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kvm_event_hw_type_mapping intel_arch_events[] = {\n\t/* Index must match CPUID 0x0A.EBX bit vector */\n\t[0] = { 0x3c, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x3c, 0x01, PERF_COUNT_HW_BUS_CYCLES  },\n\t[3] = { 0x2e, 0x4f, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[4] = { 0x2e, 0x41, PERF_COUNT_HW_CACHE_MISSES },\n\t[5] = { 0xc4, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[6] = { 0xc5, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[7] = { 0x00, 0x30, PERF_COUNT_HW_REF_CPU_CYCLES },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "intel_arch_events"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "intel_arch_events"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic struct kvm_event_hw_type_mapping intel_arch_events[] = {\n\t/* Index must match CPUID 0x0A.EBX bit vector */\n\t[0] = { 0x3c, 0x00, PERF_COUNT_HW_CPU_CYCLES },\n\t[1] = { 0xc0, 0x00, PERF_COUNT_HW_INSTRUCTIONS },\n\t[2] = { 0x3c, 0x01, PERF_COUNT_HW_BUS_CYCLES  },\n\t[3] = { 0x2e, 0x4f, PERF_COUNT_HW_CACHE_REFERENCES },\n\t[4] = { 0x2e, 0x41, PERF_COUNT_HW_CACHE_MISSES },\n\t[5] = { 0xc4, 0x00, PERF_COUNT_HW_BRANCH_INSTRUCTIONS },\n\t[6] = { 0xc5, 0x00, PERF_COUNT_HW_BRANCH_MISSES },\n\t[7] = { 0x00, 0x30, PERF_COUNT_HW_REF_CPU_CYCLES },\n};\n\nstatic unsigned intel_find_arch_event(struct kvm_pmu *pmu,\n\t\t\t\t      u8 event_select,\n\t\t\t\t      u8 unit_mask)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(intel_arch_events); i++)\n\t\tif (intel_arch_events[i].eventsel == event_select\n\t\t    && intel_arch_events[i].unit_mask == unit_mask\n\t\t    && (pmu->available_event_types & (1 << i)))\n\t\t\tbreak;\n\n\tif (i == ARRAY_SIZE(intel_arch_events))\n\t\treturn PERF_COUNT_HW_MAX;\n\n\treturn intel_arch_events[i].event_type;\n}"
  },
  {
    "function_name": "global_ctrl_changed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "58-67",
    "snippet": "static void global_ctrl_changed(struct kvm_pmu *pmu, u64 data)\n{\n\tint bit;\n\tu64 diff = pmu->global_ctrl ^ data;\n\n\tpmu->global_ctrl = data;\n\n\tfor_each_set_bit(bit, (unsigned long *)&diff, X86_PMC_IDX_MAX)\n\t\treprogram_counter(pmu, bit);\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reprogram_counter",
          "args": [
            "pmu",
            "bit"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.c",
          "lines": "275-290",
          "snippet": "void reprogram_counter(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tstruct kvm_pmc *pmc = kvm_x86_ops.pmu_ops->pmc_idx_to_pmc(pmu, pmc_idx);\n\n\tif (!pmc)\n\t\treturn;\n\n\tif (pmc_is_gp(pmc))\n\t\treprogram_gp_counter(pmc, pmc->eventsel);\n\telse {\n\t\tint idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\t\tu8 ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, idx);\n\n\t\treprogram_fixed_counter(pmc, ctrl, idx);\n\t}\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_counter(struct kvm_pmu *pmu, int pmc_idx)\n{\n\tstruct kvm_pmc *pmc = kvm_x86_ops.pmu_ops->pmc_idx_to_pmc(pmu, pmc_idx);\n\n\tif (!pmc)\n\t\treturn;\n\n\tif (pmc_is_gp(pmc))\n\t\treprogram_gp_counter(pmc, pmc->eventsel);\n\telse {\n\t\tint idx = pmc_idx - INTEL_PMC_IDX_FIXED;\n\t\tu8 ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, idx);\n\n\t\treprogram_fixed_counter(pmc, ctrl, idx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "bit",
            "(unsigned long *)&diff",
            "X86_PMC_IDX_MAX"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void global_ctrl_changed(struct kvm_pmu *pmu, u64 data)\n{\n\tint bit;\n\tu64 diff = pmu->global_ctrl ^ data;\n\n\tpmu->global_ctrl = data;\n\n\tfor_each_set_bit(bit, (unsigned long *)&diff, X86_PMC_IDX_MAX)\n\t\treprogram_counter(pmu, bit);\n}"
  },
  {
    "function_name": "reprogram_fixed_counters",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/pmu_intel.c",
    "lines": "36-55",
    "snippet": "static void reprogram_fixed_counters(struct kvm_pmu *pmu, u64 data)\n{\n\tint i;\n\n\tfor (i = 0; i < pmu->nr_arch_fixed_counters; i++) {\n\t\tu8 new_ctrl = fixed_ctrl_field(data, i);\n\t\tu8 old_ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, i);\n\t\tstruct kvm_pmc *pmc;\n\n\t\tpmc = get_fixed_pmc(pmu, MSR_CORE_PERF_FIXED_CTR0 + i);\n\n\t\tif (old_ctrl == new_ctrl)\n\t\t\tcontinue;\n\n\t\t__set_bit(INTEL_PMC_IDX_FIXED + i, pmu->pmc_in_use);\n\t\treprogram_fixed_counter(pmc, new_ctrl, i);\n\t}\n\n\tpmu->fixed_ctr_ctrl = data;\n}",
    "includes": [
      "#include \"pmu.h\"",
      "#include \"nested.h\"",
      "#include \"lapic.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include <asm/perf_event.h>",
      "#include <linux/perf_event.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reprogram_fixed_counter",
          "args": [
            "pmc",
            "new_ctrl",
            "i"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "reprogram_fixed_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.c",
          "lines": "239-272",
          "snippet": "void reprogram_fixed_counter(struct kvm_pmc *pmc, u8 ctrl, int idx)\n{\n\tunsigned en_field = ctrl & 0x3;\n\tbool pmi = ctrl & 0x8;\n\tstruct kvm_pmu_event_filter *filter;\n\tstruct kvm *kvm = pmc->vcpu->kvm;\n\n\tpmc_pause_counter(pmc);\n\n\tif (!en_field || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tfilter = srcu_dereference(kvm->arch.pmu_event_filter, &kvm->srcu);\n\tif (filter) {\n\t\tif (filter->action == KVM_PMU_EVENT_DENY &&\n\t\t    test_bit(idx, (ulong *)&filter->fixed_counter_bitmap))\n\t\t\treturn;\n\t\tif (filter->action == KVM_PMU_EVENT_ALLOW &&\n\t\t    !test_bit(idx, (ulong *)&filter->fixed_counter_bitmap))\n\t\t\treturn;\n\t}\n\n\tif (pmc->current_config == (u64)ctrl && pmc_resume_counter(pmc))\n\t\treturn;\n\n\tpmc_release_perf_event(pmc);\n\n\tpmc->current_config = (u64)ctrl;\n\tpmc_reprogram_counter(pmc, PERF_TYPE_HARDWARE,\n\t\t\t      kvm_x86_ops.pmu_ops->find_fixed_event(idx),\n\t\t\t      !(en_field & 0x2), /* exclude user */\n\t\t\t      !(en_field & 0x1), /* exclude kernel */\n\t\t\t      pmi, false, false);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include <asm/perf_event.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nvoid reprogram_fixed_counter(struct kvm_pmc *pmc, u8 ctrl, int idx)\n{\n\tunsigned en_field = ctrl & 0x3;\n\tbool pmi = ctrl & 0x8;\n\tstruct kvm_pmu_event_filter *filter;\n\tstruct kvm *kvm = pmc->vcpu->kvm;\n\n\tpmc_pause_counter(pmc);\n\n\tif (!en_field || !pmc_is_enabled(pmc))\n\t\treturn;\n\n\tfilter = srcu_dereference(kvm->arch.pmu_event_filter, &kvm->srcu);\n\tif (filter) {\n\t\tif (filter->action == KVM_PMU_EVENT_DENY &&\n\t\t    test_bit(idx, (ulong *)&filter->fixed_counter_bitmap))\n\t\t\treturn;\n\t\tif (filter->action == KVM_PMU_EVENT_ALLOW &&\n\t\t    !test_bit(idx, (ulong *)&filter->fixed_counter_bitmap))\n\t\t\treturn;\n\t}\n\n\tif (pmc->current_config == (u64)ctrl && pmc_resume_counter(pmc))\n\t\treturn;\n\n\tpmc_release_perf_event(pmc);\n\n\tpmc->current_config = (u64)ctrl;\n\tpmc_reprogram_counter(pmc, PERF_TYPE_HARDWARE,\n\t\t\t      kvm_x86_ops.pmu_ops->find_fixed_event(idx),\n\t\t\t      !(en_field & 0x2), /* exclude user */\n\t\t\t      !(en_field & 0x1), /* exclude kernel */\n\t\t\t      pmi, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "INTEL_PMC_IDX_FIXED + i",
            "pmu->pmc_in_use"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fixed_pmc",
          "args": [
            "pmu",
            "MSR_CORE_PERF_FIXED_CTR0 + i"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "get_fixed_pmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/pmu.h",
          "lines": "118-130",
          "snippet": "static inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n\nstatic inline struct kvm_pmc *get_fixed_pmc(struct kvm_pmu *pmu, u32 msr)\n{\n\tint base = MSR_CORE_PERF_FIXED_CTR0;\n\n\tif (msr >= base && msr < base + pmu->nr_arch_fixed_counters) {\n\t\tu32 index = array_index_nospec(msr - base,\n\t\t\t\t\t       pmu->nr_arch_fixed_counters);\n\n\t\treturn &pmu->fixed_counters[index];\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fixed_ctrl_field",
          "args": [
            "pmu->fixed_ctr_ctrl",
            "i"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixed_ctrl_field",
          "args": [
            "data",
            "i"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pmu.h\"\n#include \"nested.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include <asm/perf_event.h>\n#include <linux/perf_event.h>\n#include <linux/kvm_host.h>\n#include <linux/types.h>\n\nstatic void reprogram_fixed_counters(struct kvm_pmu *pmu, u64 data)\n{\n\tint i;\n\n\tfor (i = 0; i < pmu->nr_arch_fixed_counters; i++) {\n\t\tu8 new_ctrl = fixed_ctrl_field(data, i);\n\t\tu8 old_ctrl = fixed_ctrl_field(pmu->fixed_ctr_ctrl, i);\n\t\tstruct kvm_pmc *pmc;\n\n\t\tpmc = get_fixed_pmc(pmu, MSR_CORE_PERF_FIXED_CTR0 + i);\n\n\t\tif (old_ctrl == new_ctrl)\n\t\t\tcontinue;\n\n\t\t__set_bit(INTEL_PMC_IDX_FIXED + i, pmu->pmc_in_use);\n\t\treprogram_fixed_counter(pmc, new_ctrl, i);\n\t}\n\n\tpmu->fixed_ctr_ctrl = data;\n}"
  }
]