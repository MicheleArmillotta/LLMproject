[
  {
    "function_name": "ept_sync_context",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "312-318",
    "snippet": "static inline void ept_sync_context(u64 eptp)\n{\n\tif (cpu_has_vmx_invept_context())\n\t\t__invept(VMX_EPT_EXTENT_CONTEXT, eptp, 0);\n\telse\n\t\tept_sync_global();\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ept_sync_global",
          "args": [],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ept_sync_global",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "307-310",
          "snippet": "static inline void ept_sync_global(void)\n{\n\t__invept(VMX_EPT_EXTENT_GLOBAL, 0, 0);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void ept_sync_global(void)\n{\n\t__invept(VMX_EPT_EXTENT_GLOBAL, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__invept",
          "args": [
            "VMX_EPT_EXTENT_CONTEXT",
            "eptp",
            "0"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "__invept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "262-269",
          "snippet": "static inline void __invept(unsigned long ext, u64 eptp, gpa_t gpa)\n{\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand = {eptp, gpa};\n\n\tvmx_asm2(invept, \"r\"(ext), \"m\"(operand), ext, eptp, gpa);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void __invept(unsigned long ext, u64 eptp, gpa_t gpa)\n{\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand = {eptp, gpa};\n\n\tvmx_asm2(invept, \"r\"(ext), \"m\"(operand), ext, eptp, gpa);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_invept_context",
          "args": [],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_invept_context",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "311-314",
          "snippet": "static inline bool cpu_has_vmx_invept_context(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_CONTEXT_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_invept_context(void)\n{\n\treturn vmx_capability.ept & VMX_EPT_EXTENT_CONTEXT_BIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void ept_sync_context(u64 eptp)\n{\n\tif (cpu_has_vmx_invept_context())\n\t\t__invept(VMX_EPT_EXTENT_CONTEXT, eptp, 0);\n\telse\n\t\tept_sync_global();\n}"
  },
  {
    "function_name": "ept_sync_global",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "307-310",
    "snippet": "static inline void ept_sync_global(void)\n{\n\t__invept(VMX_EPT_EXTENT_GLOBAL, 0, 0);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__invept",
          "args": [
            "VMX_EPT_EXTENT_GLOBAL",
            "0",
            "0"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "__invept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "262-269",
          "snippet": "static inline void __invept(unsigned long ext, u64 eptp, gpa_t gpa)\n{\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand = {eptp, gpa};\n\n\tvmx_asm2(invept, \"r\"(ext), \"m\"(operand), ext, eptp, gpa);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void __invept(unsigned long ext, u64 eptp, gpa_t gpa)\n{\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand = {eptp, gpa};\n\n\tvmx_asm2(invept, \"r\"(ext), \"m\"(operand), ext, eptp, gpa);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void ept_sync_global(void)\n{\n\t__invept(VMX_EPT_EXTENT_GLOBAL, 0, 0);\n}"
  },
  {
    "function_name": "vpid_sync_context",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "299-305",
    "snippet": "static inline void vpid_sync_context(int vpid)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vpid);\n\telse\n\t\tvpid_sync_vcpu_global();\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vpid_sync_vcpu_global",
          "args": [],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "vpid_sync_vcpu_global",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "293-297",
          "snippet": "static inline void vpid_sync_vcpu_global(void)\n{\n\tif (cpu_has_vmx_invvpid_global())\n\t\t__invvpid(VMX_VPID_EXTENT_ALL_CONTEXT, 0, 0);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void vpid_sync_vcpu_global(void)\n{\n\tif (cpu_has_vmx_invvpid_global())\n\t\t__invvpid(VMX_VPID_EXTENT_ALL_CONTEXT, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vpid_sync_vcpu_single",
          "args": [
            "vpid"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "vpid_sync_vcpu_single",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "284-291",
          "snippet": "static inline void vpid_sync_vcpu_single(int vpid)\n{\n\tif (vpid == 0)\n\t\treturn;\n\n\tif (cpu_has_vmx_invvpid_single())\n\t\t__invvpid(VMX_VPID_EXTENT_SINGLE_CONTEXT, vpid, 0);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void vpid_sync_vcpu_single(int vpid)\n{\n\tif (vpid == 0)\n\t\treturn;\n\n\tif (cpu_has_vmx_invvpid_single())\n\t\t__invvpid(VMX_VPID_EXTENT_SINGLE_CONTEXT, vpid, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_invvpid_single",
          "args": [],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_invvpid_single",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "331-334",
          "snippet": "static inline bool cpu_has_vmx_invvpid_single(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_invvpid_single(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void vpid_sync_context(int vpid)\n{\n\tif (cpu_has_vmx_invvpid_single())\n\t\tvpid_sync_vcpu_single(vpid);\n\telse\n\t\tvpid_sync_vcpu_global();\n}"
  },
  {
    "function_name": "vpid_sync_vcpu_global",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "293-297",
    "snippet": "static inline void vpid_sync_vcpu_global(void)\n{\n\tif (cpu_has_vmx_invvpid_global())\n\t\t__invvpid(VMX_VPID_EXTENT_ALL_CONTEXT, 0, 0);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__invvpid",
          "args": [
            "VMX_VPID_EXTENT_ALL_CONTEXT",
            "0",
            "0"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "__invvpid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "251-260",
          "snippet": "static inline void __invvpid(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tstruct {\n\t\tu64 vpid : 16;\n\t\tu64 rsvd : 48;\n\t\tu64 gva;\n\t} operand = { vpid, 0, gva };\n\n\tvmx_asm2(invvpid, \"r\"(ext), \"m\"(operand), ext, vpid, gva);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void __invvpid(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tstruct {\n\t\tu64 vpid : 16;\n\t\tu64 rsvd : 48;\n\t\tu64 gva;\n\t} operand = { vpid, 0, gva };\n\n\tvmx_asm2(invvpid, \"r\"(ext), \"m\"(operand), ext, vpid, gva);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_invvpid_global",
          "args": [],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_invvpid_global",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "336-339",
          "snippet": "static inline bool cpu_has_vmx_invvpid_global(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_invvpid_global(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void vpid_sync_vcpu_global(void)\n{\n\tif (cpu_has_vmx_invvpid_global())\n\t\t__invvpid(VMX_VPID_EXTENT_ALL_CONTEXT, 0, 0);\n}"
  },
  {
    "function_name": "vpid_sync_vcpu_single",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "284-291",
    "snippet": "static inline void vpid_sync_vcpu_single(int vpid)\n{\n\tif (vpid == 0)\n\t\treturn;\n\n\tif (cpu_has_vmx_invvpid_single())\n\t\t__invvpid(VMX_VPID_EXTENT_SINGLE_CONTEXT, vpid, 0);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__invvpid",
          "args": [
            "VMX_VPID_EXTENT_SINGLE_CONTEXT",
            "vpid",
            "0"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "__invvpid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "251-260",
          "snippet": "static inline void __invvpid(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tstruct {\n\t\tu64 vpid : 16;\n\t\tu64 rsvd : 48;\n\t\tu64 gva;\n\t} operand = { vpid, 0, gva };\n\n\tvmx_asm2(invvpid, \"r\"(ext), \"m\"(operand), ext, vpid, gva);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void __invvpid(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tstruct {\n\t\tu64 vpid : 16;\n\t\tu64 rsvd : 48;\n\t\tu64 gva;\n\t} operand = { vpid, 0, gva };\n\n\tvmx_asm2(invvpid, \"r\"(ext), \"m\"(operand), ext, vpid, gva);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_invvpid_single",
          "args": [],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_invvpid_single",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "331-334",
          "snippet": "static inline bool cpu_has_vmx_invvpid_single(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_invvpid_single(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_SINGLE_CONTEXT_BIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void vpid_sync_vcpu_single(int vpid)\n{\n\tif (vpid == 0)\n\t\treturn;\n\n\tif (cpu_has_vmx_invvpid_single())\n\t\t__invvpid(VMX_VPID_EXTENT_SINGLE_CONTEXT, vpid, 0);\n}"
  },
  {
    "function_name": "vpid_sync_vcpu_addr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "271-282",
    "snippet": "static inline bool vpid_sync_vcpu_addr(int vpid, gva_t addr)\n{\n\tif (vpid == 0)\n\t\treturn true;\n\n\tif (cpu_has_vmx_invvpid_individual_addr()) {\n\t\t__invvpid(VMX_VPID_EXTENT_INDIVIDUAL_ADDR, vpid, addr);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__invvpid",
          "args": [
            "VMX_VPID_EXTENT_INDIVIDUAL_ADDR",
            "vpid",
            "addr"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "__invvpid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "251-260",
          "snippet": "static inline void __invvpid(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tstruct {\n\t\tu64 vpid : 16;\n\t\tu64 rsvd : 48;\n\t\tu64 gva;\n\t} operand = { vpid, 0, gva };\n\n\tvmx_asm2(invvpid, \"r\"(ext), \"m\"(operand), ext, vpid, gva);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void __invvpid(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tstruct {\n\t\tu64 vpid : 16;\n\t\tu64 rsvd : 48;\n\t\tu64 gva;\n\t} operand = { vpid, 0, gva };\n\n\tvmx_asm2(invvpid, \"r\"(ext), \"m\"(operand), ext, vpid, gva);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_has_vmx_invvpid_individual_addr",
          "args": [],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_invvpid_individual_addr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "326-329",
          "snippet": "static inline bool cpu_has_vmx_invvpid_individual_addr(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_INDIVIDUAL_ADDR_BIT;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_invvpid_individual_addr(void)\n{\n\treturn vmx_capability.vpid & VMX_VPID_EXTENT_INDIVIDUAL_ADDR_BIT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline bool vpid_sync_vcpu_addr(int vpid, gva_t addr)\n{\n\tif (vpid == 0)\n\t\treturn true;\n\n\tif (cpu_has_vmx_invvpid_individual_addr()) {\n\t\t__invvpid(VMX_VPID_EXTENT_INDIVIDUAL_ADDR, vpid, addr);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "__invept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "262-269",
    "snippet": "static inline void __invept(unsigned long ext, u64 eptp, gpa_t gpa)\n{\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand = {eptp, gpa};\n\n\tvmx_asm2(invept, \"r\"(ext), \"m\"(operand), ext, eptp, gpa);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_asm2",
          "args": [
            "invept",
            "\"r\"(ext)",
            "\"m\"(operand)",
            "ext",
            "eptp",
            "gpa"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"m\"",
          "args": [
            "operand"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"r\"",
          "args": [
            "ext"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void __invept(unsigned long ext, u64 eptp, gpa_t gpa)\n{\n\tstruct {\n\t\tu64 eptp, gpa;\n\t} operand = {eptp, gpa};\n\n\tvmx_asm2(invept, \"r\"(ext), \"m\"(operand), ext, eptp, gpa);\n}"
  },
  {
    "function_name": "__invvpid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "251-260",
    "snippet": "static inline void __invvpid(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tstruct {\n\t\tu64 vpid : 16;\n\t\tu64 rsvd : 48;\n\t\tu64 gva;\n\t} operand = { vpid, 0, gva };\n\n\tvmx_asm2(invvpid, \"r\"(ext), \"m\"(operand), ext, vpid, gva);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_asm2",
          "args": [
            "invvpid",
            "\"r\"(ext)",
            "\"m\"(operand)",
            "ext",
            "vpid",
            "gva"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"m\"",
          "args": [
            "operand"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"r\"",
          "args": [
            "ext"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void __invvpid(unsigned long ext, u16 vpid, gva_t gva)\n{\n\tstruct {\n\t\tu64 vpid : 16;\n\t\tu64 rsvd : 48;\n\t\tu64 gva;\n\t} operand = { vpid, 0, gva };\n\n\tvmx_asm2(invvpid, \"r\"(ext), \"m\"(operand), ext, vpid, gva);\n}"
  },
  {
    "function_name": "vmcs_load",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "241-249",
    "snippet": "static inline void vmcs_load(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_load(phys_addr);\n\n\tvmx_asm1(vmptrld, \"m\"(phys_addr), vmcs, phys_addr);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_asm1",
          "args": [
            "vmptrld",
            "\"m\"(phys_addr)",
            "vmcs",
            "phys_addr"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"m\"",
          "args": [
            "phys_addr"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evmcs_load",
          "args": [
            "phys_addr"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_load",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "196-196",
          "snippet": "static inline void evmcs_load(u64 phys_addr) {}",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline void evmcs_load(u64 phys_addr) {}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vmcs"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void vmcs_load(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_load(phys_addr);\n\n\tvmx_asm1(vmptrld, \"m\"(phys_addr), vmcs, phys_addr);\n}"
  },
  {
    "function_name": "vmcs_clear",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "234-239",
    "snippet": "static inline void vmcs_clear(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\n\tvmx_asm1(vmclear, \"m\"(phys_addr), vmcs, phys_addr);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_asm1",
          "args": [
            "vmclear",
            "\"m\"(phys_addr)",
            "vmcs",
            "phys_addr"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"m\"",
          "args": [
            "phys_addr"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vmcs"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic inline void vmcs_clear(struct vmcs *vmcs)\n{\n\tu64 phys_addr = __pa(vmcs);\n\n\tvmx_asm1(vmclear, \"m\"(phys_addr), vmcs, phys_addr);\n}"
  },
  {
    "function_name": "vmcs_set_bits",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "224-232",
    "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmcs_writel",
          "args": [
            "field",
            "__vmcs_readl(field) | mask"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmcs_readl",
          "args": [
            "field"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "__vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "68-102",
          "snippet": "static __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evmcs_write32",
          "args": [
            "field",
            "evmcs_read32(field) | mask"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "191-191",
          "snippet": "static inline void evmcs_write32(unsigned long field, u32 value) {}",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline void evmcs_write32(unsigned long field, u32 value) {}"
        }
      },
      {
        "call_info": {
          "callee": "evmcs_read32",
          "args": [
            "field"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "194-194",
          "snippet": "static inline u32 evmcs_read32(unsigned long field) { return 0; }",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline u32 evmcs_read32(unsigned long field) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000",
            "\"vmcs_set_bits does not support 64-bit fields\""
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
  },
  {
    "function_name": "vmcs_clear_bits",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "214-222",
    "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmcs_writel",
          "args": [
            "field",
            "__vmcs_readl(field) & ~mask"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmcs_readl",
          "args": [
            "field"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "68-102",
          "snippet": "static __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evmcs_write32",
          "args": [
            "field",
            "evmcs_read32(field) & ~mask"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "191-191",
          "snippet": "static inline void evmcs_write32(unsigned long field, u32 value) {}",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline void evmcs_write32(unsigned long field, u32 value) {}"
        }
      },
      {
        "call_info": {
          "callee": "evmcs_read32",
          "args": [
            "field"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "194-194",
          "snippet": "static inline u32 evmcs_read32(unsigned long field) { return 0; }",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline u32 evmcs_read32(unsigned long field) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000",
            "\"vmcs_clear_bits does not support 64-bit fields\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
  },
  {
    "function_name": "vmcs_writel",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "205-212",
    "snippet": "static __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmcs_writel",
          "args": [
            "field",
            "value"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evmcs_write64",
          "args": [
            "field",
            "value"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "190-190",
          "snippet": "static inline void evmcs_write64(unsigned long field, u64 value) {}",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline void evmcs_write64(unsigned long field, u64 value) {}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_checkl",
          "args": [
            "field"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_checkl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "56-66",
          "snippet": "static __always_inline void vmcs_checkl(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"Natural width accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"Natural width accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"Natural width accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"Natural width accessor invalid for 32-bit field\");\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_checkl(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"Natural width accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"Natural width accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"Natural width accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"Natural width accessor invalid for 32-bit field\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_writel(unsigned long field, unsigned long value)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n}"
  },
  {
    "function_name": "vmcs_write64",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "193-203",
    "snippet": "static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmcs_writel",
          "args": [
            "field+1",
            "value >> 32"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmcs_writel",
          "args": [
            "field",
            "value"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evmcs_write64",
          "args": [
            "field",
            "value"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_write64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "190-190",
          "snippet": "static inline void evmcs_write64(unsigned long field, u64 value) {}",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline void evmcs_write64(unsigned long field, u64 value) {}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_check64",
          "args": [
            "field"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_check64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "44-54",
          "snippet": "static __always_inline void vmcs_check64(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"64-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"64-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"64-bit accessor invalid for 32-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"64-bit accessor invalid for natural width field\");\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_check64(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"64-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"64-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"64-bit accessor invalid for 32-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"64-bit accessor invalid for natural width field\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write64(field, value);\n\n\t__vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n\t__vmcs_writel(field+1, value >> 32);\n#endif\n}"
  },
  {
    "function_name": "vmcs_write32",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "184-191",
    "snippet": "static __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmcs_writel",
          "args": [
            "field",
            "value"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evmcs_write32",
          "args": [
            "field",
            "value"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_write32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "191-191",
          "snippet": "static inline void evmcs_write32(unsigned long field, u32 value) {}",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline void evmcs_write32(unsigned long field, u32 value) {}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_check32",
          "args": [
            "field"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_check32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "36-42",
          "snippet": "static __always_inline void vmcs_check32(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"32-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"32-bit accessor invalid for natural width field\");\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_check32(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"32-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"32-bit accessor invalid for natural width field\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write32(unsigned long field, u32 value)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, value);\n\n\t__vmcs_writel(field, value);\n}"
  },
  {
    "function_name": "vmcs_write16",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "175-182",
    "snippet": "static __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmcs_writel",
          "args": [
            "field",
            "value"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evmcs_write16",
          "args": [
            "field",
            "value"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_write16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "192-192",
          "snippet": "static inline void evmcs_write16(unsigned long field, u16 value) {}",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline void evmcs_write16(unsigned long field, u16 value) {}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_check16",
          "args": [
            "field"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_check16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "24-34",
          "snippet": "static __always_inline void vmcs_check16(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"16-bit accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"16-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"16-bit accessor invalid for 32-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"16-bit accessor invalid for natural width field\");\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_check16(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"16-bit accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"16-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"16-bit accessor invalid for 32-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"16-bit accessor invalid for natural width field\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_write16(unsigned long field, u16 value)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write16(field, value);\n\n\t__vmcs_writel(field, value);\n}"
  },
  {
    "function_name": "vmcs_readl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "132-138",
    "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmcs_readl",
          "args": [
            "field"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "__vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "68-102",
          "snippet": "static __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evmcs_read64",
          "args": [
            "field"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_read64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "193-193",
          "snippet": "static inline u64 evmcs_read64(unsigned long field) { return 0; }",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline u64 evmcs_read64(unsigned long field) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_checkl",
          "args": [
            "field"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_checkl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "56-66",
          "snippet": "static __always_inline void vmcs_checkl(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"Natural width accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"Natural width accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"Natural width accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"Natural width accessor invalid for 32-bit field\");\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_checkl(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"Natural width accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"Natural width accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"Natural width accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"Natural width accessor invalid for 32-bit field\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
  },
  {
    "function_name": "vmcs_read64",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "120-130",
    "snippet": "static __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmcs_readl",
          "args": [
            "field+1"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "__vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "68-102",
          "snippet": "static __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evmcs_read64",
          "args": [
            "field"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_read64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "193-193",
          "snippet": "static inline u64 evmcs_read64(unsigned long field) { return 0; }",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline u64 evmcs_read64(unsigned long field) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_check64",
          "args": [
            "field"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_check64",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "44-54",
          "snippet": "static __always_inline void vmcs_check64(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"64-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"64-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"64-bit accessor invalid for 32-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"64-bit accessor invalid for natural width field\");\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_check64(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"64-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"64-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"64-bit accessor invalid for 32-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"64-bit accessor invalid for natural width field\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u64 vmcs_read64(unsigned long field)\n{\n\tvmcs_check64(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n#ifdef CONFIG_X86_64\n\treturn __vmcs_readl(field);\n#else\n\treturn __vmcs_readl(field) | ((u64)__vmcs_readl(field+1) << 32);\n#endif\n}"
  },
  {
    "function_name": "vmcs_read32",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "112-118",
    "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmcs_readl",
          "args": [
            "field"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "__vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "68-102",
          "snippet": "static __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evmcs_read32",
          "args": [
            "field"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "194-194",
          "snippet": "static inline u32 evmcs_read32(unsigned long field) { return 0; }",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline u32 evmcs_read32(unsigned long field) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_check32",
          "args": [
            "field"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_check32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "36-42",
          "snippet": "static __always_inline void vmcs_check32(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"32-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"32-bit accessor invalid for natural width field\");\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_check32(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"32-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"32-bit accessor invalid for natural width field\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
  },
  {
    "function_name": "vmcs_read16",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "104-110",
    "snippet": "static __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmcs_readl",
          "args": [
            "field"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "__vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "68-102",
          "snippet": "static __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "evmcs_read16",
          "args": [
            "field"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "evmcs_read16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.h",
          "lines": "195-195",
          "snippet": "static inline u16 evmcs_read16(unsigned long field) { return 0; }",
          "includes": [
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/hyperv-tlfs.h>",
            "#include <linux/jump_label.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/mshyperv.h>\n#include <asm/hyperv-tlfs.h>\n#include <linux/jump_label.h>\n\nstatic inline u16 evmcs_read16(unsigned long field) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&enable_evmcs"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmcs_check16",
          "args": [
            "field"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_check16",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "24-34",
          "snippet": "static __always_inline void vmcs_check16(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"16-bit accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"16-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"16-bit accessor invalid for 32-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"16-bit accessor invalid for natural width field\");\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_check16(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"16-bit accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"16-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"16-bit accessor invalid for 32-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"16-bit accessor invalid for natural width field\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u16 vmcs_read16(unsigned long field)\n{\n\tvmcs_check16(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read16(field);\n\treturn __vmcs_readl(field);\n}"
  },
  {
    "function_name": "__vmcs_readl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "68-102",
    "snippet": "static __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "\"=r\"",
          "args": [
            "value"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asm volatile",
          "args": [
            "1b",
            "4b"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long __vmcs_readl(unsigned long field)\n{\n\tunsigned long value;\n\n\tasm volatile(\"1: vmread %2, %1\\n\\t\"\n\t\t     \".byte 0x3e\\n\\t\" /* branch taken hint */\n\t\t     \"ja 3f\\n\\t\"\n\n\t\t     /*\n\t\t      * VMREAD failed.  Push '0' for @fault, push the failing\n\t\t      * @field, and bounce through the trampoline to preserve\n\t\t      * volatile registers.\n\t\t      */\n\t\t     \"push $0\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"2:call vmread_error_trampoline\\n\\t\"\n\n\t\t     /*\n\t\t      * Unwind the stack.  Note, the trampoline zeros out the\n\t\t      * memory for @fault so that the result is '0' on error.\n\t\t      */\n\t\t     \"pop %2\\n\\t\"\n\t\t     \"pop %1\\n\\t\"\n\t\t     \"3:\\n\\t\"\n\n\t\t     /* VMREAD faulted.  As above, except push '1' for @fault. */\n\t\t     \".pushsection .fixup, \\\"ax\\\"\\n\\t\"\n\t\t     \"4: push $1\\n\\t\"\n\t\t     \"push %2\\n\\t\"\n\t\t     \"jmp 2b\\n\\t\"\n\t\t     \".popsection\\n\\t\"\n\t\t     _ASM_EXTABLE(1b, 4b)\n\t\t     : ASM_CALL_CONSTRAINT, \"=r\"(value) : \"r\"(field) : \"cc\");\n\treturn value;\n}"
  },
  {
    "function_name": "vmcs_checkl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "56-66",
    "snippet": "static __always_inline void vmcs_checkl(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"Natural width accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"Natural width accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"Natural width accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"Natural width accessor invalid for 32-bit field\");\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000",
            "\"Natural width accessor invalid for 32-bit field\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001",
            "\"Natural width accessor invalid for 64-bit high field\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000",
            "\"Natural width accessor invalid for 64-bit field\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6000) == 0",
            "\"Natural width accessor invalid for 16-bit field\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_checkl(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"Natural width accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"Natural width accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"Natural width accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"Natural width accessor invalid for 32-bit field\");\n}"
  },
  {
    "function_name": "vmcs_check64",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "44-54",
    "snippet": "static __always_inline void vmcs_check64(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"64-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"64-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"64-bit accessor invalid for 32-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"64-bit accessor invalid for natural width field\");\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000",
            "\"64-bit accessor invalid for natural width field\""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000",
            "\"64-bit accessor invalid for 32-bit field\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001",
            "\"64-bit accessor invalid for 64-bit high field\""
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6000) == 0",
            "\"64-bit accessor invalid for 16-bit field\""
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_check64(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"64-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"64-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"64-bit accessor invalid for 32-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"64-bit accessor invalid for natural width field\");\n}"
  },
  {
    "function_name": "vmcs_check32",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "36-42",
    "snippet": "static __always_inline void vmcs_check32(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"32-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"32-bit accessor invalid for natural width field\");\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000",
            "\"32-bit accessor invalid for natural width field\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6000) == 0",
            "\"32-bit accessor invalid for 16-bit field\""
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_check32(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0,\n\t\t\t \"32-bit accessor invalid for 16-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"32-bit accessor invalid for natural width field\");\n}"
  },
  {
    "function_name": "vmcs_check16",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
    "lines": "24-34",
    "snippet": "static __always_inline void vmcs_check16(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"16-bit accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"16-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"16-bit accessor invalid for 32-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"16-bit accessor invalid for natural width field\");\n}",
    "includes": [
      "#include \"vmcs.h\"",
      "#include \"evmcs.h\"",
      "#include <asm/vmx.h>",
      "#include <asm/kvm_host.h>",
      "#include <linux/nospec.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000",
            "\"16-bit accessor invalid for natural width field\""
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000",
            "\"16-bit accessor invalid for 32-bit high field\""
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001",
            "\"16-bit accessor invalid for 64-bit high field\""
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON_MSG",
          "args": [
            "__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000",
            "\"16-bit accessor invalid for 64-bit field\""
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_constant_p",
          "args": [
            "field"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_check16(unsigned long field)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2000,\n\t\t\t \"16-bit accessor invalid for 64-bit field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6001) == 0x2001,\n\t\t\t \"16-bit accessor invalid for 64-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x4000,\n\t\t\t \"16-bit accessor invalid for 32-bit high field\");\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x6000,\n\t\t\t \"16-bit accessor invalid for natural width field\");\n}"
  }
]